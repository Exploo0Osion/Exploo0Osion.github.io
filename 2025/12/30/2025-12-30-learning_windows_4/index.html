<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="windows系统调用syscallx86下R3-&gt;R0int 2eCPU获取 IDT 的基地址，计算目标描述符地址：IDT Base + (0x2e * 8) 进行特权级检查：CPL &lt;&#x3D; DPL  CPL (Current Privilege Level) ：当前代码段（CS）的特权级（Ring 3）。 DPL (Descriptor Privilege Level)">
<meta property="og:type" content="article">
<meta property="og:title" content="windows系统调用&#x2F;对象管理&#x2F;进程调度&#x2F;内存管理&#x2F;内核回调">
<meta property="og:url" content="https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/index.html">
<meta property="og:site_name" content="wooo~ Exploooosion&#39;s blog">
<meta property="og:description" content="windows系统调用syscallx86下R3-&gt;R0int 2eCPU获取 IDT 的基地址，计算目标描述符地址：IDT Base + (0x2e * 8) 进行特权级检查：CPL &lt;&#x3D; DPL  CPL (Current Privilege Level) ：当前代码段（CS）的特权级（Ring 3）。 DPL (Descriptor Privilege Level)">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://exploo0osion.github.io/image/2025-12-30-learning_windows_4/1767091367705.png">
<meta property="og:image" content="https://exploo0osion.github.io/image/2025-12-30-learning_windows_4/1768644706020.png">
<meta property="og:image" content="https://exploo0osion.github.io/image/2025-12-30-learning_windows_4/1768829175440.png">
<meta property="og:image" content="https://exploo0osion.github.io/image/2025-12-30-learning_windows_4/1767171485680.png">
<meta property="og:image" content="https://exploo0osion.github.io/image/2025-12-30-learning_windows_4/1767171602190.png">
<meta property="og:image" content="https://exploo0osion.github.io/image/2025-12-30-learning_windows_4/1769050159668.png">
<meta property="og:image" content="https://ashlq.github.io/2023/08/22/Windows10%E5%86%85%E6%A0%B8%E6%B1%A0%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/image-20230822151821128.png">
<meta property="article:published_time" content="2025-12-29T16:00:00.000Z">
<meta property="article:modified_time" content="2026-01-27T05:57:42.137Z">
<meta property="article:author" content="Exploooosion">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://exploo0osion.github.io/image/2025-12-30-learning_windows_4/1767091367705.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>windows系统调用/对象管理/进程调度/内存管理/内核回调</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<meta name="generator" content="Hexo 8.1.1"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/categories/">Category</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/friends/">friends</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2025/12/31/2025-12-31-leaning_windows_5/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2025/12/12/2025-12-12-windows_dll_injection/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/&text=windows系统调用/对象管理/进程调度/内存管理/内核回调"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/&title=windows系统调用/对象管理/进程调度/内存管理/内核回调"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/&is_video=false&description=windows系统调用/对象管理/进程调度/内存管理/内核回调"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=windows系统调用/对象管理/进程调度/内存管理/内核回调&body=Check out this article: https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/&title=windows系统调用/对象管理/进程调度/内存管理/内核回调"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/&title=windows系统调用/对象管理/进程调度/内存管理/内核回调"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/&title=windows系统调用/对象管理/进程调度/内存管理/内核回调"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/&title=windows系统调用/对象管理/进程调度/内存管理/内核回调"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/&name=windows系统调用/对象管理/进程调度/内存管理/内核回调&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/&t=windows系统调用/对象管理/进程调度/内存管理/内核回调"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#windows"><span class="toc-number">1.</span> <span class="toc-text">windows</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8syscall"><span class="toc-number">1.1.</span> <span class="toc-text">系统调用syscall</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#x86%E4%B8%8BR3-R0"><span class="toc-number">1.1.1.</span> <span class="toc-text">x86下R3-&gt;R0</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#int-2e"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">int 2e</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sysenter-sysreturn"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">sysenter &#x2F; sysreturn</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KiFastCallEntry%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">KiFastCallEntry函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GDT%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E8%A1%A8%EF%BC%88Global-Description-Table%EF%BC%89"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">GDT全局描述表（Global Description Table）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.1.1.5.</span> <span class="toc-text">段寄存器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#x86%E4%B8%8BR0-R3"><span class="toc-number">1.1.2.</span> <span class="toc-text">x86下R0-&gt;R3</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">对象管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.1.</span> <span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#OBJECT-HEADER"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">_OBJECT_HEADER</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OBJECT-TYPE"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">_OBJECT_TYPE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ObCreateObject-ObjectAttributes-size-ObjectType"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">ObCreateObject(ObjectAttributes,size,ObjectType)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">1.2.2.</span> <span class="toc-text">对象命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#OBJECT-DIRECTORY"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">OBJECT_DIRECTORY</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E8%A7%A3%E6%9E%90"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">路径解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OBJECT-DIRECTORY-ENTRY"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">_OBJECT_DIRECTORY_ENTRY</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%A5%E6%9F%84"><span class="toc-number">1.2.3.</span> <span class="toc-text">句柄</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#EXHANDLE"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">EXHANDLE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HANDLE-TABLE"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">HANDLE_TABLE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HANDLE-TABLE-ENTRY"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">HANDLE_TABLE_ENTRY</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%AA%E5%8F%A5%E6%9F%84-Pseudo-Handles"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">伪句柄 (Pseudo Handles)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%A5%E6%9F%84%E8%A1%A8"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">全局句柄表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E5%8F%A5%E6%9F%84%E8%A1%A8"><span class="toc-number">1.2.3.6.</span> <span class="toc-text">私有句柄表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">1.3.</span> <span class="toc-text">线程&#x2F;进程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.1.</span> <span class="toc-text">进程结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#EPROCESS-Executive-Process"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">EPROCESS (Executive Process)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KPROCESS-Kernel-Process"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">KPROCESS (Kernel Process)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PEB-Process-Environment-Block"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">PEB (Process Environment Block)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%9F%A5%E6%89%BE"><span class="toc-number">1.3.2.</span> <span class="toc-text">进程查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E8%BF%9B%E7%A8%8B%E9%93%BE%E8%A1%A8"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">遍历进程链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E8%BF%9B%E7%A8%8BID"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">枚举进程ID</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F"><span class="toc-number">1.3.3.</span> <span class="toc-text">进程隐藏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%8A%A4"><span class="toc-number">1.3.4.</span> <span class="toc-text">进程保护</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BreakOnTermination-Flags-bit13"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">BreakOnTermination (Flags bit13)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ProcessInserted-Flags-bit26"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">ProcessInserted (Flags bit26)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ProtectedProcess-Flags2-bit11"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">ProtectedProcess (Flags2 bit11)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.5.</span> <span class="toc-text">线程结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ETHREAD-Executive-Thread"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">ETHREAD(Executive Thread)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KTHREAD-Kernel-Thread"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">KTHREAD (Kernel Thread)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TEB-Thread-Environment-Block"><span class="toc-number">1.3.5.3.</span> <span class="toc-text">TEB (Thread Environment Block):</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="toc-number">1.3.6.</span> <span class="toc-text">线程切换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.4.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#x64%E9%A1%B5%E8%A1%A8%E8%87%AA%E6%98%A0%E5%B0%84"><span class="toc-number">1.4.1.</span> <span class="toc-text">x64页表自映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PFN-%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.4.2.</span> <span class="toc-text">PFN 数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MMPFN"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">MMPFN</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MMPFNENTRY1"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">MMPFNENTRY1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E9%A1%B5%E7%9A%84%E4%B8%B2%E8%81%94%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">空闲页的串联方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VAD"><span class="toc-number">1.4.3.</span> <span class="toc-text">VAD</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MMVAD-SHORT"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">MMVAD_SHORT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MMVAD-FLAGS"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">MMVAD_FLAGS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MMVAD"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">MMVAD</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8"><span class="toc-number">1.4.4.</span> <span class="toc-text">缺页异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%A0%E5%88%86%E9%85%8D%E5%99%A8"><span class="toc-number">1.4.5.</span> <span class="toc-text">池分配器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#POOL-HEADER"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">POOL_HEADER</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ExPoolState"><span class="toc-number">1.4.5.2.</span> <span class="toc-text">ExPoolState</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#EX-POOL-HEAP-MANAGER-STATE"><span class="toc-number">1.4.5.2.1.</span> <span class="toc-text">EX_POOL_HEAP_MANAGER_STATE</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#EX-HEAP-POOL-NODE"><span class="toc-number">1.4.5.2.2.</span> <span class="toc-text">EX_HEAP_POOL_NODE</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ExAllocatePool2%E7%AE%80%E5%8C%96%E6%B5%81%E7%A8%8B"><span class="toc-number">1.4.5.3.</span> <span class="toc-text">ExAllocatePool2简化流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%9B%9E%E8%B0%83"><span class="toc-number">1.5.</span> <span class="toc-text">内核回调</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%9F%A5%E5%9E%8B%E5%9B%9E%E8%B0%83%EF%BC%88Notify-Callbacks%EF%BC%89"><span class="toc-number">1.5.1.</span> <span class="toc-text">系统通知型回调（Notify Callbacks）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%9B%9E%E8%B0%83"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">进程回调</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">1.5.1.1.1.</span> <span class="toc-text">注册过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E8%BF%87%E7%A8%8B"><span class="toc-number">1.5.1.1.2.</span> <span class="toc-text">回调过程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="toc-number">1.5.1.1.2.1.</span> <span class="toc-text">进程创建</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.5.1.1.2.2.</span> <span class="toc-text">隐藏进程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.5.1.1.2.3.</span> <span class="toc-text">拦截进程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%AC%BA%E9%AA%97-Spoofing"><span class="toc-number">1.5.1.1.2.4.</span> <span class="toc-text">欺骗(Spoofing)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA"><span class="toc-number">1.5.1.1.2.5.</span> <span class="toc-text">进程退出</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%9B%9E%E8%B0%83"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">线程回调</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E8%BF%87%E7%A8%8B-1"><span class="toc-number">1.5.1.2.1.</span> <span class="toc-text">注册过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E8%BF%87%E7%A8%8B-1"><span class="toc-number">1.5.1.2.2.</span> <span class="toc-text">回调过程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%9B%9E%E8%B0%83"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">模块回调</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E8%BF%87%E7%A8%8B-2"><span class="toc-number">1.5.1.3.1.</span> <span class="toc-text">注册过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E8%BF%87%E7%A8%8B-2"><span class="toc-number">1.5.1.3.2.</span> <span class="toc-text">回调过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%9B%9E%E8%B0%83"><span class="toc-number">1.5.2.</span> <span class="toc-text">对象回调</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C-%E5%8D%B8%E8%BD%BD%E5%9B%9E%E8%B0%83"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">注册&#x2F;卸载回调</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#PreOperation"><span class="toc-number">1.5.2.1.1.</span> <span class="toc-text">PreOperation</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#PostOperation"><span class="toc-number">1.5.2.1.2.</span> <span class="toc-text">PostOperation</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">相关结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#OBJECT-TYPE-1"><span class="toc-number">1.5.2.2.1.</span> <span class="toc-text">OBJECT_TYPE</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#OBJECT-TYPE-INITIALIZER"><span class="toc-number">1.5.2.2.2.</span> <span class="toc-text">OBJECT_TYPE_INITIALIZER</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#OB-CALLBACK-HANDLE"><span class="toc-number">1.5.2.2.3.</span> <span class="toc-text">OB_CALLBACK_HANDLE</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E8%BF%87%E7%A8%8B-3"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">注册过程</span></a></li></ol></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        windows系统调用/对象管理/进程调度/内存管理/内核回调
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">Exploooosion</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2025-12-29T16:00:00.000Z" class="dt-published" itemprop="datePublished">2025-12-30</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/windows/">windows</a>
    </div>


      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <span id="more"></span>

<h1 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h1><h2 id="系统调用syscall"><a href="#系统调用syscall" class="headerlink" title="系统调用syscall"></a>系统调用syscall</h2><h3 id="x86下R3-R0"><a href="#x86下R3-R0" class="headerlink" title="x86下R3-&gt;R0"></a>x86下R3-&gt;R0</h3><h4 id="int-2e"><a href="#int-2e" class="headerlink" title="int 2e"></a>int 2e</h4><p>CPU获取 IDT 的基地址，计算目标描述符地址：<code>IDT Base + (0x2e * 8)</code></p>
<p>进行特权级检查：CPL &lt;&#x3D; DPL</p>
<ul>
<li>CPL (Current Privilege Level) ：当前代码段（CS）的特权级（Ring 3）。</li>
<li>DPL (Descriptor Privilege Level) ：IDT 描述符中规定的特权级（必须是 3，否则用户态无权调用）</li>
</ul>
<p>从 IDT 描述符中提取段选择子 Segment Selector 。CPU 使用该 Selector 去查询 GDT</p>
<p>用户线程栈切换成内核线程栈，保存上下文 (Push Context，会压入一些寄存器)，从IDT（Interrupt Descriptor Table）中寻找0x2e对应的异常处理函数（KiSystemService）进入内核代码空间</p>
<h4 id="sysenter-sysreturn"><a href="#sysenter-sysreturn" class="headerlink" title="sysenter &#x2F; sysreturn"></a>sysenter &#x2F; sysreturn</h4><p>sysenter指令执行时会跳转到MSR[176]指向的函数地址（该函数实际是KiFastCallEntry），CS、SS、EIP、ESP均来自MSR寄存器，因此速度上比int 2e块（不需要压参数、读内存）</p>
<p>CS &lt;&#x3D;&#x3D; <code>IA32_SYSENTER_CS</code> (MSR 0x174)。</p>
<p>EIP &lt;&#x3D;&#x3D; <code>IA32_SYSENTER_EIP</code> (MSR 0x176)。</p>
<p>ESP &lt;&#x3D;&#x3D; <code>IA32_SYSENTER_ESP</code> (MSR 0x175)。</p>
<h4 id="KiFastCallEntry函数"><a href="#KiFastCallEntry函数" class="headerlink" title="KiFastCallEntry函数"></a>KiFastCallEntry函数</h4><p> <code>push 30h</code> &#x2F; <code>pop fs</code> FS 寄存器从用户态的  TEB 切换到内核态的 KPCR</p>
<p>0x30的二进制 ：<code>0000 0000 0011 0000</code></p>
<p>x86 段选择子的结构：</p>
<ul>
<li>RPL (最后2位) : <code>00</code> -&gt; Ring 0 (特权级 0，即内核态)。</li>
<li>TI (第3位) : <code>0</code> -&gt; GDT (全局描述符表)。</li>
<li>Index (高13位) : <code>0000000000110</code> -&gt; 6 (十进制)。</li>
</ul>
<h4 id="GDT全局描述表（Global-Description-Table）"><a href="#GDT全局描述表（Global-Description-Table）" class="headerlink" title="GDT全局描述表（Global Description Table）"></a>GDT全局描述表（Global Description Table）</h4><p>在 x86 保护模式 (Protected Mode) 下，内存不再是直接通过物理地址访问，而是通过 “分段 (Segmentation)” 机制访问。</p>
<ol>
<li>不直接给地址 ：当程序执行 <code>mov eax, [0x12345678]</code> 时，CPU 并不是直接去物理内存的 <code>0x12345678</code> 拿数据。</li>
<li>段选择子 (Selector) ：CPU 会先看当前段寄存器（如 <code>DS</code>、<code>CS</code>、<code>SS</code>）里存的  “索引号” （即选择子）。</li>
<li>查表 (Lookup) ：CPU 根据这个索引号，去 GDT 表里找到对应的  “段描述符 (Descriptor)” 。</li>
<li>鉴权与定位 ：描述符里记录了这段内存的  基地址 (Base) 、大小 (Limit) 和  权限 (Access Rights) 。只有检查通过，CPU 才会把 基地址 + 偏移量 算出线性地址。</li>
</ol>
<table>
<thead>
<tr>
<th>索引 (Index)</th>
<th>选择子 (Selector)</th>
<th>名称</th>
<th>DPL (特权级)</th>
<th>用途与特征</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0x00</td>
<td>NULL</td>
<td>-</td>
<td>空描述符 。硬件规定，不可使用。</td>
</tr>
<tr>
<td>1</td>
<td>0x08</td>
<td>KGDT_R0_CODE</td>
<td>0 (内核)</td>
<td>内核代码段 。Base&#x3D;0, Limit&#x3D;4GB。内核执行代码时 CS&#x3D;0x08。</td>
</tr>
<tr>
<td>2</td>
<td>0x10</td>
<td>KGDT_R0_DATA</td>
<td>0 (内核)</td>
<td>内核数据段 。Base&#x3D;0, Limit&#x3D;4GB。内核读写数据时 DS&#x2F;ES&#x2F;SS&#x3D;0x10。</td>
</tr>
<tr>
<td>3</td>
<td>0x1B</td>
<td>KGDT_R3_CODE</td>
<td>3 (用户)</td>
<td>用户代码段 。Base&#x3D;0, Limit&#x3D;4GB。用户程序运行时 CS&#x3D;0x1B (0x18</td>
</tr>
<tr>
<td>4</td>
<td>0x23</td>
<td>KGDT_R3_DATA</td>
<td>3 (用户)</td>
<td>用户数据段 。Base&#x3D;0, Limit&#x3D;4GB。用户程序运行时 DS&#x2F;ES&#x2F;SS&#x3D;0x23 (0x20</td>
</tr>
<tr>
<td>5</td>
<td>0x28</td>
<td>KGDT_TSS</td>
<td>0 (内核)</td>
<td>TSS (任务状态段) 。用于保存硬件上下文和栈切换信息 (ESP0)。</td>
</tr>
<tr>
<td>6</td>
<td>0x30</td>
<td>KGDT_R0_PCR</td>
<td>0 (内核)</td>
<td>内核 KPCR 指针 。 这是唯一的非平坦段 。Base&#x3D;KPCR地址。内核通过 FS 访问 CPU 专属数据。</td>
</tr>
<tr>
<td>7</td>
<td>0x3B</td>
<td>KGDT_R3_TEB</td>
<td>3 (用户)</td>
<td>用户 TEB 指针 。Base&#x3D;当前线程TEB地址。用户通过 FS 访问线程局部存储。</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>(其他保留项，如 LDT, VDM 等)</td>
</tr>
</tbody></table>
<p>LDT：局部描述表（Local Description Table），与GDT功能一致，但不能单独存在，只能嵌套在GDT中。</p>
<h4 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h4><p>CS (Code Segment) —— 必须指向代码</p>
<p>CPU 的取指单元（Instruction Fetch Unit）永远只从 <code>CS:EIP</code>（或 <code>CS:RIP</code>）指向的地址读取指令。CS 寄存器的低 2 位（CPL）代表了当前 CPU 的特权级（Ring 0 - Ring 3）。CS 指向 Ring 0 代码段 (0x08) 或 Ring 3 代码段 (0x1B)。</p>
<p>SS (Stack Segment) —— 必须指向堆栈</p>
<p>所有的隐式堆栈操作（如 <code>push</code>, <code>pop</code>, <code>call</code>, <code>ret</code>, <code>enter</code>, <code>leave</code>）以及基于 <code>ESP</code>&#x2F;<code>EBP</code> 的内存访问，默认使用 SS 段。SS 指向内核栈段 (0x10) 或用户栈段 (0x23)。</p>
<p>DS (Data Segment) &amp; ES (Extra Segment)</p>
<p>DS 是数据访问的默认段（例如 <code>mov eax, [ebx]</code> 默认就是 <code>ds:[ebx]</code>）。ES 是字符串指令（如 <code>movs</code>, <code>stos</code>）的目标段默认值。</p>
<p>FS &amp; GS (F-Segment &#x2F; G-Segment)</p>
<table>
<thead>
<tr>
<th>架构</th>
<th>FS 寄存器用途</th>
<th>GS 寄存器用途</th>
<th>为什么不同？</th>
</tr>
</thead>
<tbody><tr>
<td>x86 (32位)</td>
<td>指向 TEB (R3) &#x2F; KPCR (R0)</td>
<td>未大量使用 (通常为0)</td>
<td>x86下 FS 选择子很早就被分配给了 TEB&#x2F;PCR。</td>
</tr>
<tr>
<td>x64 (64位)</td>
<td>(兼容性保留，指向 32位TEB)</td>
<td>指向 TEB (R3) &#x2F; KPCR (R0)</td>
<td>x64下 CPU 允许 <code>swapgs</code>快速切换 GS，所以主要用 GS。</td>
</tr>
</tbody></table>
<p>fs:[0]：在3环时，该处指向的是TEB结构，0环下指向_KPCR结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">KPCR</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">NT_TIB</span> <span class="title">NtTib</span>;</span>                                               <span class="comment">//0x0</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span>* <span class="title">Used_ExceptionList</span>;</span>      <span class="comment">//0x0</span></span><br><span class="line">            VOID* Used_StackBase;                                           <span class="comment">//0x4</span></span><br><span class="line">            VOID* Spare2;                                                   <span class="comment">//0x8</span></span><br><span class="line">            VOID* TssCopy;                                                  <span class="comment">//0xc</span></span><br><span class="line">            ULONG ContextSwitches;                                          <span class="comment">//0x10</span></span><br><span class="line">            ULONG SetMemberCopy;                                            <span class="comment">//0x14</span></span><br><span class="line">            VOID* Used_Self;                                                <span class="comment">//0x18</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KPCR</span>* <span class="title">SelfPcr</span>;</span>                                                  <span class="comment">//0x1c</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KPRCB</span>* <span class="title">Prcb</span>;</span>                                                    <span class="comment">//0x20</span></span><br><span class="line">    UCHAR Irql;                                                             <span class="comment">//0x24</span></span><br><span class="line">    ULONG IRR;                                                              <span class="comment">//0x28</span></span><br><span class="line">    ULONG IrrActive;                                                        <span class="comment">//0x2c</span></span><br><span class="line">    ULONG IDR;                                                              <span class="comment">//0x30</span></span><br><span class="line">    VOID* KdVersionBlock;                                                   <span class="comment">//0x34</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KIDTENTRY</span>* <span class="title">IDT</span>;</span>                                                 <span class="comment">//0x38</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KGDTENTRY</span>* <span class="title">GDT</span>;</span>                                                 <span class="comment">//0x3c</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KTSS</span>* <span class="title">TSS</span>;</span>                                                      <span class="comment">//0x40</span></span><br><span class="line">    USHORT MajorVersion;                                                    <span class="comment">//0x44</span></span><br><span class="line">    USHORT MinorVersion;                                                    <span class="comment">//0x46</span></span><br><span class="line">    ULONG SetMember;                                                        <span class="comment">//0x48</span></span><br><span class="line">    ULONG StallScaleFactor;                                                 <span class="comment">//0x4c</span></span><br><span class="line">    UCHAR SpareUnused;                                                      <span class="comment">//0x50</span></span><br><span class="line">    UCHAR Number;                                                           <span class="comment">//0x51</span></span><br><span class="line">    UCHAR Spare0;                                                           <span class="comment">//0x52</span></span><br><span class="line">    UCHAR SecondLevelCacheAssociativity;                                    <span class="comment">//0x53</span></span><br><span class="line">    ULONG VdmAlert;                                                         <span class="comment">//0x54</span></span><br><span class="line">    ULONG KernelReserved[<span class="number">14</span>];                                               <span class="comment">//0x58</span></span><br><span class="line">    ULONG SecondLevelCacheSize;                                             <span class="comment">//0x90</span></span><br><span class="line">    ULONG HalReserved[<span class="number">16</span>];                                                  <span class="comment">//0x94</span></span><br><span class="line">    ULONG InterruptMode;                                                    <span class="comment">//0xd4</span></span><br><span class="line">    UCHAR Spare1;                                                           <span class="comment">//0xd8</span></span><br><span class="line">    ULONG KernelReserved2[<span class="number">17</span>];                                              <span class="comment">//0xdc</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KPRCB</span> <span class="title">PrcbData</span>;</span>                                                 <span class="comment">//0x120</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p> <code>mov ecx, fs:_KPCR.TSS</code>：通过 FS (KPCR) 获取当前任务状态段 (TSS)。</p>
<p><code>mov esp, [ecx+_KTSS.Esp0]</code>：栈指针切换到该线程真正的内核栈顶</p>
<p>后续是根据 <code>KTrap_Frame</code>的结构构建完整 <code>Trap Frame</code> 与异常链表，需要注意的是用户态的 <code>esp</code>是通过 <code>push edx</code>来压入的，因为 <code>sysenter</code>被封装成了 <code>KiFastSystemCall</code>函数，会先进行 <code>mov edx,esp;</code>然后再 <code>sysenter</code>，eip则是 <code>_KUSER_SHARED_DATA</code>中的 <code>SystemCallReturn</code> 地址</p>
<p><code>mov ebx, large fs:KPCR.SelfPcr</code>：获取 PCR 指针，<code>push dword ptr [ebx]</code>：保存当前的异常处理链表头 (<code>PCR.ExceptionList</code>) 到栈</p>
<p>最后保存到_KTHREAD.TrapFrame中</p>
<p>KTrap_Frame：栈帧，用来保存R3切换到R0的环境</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x8c bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">KTRAP_FRAME</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ULONG DbgEbp;                                                           <span class="comment">//0x0</span></span><br><span class="line">    ULONG DbgEip;                                                           <span class="comment">//0x4</span></span><br><span class="line">    ULONG DbgArgMark;                                                       <span class="comment">//0x8</span></span><br><span class="line">    ULONG DbgArgPointer;                                                    <span class="comment">//0xc</span></span><br><span class="line">    USHORT TempSegCs;                                                       <span class="comment">//0x10</span></span><br><span class="line">    UCHAR Logging;                                                          <span class="comment">//0x12</span></span><br><span class="line">    UCHAR Reserved;                                                         <span class="comment">//0x13</span></span><br><span class="line">    ULONG TempEsp;                                                          <span class="comment">//0x14</span></span><br><span class="line">    ULONG Dr0;                                                              <span class="comment">//0x18</span></span><br><span class="line">    ULONG Dr1;                                                              <span class="comment">//0x1c</span></span><br><span class="line">    ULONG Dr2;                                                              <span class="comment">//0x20</span></span><br><span class="line">    ULONG Dr3;                                                              <span class="comment">//0x24</span></span><br><span class="line">    ULONG Dr6;                                                              <span class="comment">//0x28</span></span><br><span class="line">    ULONG Dr7;                                                              <span class="comment">//0x2c</span></span><br><span class="line">    ULONG SegGs;                                                            <span class="comment">//0x30</span></span><br><span class="line">    ULONG SegEs;                                                            <span class="comment">//0x34</span></span><br><span class="line">    ULONG SegDs;                                                            <span class="comment">//0x38</span></span><br><span class="line">    ULONG Edx;                                                              <span class="comment">//0x3c</span></span><br><span class="line">    ULONG Ecx;                                                              <span class="comment">//0x40</span></span><br><span class="line">    ULONG Eax;                                                              <span class="comment">//0x44</span></span><br><span class="line">    ULONG PreviousPreviousMode;                                             <span class="comment">//0x48-----R0用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span>* <span class="title">ExceptionList</span>;</span>                   <span class="comment">//0x4c</span></span><br><span class="line">    ULONG SegFs;                                                            <span class="comment">//0x50</span></span><br><span class="line">    ULONG Edi;                                                              <span class="comment">//0x54</span></span><br><span class="line">    ULONG Esi;                                                              <span class="comment">//0x58</span></span><br><span class="line">    ULONG Ebx;                                                              <span class="comment">//0x5c</span></span><br><span class="line">    ULONG Ebp;                                                              <span class="comment">//0x60</span></span><br><span class="line">    ULONG ErrCode;                                                          <span class="comment">//0x64</span></span><br><span class="line">    ULONG Eip;                                                              <span class="comment">//0x68</span></span><br><span class="line">    ULONG SegCs;                                                            <span class="comment">//0x6c </span></span><br><span class="line">    ULONG EFlags;                                                           <span class="comment">//0x70-----R3用</span></span><br><span class="line">    ULONG HardwareEsp;                                                      <span class="comment">//0x74 </span></span><br><span class="line">    ULONG HardwareSegSs;                                                    <span class="comment">//0x78</span></span><br><span class="line">    ULONG V86Es;                                                            <span class="comment">//0x7c	虚拟8086模式下，保护模式下不用</span></span><br><span class="line">    ULONG V86Ds;                                                            <span class="comment">//0x80</span></span><br><span class="line">    ULONG V86Fs;                                                            <span class="comment">//0x84</span></span><br><span class="line">    ULONG V86Gs;                                                            <span class="comment">//0x88</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>确定系统服务表（SSDT vs Shadow SSDT）</p>
<p><code>mov edi, eax</code> &#x2F; <code>shr edi, 8</code> &#x2F; <code>and edi, 10h</code></p>
<p>Windows 系统调用号第 12 位（bit 12）用于区分表。</p>
<ul>
<li>如果 ID &lt; 0x1000，<code>edi</code> 结果为 0 -&gt; 使用 KeServiceDescriptorTable (核心内核函数)。</li>
<li>如果 ID &gt;&#x3D; 0x1000 (如 0x1xxx)，<code>edi</code> 结果为 0x10 -&gt; 使用 KeServiceDescriptorTableShadow (win32k.sys 图形&#x2F;窗口函数)。</li>
</ul>
<p><code>add edi, [esi+_KTHREAD.ServiceTable]</code> _KTHREAD中有服务表的基址，现在edi指向了正确的 Service Descriptor Table 结构体</p>
<p>获取 SSDT 参数表 (Argument Table) 的基址，获取 SSDT 函数地址表 (Service Table) 的基址。</p>
<p>从参数表中读取该系统调用需要的参数字节数 ，从函数表中读取目标内核函数地址 —-计算公式：表基址 + (调用号 * 4)。</p>
<p>通过 <code>rep movsd</code>从用户态堆栈完整拷贝到内核态堆栈（此时ECX–参数个数；ESI–由EDX赋予，EDX在sysenter前就指向old esp；   EDI–内核栈地址），最后 <code>call ebx</code>调用内核函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KSERVICE_TABLKSERVICE_TABLE_DESCRIPTORE_DESCRIPTOR</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PULONG_PTR FuncPoint;	<span class="comment">//指向函数表</span></span><br><span class="line">    PULONG Count;			<span class="comment">//调用的次数</span></span><br><span class="line">    PULONG Limit;			<span class="comment">//函数个数</span></span><br><span class="line">    PUCHAR ArgsPoint;		<span class="comment">//参数列表</span></span><br><span class="line">&#125;KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUMBER_SERVICE_TABLES 2</span></span><br><span class="line"> </span><br><span class="line">KSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTable[NUMBER_SERVICE_TABLES]</span><br><span class="line">KSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTableShadow[NUMBER_SERVICE_TABLES]</span><br></pre></td></tr></table></figure>

<p><img src="/image/2025-12-30-learning_windows_4/1767091367705.png" alt="1767091367705"></p>
<p>x64下 <code>syscall</code>似乎和x86下的 <code>sysenter</code>差不多，跳转的内核函数是 <code>KiSystemCall64</code></p>
<h3 id="x86下R0-R3"><a href="#x86下R0-R3" class="headerlink" title="x86下R0-&gt;R3"></a>x86下R0-&gt;R3</h3><p>处理APC：代码读取 <code>KPCR-&gt;CurrentThread</code> (<code>fs:124h</code>)</p>
<p>检查 <code>Thread-&gt;ApcState.UserApcPending</code>，如果有用户态的 APC（比如某些 I&#x2F;O 完成回调、线程挂起请求）， 需要先处理掉（APC注入的发生点）<code>call _KiDeliverApc</code>直到所有挂起的 APC都执行完毕。</p>
<p>恢复异常链表及调试寄存器（如果为调试模式的话）：从 TrapFrame 中取出用户态的 <code>ExceptionList</code>，写回 <code>fs:[0]</code> (KPCR的第一个成员指向TEB )，</p>
<p>检查 <code>TrapFrame-&gt;Dr7</code>。如果用户态程序下了硬件断点（Hardware Breakpoint），这里需要恢复调试寄存器 <code>DR0</code>-<code>DR7</code>。</p>
<p>恢复通用寄存器与栈调整，将ESP移动到TrapFrame-&gt;SegFs，<code>pop fs</code>恢复3环FS，再移动esp恢复各个通用寄存器，执行iret返回用户态自动从栈上弹出 EIP, CS, EFLAGS, ESP, SS</p>
<h2 id="对象管理"><a href="#对象管理" class="headerlink" title="对象管理"></a>对象管理</h2><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>内存模型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[ Optional Headers (Name, Creator, etc.) ]</span><br><span class="line">[ _OBJECT_HEADER ]  &lt;--- 核心元数据 (引用计数, TypeIndex 等)</span><br><span class="line">[ Object Body ]     &lt;--- 外部指针指向这里 (e.g., _EPROCESS, _FILE_OBJECT等)</span><br><span class="line"></span><br><span class="line">|---------------------------|</span><br><span class="line">| POOL_HEADER               |  内存池头部</span><br><span class="line">|---------------------------|</span><br><span class="line">| OBJECT_HEADER_NAME_INFO   |  名字信息 (可选)</span><br><span class="line">|---------------------------|</span><br><span class="line">| OBJECT_HEADER_HANDLE_INFO |  句柄信息 (可选)</span><br><span class="line">|---------------------------|</span><br><span class="line">| OBJECT_HEADER_QUOTA_INFO  |  配额信息 (可选)</span><br><span class="line">|---------------------------|</span><br><span class="line">| OBJECT_HEADER             |  内核对象统一头部 (必定存在)</span><br><span class="line">|---------------------------|</span><br><span class="line">| OBJECT_BODY               |  对象体结构 (如 DRIVER_OBJECT)</span><br><span class="line">|---------------------------|</span><br></pre></td></tr></table></figure>

<p>附加信息头是可选的，它包括了以下信息头的一个或多个</p>
<table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>结构</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td>创建信息头</td>
<td>OBJECT_HEADER_CREATOR_INFO</td>
<td>包含创建者信息，用来将创建的对象挂入其创建者的对象队列</td>
</tr>
<tr>
<td>命名信息头</td>
<td>OBJECT_HEADER_NAME_INFO</td>
<td>载有对象名和目录节点的指针</td>
</tr>
<tr>
<td>句柄信息头</td>
<td>OBJECT_HEADER_HANDLE_INFO</td>
<td>关于句柄的信息</td>
</tr>
<tr>
<td>配额信息头</td>
<td>OBJECT_HEADER_QUOTA_INFO</td>
<td>关于耗用内存配额的信息</td>
</tr>
</tbody></table>
<h4 id="OBJECT-HEADER"><a href="#OBJECT-HEADER" class="headerlink" title="_OBJECT_HEADER"></a>_OBJECT_HEADER</h4><p>x64 Win10 下通常为 0x30</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">6: kd&gt; dt nt!_OBJECT_HEADER</span><br><span class="line">   +0x000 PointerCount     : Int8B         //指针引用计数,当内核组件通过指针引用对象时增加,当降为0时,对象内存被释放。初始化为 1</span><br><span class="line">   +0x008 HandleCount      : Int8B         //句柄引用计数,用户模式或内核模式打开的Handle数量。</span><br><span class="line">   +0x008 NextToFree       : Ptr64 Void</span><br><span class="line">   +0x010 Lock             : _EX_PUSH_LOCK</span><br><span class="line">   +0x018 TypeIndex        : UChar         //索引，用于在全局类型数组中找到该对象的_OBJECT_TYPE。</span><br><span class="line">   +0x019 TraceFlags       : UChar </span><br><span class="line">   +0x019 DbgRefTrace      : Pos 0, 1 Bit</span><br><span class="line">   +0x019 DbgTracePermanent : Pos 1, 1 Bit</span><br><span class="line">   +0x01a InfoMask         : UChar         //标记是否有 Name/Handle/Quota 这三种可选头</span><br><span class="line">   +0x01b Flags            : UChar</span><br><span class="line">   +0x01b NewObject        : Pos 0, 1 Bit</span><br><span class="line">   +0x01b KernelObject     : Pos 1, 1 Bit</span><br><span class="line">   +0x01b KernelOnlyAccess : Pos 2, 1 Bit</span><br><span class="line">   +0x01b ExclusiveObject  : Pos 3, 1 Bit</span><br><span class="line">   +0x01b PermanentObject  : Pos 4, 1 Bit</span><br><span class="line">   +0x01b DefaultSecurityQuota : Pos 5, 1 Bit</span><br><span class="line">   +0x01b SingleHandleEntry : Pos 6, 1 Bit</span><br><span class="line">   +0x01b DeletedInline    : Pos 7, 1 Bit</span><br><span class="line">   +0x01c Reserved         : Uint4B</span><br><span class="line">   +0x020 ObjectCreateInfo : Ptr64 _OBJECT_CREATE_INFORMATION</span><br><span class="line">   +0x020 QuotaBlockCharged : Ptr64 Void</span><br><span class="line">   +0x028 SecurityDescriptor : Ptr64 Void</span><br><span class="line">   +0x030 Body             : _QUAD</span><br></pre></td></tr></table></figure>

<h4 id="OBJECT-TYPE"><a href="#OBJECT-TYPE" class="headerlink" title="_OBJECT_TYPE"></a>_OBJECT_TYPE</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">6: kd&gt; dt nt!_OBJECT_TYPE</span><br><span class="line">   +0x000 TypeList         : _LIST_ENTRY    // 链接所有 OBJECT_TYPE 实例</span><br><span class="line">   +0x010 Name             : _UNICODE_STRING</span><br><span class="line">   +0x020 DefaultObject    : Ptr64 Void  </span><br><span class="line">   +0x028 Index            : UChar        // 对象类型索引</span><br><span class="line">   +0x02c TotalNumberOfObjects : Uint4B   // 当前该类型对象的总数</span><br><span class="line">   +0x030 TotalNumberOfHandles : Uint4B   // 该类型所有对象的句柄总数</span><br><span class="line">   +0x034 HighWaterNumberOfObjects : Uint4B</span><br><span class="line">   +0x038 HighWaterNumberOfHandles : Uint4B</span><br><span class="line">   +0x040 TypeInfo         : _OBJECT_TYPE_INITIALIZER  // 类型初始化结构，定义该类型对象的行为（如回调、池分配方式等）</span><br><span class="line">   +0x0b8 TypeLock         : _EX_PUSH_LOCK </span><br><span class="line">   +0x0c0 Key              : Uint4B</span><br><span class="line">   +0x0c8 CallbackList     : _LIST_ENTRY  //📌对象回调链表，用于支持注册的 ObRegisterCallbacks 回调</span><br></pre></td></tr></table></figure>

<h4 id="ObCreateObject-ObjectAttributes-size-ObjectType"><a href="#ObCreateObject-ObjectAttributes-size-ObjectType" class="headerlink" title="ObCreateObject(ObjectAttributes,size,ObjectType)"></a>ObCreateObject(ObjectAttributes,size,ObjectType)</h4><ol>
<li>Capture (捕获) : 解析 <code>ObjectAttributes</code>，提取名字、安全描述符，暂存到 <code>OBJECT_CREATE_INFORMATION</code> 结构（通常利用 Lookaside List 优化，不直接分配堆）。</li>
<li>Calculate (计算) :<code>TotalSize = BodySize + sizeof(FixedHeader) + sizeof(OptionalHeaders) + Padding</code>。</li>
<li>Allocate (分配) :调用 <code>ExAllocatePoolWithTag</code>。<ul>
<li>Tag : 取自 <code>ObjectType-&gt;Key</code>。</li>
<li>Ptr : 拿到堆块首地址 <code>pChunk</code>。</li>
</ul>
</li>
<li>Format (格式化) :<ul>
<li>根据计算好的偏移，定位到 <code>FixedHeader</code> 的位置。</li>
<li>填充 <code>FixedHeader</code> (写入 <code>InfoMask</code>, <code>TypeIndex</code>)。</li>
<li>如果存在 Optional Headers，将名字、配额指针填入 Header 前面的内存区域。</li>
</ul>
</li>
<li>Return (返回) :<br>返回指向 Body 的指针。</li>
</ol>
<p>假设创建了一个带名字、带安全描述符的 Event 对象。最终内存里长这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[ 内存低地址 ]</span><br><span class="line">|</span><br><span class="line">|   &lt;--- ExAllocatePoolWithTag 返回的起始地址 (pChunk)</span><br><span class="line">|</span><br><span class="line">+-------------------------------------------------------+</span><br><span class="line">| Optional Header: _OBJECT_HEADER_QUOTA_INFO            | </span><br><span class="line">| (存在是因为带了SD需要计费)                              |</span><br><span class="line">+-------------------------------------------------------+</span><br><span class="line">| Optional Header: _OBJECT_HEADER_NAME_INFO             |</span><br><span class="line">| .Name      -&gt; 指向分页池中存放 &quot;MyEvent&quot; 字符串的地址     |</span><br><span class="line">| .Directory -&gt; 指向 &quot;\BaseNamedObjects&quot; 目录对象的指针    |</span><br><span class="line">+-------------------------------------------------------+</span><br><span class="line">| padding (对齐填充)                                     |</span><br><span class="line">+-------------------------------------------------------+</span><br><span class="line">| Fixed Header: _OBJECT_HEADER                          | &lt;--- 通过 Body - 0x30 访问</span><br><span class="line">| .PointerCount = 1                                     |</span><br><span class="line">| .InfoMask     = 0x0A (0x08 Quota | 0x02 Name)         |</span><br><span class="line">| .TypeIndex    = EventTypeIndex                        |</span><br><span class="line">| .SecurityDescriptor -&gt; 指向安全描述符的指针              |</span><br><span class="line">+-------------------------------------------------------+</span><br><span class="line">| Object Body: _KEVENT                                  | </span><br><span class="line">| .Header (Dispatcher Header)                           |</span><br><span class="line">| .SignalState                                          |</span><br><span class="line">| ...                                                   |</span><br><span class="line">+-------------------------------------------------------+</span><br><span class="line">|</span><br><span class="line">[ 内存高地址 ]</span><br></pre></td></tr></table></figure>

<h3 id="对象命名空间"><a href="#对象命名空间" class="headerlink" title="对象命名空间"></a>对象命名空间</h3><p>Object Manager 命名空间是 Windows 内核中统一管理一切内核对象的“对象目录树”，本质上是一个分层的哈希表结构。</p>
<h4 id="OBJECT-DIRECTORY"><a href="#OBJECT-DIRECTORY" class="headerlink" title="OBJECT_DIRECTORY"></a>OBJECT_DIRECTORY</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; dt nt!_OBJECT_DIRECTORY</span><br><span class="line">   +0x000 HashBuckets      : [37] Ptr64 _OBJECT_DIRECTORY_ENTRY  //指针数组,每个指向一个 _OBJECT_DIRECTORY_ENTRY 链表</span><br><span class="line">   +0x128 Lock             : _EX_PUSH_LOCK</span><br><span class="line">   +0x130 DeviceMap        : Ptr64 _DEVICE_MAP</span><br><span class="line">   +0x138 ShadowDirectory  : Ptr64 _OBJECT_DIRECTORY</span><br><span class="line">   +0x140 NamespaceEntry   : Ptr64 Void</span><br><span class="line">   +0x148 SessionObject    : Ptr64 Void</span><br><span class="line">   +0x150 Flags            : Uint4B</span><br><span class="line">   +0x154 SessionId        : Uint4B</span><br></pre></td></tr></table></figure>

<p>每一个“目录对象”（Directory Object），在内核中对应的结构体是 <code>_OBJECT_DIRECTORY</code>。</p>
<p>整个 Object Manager 命名空间以 <strong><code>\</code></strong> 为根目录，形成一棵类似文件系统的目录树。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">\                                （根目录，DirectoryObject）</span><br><span class="line">├── Driver                       所有驱动对象 (DriverObject)</span><br><span class="line">│     └── MyDriver</span><br><span class="line">│</span><br><span class="line">├── Device                       所有设备对象 (DeviceObject)</span><br><span class="line">│     └── Harddisk0</span><br><span class="line">│     └── Serial0</span><br><span class="line">│</span><br><span class="line">├── ??                           ★ 符号链接桥梁目录 (SymbolicLinkObject)</span><br><span class="line">│     ├── C:         → \Device\HarddiskVolume1</span><br><span class="line">│     ├── COM1       → \Device\Serial0</span><br><span class="line">│     └── MyLink     → \Device\MyDevice</span><br><span class="line">│</span><br><span class="line">├── BaseNamedObjects             ★ 用户会话 0 命名空间（全局同步对象）</span><br><span class="line">│     └── MyEvent</span><br><span class="line">│     └── MyMutex</span><br><span class="line">│</span><br><span class="line">├── Sessions                     ★ 多用户会话隔离目录</span><br><span class="line">│     └── 1</span><br><span class="line">│         └── BaseNamedObjects   （Session 1 的私有命名空间）</span><br><span class="line">│</span><br><span class="line">├── ObjectTypes                  ★ 已注册的内核对象类型列表</span><br><span class="line">├── Windows (部分版本存在)</span><br><span class="line">└── 其它系统内部目录</span><br></pre></td></tr></table></figure>

<p>其对应的物理形态（物理上它是哈希链表的嵌套）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[\ (Root)] -&gt; HashBuckets[...]</span><br><span class="line">      |</span><br><span class="line">      +--&gt; &quot;Driver&quot; (Directory Object)</span><br><span class="line">      |       |</span><br><span class="line">      |       +--&gt; HashBuckets[...] -&gt; &quot;MyDriver&quot; (Driver Object)</span><br><span class="line">      |</span><br><span class="line">      +--&gt; &quot;Device&quot; (Directory Object)</span><br><span class="line">              |</span><br><span class="line">              +--&gt; HashBuckets[...] -&gt; &quot;Harddisk0&quot; (Device Object)</span><br></pre></td></tr></table></figure>

<p>其中每一类目录的具体作用如下：</p>
<table>
<thead>
<tr>
<th>目录名</th>
<th>作用</th>
<th>常见对象类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>\Driver</code></td>
<td>存放所有已注册的内核驱动对象</td>
<td><code>DriverObject</code></td>
</tr>
<tr>
<td><code>\Device</code></td>
<td>存放所有设备对象，供 I&#x2F;O 管理器使用</td>
<td><code>DeviceObject</code></td>
</tr>
<tr>
<td><code>\??</code></td>
<td>符号链接目录：Win32 路径与内核对象桥接</td>
<td><code>SymbolicLinkObject</code></td>
</tr>
<tr>
<td><code>\BaseNamedObjects</code></td>
<td>全局同步对象命名区（Session 0 共享）</td>
<td><code>Event</code> &#x2F; <code>Mutex</code> &#x2F; <code>Semaphore</code></td>
</tr>
<tr>
<td><code>\Sessions\N\BaseNamedObjects</code></td>
<td>多用户会话隔离命名空间</td>
<td>各自的同步对象</td>
</tr>
<tr>
<td><code>\ObjectTypes</code></td>
<td>存放系统内置的对象类型定义表</td>
<td><code>ObjectTypeObject</code></td>
</tr>
<tr>
<td><code>\Callback</code></td>
<td>存放回调对象，用于内核模块间的通信。</td>
<td></td>
</tr>
<tr>
<td><code>\KnownDlls</code></td>
<td>存放系统已知 DLL 的 Section 对象（内存映射），加速 DLL 加载</td>
<td></td>
</tr>
</tbody></table>
<p>其中 <code>\??</code> 目录（全名为 <code>DosDevices Directory</code>）是 Object Manager 里专门用来桥接 <strong>Win32 路径系统 ↔ 内核命名空间</strong> 的目录。它里面挂载的都是 <strong>符号链接对象（SymbolicLinkObject）</strong>，用于：</p>
<ul>
<li>盘符映射 (<code>C:</code> → <code>\Device\HarddiskVolumeX</code>)</li>
<li>传统设备名 (<code>COM1</code> → <code>\Device\Serial0</code>)</li>
<li>自定义设备别名（通过 <code>IoCreateSymbolicLink()</code> 创建）</li>
</ul>
<p>影子机制：解决多用户登录的符号链接问题</p>
<p>当Session 0 (系统服务) 访问 <code>\??</code> 时，它直接指向 <code>\Global??</code></p>
<p>当Session 1 (普通用户) 访问 <code>\??</code> 时，它指向 <code>\Sessions\1\DosDevices</code>，该目录下有隐藏属性 <code>DeviceMap</code>，指向 <code>\Global??</code>，当查找不到时会从影子目录中查找</p>
<h4 id="路径解析"><a href="#路径解析" class="headerlink" title="路径解析"></a>路径解析</h4><table>
<thead>
<tr>
<th>路径类型</th>
<th>格式示例</th>
<th>谁在使用</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>1. Win32 文件路径</td>
<td><code>C:\Windows\Test.sys</code></td>
<td>用户态程序 (Explorer, Notepad)</td>
<td>包含盘符。内核不认识盘符 。</td>
</tr>
<tr>
<td>2. Win32 设备路径</td>
<td><code>\\.\COM1</code></td>
<td>用户态程序 (串口助手, 磁盘工具)</td>
<td>以 <code>\\.\</code>开头，用于访问非文件的设备。</td>
</tr>
<tr>
<td>3. NT 路径 (原生路径)</td>
<td><code>\Device\HarddiskVolume1\Windows</code></td>
<td>内核、驱动程序</td>
<td>绝对路径 。没有盘符，只有设备对象名。</td>
</tr>
<tr>
<td>4. 对象管理路径</td>
<td><code>\??\C:\Windows</code></td>
<td>Object Manager (Ob)</td>
<td>Win32 路径转换后的中间形态。</td>
</tr>
</tbody></table>
<p>文件示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CreateFile(&quot;C:\\Windows\\System32\\drivers\\Test.sys&quot;)</span><br><span class="line">      │</span><br><span class="line">      └─► Win32 → NT 转换</span><br><span class="line">              \??\C:\Windows\System32\drivers\Test.sys</span><br><span class="line">                   │</span><br><span class="line">                   └─► \??\C: (符号链接)</span><br><span class="line">                           ↓</span><br><span class="line">                          \Device\HarddiskVolume1</span><br><span class="line">                                │</span><br><span class="line">                                └─► 完整 NT 路径</span><br><span class="line">                                    \Device\HarddiskVolume1\Windows\System32\drivers\Test.sys</span><br></pre></td></tr></table></figure>

<p>设备示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CreateFile(&quot;\\\\.\\COM1&quot;)</span><br><span class="line">      │</span><br><span class="line">      └─► \??\COM1   (Win32 设备路径)</span><br><span class="line">             │</span><br><span class="line">             └─► 符号链接解析</span><br><span class="line">                  \Device\Serial0   ← 真实设备对象</span><br></pre></td></tr></table></figure>

<h4 id="OBJECT-DIRECTORY-ENTRY"><a href="#OBJECT-DIRECTORY-ENTRY" class="headerlink" title="_OBJECT_DIRECTORY_ENTRY"></a>_OBJECT_DIRECTORY_ENTRY</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; dt _OBJECT_DIRECTORY_ENTRY</span><br><span class="line">nt!_OBJECT_DIRECTORY_ENTRY</span><br><span class="line">   +0x000 ChainLink        : Ptr64 _OBJECT_DIRECTORY_ENTRY</span><br><span class="line">   +0x008 Object           : Ptr64 Void</span><br><span class="line">   +0x010 HashValue        : Uint4B</span><br></pre></td></tr></table></figure>

<p><img src="/image/2025-12-30-learning_windows_4/1768644706020.png" alt="1768644706020"></p>
<p>ObInsertObject会分配一个 <code>_OBJECT_DIRECTORY_ENTRY</code> 小结构，并让 <code>Entry-&gt;Object = NewObject</code>，将 Entry 挂入计算出的哈希桶（将对象名转大写并计算 Hash % 37）链表头部。</p>
<p>查找对象</p>
<h3 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h3><p>句柄 (Handle) 是 Windows 内核分配给用户态程序的一个”凭证”或 “索引”。它是一个32位的整数（即使在64位系统上，高32位通常也为 0，以便兼容 WOW64）。</p>
<p>用户态无法直接访问内核内存地址（Object Pointer），只能持有句柄。内核通过句柄在句柄表中查找，最终定位到真正的内核对象（如 <code>EPROCESS</code>, <code>KTHREAD</code>, <code>KEVENT</code> 等）。</p>
<h4 id="EXHANDLE"><a href="#EXHANDLE" class="headerlink" title="EXHANDLE"></a>EXHANDLE</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; dt _EXHANDLE</span><br><span class="line">nt!_EXHANDLE</span><br><span class="line">   +0x000 TagBits          : Pos 0, 2 Bits  //用户程序可使用的标签位，这两位对系统无意义，用户可用作句柄类型区分、调试标记等；</span><br><span class="line">   +0x000 Index            : Pos 2, 30 Bits //句柄索引字段，实际句柄值 / 4 即为该索引（因为句柄步长为 4）；</span><br><span class="line">   +0x000 GenericHandleOverlay : Ptr64 Void</span><br><span class="line">   +0x000 Value            : Uint8B</span><br></pre></td></tr></table></figure>

<ul>
<li>进程 ID 和线程 ID 本质上是全局句柄表(<code>PspCidTable</code>)的索引</li>
</ul>
<h4 id="HANDLE-TABLE"><a href="#HANDLE-TABLE" class="headerlink" title="HANDLE_TABLE"></a>HANDLE_TABLE</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; dt _HANDLE_TABLE</span><br><span class="line">nt!_HANDLE_TABLE</span><br><span class="line">   +0x000 NextHandleNeedingPool : Uint4B</span><br><span class="line">   +0x004 ExtraInfoPages   : Int4B</span><br><span class="line">   +0x008 TableCode        : Uint8B</span><br><span class="line">   +0x010 QuotaProcess     : Ptr64 _EPROCESS //所属进程的 EPROCESS 指针</span><br><span class="line">   +0x018 HandleTableList  : _LIST_ENTRY     //所有句柄表的全局链表</span><br><span class="line">   +0x028 UniqueProcessId  : Uint4B          //拥有该句柄表的进程 ID（PID）</span><br><span class="line">   +0x02c Flags            : Uint4B</span><br><span class="line">   +0x02c StrictFIFO       : Pos 0, 1 Bit</span><br><span class="line">   +0x02c EnableHandleExceptions : Pos 1, 1 Bit</span><br><span class="line">   +0x02c Rundown          : Pos 2, 1 Bit</span><br><span class="line">   +0x02c Duplicated       : Pos 3, 1 Bit</span><br><span class="line">   +0x02c RaiseUMExceptionOnInvalidHandleClose : Pos 4, 1 Bit</span><br><span class="line">   +0x030 HandleContentionEvent : _EX_PUSH_LOCK</span><br><span class="line">   +0x038 HandleTableLock  : _EX_PUSH_LOCK</span><br><span class="line">   +0x040 FreeLists        : [1] _HANDLE_TABLE_FREE_LIST</span><br><span class="line">   +0x040 ActualEntry      : [32] UChar</span><br><span class="line">   +0x060 DebugInfo        : Ptr64 _HANDLE_TRACE_DEBUG_INFO</span><br></pre></td></tr></table></figure>

<p>Windows 采用了类似内存分页的多级索引结构</p>
<p><code>TableCode</code> 是查找的入口，它编码了<strong>层级</strong>和<strong>地址</strong>：</p>
<p>低 2 位 (Level) :</p>
<ul>
<li><code>0</code>:  L0 (直接表) 。<code>TableCode</code> 指向直接的 <code>_HANDLE_TABLE_ENTRY</code> 数组。</li>
<li><code>1</code>:  L1 (两级表) 。<code>TableCode</code> 指向一个指针数组，每个指针指向一个 L0 表。</li>
<li><code>2</code>:  L2 (三级表) 。指向指针的指针。</li>
</ul>
<p>高位 (Address) : 清除低 2 位后，即为物理层级表的基址。</p>
<p>以 x64 为例（每页 4KB）：</p>
<ul>
<li>1 页存句柄项(存放实际的 <code>HANDLE_TABLE_ENTRY</code> 数组,256个指针项)。</li>
<li>1 页 L0页(512 个指针项，每个8字节)-&gt;句柄项。</li>
<li>1 页L1页 -&gt; 1 页 L0页-&gt;句柄项</li>
</ul>
<p><img src="/image/2025-12-30-learning_windows_4/1768829175440.png" alt="1768829175440"></p>
<h4 id="HANDLE-TABLE-ENTRY"><a href="#HANDLE-TABLE-ENTRY" class="headerlink" title="HANDLE_TABLE_ENTRY"></a>HANDLE_TABLE_ENTRY</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; dt nt!_HANDLE_TABLE_ENTRY</span><br><span class="line">   +0x000 Unlocked         : Pos 0, 1 Bit     //锁</span><br><span class="line">   +0x000 RefCnt           : Pos 1, 16 Bits   //句柄引用计数</span><br><span class="line">   +0x000 Attributes       : Pos 17, 3 Bits   //句柄属性(继承、保护)</span><br><span class="line">   +0x000 ObjectPointerBits : Pos 20, 44 Bits //对象指针</span><br><span class="line">   +0x008 GrantedAccessBits : Pos 0, 25 Bits  //打开句柄时获得的权限</span><br><span class="line">   +0x008 NoRightsUpgrade  : Pos 25, 1 Bit</span><br><span class="line">   +0x008 Spare1           : Pos 26, 6 Bits</span><br><span class="line">   +0x00c Spare2           : Uint4B</span><br></pre></td></tr></table></figure>

<p><code>Object</code>：指向实际内核对象的指针。</p>
<ul>
<li>全局句柄表 ，该指针指向进程或线程对象 。</li>
<li>私有句柄表 ，该指针指向内核对象的 <code>OBJECT_HEADER</code></li>
</ul>
<h4 id="伪句柄-Pseudo-Handles"><a href="#伪句柄-Pseudo-Handles" class="headerlink" title="伪句柄 (Pseudo Handles)"></a>伪句柄 (Pseudo Handles)</h4><p>这些值是硬编码的常量，不在句柄表中分配，直接由内核函数（如 <code>ObReferenceObjectByHandle</code>）特殊处理。</p>
<ul>
<li>-1 (CurrentProcess) : 指向当前进程自身。</li>
<li>-2 (CurrentThread) : 指向当前线程自身。</li>
<li>-3 (CurrentDebugObject) : 当前进程的调试端口。</li>
<li>-4 (CurrentDirectory) : 当前目录句柄。</li>
</ul>
<h4 id="全局句柄表"><a href="#全局句柄表" class="headerlink" title="全局句柄表"></a>全局句柄表</h4><p>全局句柄表 <code>PspCidTable</code> 是一个 <code>HANDLE_TABLE</code> 类型的全局指针，指向一个句柄表管理结构。这个表中存储着所有进程和线程对象。</p>
<p>表项中的 <code>Object</code> 字段直接指向对象体 (Body) （即 <code>EPROCESS</code> 或 <code>ETHREAD</code> 的起始地址），而不是指向 <code>OBJECT_HEADER</code></p>
<p>表项的 <code>GrantedAccess</code> 通常为 <code>0</code>，因为 PID&#x2F;TID 仅用于标识，不承载访问权限（权限检查在打开这些 ID 获取真正句柄时进行）。</p>
<h4 id="私有句柄表"><a href="#私有句柄表" class="headerlink" title="私有句柄表"></a>私有句柄表</h4><p>每个进程都有私有句柄表 (<code>EPROCESS-&gt;ObjectTable</code>)。</p>
<p>对象指针 ：表项指向对象的  OBJECT_HEADER （而非 Body）</p>
<h2 id="线程-进程调度"><a href="#线程-进程调度" class="headerlink" title="线程&#x2F;进程调度"></a>线程&#x2F;进程调度</h2><h3 id="进程结构"><a href="#进程结构" class="headerlink" title="进程结构"></a>进程结构</h3><h4 id="EPROCESS-Executive-Process"><a href="#EPROCESS-Executive-Process" class="headerlink" title="EPROCESS (Executive Process)"></a>EPROCESS (Executive Process)</h4><p>进程管理的最高层结构，管理进程生命周期、对象句柄、内存空间等。</p>
<p>包含: 资源配额、句柄表、令牌（Token）、调试端口等。</p>
<p>关键成员:</p>
<ul>
<li><code>ActiveProcessLinks</code>: 双向链表，连接所有活动进程。这是任务管理器枚举进程的依据。</li>
<li><code>UniqueProcessId</code>: 进程 ID (PID) 。</li>
<li><code>Token</code>: 访问令牌，决定进程权限。</li>
<li><code>ImageFileName</code>: 进程名（如 <code>notepad.exe</code>）。</li>
<li><code>Peb</code>: 指向用户模式 PEB 的指针 。</li>
<li><code>ObjectTable</code>: 当前进程的句柄表</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">EPROCESS</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KPROCESS</span> <span class="title">Pcb</span>;</span>                         <span class="comment">// 0x00: 📌进程调度器相关信息（KPROCESS，前面已详细注释）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EX_PUSH_LOCK</span> <span class="title">ProcessLock</span>;</span>             <span class="comment">// 0x98: 进程结构体自旋锁（用于多核同步）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">CreateTime</span>;</span>              <span class="comment">// 0xA0: 进程创建时间</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">ExitTime</span>;</span>                <span class="comment">// 0xA8: 进程退出时间（如果还在运行则为 0）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EX_RUNDOWN_REF</span> <span class="title">RundownProtect</span>;</span>        <span class="comment">// 0xB0: 清理保护机制（防止进程在使用中被删除）</span></span><br><span class="line">    VOID* UniqueProcessId;                        <span class="comment">// 0xB4: 📌当前进程的唯一 PID（HANDLE 类型）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ActiveProcessLinks</span>;</span>        <span class="comment">// 0xB8: 📌所有活动进程的双向链表</span></span><br><span class="line">    ULONG ProcessQuotaUsage[<span class="number">2</span>];                   <span class="comment">// 0xC0: 当前使用的分页池和非分页池配额</span></span><br><span class="line">    ULONG ProcessQuotaPeak[<span class="number">2</span>];                    <span class="comment">// 0xC8: 使用分页池和非分页池配额的历史峰值</span></span><br><span class="line">    <span class="keyword">volatile</span> ULONG CommitCharge;                  <span class="comment">// 0xD0: 当前已提交虚拟内存（以页为单位）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EPROCESS_QUOTA_BLOCK</span>* <span class="title">QuotaBlock</span>;</span>     <span class="comment">// 0xD4: 引用进程所属的配额块</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">PS_CPU_QUOTA_BLOCK</span>* <span class="title">CpuQuotaBlock</span>;</span>    <span class="comment">// 0xD8: CPU 使用配额控制结构</span></span><br><span class="line">    ULONG PeakVirtualSize;                        <span class="comment">// 0xDC: 虚拟内存使用峰值</span></span><br><span class="line">    ULONG VirtualSize;                            <span class="comment">// 0xE0: 当前虚拟内存使用量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">SessionProcessLinks</span>;</span>       <span class="comment">// 0xE4: 当前进程所属 session 的进程链表</span></span><br><span class="line">    VOID* DebugPort;                              <span class="comment">// 0xEC: 📌调试器端口（被调试时非 NULL）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        VOID* ExceptionPortData;                  <span class="comment">// 0xF0: 异常端口数据（调试器使用）</span></span><br><span class="line">        ULONG ExceptionPortValue;</span><br><span class="line">        ULONG ExceptionPortState:<span class="number">3</span>;               <span class="comment">// 异常端口状态位</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">HANDLE_TABLE</span>* <span class="title">ObjectTable</span>;</span>            <span class="comment">// 0xF4: 📌当前进程句柄表（用于对象管理）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EX_FAST_REF</span> <span class="title">Token</span>;</span>                    <span class="comment">// 0xF8: 📌进程访问令牌（权限、安全上下文）</span></span><br><span class="line">    ULONG WorkingSetPage;                         <span class="comment">// 0xFC: 工作集起始页（即最小驻留页数）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EX_PUSH_LOCK</span> <span class="title">AddressCreationLock</span>;</span>     <span class="comment">// 0x100: 地址空间创建时使用的锁</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ETHREAD</span>* <span class="title">RotateInProgress</span>;</span>            <span class="comment">// 0x104: 正在切换线程（调度使用）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ETHREAD</span>* <span class="title">ForkInProgress</span>;</span>              <span class="comment">// 0x108: 正在进行 fork 操作的线程</span></span><br><span class="line">    ULONG HardwareTrigger;                        <span class="comment">// 0x10C: 硬件相关标志，可能由调试或诊断工具触发</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">MM_AVL_TABLE</span>* <span class="title">PhysicalVadRoot</span>;</span>        <span class="comment">// 0x110: VAD AVL 树根指针（描述虚拟内存分布）</span></span><br><span class="line">    VOID* CloneRoot;                              <span class="comment">// 0x114: 克隆 VAD 树根（用于进程克隆）</span></span><br><span class="line">    <span class="keyword">volatile</span> ULONG NumberOfPrivatePages;          <span class="comment">// 0x118: 分配给进程的私有页数</span></span><br><span class="line">    <span class="keyword">volatile</span> ULONG NumberOfLockedPages;           <span class="comment">// 0x11C: 被锁定（不可换出）的页数</span></span><br><span class="line">    VOID* Win32Process;                           <span class="comment">// 0x120: 指向 Win32 子系统使用的进程结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EJOB</span>* <span class="title">volatile</span> <span class="title">Job</span>;</span>                   <span class="comment">// 0x124: 所属作业对象（Job 对象）</span></span><br><span class="line">    VOID* SectionObject;                          <span class="comment">// 0x128: 映像节对象（表示映像在内存中的映射）</span></span><br><span class="line">    VOID* SectionBaseAddress;                     <span class="comment">// 0x12C: 映像加载的基址（即 EXE 的加载地址）</span></span><br><span class="line">    ULONG Cookie;                                 <span class="comment">// 0x130: 安全 cookie（用于防护堆栈溢出等）</span></span><br><span class="line">    ULONG Spare8;                                 <span class="comment">// 0x134: 保留字段</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">PAGEFAULT_HISTORY</span>* <span class="title">WorkingSetWatch</span>;</span>   <span class="comment">// 0x138: 页面错误历史记录（用于诊断内存访问）</span></span><br><span class="line">    VOID* Win32WindowStation;                     <span class="comment">// 0x13C: 进程关联的窗口站</span></span><br><span class="line">    VOID* InheritedFromUniqueProcessId;           <span class="comment">// 0x140: 父进程 PID（如果有）</span></span><br><span class="line">    VOID* LdtInformation;                         <span class="comment">// 0x144: 本地描述符表（LDT）信息（32位支持）</span></span><br><span class="line">    VOID* VdmObjects;                             <span class="comment">// 0x148: 虚拟 DOS 支持结构体（V86 模式）</span></span><br><span class="line">    ULONG ConsoleHostProcess;                     <span class="comment">// 0x14C: 控制台宿主进程 PID（仅控制台进程使用）</span></span><br><span class="line">    VOID* DeviceMap;                              <span class="comment">// 0x150: 设备映射信息（如 \\Device\\HarddiskX）</span></span><br><span class="line">    VOID* EtwDataSource;                          <span class="comment">// 0x154: ETW 跟踪数据源指针</span></span><br><span class="line">    VOID* FreeTebHint;                            <span class="comment">// 0x158: 用于优化 TEB 分配的 hint 指针</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">HARDWARE_PTE</span> <span class="title">PageDirectoryPte</span>;</span>    <span class="comment">// 0x160: 页目录表条目（硬件 PTE 格式）</span></span><br><span class="line">        ULONGLONG Filler;</span><br><span class="line">    &#125;;</span><br><span class="line">    VOID* Session;                                <span class="comment">// 0x168: 当前进程所属的 session 对象</span></span><br><span class="line">    UCHAR ImageFileName[<span class="number">15</span>];                      <span class="comment">// 0x16C: 📌可执行文件名称（不带路径）</span></span><br><span class="line">    UCHAR PriorityClass;                          <span class="comment">// 0x17B: 优先级类别（与线程优先级相关）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">JobLinks</span>;</span>                  <span class="comment">// 0x17C: Job 对象下进程的链表节点</span></span><br><span class="line">    VOID* LockedPagesList;                        <span class="comment">// 0x184: 锁定页链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ThreadListHead</span>;</span>            <span class="comment">// 0x188: 当前进程线程链表头</span></span><br><span class="line">    VOID* SecurityPort;                           <span class="comment">// 0x190: 安全通信端口（IPC）</span></span><br><span class="line">    VOID* PaeTop;                                 <span class="comment">// 0x194: PAE 页表顶端指针（仅在 PAE 模式使用）</span></span><br><span class="line">    <span class="keyword">volatile</span> ULONG ActiveThreads;                 <span class="comment">// 0x198: 当前活跃线程数量</span></span><br><span class="line">    ULONG ImagePathHash;                          <span class="comment">// 0x19C: 映像路径哈希值（用于快速查找）</span></span><br><span class="line">    ULONG DefaultHardErrorProcessing;             <span class="comment">// 0x1A0: 错误处理策略（如是否弹框）</span></span><br><span class="line">    LONG LastThreadExitStatus;                    <span class="comment">// 0x1A4: 最后一个线程的退出码</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">PEB</span>* <span class="title">Peb</span>;</span>                             <span class="comment">// 0x1A8: 📌指向用户态的 PEB 结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EX_FAST_REF</span> <span class="title">PrefetchTrace</span>;</span>            <span class="comment">// 0x1AC: 预取跟踪结构</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">ReadOperationCount</span>;</span>      <span class="comment">// 0x1B0: 读操作次数</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">WriteOperationCount</span>;</span>     <span class="comment">// 0x1B8: 写操作次数</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">OtherOperationCount</span>;</span>     <span class="comment">// 0x1C0: 其他操作次数</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">ReadTransferCount</span>;</span>       <span class="comment">// 0x1C8: 读取字节数总和</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">WriteTransferCount</span>;</span>      <span class="comment">// 0x1D0: 写入字节数总和</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">OtherTransferCount</span>;</span>      <span class="comment">// 0x1D8: 其他传输字节数</span></span><br><span class="line">    ULONG CommitChargeLimit;                      <span class="comment">// 0x1E0: 提交内存配额上限</span></span><br><span class="line">    <span class="keyword">volatile</span> ULONG CommitChargePeak;              <span class="comment">// 0x1E4: 提交内存配额峰值</span></span><br><span class="line">    VOID* AweInfo;                                <span class="comment">// 0x1E8: Address Windowing Extensions 支持</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">SE_AUDIT_PROCESS_CREATION_INFO</span> <span class="title">SeAuditProcessCreationInfo</span>;</span> <span class="comment">// 0x1EC: 📌审计信息，指向映像路径（可能包含命令行、EXE 路径）的结构体，供审计系统使用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">MMSUPPORT</span> <span class="title">Vm</span>;</span>                         <span class="comment">// 0x1F0: 进程的内存管理器支持结构（MMSUPPORT）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">MmProcessLinks</span>;</span>            <span class="comment">// 0x25C: 用于分页内存管理的进程链表</span></span><br><span class="line">    VOID* HighestUserAddress;                     <span class="comment">// 0x264: 用户态可访问的最高地址</span></span><br><span class="line">    ULONG ModifiedPageCount;                      <span class="comment">// 0x268: 被修改的页面计数</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ULONG Flags2;                             <span class="comment">// 0x26C: 与调度、NUMA、安全、资源管理有关的扩展状态标志</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            ULONG JobNotReallyActive:<span class="number">1</span>;         <span class="comment">// bit 0: 进程关联的 Job 对象当前未被视为活跃状态</span></span><br><span class="line">            ULONG AccountingFolded:<span class="number">1</span>;           <span class="comment">// bit 1: 资源使用计数合并入 Job，不独立统计进程自身</span></span><br><span class="line">            ULONG NewProcessReported:<span class="number">1</span>;         <span class="comment">// bit 2: 进程创建事件已上报（防止重复报告）</span></span><br><span class="line">            ULONG ExitProcessReported:<span class="number">1</span>;        <span class="comment">// bit 3: 进程退出事件已上报</span></span><br><span class="line">            ULONG ReportCommitChanges:<span class="number">1</span>;        <span class="comment">// bit 4: 提交内存变化需要通知资源跟踪</span></span><br><span class="line">            ULONG LastReportMemory:<span class="number">1</span>;           <span class="comment">// bit 5: 记录上次内存报告（用于比较/优化）</span></span><br><span class="line">            ULONG ReportPhysicalPageChanges:<span class="number">1</span>;  <span class="comment">// bit 6: 页面物理位置变化需上报（诊断用途）</span></span><br><span class="line">            ULONG HandleTableRundown:<span class="number">1</span>;         <span class="comment">// bit 7: 句柄表正在清理中</span></span><br><span class="line">            ULONG NeedsHandleRundown:<span class="number">1</span>;         <span class="comment">// bit 8: 需要清理句柄表</span></span><br><span class="line">            ULONG RefTraceEnabled:<span class="number">1</span>;            <span class="comment">// bit 9: 启用引用计数跟踪</span></span><br><span class="line">            ULONG NumaAware:<span class="number">1</span>;                  <span class="comment">// bit10: 该进程为 NUMA 感知进程</span></span><br><span class="line">            ULONG ProtectedProcess:<span class="number">1</span>;           <span class="comment">// bit11: 📌受保护进程（如 lsass，不可注入/调试）</span></span><br><span class="line">            ULONG DefaultPagePriority:<span class="number">3</span>;        <span class="comment">// bit12–14: 默认页面优先级（用于分页决策）</span></span><br><span class="line">            ULONG PrimaryTokenFrozen:<span class="number">1</span>;         <span class="comment">// bit15: 主令牌被冻结（不可替换）</span></span><br><span class="line">            ULONG ProcessVerifierTarget:<span class="number">1</span>;      <span class="comment">// bit16: 启用进程验证器跟踪</span></span><br><span class="line">            ULONG StackRandomizationDisabled:<span class="number">1</span>; <span class="comment">// bit17: 禁用堆栈地址随机化（如调试中）</span></span><br><span class="line">            ULONG AffinityPermanent:<span class="number">1</span>;          <span class="comment">// bit18: 永久绑定 CPU 亲和性</span></span><br><span class="line">            ULONG AffinityUpdateEnable:<span class="number">1</span>;       <span class="comment">// bit19: 允许动态更新亲和性</span></span><br><span class="line">            ULONG PropagateNode:<span class="number">1</span>;              <span class="comment">// bit20: 跨 NUMA 节点传播数据</span></span><br><span class="line">            ULONG ExplicitAffinity:<span class="number">1</span>;           <span class="comment">// bit21: 已显式设置亲和性</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ULONG Flags;                              <span class="comment">// 0x270: 控制进程生命周期、内存行为、调试行为等的主状态标志</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            ULONG CreateReported:<span class="number">1</span>;           <span class="comment">// bit 0: 已报告进程创建事件（如 ETW）</span></span><br><span class="line">            ULONG NoDebugInherit:<span class="number">1</span>;           <span class="comment">// bit 1: 禁止继承调试器（子进程隔离）</span></span><br><span class="line">            ULONG ProcessExiting:<span class="number">1</span>;           <span class="comment">// bit 2: 进程正在退出（终止流程中）</span></span><br><span class="line">            ULONG ProcessDelete:<span class="number">1</span>;            <span class="comment">// bit 3: 进程对象标记为删除</span></span><br><span class="line">            ULONG Wow64SplitPages:<span class="number">1</span>;          <span class="comment">// bit 4: 启用分页拆分机制（32位兼容性）</span></span><br><span class="line">            ULONG VmDeleted:<span class="number">1</span>;                <span class="comment">// bit 5: 虚拟内存空间已销毁</span></span><br><span class="line">            ULONG OutswapEnabled:<span class="number">1</span>;           <span class="comment">// bit 6: 允许被换出内存（Outswap）</span></span><br><span class="line">            ULONG Outswapped:<span class="number">1</span>;               <span class="comment">// bit 7: 已被换出内存</span></span><br><span class="line">            ULONG ForkFailed:<span class="number">1</span>;               <span class="comment">// bit 8: Fork 操作失败</span></span><br><span class="line">            ULONG Wow64VaSpace4Gb:<span class="number">1</span>;          <span class="comment">// bit 9: 启用 Wow64 的完整 4GB 虚拟地址空间</span></span><br><span class="line">            ULONG AddressSpaceInitialized:<span class="number">2</span>;  <span class="comment">// bit10–11: 地址空间初始化状态（0=未初始化，1=中，2=完成）</span></span><br><span class="line">            ULONG SetTimerResolution:<span class="number">1</span>;       <span class="comment">// bit12: 请求高分辨率定时器</span></span><br><span class="line">            ULONG BreakOnTermination:<span class="number">1</span>;       <span class="comment">// bit13: 📌终止进程时触发调试器中断</span></span><br><span class="line">            ULONG DeprioritizeViews:<span class="number">1</span>;        <span class="comment">// bit14: 降低视图优先级</span></span><br><span class="line">            ULONG WriteWatch:<span class="number">1</span>;               <span class="comment">// bit15: 启用写入监控页机制</span></span><br><span class="line">            ULONG ProcessInSession:<span class="number">1</span>;         <span class="comment">// bit16: 进程属于用户会话</span></span><br><span class="line">            ULONG OverrideAddressSpace:<span class="number">1</span>;     <span class="comment">// bit17: 允许覆盖地址空间</span></span><br><span class="line">            ULONG HasAddressSpace:<span class="number">1</span>;          <span class="comment">// bit18: 地址空间已分配</span></span><br><span class="line">            ULONG LaunchPrefetched:<span class="number">1</span>;         <span class="comment">// bit19: 由预取器发起的进程</span></span><br><span class="line">            ULONG InjectInpageErrors:<span class="number">1</span>;       <span class="comment">// bit20: 启用页错误注入</span></span><br><span class="line">            ULONG VmTopDown:<span class="number">1</span>;                <span class="comment">// bit21: 自顶向下分配地址空间</span></span><br><span class="line">            ULONG ImageNotifyDone:<span class="number">1</span>;          <span class="comment">// bit22: 映像加载通知已完成</span></span><br><span class="line">            ULONG PdeUpdateNeeded:<span class="number">1</span>;          <span class="comment">// bit23: 需要更新页目录项</span></span><br><span class="line">            ULONG VdmAllowed:<span class="number">1</span>;               <span class="comment">// bit24: 允许 V86 模式执行（虚拟 8086）</span></span><br><span class="line">            ULONG CrossSessionCreate:<span class="number">1</span>;       <span class="comment">// bit25: 允许跨会话创建</span></span><br><span class="line">            ULONG ProcessInserted:<span class="number">1</span>;          <span class="comment">// bit26: 📌进程已插入系统链表</span></span><br><span class="line">            ULONG DefaultIoPriority:<span class="number">3</span>;        <span class="comment">// bit27–29: 默认 I/O 优先级（0=低优先，3=普通）</span></span><br><span class="line">            ULONG ProcessSelfDelete:<span class="number">1</span>;        <span class="comment">// bit30: 允许进程自删除（常用于恶意进程清理）</span></span><br><span class="line">            ULONG SetTimerResolutionLink:<span class="number">1</span>;   <span class="comment">// bit31: 关联定时器精度链表</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    LONG ExitStatus;                              <span class="comment">// 0x274: 📌进程的退出码，259（0x103）是 Windows 的“还在运行”的默认占位退出码，可以借此判断进程是否退出</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">MM_AVL_TABLE</span> <span class="title">VadRoot</span>;</span>                 <span class="comment">// 0x278: 📌VAD 树（内存分配记录 AVL 树）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ALPC_PROCESS_CONTEXT</span> <span class="title">AlpcContext</span>;</span>     <span class="comment">// 0x298: ALPC 本地进程通信上下文</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">TimerResolutionLink</span>;</span>       <span class="comment">// 0x2A8: 定时器精度链接节点</span></span><br><span class="line">    ULONG RequestedTimerResolution;               <span class="comment">// 0x2B0: 请求的定时器精度</span></span><br><span class="line">    ULONG ActiveThreadsHighWatermark;             <span class="comment">// 0x2B4: 活跃线程历史最高值</span></span><br><span class="line">    ULONG SmallestTimerResolution;                <span class="comment">// 0x2B8: 系统允许的最小定时器分辨率</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">PO_DIAG_STACK_RECORD</span>* <span class="title">TimerResolutionStackRecord</span>;</span> <span class="comment">// 0x2BC: 用于记录调用栈等定时器信息</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="KPROCESS-Kernel-Process"><a href="#KPROCESS-Kernel-Process" class="headerlink" title="KPROCESS (Kernel Process)"></a>KPROCESS (Kernel Process)</h4><p>EPROCESS 的第一个成员，专用于内核调度，仅描述 CPU 调度相关属性 。</p>
<p>关键成员:</p>
<ul>
<li><code>DirectoryTableBase</code>:  CR3 寄存器值，即页目录基址。切换进程本质就是切换这个值来改变虚拟地址空间。</li>
<li><code>ThreadListHead</code>: 该进程下所有线程的链表头。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0x98 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">KPROCESS</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DISPATCHER_HEADER</span> <span class="title">Header</span>;</span>             <span class="comment">// 0x00: 内核对象头，支持调度器的等待/信号机制（继承自调度器对象）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ProfileListHead</span>;</span>           <span class="comment">// 0x10: 性能分析器使用的链表，用于跟踪采样信息</span></span><br><span class="line">    ULONG DirectoryTableBase;                     <span class="comment">// 0x18: 📌页目录基址（CR3），用于进程虚拟地址空间的转换</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KGDTENTRY</span> <span class="title">LdtDescriptor</span>;</span>              <span class="comment">// 0x1C: 进程的 LDT（本地描述符表）描述符（32位兼容）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KIDTENTRY</span> <span class="title">Int21Descriptor</span>;</span>            <span class="comment">// 0x24: 兼容 INT 21H（DOS 中断）的描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ThreadListHead</span>;</span>            <span class="comment">// 0x2C: 📌本进程包含的所有线程链表头（每个 ETHREAD 挂在上面）</span></span><br><span class="line">    ULONG ProcessLock;                            <span class="comment">// 0x34: 内部同步锁，用于进程结构保护</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KAFFINITY_EX</span> <span class="title">Affinity</span>;</span>                <span class="comment">// 0x38: 允许在哪些处理器组（NUMA node）上运行的亲和性掩码</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ReadyListHead</span>;</span>             <span class="comment">// 0x44: 当前进程就绪线程列表（调度器使用）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">SINGLE_LIST_ENTRY</span> <span class="title">SwapListEntry</span>;</span>      <span class="comment">// 0x4C: 换出链表，用于支持进程的虚拟内存分页</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KAFFINITY_EX</span> <span class="title">ActiveProcessors</span>;</span><span class="comment">// 0x50: 当前活跃运行该进程线程的处理器掩码</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="keyword">volatile</span> LONG AutoAlignment:<span class="number">1</span>;        <span class="comment">// 0x5C.0: 自动对齐模式（用于捕获未对齐访问）</span></span><br><span class="line">            <span class="keyword">volatile</span> LONG DisableBoost:<span class="number">1</span>;         <span class="comment">// 0x5C.1: 禁用线程优先级提升（防止因等待而提升优先级）</span></span><br><span class="line">            <span class="keyword">volatile</span> LONG DisableQuantum:<span class="number">1</span>;       <span class="comment">// 0x5C.2: 禁用时间片限制（不被抢占）</span></span><br><span class="line">            <span class="keyword">volatile</span> ULONG ActiveGroupsMask:<span class="number">1</span>;    <span class="comment">// 0x5C.3: 活跃处理器组标志</span></span><br><span class="line">            <span class="keyword">volatile</span> LONG ReservedFlags:<span class="number">28</span>;       <span class="comment">// 0x5C.4~31: 保留</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">volatile</span> LONG ProcessFlags;               <span class="comment">// 0x5C: 原始标志位表示，整体视图</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    CHAR BasePriority;                            <span class="comment">// 0x60: 初始线程优先级（线程继承此值）</span></span><br><span class="line">    CHAR QuantumReset;                            <span class="comment">// 0x61: 时间片重置值（用于线程运行时刷新）</span></span><br><span class="line">    UCHAR Visited;                                <span class="comment">// 0x62: NUMA 节点访问标志（内部使用）</span></span><br><span class="line">    UCHAR Unused3;                                <span class="comment">// 0x63: 保留</span></span><br><span class="line"></span><br><span class="line">    ULONG ThreadSeed[<span class="number">1</span>];                          <span class="comment">// 0x64: 用于线程亲和性随机调度的种子</span></span><br><span class="line">    USHORT IdealNode[<span class="number">1</span>];                          <span class="comment">// 0x68: 线程理想的 NUMA 节点</span></span><br><span class="line">    USHORT IdealGlobalNode;                       <span class="comment">// 0x6A: 全局理想节点编号</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">KEXECUTE_OPTIONS</span> <span class="title">Flags</span>;</span>                <span class="comment">// 0x6C: 执行选项（禁止动态代码等安全配置）</span></span><br><span class="line">    UCHAR Unused1;                                <span class="comment">// 0x6D: 保留</span></span><br><span class="line">    USHORT IopmOffset;                            <span class="comment">// 0x6E: IO 权限位图偏移（用于 Virtual 8086 模式 I/O 控制）</span></span><br><span class="line"></span><br><span class="line">    ULONG Unused4;                                <span class="comment">// 0x70: 保留</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">KSTACK_COUNT</span> <span class="title">StackCount</span>;</span>               <span class="comment">// 0x74: 栈引用计数（线程栈使用情况）</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ProcessListEntry</span>;</span>          <span class="comment">// 0x78: 调度器用的进程链表项（可能链接所有活跃进程）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> ULONGLONG CycleTime;                 <span class="comment">// 0x80: 此进程被调度的 CPU 时间（时钟周期）</span></span><br><span class="line">    ULONG KernelTime;                             <span class="comment">// 0x88: 内核模式运行时间（单位：100ns）</span></span><br><span class="line">    ULONG UserTime;                               <span class="comment">// 0x8C: 用户模式运行时间（单位：100ns）</span></span><br><span class="line"></span><br><span class="line">    VOID* VdmTrapcHandler;                        <span class="comment">// 0x90: 虚拟 DOS 兼容处理程序（V86 模式支持）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="PEB-Process-Environment-Block"><a href="#PEB-Process-Environment-Block" class="headerlink" title="PEB (Process Environment Block)"></a>PEB (Process Environment Block)</h4><p>位于用户模式，存储进程的全局信息，描述当前进程的用户态环境，如模块、堆、TLS、参数等。</p>
<p>关键成员:<code>ImageBaseAddress</code> (基址), <code>Ldr</code> (模块加载链表), <code>ProcessParameters</code> (命令行参数) 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">PEB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    UCHAR InheritedAddressSpace;            <span class="comment">// 0x00: 是否继承地址空间（fork 子进程时为 TRUE）</span></span><br><span class="line">    UCHAR ReadImageFileExecOptions;         <span class="comment">// 0x01: 是否读取镜像执行选项（调试器等兼容选项）</span></span><br><span class="line">    UCHAR BeingDebugged;                    <span class="comment">// 0x02: 当前进程是否正在被调试（由调试器设置）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        UCHAR BitField;                     <span class="comment">// 0x03: 标志位集合</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            UCHAR ImageUsesLargePages:<span class="number">1</span>;            <span class="comment">// bit 0: 镜像是否使用大页内存</span></span><br><span class="line">            UCHAR IsProtectedProcess:<span class="number">1</span>;             <span class="comment">// bit 1: 是否为受保护进程（如 lsass）</span></span><br><span class="line">            UCHAR IsLegacyProcess:<span class="number">1</span>;                <span class="comment">// bit 2: 是否为传统进程（兼容旧系统）</span></span><br><span class="line">            UCHAR IsImageDynamicallyRelocated:<span class="number">1</span>;    <span class="comment">// bit 3: 是否启用了 ASLR（地址随机化）</span></span><br><span class="line">            UCHAR SkipPatchingUser32Forwarders:<span class="number">1</span>;   <span class="comment">// bit 4: 是否跳过 User32.dll 的 API 前向导出修补</span></span><br><span class="line">            UCHAR SpareBits:<span class="number">3</span>;                      <span class="comment">// bit 5-7: 保留位</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    VOID* Mutant;                          <span class="comment">// 0x04: 用于同步的互斥体句柄（防止并发创建）</span></span><br><span class="line">    VOID* ImageBaseAddress;               <span class="comment">// 0x08: 主模块（EXE）加载基地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">PEB_LDR_DATA</span>* <span class="title">Ldr</span>;</span>            <span class="comment">// 0x0C: 指向模块加载器（LDR）数据结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_USER_PROCESS_PARAMETERS</span>* <span class="title">ProcessParameters</span>;</span> <span class="comment">// 0x10: 进程参数，如命令行、环境变量等</span></span><br><span class="line">    VOID* SubSystemData;                  <span class="comment">// 0x14: 子系统专用数据（如 POSIX 子系统）</span></span><br><span class="line">    VOID* ProcessHeap;                    <span class="comment">// 0x18: 默认进程堆的地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_CRITICAL_SECTION</span>* <span class="title">FastPebLock</span>;</span>  <span class="comment">// 0x1C: 用于快速同步的临界区锁</span></span><br><span class="line">    VOID* AtlThunkSListPtr;               <span class="comment">// 0x20: ATL thunk 使用的单链表指针</span></span><br><span class="line">    VOID* IFEOKey;                        <span class="comment">// 0x24: 映像文件执行选项（Image File Execution Options）注册表键句柄</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ULONG CrossProcessFlags;          <span class="comment">// 0x28: 进程状态标志</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            ULONG ProcessInJob:<span class="number">1</span>;         <span class="comment">// bit 0: 进程是否属于 Job 对象</span></span><br><span class="line">            ULONG ProcessInitializing:<span class="number">1</span>;  <span class="comment">// bit 1: 进程是否尚在初始化中</span></span><br><span class="line">            ULONG ProcessUsingVEH:<span class="number">1</span>;      <span class="comment">// bit 2: 是否使用 VEH 异常处理（Vectored Exception Handler）</span></span><br><span class="line">            ULONG ProcessUsingVCH:<span class="number">1</span>;      <span class="comment">// bit 3: 是否使用 VCH 异常处理（Vectored Continue Handler）</span></span><br><span class="line">            ULONG ProcessUsingFTH:<span class="number">1</span>;      <span class="comment">// bit 4: 是否启用了故障容错处理（Fault Tolerant Heap）</span></span><br><span class="line">            ULONG ReservedBits0:<span class="number">27</span>;       <span class="comment">// bit 5-31: 保留</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        VOID* KernelCallbackTable;        <span class="comment">// 0x2C: 内核模式回调表（如 GUI 回调）</span></span><br><span class="line">        VOID* UserSharedInfoPtr;          <span class="comment">//        用户共享信息结构指针</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ULONG SystemReserved[<span class="number">1</span>];             <span class="comment">// 0x30: 系统保留字段</span></span><br><span class="line">    ULONG AtlThunkSListPtr32;            <span class="comment">// 0x34: ATL thunk 用于 32 位兼容的单链表指针</span></span><br><span class="line">    VOID* ApiSetMap;                     <span class="comment">// 0x38: API Set 映射结构（用于模块重定向）</span></span><br><span class="line">    ULONG TlsExpansionCounter;           <span class="comment">// 0x3C: TLS 扩展槽计数器</span></span><br><span class="line">    VOID* TlsBitmap;                     <span class="comment">// 0x40: TLS 位图指针（标记可用的 TLS 插槽）</span></span><br><span class="line">    ULONG TlsBitmapBits[<span class="number">2</span>];             <span class="comment">// 0x44: TLS 位图本体（64 个槽）</span></span><br><span class="line">    VOID* ReadOnlySharedMemoryBase;      <span class="comment">// 0x4C: 只读共享内存基地址（Windows 内部用途）</span></span><br><span class="line">    VOID* HotpatchInformation;           <span class="comment">// 0x50: 热补丁相关结构体</span></span><br><span class="line">    VOID** ReadOnlyStaticServerData;     <span class="comment">// 0x54: 静态服务器数据的指针数组</span></span><br><span class="line">    VOID* AnsiCodePageData;              <span class="comment">// 0x58: ANSI 码页数据（LCID 对应）</span></span><br><span class="line">    VOID* OemCodePageData;               <span class="comment">// 0x5C: OEM 码页数据</span></span><br><span class="line">    VOID* UnicodeCaseTableData;          <span class="comment">// 0x60: Unicode 大小写映射表</span></span><br><span class="line">    ULONG NumberOfProcessors;            <span class="comment">// 0x64: 系统中可用的逻辑处理器数量</span></span><br><span class="line">    ULONG NtGlobalFlag;                  <span class="comment">// 0x68: 全局标志位（调试器、特殊分配等标记）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">CriticalSectionTimeout</span>;</span>  <span class="comment">// 0x70: 临界区超时时间（用于死锁检测）</span></span><br><span class="line">    ULONG HeapSegmentReserve;            <span class="comment">// 0x78: 堆段保留大小</span></span><br><span class="line">    ULONG HeapSegmentCommit;             <span class="comment">// 0x7C: 堆段提交大小</span></span><br><span class="line">    ULONG HeapDeCommitTotalFreeThreshold;<span class="comment">// 0x80: 堆释放总阈值</span></span><br><span class="line">    ULONG HeapDeCommitFreeBlockThreshold;<span class="comment">// 0x84: 堆释放单块阈值</span></span><br><span class="line">    ULONG NumberOfHeaps;                 <span class="comment">// 0x88: 当前进程拥有的堆数量</span></span><br><span class="line">    ULONG MaximumNumberOfHeaps;          <span class="comment">// 0x8C: 最大堆数量</span></span><br><span class="line">    VOID** ProcessHeaps;                 <span class="comment">// 0x90: 堆数组指针（实际堆地址数组）</span></span><br><span class="line">    VOID* GdiSharedHandleTable;          <span class="comment">// 0x94: GDI 共享句柄表</span></span><br><span class="line">    VOID* ProcessStarterHelper;          <span class="comment">// 0x98: 启动帮助函数</span></span><br><span class="line">    ULONG GdiDCAttributeList;            <span class="comment">// 0x9C: GDI DC 属性位图（标识属性状态）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_CRITICAL_SECTION</span>* <span class="title">LoaderLock</span>;</span>  <span class="comment">// 0xA0: Ldr 模块加载器锁</span></span><br><span class="line">    ULONG OSMajorVersion;                <span class="comment">// 0xA4: 操作系统主版本号</span></span><br><span class="line">    ULONG OSMinorVersion;                <span class="comment">// 0xA8: 操作系统次版本号</span></span><br><span class="line">    USHORT OSBuildNumber;                <span class="comment">// 0xAC: 构建号（Build Number）</span></span><br><span class="line">    USHORT OSCSDVersion;                 <span class="comment">// 0xAE: 客户服务描述版本（如 SP1）</span></span><br><span class="line">    ULONG OSPlatformId;                  <span class="comment">// 0xB0: 平台 ID（Win32 NT = 2）</span></span><br><span class="line">    ULONG ImageSubsystem;                <span class="comment">// 0xB4: 子系统类型（GUI = 2, CUI = 3）</span></span><br><span class="line">    ULONG ImageSubsystemMajorVersion;    <span class="comment">// 0xB8: 子系统主版本号</span></span><br><span class="line">    ULONG ImageSubsystemMinorVersion;    <span class="comment">// 0xBC: 子系统次版本号</span></span><br><span class="line">    ULONG ActiveProcessAffinityMask;     <span class="comment">// 0xC0: 进程默认亲和性掩码</span></span><br><span class="line">    ULONG GdiHandleBuffer[<span class="number">34</span>];           <span class="comment">// 0xC4: 用于 GDI 的句柄缓存（优化）</span></span><br><span class="line">    VOID (*PostProcessInitRoutine)();    <span class="comment">// 0x14C: 进程初始化后回调函数</span></span><br><span class="line">    VOID* TlsExpansionBitmap;            <span class="comment">// 0x150: 扩展 TLS 位图</span></span><br><span class="line">    ULONG TlsExpansionBitmapBits[<span class="number">32</span>];    <span class="comment">// 0x154: TLS 扩展槽使用位图</span></span><br><span class="line">    ULONG SessionId;                     <span class="comment">// 0x1D4: 当前 Session 的 ID</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">ULARGE_INTEGER</span> <span class="title">AppCompatFlags</span>;</span>        <span class="comment">// 0x1D8: 应用兼容性标志</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">ULARGE_INTEGER</span> <span class="title">AppCompatFlagsUser</span>;</span>    <span class="comment">// 0x1E0: 用户级应用兼容性标志</span></span><br><span class="line">    VOID* pShimData;                     <span class="comment">// 0x1E8: Shim 层数据（兼容性修复层）</span></span><br><span class="line">    VOID* AppCompatInfo;                 <span class="comment">// 0x1EC: 应用兼容性信息结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> <span class="title">CSDVersion</span>;</span>   <span class="comment">// 0x1F0: 系统版本描述字符串（如 &quot;Service Pack 1&quot;）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ACTIVATION_CONTEXT_DATA</span>* <span class="title">ActivationContextData</span>;</span> <span class="comment">// 0x1F8: 激活上下文信息（Side-by-Side）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ASSEMBLY_STORAGE_MAP</span>* <span class="title">ProcessAssemblyStorageMap</span>;</span> <span class="comment">// 0x1FC: 应用程序集存储映射表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ACTIVATION_CONTEXT_DATA</span>* <span class="title">SystemDefaultActivationContextData</span>;</span> <span class="comment">// 0x200: 系统默认激活上下文</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ASSEMBLY_STORAGE_MAP</span>* <span class="title">SystemAssemblyStorageMap</span>;</span> <span class="comment">// 0x204: 系统程序集映射表</span></span><br><span class="line">    ULONG MinimumStackCommit;            <span class="comment">// 0x208: 最小堆栈提交大小</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">FLS_CALLBACK_INFO</span>* <span class="title">FlsCallback</span>;</span>      <span class="comment">// 0x20C: FLS 回调函数指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">FlsListHead</span>;</span>      <span class="comment">// 0x210: FLS 数据链表</span></span><br><span class="line">    VOID* FlsBitmap;                     <span class="comment">// 0x218: FLS 插槽使用位图</span></span><br><span class="line">    ULONG FlsBitmapBits[<span class="number">4</span>];              <span class="comment">// 0x21C: FLS 插槽实际位图（128 位）</span></span><br><span class="line">    ULONG FlsHighIndex;                  <span class="comment">// 0x22C: 当前最大 FLS 插槽索引</span></span><br><span class="line">    VOID* WerRegistrationData;           <span class="comment">// 0x230: Windows 错误报告注册数据</span></span><br><span class="line">    VOID* WerShipAssertPtr;              <span class="comment">// 0x234: Ship Assert 支持结构</span></span><br><span class="line">    VOID* pContextData;                  <span class="comment">// 0x238: 上下文数据（调试器/CLR）</span></span><br><span class="line">    VOID* pImageHeaderHash;              <span class="comment">// 0x23C: 镜像头部哈希值（完整性验证）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ULONG TracingFlags;              <span class="comment">// 0x240: 跟踪标志</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            ULONG HeapTracingEnabled:<span class="number">1</span>;         <span class="comment">// bit 0: 启用堆跟踪</span></span><br><span class="line">            ULONG CritSecTracingEnabled:<span class="number">1</span>;      <span class="comment">// bit 1: 启用临界区跟踪</span></span><br><span class="line">            ULONG SpareTracingBits:<span class="number">30</span>;          <span class="comment">// bit 2-31: 保留</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="进程查找"><a href="#进程查找" class="headerlink" title="进程查找"></a>进程查找</h3><h4 id="遍历进程链表"><a href="#遍历进程链表" class="headerlink" title="遍历进程链表"></a>遍历进程链表</h4><p><code>EPROCESS</code> 的 <code>ActiveProcessLinks</code> 字段表示当前活动的进程的 <code>EPROCESS</code> 构成的双向链表，我们可以遍历这个双向链表来查找指定进程名对应的 <code>EPROCESS</code></p>
<p><code>ActiveProcessLinks</code> 字段的偏移量可以通过 <code>PsGetProcessId</code> 函数来定位 <code>UniqueProcessId</code> 字段（该字段和 <code>ActiveProcessLinks</code>相邻）</p>
<p>对于 64 位我们只需要取 <code>PsGetProcessId</code> 后面 3 字节偏移位置的 4 字节即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">; HANDLE __stdcall PsGetProcessId(_EPROCESS *Process)</span><br><span class="line">PsGetProcessId proc near</span><br><span class="line">    mov     rax, [rcx+_EPROCESS.UniqueProcessId] ; 👈 48 8B 81 xx xx xx xx</span><br><span class="line">    retn</span><br><span class="line">PsGetProcessId endp</span><br></pre></td></tr></table></figure>

<h4 id="枚举进程ID"><a href="#枚举进程ID" class="headerlink" title="枚举进程ID"></a>枚举进程ID</h4><p>在某些场景下（如内核 Rootkit），<code>ActiveProcessLinks</code> 链表可能被恶意修改（如断链）以隐藏进程。这种情况下，仅靠 <code>ActiveProcessLinks</code> 遍历将无法发现目标进程。</p>
<p>Windows 为所有活动进程维护了系统对象句柄表。<code>PsLookupProcessByProcessId</code> 会通过这些内核内部机制而不是链表查找 <code>EPROCESS</code>，因此仍能定位被“断链”隐藏的进程。</p>
<h3 id="进程隐藏"><a href="#进程隐藏" class="headerlink" title="进程隐藏"></a>进程隐藏</h3><p>进程断链：将目标进程的 EPROCESS 从 <code>ActiveProcessLinks</code>链表中摘除（修改 Flink 和 Blink 指针）。这会让任务管理器无法显示该进程，但进程依然被 CPU 调度（因为它还在调度器的就绪队列中）。</p>
<p>PID 篡改：直接修改 <code>EPROCESS.UniqueProcessId</code>。虽然能干扰基于 PID 的工具，但可能导致系统不稳定 。</p>
<h3 id="进程保护"><a href="#进程保护" class="headerlink" title="进程保护"></a>进程保护</h3><h4 id="BreakOnTermination-Flags-bit13"><a href="#BreakOnTermination-Flags-bit13" class="headerlink" title="BreakOnTermination (Flags bit13)"></a>BreakOnTermination (Flags bit13)</h4><p>是一种机制，在进程即将被终止时触发断点。设置 <code>ETHREAD</code>或 <code>EPROCESS</code>的特定标志位。如果该进程被强行终止，系统会触发蓝屏（BSOD）。这通常是杀软或恶意驱动的自我保护手段。</p>
<h4 id="ProcessInserted-Flags-bit26"><a href="#ProcessInserted-Flags-bit26" class="headerlink" title="ProcessInserted (Flags bit26)"></a>ProcessInserted (Flags bit26)</h4><p>标志位设置为 0时，其他进程无法通过获得句柄对受保护进程进行修改或干预。常见的应用场景包括防止恶意软件或不当操作干扰受保护进程的运行。进程自身也将无法创建线程、访问或操作其他句柄，甚至可能无法执行对自身的管理操作。具体来说，创建新线程、分配内存、访问文件句柄等操作将受到影响，导致进程无法正常执行这些任务。</p>
<h4 id="ProtectedProcess-Flags2-bit11"><a href="#ProtectedProcess-Flags2-bit11" class="headerlink" title="ProtectedProcess (Flags2 bit11)"></a>ProtectedProcess (Flags2 bit11)</h4><p>是一种通过在操作系统中标记进程来防止其被结束或修改的技术。它可以确保某些关键进程（如操作系统服务或反病毒进程）不被恶意软件或未经授权的操作干扰。</p>
<p><code>ProtectedProcess</code> 标志与 <code>CreateProcess</code> 函数中的 <code>dwCreationFlags</code> 参数中的 <code>CREATE_PROTECTED_PROCESS</code> 标志位相关。使用 <code>CREATE_PROTECTED_PROCESS</code> 启动的进程会被标记为受保护进程。然而，该二进制文件必须具有由 Microsoft 提供的特殊签名，非 Microsoft 的二进制文件无法直接成为受保护进程。</p>
<h3 id="线程结构"><a href="#线程结构" class="headerlink" title="线程结构"></a>线程结构</h3><h4 id="ETHREAD-Executive-Thread"><a href="#ETHREAD-Executive-Thread" class="headerlink" title="ETHREAD(Executive Thread)"></a>ETHREAD(Executive Thread)</h4><p>线程管理的最高层结构。</p>
<p>包含: 线程创建时间、起始地址、所属进程等。</p>
<p>关键成员:<code>Cid</code> (包含 PID 和 TID) , <code>StartAddress</code> (线程入口) 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0x2B8 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">ETHREAD</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KTHREAD</span> <span class="title">Tcb</span>;</span>                            <span class="comment">// 0x000: 内核线程结构（线程控制块，KTHREAD）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">CreateTime</span>;</span>               <span class="comment">// 0x200: 线程创建时间（自系统启动以来的时间）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">ExitTime</span>;</span>             <span class="comment">// 0x208: 线程退出时间（0 表示未退出）</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">KeyedWaitChain</span>;</span>         <span class="comment">// 0x208: 用于 Keyed Event 同步的链表</span></span><br><span class="line">    &#125;;</span><br><span class="line">    LONG ExitStatus;                               <span class="comment">// 0x210: 线程退出状态码（如 0 为正常）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">PostBlockList</span>;</span>          <span class="comment">// 0x214: APC 完成时挂起的 IRP 等列表</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            VOID* ForwardLinkShadow;               <span class="comment">// 0x214: 内部链接指针</span></span><br><span class="line">            VOID* StartAddress;                    <span class="comment">// 0x218: 📌用户模式下的线程起始地址</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">TERMINATION_PORT</span>* <span class="title">TerminationPort</span>;</span> <span class="comment">// 0x21C: 通知线程终止的端口对象</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">ETHREAD</span>* <span class="title">ReaperLink</span>;</span>               <span class="comment">// 0x21C: 用于线程回收（Reaper）链表</span></span><br><span class="line">        VOID* KeyedWaitValue;                      <span class="comment">// 0x21C: Keyed Event 用的值</span></span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG ActiveTimerListLock;                     <span class="comment">// 0x220: 活动定时器链表锁</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ActiveTimerListHead</span>;</span>        <span class="comment">// 0x224: 活动定时器链表头</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">CLIENT_ID</span> <span class="title">Cid</span>;</span>                         <span class="comment">// 0x22C: 📌客户端 ID（包含进程 ID 和线程 ID）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">KSEMAPHORE</span> <span class="title">KeyedWaitSemaphore</span>;</span>     <span class="comment">// 0x234: Keyed Event 信号量</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">KSEMAPHORE</span> <span class="title">AlpcWaitSemaphore</span>;</span>      <span class="comment">// 0x234: ALPC 使用的信号量</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">PS_CLIENT_SECURITY_CONTEXT</span> <span class="title">ClientSecurity</span>;</span> <span class="comment">// 0x248: 线程安全上下文（用于模拟）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">IrpList</span>;</span>                    <span class="comment">// 0x24C: 线程持有的 IRP 链表</span></span><br><span class="line">    ULONG TopLevelIrp;                             <span class="comment">// 0x254: 用于避免 IRP 嵌套递归</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DEVICE_OBJECT</span>* <span class="title">DeviceToVerify</span>;</span>         <span class="comment">// 0x258: 安全检查使用的设备对象</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">PSP_CPU_QUOTA_APC</span>* <span class="title">CpuQuotaApc</span>;</span>         <span class="comment">// 0x25C: CPU 配额 APC（调控线程使用时间）</span></span><br><span class="line">    VOID* Win32StartAddress;                       <span class="comment">// 0x260: 📌Win32 子系统看到的起始地址</span></span><br><span class="line">    VOID* LegacyPowerObject;                       <span class="comment">// 0x264: 旧版电源对象（已废弃）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ThreadListEntry</span>;</span>            <span class="comment">// 0x268: 所在进程线程列表的节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EX_RUNDOWN_REF</span> <span class="title">RundownProtect</span>;</span>         <span class="comment">// 0x270: Rundown 保护机制（防止销毁中访问）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EX_PUSH_LOCK</span> <span class="title">ThreadLock</span>;</span>               <span class="comment">// 0x274: 线程对象自旋锁</span></span><br><span class="line">    ULONG ReadClusterSize;                         <span class="comment">// 0x278: 用于文件读取的集群大小优化</span></span><br><span class="line">    <span class="keyword">volatile</span> LONG MmLockOrdering;                  <span class="comment">// 0x27C: 内存管理器锁顺序调试字段</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        ULONG CrossThreadFlags;                    <span class="comment">// 0x280: 跨线程共享的状态标志</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ULONG Terminated               : <span class="number">1</span>;    <span class="comment">// bit 0: 线程已终止</span></span><br><span class="line">            ULONG ThreadInserted           : <span class="number">1</span>;    <span class="comment">// bit 1: 📌插入线程调度队列</span></span><br><span class="line">            ULONG HideFromDebugger         : <span class="number">1</span>;    <span class="comment">// bit 2: 📌隐藏线程以防调试</span></span><br><span class="line">            ULONG ActiveImpersonationInfo  : <span class="number">1</span>;    <span class="comment">// bit 3: 当前线程启用了模拟令牌</span></span><br><span class="line">            ULONG Reserved                 : <span class="number">1</span>;    <span class="comment">// bit 4: 保留位</span></span><br><span class="line">            ULONG HardErrorsAreDisabled    : <span class="number">1</span>;    <span class="comment">// bit 5: 禁用硬错误弹窗</span></span><br><span class="line">            ULONG BreakOnTermination       : <span class="number">1</span>;    <span class="comment">// bit 6: 📌线程终止时触发断点（调试用）</span></span><br><span class="line">            ULONG SkipCreationMsg          : <span class="number">1</span>;    <span class="comment">// bit 7: 跳过创建消息通知</span></span><br><span class="line">            ULONG SkipTerminationMsg       : <span class="number">1</span>;    <span class="comment">// bit 8: 跳过终止消息通知</span></span><br><span class="line">            ULONG CopyTokenOnOpen          : <span class="number">1</span>;    <span class="comment">// bit 9: 打开线程时复制其访问令牌</span></span><br><span class="line">            ULONG ThreadIoPriority         : <span class="number">3</span>;    <span class="comment">// bit 10–12: IO 优先级（0~7）</span></span><br><span class="line">            ULONG ThreadPagePriority       : <span class="number">3</span>;    <span class="comment">// bit 13–15: 页面优先级（0~7）</span></span><br><span class="line">            ULONG RundownFail              : <span class="number">1</span>;    <span class="comment">// bit 16: Rundown 阶段失败标记</span></span><br><span class="line">            ULONG NeedsWorkingSetAging     : <span class="number">1</span>;    <span class="comment">// bit 17: 需要工作集老化处理</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        ULONG SameThreadPassiveFlags;             <span class="comment">// 0x284: 被动线程上下文状态位（当前线程本地）</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ULONG ActiveExWorker                : <span class="number">1</span>;  <span class="comment">// bit 0: 是否为激活的工作线程（Ex worker）</span></span><br><span class="line">            ULONG ExWorkerCanWaitUser           : <span class="number">1</span>;  <span class="comment">// bit 1: Ex worker 是否可以等待用户对象</span></span><br><span class="line">            ULONG MemoryMaker                   : <span class="number">1</span>;  <span class="comment">// bit 2: 是否参与内存页生成（如内存映射）</span></span><br><span class="line">            ULONG ClonedThread                  : <span class="number">1</span>;  <span class="comment">// bit 3: 是否为克隆线程（CreateRemoteThreadEx 等）</span></span><br><span class="line">            ULONG KeyedEventInUse               : <span class="number">1</span>;  <span class="comment">// bit 4: 是否正在使用 KeyedEvent</span></span><br><span class="line">            ULONG RateApcState                  : <span class="number">2</span>;  <span class="comment">// bit 5–6: 用于页面优先级/调度器统计用途</span></span><br><span class="line">            ULONG SelfTerminate                 : <span class="number">1</span>;  <span class="comment">// bit 7: 是否调用 PsTerminateThread 终止自身</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        ULONG SameThreadApcFlags;                 <span class="comment">// 0x288: 当前线程用于 APC 管理的状态标志位</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            UCHAR Spare                              : <span class="number">1</span>;  <span class="comment">// bit  0: 保留</span></span><br><span class="line">            <span class="keyword">volatile</span> UCHAR StartAddressInvalid       : <span class="number">1</span>;  <span class="comment">// bit  1: 启动地址是否无效（调试或错误状态）</span></span><br><span class="line">            UCHAR EtwPageFaultCalloutActive          : <span class="number">1</span>;  <span class="comment">// bit  2: 是否正在处理 ETW 页面错误回调</span></span><br><span class="line">            UCHAR OwnsProcessWorkingSetExclusive     : <span class="number">1</span>;  <span class="comment">// bit  3: 是否独占进程工作集</span></span><br><span class="line">            UCHAR OwnsProcessWorkingSetShared        : <span class="number">1</span>;  <span class="comment">// bit  4: 是否共享进程工作集</span></span><br><span class="line">            UCHAR OwnsSystemCacheWorkingSetExclusive : <span class="number">1</span>;  <span class="comment">// bit  5: 是否独占系统缓存工作集</span></span><br><span class="line">            UCHAR OwnsSystemCacheWorkingSetShared    : <span class="number">1</span>;  <span class="comment">// bit  6: 是否共享系统缓存工作集</span></span><br><span class="line">            UCHAR OwnsSessionWorkingSetExclusive     : <span class="number">1</span>;  <span class="comment">// bit  7: 是否独占 session 工作集</span></span><br><span class="line">            UCHAR OwnsSessionWorkingSetShared        : <span class="number">1</span>;  <span class="comment">// bit  8: 是否共享 session 工作集</span></span><br><span class="line">            UCHAR OwnsProcessAddressSpaceExclusive   : <span class="number">1</span>;  <span class="comment">// bit  9: 是否独占进程地址空间</span></span><br><span class="line">            UCHAR OwnsProcessAddressSpaceShared      : <span class="number">1</span>;  <span class="comment">// bit 10: 是否共享进程地址空间</span></span><br><span class="line">            UCHAR SuppressSymbolLoad                 : <span class="number">1</span>;  <span class="comment">// bit 11: 禁用符号加载（用于调试）</span></span><br><span class="line">            UCHAR Prefetching                        : <span class="number">1</span>;  <span class="comment">// bit 12: 是否正在预取内存</span></span><br><span class="line">            UCHAR OwnsDynamicMemoryShared            : <span class="number">1</span>;  <span class="comment">// bit 13: 是否共享动态内存访问</span></span><br><span class="line">            UCHAR OwnsChangeControlAreaExclusive     : <span class="number">1</span>;  <span class="comment">// bit 14: 是否独占控制区（节段/文件映射）</span></span><br><span class="line">            UCHAR OwnsChangeControlAreaShared        : <span class="number">1</span>;  <span class="comment">// bit 15: 是否共享控制区</span></span><br><span class="line">            UCHAR OwnsPagedPoolWorkingSetExclusive   : <span class="number">1</span>;  <span class="comment">// bit 16: 是否独占分页池工作集</span></span><br><span class="line">            UCHAR OwnsPagedPoolWorkingSetShared      : <span class="number">1</span>;  <span class="comment">// bit 17: 是否共享分页池工作集</span></span><br><span class="line">            UCHAR OwnsSystemPtesWorkingSetExclusive  : <span class="number">1</span>;  <span class="comment">// bit 18: 是否独占系统 PTE 工作集</span></span><br><span class="line">            UCHAR OwnsSystemPtesWorkingSetShared     : <span class="number">1</span>;  <span class="comment">// bit 19: 是否共享系统 PTE 工作集</span></span><br><span class="line">            UCHAR TrimTrigger                        : <span class="number">2</span>;  <span class="comment">// bit 20–21: 页面修剪触发器标志</span></span><br><span class="line">            UCHAR Spare1                             : <span class="number">2</span>;  <span class="comment">// bit 22–23: 保留</span></span><br><span class="line">            UCHAR PriorityRegionActive;                    <span class="comment">// 0x28B: 当前是否处于优先处理区域（内存调度相关）</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    UCHAR CacheManagerActive;                      <span class="comment">// 0x28C: 是否参与 Cache Manager 操作</span></span><br><span class="line">    UCHAR DisablePageFaultClustering;              <span class="comment">// 0x28D: 是否禁用页面错误聚类（优化调入）</span></span><br><span class="line">    UCHAR ActiveFaultCount;                        <span class="comment">// 0x28E: 当前活动页面错误计数</span></span><br><span class="line">    UCHAR LockOrderState;                          <span class="comment">// 0x28F: 锁顺序状态标志（死锁检测辅助）</span></span><br><span class="line"></span><br><span class="line">    ULONG AlpcMessageId;                           <span class="comment">// 0x290: 当前正在处理的 ALPC 消息 ID</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        VOID* AlpcMessage;                         <span class="comment">// 0x294: 当前 ALPC 消息的指针</span></span><br><span class="line">        ULONG AlpcReceiveAttributeSet;             <span class="comment">// 0x294: ALPC 接收消息时的属性掩码</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">AlpcWaitListEntry</span>;</span>          <span class="comment">// 0x298: 等待 ALPC 消息时的链表节点</span></span><br><span class="line">    ULONG CacheManagerCount;                       <span class="comment">// 0x2A0: 参与 Cache Manager 调度的次数</span></span><br><span class="line">    ULONG IoBoostCount;                            <span class="comment">// 0x2A4: IO 优先级提升计数</span></span><br><span class="line">    ULONG IrpListLock;                             <span class="comment">// 0x2A8: IRP 列表自旋锁</span></span><br><span class="line">    VOID* ReservedForSynchTracking;                <span class="comment">// 0x2AC: 同步追踪保留字段</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">SINGLE_LIST_ENTRY</span> <span class="title">CmCallbackListHead</span>;</span>  <span class="comment">// 0x2B0: 注册表回调链表头（用于 Cm 注册通知）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="KTHREAD-Kernel-Thread"><a href="#KTHREAD-Kernel-Thread" class="headerlink" title="KTHREAD (Kernel Thread)"></a>KTHREAD (Kernel Thread)</h4><p>ETHREAD 的第一个成员，包含调度器所需的所有状态。</p>
<p>关键成员:</p>
<ul>
<li><code>KernelStack</code>: 内核栈指针（切换线程时保存 ESP）。</li>
<li><code>State</code>: 线程状态（Running, Ready, Waiting 等）。</li>
<li><code>Teb</code>: 指向用户模式 TEB 的指针。</li>
<li><code>ContextSwitches</code>: 上下文切换次数统计。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">KTHREAD</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DISPATCHER_HEADER</span> <span class="title">Header</span>;</span>             <span class="comment">// 0x00: 调度器头，支持线程同步、定时器等</span></span><br><span class="line">    <span class="keyword">volatile</span> ULONGLONG CycleTime;                 <span class="comment">// 0x10: 累计使用的 CPU 时间（时间戳计数）</span></span><br><span class="line">    <span class="keyword">volatile</span> ULONG HighCycleTime;                 <span class="comment">// 0x18: CycleTime 的高 32 位</span></span><br><span class="line">    ULONGLONG QuantumTarget;                      <span class="comment">// 0x20: 时间片截止时间</span></span><br><span class="line">    VOID* InitialStack;                           <span class="comment">// 0x28: 📌栈底指针</span></span><br><span class="line">    VOID* <span class="keyword">volatile</span> StackLimit;                    <span class="comment">// 0x2C: 📌栈顶界限（溢出保护）</span></span><br><span class="line">    VOID* KernelStack;                            <span class="comment">// 0x30: 📌当前内核栈指针，用户线程切换的时候保存 ESP</span></span><br><span class="line">    ULONG ThreadLock;                             <span class="comment">// 0x34: 自旋锁，用于线程结构保护</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">KWAIT_STATUS_REGISTER</span> <span class="title">WaitRegister</span>;</span>    <span class="comment">// 0x38: 等待状态寄存器（压缩状态位）</span></span><br><span class="line">    <span class="keyword">volatile</span> UCHAR Running;                       <span class="comment">// 0x39: 📌当前是否正在运行（1 表示运行）</span></span><br><span class="line">    UCHAR Alerted[<span class="number">2</span>];                             <span class="comment">// 0x3A: 📌[0]=内核APC警报, [1]=用户APC警报</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ULONG KernelStackResident:<span class="number">1</span>;          <span class="comment">// bit  0: 栈是否驻留在内存中</span></span><br><span class="line">            ULONG ReadyTransition:<span class="number">1</span>;              <span class="comment">// bit  1: 准备态转运行态</span></span><br><span class="line">            ULONG ProcessReadyQueue:<span class="number">1</span>;            <span class="comment">// bit  2: 线程是否在进程就绪队列中</span></span><br><span class="line">            ULONG WaitNext:<span class="number">1</span>;                     <span class="comment">// bit  3: 是否立即等待下一个事件</span></span><br><span class="line">            ULONG SystemAffinityActive:<span class="number">1</span>;         <span class="comment">// bit  4: 是否强制使用系统亲和性</span></span><br><span class="line">            ULONG Alertable:<span class="number">1</span>;                    <span class="comment">// bit  5: 📌是否可以中断（用于 APC）</span></span><br><span class="line">            ULONG GdiFlushActive:<span class="number">1</span>;               <span class="comment">// bit  6: 是否在刷新 GDI 缓存</span></span><br><span class="line">            ULONG UserStackWalkActive:<span class="number">1</span>;          <span class="comment">// bit  7: 是否正在遍历用户栈</span></span><br><span class="line">            ULONG ApcInterruptRequest:<span class="number">1</span>;          <span class="comment">// bit  8: 📌是否请求 APC 中断</span></span><br><span class="line">            ULONG ForceDeferSchedule:<span class="number">1</span>;           <span class="comment">// bit  9: 是否强制延迟调度</span></span><br><span class="line">            ULONG QuantumEndMigrate:<span class="number">1</span>;            <span class="comment">// bit 10: 是否允许量子结束时迁移</span></span><br><span class="line">            ULONG UmsDirectedSwitchEnable:<span class="number">1</span>;      <span class="comment">// bit 11: 是否启用 UMS 指定切换</span></span><br><span class="line">            ULONG TimerActive:<span class="number">1</span>;                  <span class="comment">// bit 12: 线程是否激活了计时器</span></span><br><span class="line">            ULONG SystemThread:<span class="number">1</span>;                 <span class="comment">// bit 13: 是否为系统线程（非用户）</span></span><br><span class="line">            ULONG Reserved:<span class="number">18</span>;                    <span class="comment">// bit 14-31: 保留位</span></span><br><span class="line">        &#125;;</span><br><span class="line">        LONG MiscFlags;                           <span class="comment">// 0x3C: 以上所有位的组合访问</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">KAPC_STATE</span> <span class="title">ApcState</span>;</span>              <span class="comment">// 0x40: 📌APC 状态，含队列与锁</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            UCHAR ApcStateFill[<span class="number">23</span>];               <span class="comment">// 填充</span></span><br><span class="line">            CHAR Priority;                        <span class="comment">// 0x57: 当前线程调度优先级</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">volatile</span> ULONG NextProcessor;                <span class="comment">// 0x58: 调度目标 CPU</span></span><br><span class="line">    <span class="keyword">volatile</span> ULONG DeferredProcessor;            <span class="comment">// 0x5C: 被延迟分配的 CPU</span></span><br><span class="line">    ULONG ApcQueueLock;                          <span class="comment">// 0x60: APC 队列互斥锁</span></span><br><span class="line">    ULONG ContextSwitches;                       <span class="comment">// 0x64: 上下文切换计数器</span></span><br><span class="line">    <span class="keyword">volatile</span> UCHAR State;                        <span class="comment">// 0x68: 线程状态（Initialized 等）</span></span><br><span class="line">    CHAR NpxState;                               <span class="comment">// 0x69: 协处理器状态</span></span><br><span class="line">    UCHAR WaitIrql;                              <span class="comment">// 0x6A: 等待时提升的 IRQL</span></span><br><span class="line">    CHAR WaitMode;                               <span class="comment">// 0x6B: 等待模式（内核 / 用户）</span></span><br><span class="line">    <span class="keyword">volatile</span> LONG WaitStatus;                    <span class="comment">// 0x6C: 等待完成状态</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KWAIT_BLOCK</span>* <span class="title">WaitBlockList</span>;</span>          <span class="comment">// 0x70: 等待块链表指针</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">WaitListEntry</span>;</span>        <span class="comment">// 0x74: 等待对象链表节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">SINGLE_LIST_ENTRY</span> <span class="title">SwapListEntry</span>;</span> <span class="comment">// 0x74: 用于交换线程的备用单链</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KQUEUE</span>* <span class="title">volatile</span> <span class="title">Queue</span>;</span>              <span class="comment">// 0x7C: 所在等待队列</span></span><br><span class="line">    ULONG WaitTime;                              <span class="comment">// 0x80: 等待开始时间</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            SHORT KernelApcDisable;              <span class="comment">// 0x84: 禁止内核 APC</span></span><br><span class="line">            SHORT SpecialApcDisable;             <span class="comment">// 0x86: 禁止特殊 APC（如调度）</span></span><br><span class="line">        &#125;;</span><br><span class="line">        ULONG CombinedApcDisable;                <span class="comment">// 0x84: 合并后的 APC 禁止位</span></span><br><span class="line">    &#125;;</span><br><span class="line">    VOID* Teb;                                   <span class="comment">// 0x88: 📌用户线程环境块 TEB 指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KTIMER</span> <span class="title">Timer</span>;</span>                        <span class="comment">// 0x90: 内核定时器对象</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ULONG AutoAlignment:<span class="number">1</span>;               <span class="comment">// bit  0: 栈自动对齐</span></span><br><span class="line">            ULONG DisableBoost:<span class="number">1</span>;                <span class="comment">// bit  1: 禁用优先级提升</span></span><br><span class="line">            ULONG EtwStackTraceApc1Inserted:<span class="number">1</span>;   <span class="comment">// bit  2: ETW APC1 插入标志</span></span><br><span class="line">            ULONG EtwStackTraceApc2Inserted:<span class="number">1</span>;   <span class="comment">// bit  3: ETW APC2 插入标志</span></span><br><span class="line">            ULONG CalloutActive:<span class="number">1</span>;               <span class="comment">// bit  4: 回调活动中</span></span><br><span class="line">            ULONG ApcQueueable:<span class="number">1</span>;                <span class="comment">// bit  5: 是否允许 APC 入队</span></span><br><span class="line">            ULONG EnableStackSwap:<span class="number">1</span>;             <span class="comment">// bit  6: 启用栈切换</span></span><br><span class="line">            ULONG GuiThread:<span class="number">1</span>;                   <span class="comment">// bit  7: 是否 GUI 线程</span></span><br><span class="line">            ULONG UmsPerformingSyscall:<span class="number">1</span>;        <span class="comment">// bit  8: UMS 正在执行系统调用</span></span><br><span class="line">            ULONG VdmSafe:<span class="number">1</span>;                     <span class="comment">// bit  9: VDM 兼容（16 位支持）</span></span><br><span class="line">            ULONG UmsDispatched:<span class="number">1</span>;               <span class="comment">// bit 10: 已分派为 UMS 线程</span></span><br><span class="line">            ULONG ReservedFlags:<span class="number">21</span>;              <span class="comment">// bit 11-31: 保留</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">volatile</span> LONG ThreadFlags;               <span class="comment">// 0xB8: 所有标志位联合体访问</span></span><br><span class="line">    &#125;;</span><br><span class="line">    VOID* ServiceTable;                          <span class="comment">// 0xBC: 系统调用服务表（指向 SSDT）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KWAIT_BLOCK</span> <span class="title">WaitBlock</span>[4];</span>           <span class="comment">// 0xC0: 最多支持同时等待 4 个同步对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">QueueListEntry</span>;</span>          <span class="comment">// 0x120: 在线程队列（如工作队列）中的节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KTRAP_FRAME</span>* <span class="title">TrapFrame</span>;</span>             <span class="comment">// 0x128: 当前陷阱帧指针（中断或异常时的栈帧）</span></span><br><span class="line">    VOID* FirstArgument;                        <span class="comment">// 0x12C: 初始参数（如新线程的入口参数）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        VOID* CallbackStack;                    <span class="comment">// 0x130: 当前正在执行的回调栈地址</span></span><br><span class="line">        ULONG CallbackDepth;                    <span class="comment">// 0x130: 回调嵌套深度</span></span><br><span class="line">    &#125;;</span><br><span class="line">    UCHAR ApcStateIndex;                        <span class="comment">// 0x134: 📌APC 状态索引（内核/用户）</span></span><br><span class="line">    CHAR BasePriority;                          <span class="comment">// 0x135: 初始基本优先级</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        CHAR PriorityDecrement;                 <span class="comment">// 0x136: 当前优先级减少值（优先级衰减）</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            UCHAR ForegroundBoost : <span class="number">4</span>;          <span class="comment">// bit 0-3: 前台线程优先级提升</span></span><br><span class="line">            UCHAR UnusualBoost   : <span class="number">4</span>;           <span class="comment">// bit 4-7: 特殊调度场景提升</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    UCHAR Preempted;                            <span class="comment">// 0x137: 是否被抢占</span></span><br><span class="line">    UCHAR AdjustReason;                         <span class="comment">// 0x138: 优先级调整原因</span></span><br><span class="line">    CHAR AdjustIncrement;                       <span class="comment">// 0x139: 优先级调整增量</span></span><br><span class="line">    CHAR PreviousMode;                          <span class="comment">// 0x13A: 上下文切换前的 CPU 模式（用户/内核）</span></span><br><span class="line">    CHAR Saturation;                            <span class="comment">// 0x13B: 饱和度指标，用于调度策略</span></span><br><span class="line">    ULONG SystemCallNumber;                     <span class="comment">// 0x13C: 上次系统调用号</span></span><br><span class="line">    ULONG FreezeCount;                          <span class="comment">// 0x140: 冻结计数（例如调试器挂起）</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> _<span class="title">GROUP_AFFINITY</span> <span class="title">UserAffinity</span>;</span> <span class="comment">// 0x144: 用户设置的 CPU 亲和性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KPROCESS</span>* <span class="title">Process</span>;</span>                  <span class="comment">// 0x150: 📌所属进程的 `_KPROCESS` 指针</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> _<span class="title">GROUP_AFFINITY</span> <span class="title">Affinity</span>;</span>   <span class="comment">// 0x154: 当前线程亲和性掩码（活动 CPU 集）</span></span><br><span class="line">    ULONG IdealProcessor;                       <span class="comment">// 0x160: 调度器理想的运行 CPU</span></span><br><span class="line">    ULONG UserIdealProcessor;                   <span class="comment">// 0x164: 用户设置的理想处理器编号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KAPC_STATE</span>* <span class="title">ApcStatePointer</span>[2];</span>     <span class="comment">// 0x168: 指向内核 / 用户 APC 状态</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">KAPC_STATE</span> <span class="title">SavedApcState</span>;</span>       <span class="comment">// 0x170: 保存的 APC 状态（线程挂起/恢复时）</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            UCHAR SavedApcStateFill[<span class="number">23</span>];        <span class="comment">// 填充对齐</span></span><br><span class="line">            UCHAR WaitReason;                   <span class="comment">// 0x187: 当前线程的等待原因（调试、同步等）</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    CHAR SuspendCount;                          <span class="comment">// 0x188: 被挂起次数（非 0 时线程暂停）</span></span><br><span class="line">    CHAR Spare1;                                <span class="comment">// 0x189: 保留</span></span><br><span class="line">    UCHAR OtherPlatformFill;                    <span class="comment">// 0x18A: 多平台兼容保留位</span></span><br><span class="line">    VOID* <span class="keyword">volatile</span> Win32Thread;                 <span class="comment">// 0x18C: 指向 Win32 子系统线程结构（如 CSR）</span></span><br><span class="line">    VOID* StackBase;                            <span class="comment">// 0x190: 栈基地址（高地址）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">KAPC</span> <span class="title">SuspendApc</span>;</span>                <span class="comment">// 0x194: 用于挂起线程的 APC 对象</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            UCHAR SuspendApcFill0[<span class="number">1</span>];           <span class="comment">// 0x194</span></span><br><span class="line">            UCHAR ResourceIndex;                <span class="comment">// 0x195: 分配资源索引</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            UCHAR SuspendApcFill1[<span class="number">3</span>];           <span class="comment">// 0x194</span></span><br><span class="line">            UCHAR QuantumReset;                 <span class="comment">// 0x197: 时间片重置标志</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            UCHAR SuspendApcFill2[<span class="number">4</span>];           <span class="comment">// 0x194</span></span><br><span class="line">            ULONG KernelTime;                   <span class="comment">// 0x198: 已消耗的内核时间</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            UCHAR SuspendApcFill3[<span class="number">36</span>];          <span class="comment">// 0x194</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">KPRCB</span>* <span class="title">volatile</span> <span class="title">WaitPrcb</span>;</span>   <span class="comment">// 0x1B8: 当前等待的 PRCB（处理器控制块）</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            UCHAR SuspendApcFill4[<span class="number">40</span>];          <span class="comment">// 0x194</span></span><br><span class="line">            VOID* LegoData;                     <span class="comment">// 0x1BC: LEGO 用户模式调度器数据</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            UCHAR SuspendApcFill5[<span class="number">47</span>];          <span class="comment">// 0x194</span></span><br><span class="line">            UCHAR LargeStack;                   <span class="comment">// 0x1C3: 是否使用大栈（&gt;默认大小）</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG UserTime;                             <span class="comment">// 0x1C4: 已消耗的用户模式时间</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">KSEMAPHORE</span> <span class="title">SuspendSemaphore</span>;</span>    <span class="comment">// 0x1C8: 挂起信号量（用于线程恢复）</span></span><br><span class="line">        UCHAR SuspendSemaphorefill[<span class="number">20</span>];         <span class="comment">// 填充用</span></span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG SListFaultCount;                      <span class="comment">// 0x1DC: SList 异常计数（栈溢出等）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ThreadListEntry</span>;</span>         <span class="comment">// 0x1E0: 📌线程链表节点（进程中的线程列表）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">MutantListHead</span>;</span>          <span class="comment">// 0x1E8: 线程持有的互斥体链表头</span></span><br><span class="line">    VOID* SListFaultAddress;                    <span class="comment">// 0x1F0: 最后一个异常 SList 操作地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KTHREAD_COUNTERS</span>* <span class="title">ThreadCounters</span>;</span>   <span class="comment">// 0x1F4: 性能统计计数器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">XSTATE_SAVE</span>* <span class="title">XStateSave</span>;</span>            <span class="comment">// 0x1F8: 扩展浮点 / AVX 状态保存结构</span></span><br><span class="line">&#125;; <span class="comment">// 0x200 bytes</span></span><br></pre></td></tr></table></figure>

<h4 id="TEB-Thread-Environment-Block"><a href="#TEB-Thread-Environment-Block" class="headerlink" title="TEB (Thread Environment Block):"></a>TEB (Thread Environment Block):</h4><p>位于用户模式，存储线程局部数据。</p>
<ul>
<li>关键成员:<code>NtTib</code> (栈范围), <code>TlsSlots</code> (线程本地存储 TLS)。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">TEB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">NT_TIB</span> <span class="title">NtTib</span>;</span>                                                   <span class="comment">// 0x0  存储线程信息块（TIB），包括堆栈指针、异常处理信息等。</span></span><br><span class="line">    VOID* EnvironmentPointer;                                               <span class="comment">// 0x1c 指向当前线程环境块的指针，通常包含与线程环境相关的信息。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">CLIENT_ID</span> <span class="title">ClientId</span>;</span>                                             <span class="comment">// 0x20 存储线程的客户端ID（包含进程ID和线程ID）。</span></span><br><span class="line">    VOID* ActiveRpcHandle;                                                  <span class="comment">// 0x28 当前活动的 RPC 句柄，用于跟踪线程参与的 RPC 调用。</span></span><br><span class="line">    VOID* ThreadLocalStoragePointer;                                        <span class="comment">// 0x2c 指向线程本地存储（TLS）区域的指针。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">PEB</span>* <span class="title">ProcessEnvironmentBlock</span>;</span>                                   <span class="comment">// 0x30 指向进程环境块（PEB）的指针，包含进程的全局信息。</span></span><br><span class="line">    ULONG LastErrorValue;                                                   <span class="comment">// 0x34 线程的最后错误值，用于记录线程的错误状态。</span></span><br><span class="line">    ULONG CountOfOwnedCriticalSections;                                     <span class="comment">// 0x38 线程拥有的临界区数量，表示该线程管理的临界区的数量。</span></span><br><span class="line">    VOID* CsrClientThread;                                                  <span class="comment">// 0x3c 指向客户端线程信息的指针。</span></span><br><span class="line">    VOID* Win32ThreadInfo;                                                  <span class="comment">// 0x40 指向 Windows 32 位线程信息的指针，通常用于存储 Windows 特定的线程信息。</span></span><br><span class="line">    ULONG User32Reserved[<span class="number">26</span>];                                               <span class="comment">// 0x44 保留字段，供用户使用的 32 位操作系统相关数据。</span></span><br><span class="line">    ULONG UserReserved[<span class="number">5</span>];                                                  <span class="comment">// 0xac 额外的用户保留数据。</span></span><br><span class="line">    VOID* WOW32Reserved;                                                    <span class="comment">// 0xc0 32 位应用程序的相关数据，供 WOW（Windows on Windows）支持使用。</span></span><br><span class="line">    ULONG CurrentLocale;                                                    <span class="comment">// 0xc4 当前线程的区域设置标识符。</span></span><br><span class="line">    ULONG FpSoftwareStatusRegister;                                         <span class="comment">// 0xc8 用于存储浮点运算软件状态寄存器的值。</span></span><br><span class="line">    VOID* SystemReserved1[<span class="number">54</span>];                                              <span class="comment">// 0xcc 保留字段，供系统内部使用。</span></span><br><span class="line">    LONG ExceptionCode;                                                     <span class="comment">// 0x1a4 存储与当前线程异常相关的代码。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ACTIVATION_CONTEXT_STACK</span>* <span class="title">ActivationContextStackPointer</span>;</span>        <span class="comment">// 0x1a8 指向激活上下文堆栈的指针，通常用于存储与应用程序活动相关的上下文信息。</span></span><br><span class="line">    UCHAR SpareBytes[<span class="number">36</span>];                                                   <span class="comment">// 0x1ac 保留字节，供未来使用。</span></span><br><span class="line">    ULONG TxFsContext;                                                      <span class="comment">// 0x1d0 用于跟踪事务文件系统（TxFs）上下文的字段。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">GDI_TEB_BATCH</span> <span class="title">GdiTebBatch</span>;</span>                                      <span class="comment">// 0x1d4 与 GDI（图形设备接口）相关的线程批处理信息。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">CLIENT_ID</span> <span class="title">RealClientId</span>;</span>                                         <span class="comment">// 0x6b4 线程的实际客户端ID，包含进程ID和线程ID。</span></span><br><span class="line">    VOID* GdiCachedProcessHandle;                                           <span class="comment">// 0x6bc 存储 GDI 缓存的进程句柄。</span></span><br><span class="line">    ULONG GdiClientPID;                                                     <span class="comment">// 0x6c0 GDI 客户端进程ID。</span></span><br><span class="line">    ULONG GdiClientTID;                                                     <span class="comment">// 0x6c4 GDI 客户端线程ID。</span></span><br><span class="line">    VOID* GdiThreadLocalInfo;                                               <span class="comment">// 0x6c8 存储 GDI 线程本地信息的指针。</span></span><br><span class="line">    ULONG Win32ClientInfo[<span class="number">62</span>];                                              <span class="comment">// 0x6cc 存储 Windows 32 位客户端信息的数组。</span></span><br><span class="line">    VOID* glDispatchTable[<span class="number">233</span>];                                             <span class="comment">// 0x7c4 OpenGL 调度表，包含图形渲染相关的函数指针。</span></span><br><span class="line">    ULONG glReserved1[<span class="number">29</span>];                                                  <span class="comment">// 0xb68 OpenGL 保留字段。</span></span><br><span class="line">    VOID* glReserved2;                                                      <span class="comment">// 0xbdc 额外的 OpenGL 保留字段。</span></span><br><span class="line">    VOID* glSectionInfo;                                                    <span class="comment">// 0xbe0 OpenGL 部分信息。</span></span><br><span class="line">    VOID* glSection;                                                        <span class="comment">// 0xbe4 OpenGL 部分数据。</span></span><br><span class="line">    VOID* glTable;                                                          <span class="comment">// 0xbe8 OpenGL 表格数据。</span></span><br><span class="line">    VOID* glCurrentRC;                                                      <span class="comment">// 0xbec 当前渲染上下文。</span></span><br><span class="line">    VOID* glContext;                                                        <span class="comment">// 0xbf0 OpenGL 上下文。</span></span><br><span class="line">    ULONG LastStatusValue;                                                  <span class="comment">// 0xbf4 记录线程的最后状态值。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> <span class="title">StaticUnicodeString</span>;</span>                             <span class="comment">// 0xbf8 静态 Unicode 字符串，用于存储静态字符串数据。</span></span><br><span class="line">    WCHAR StaticUnicodeBuffer[<span class="number">261</span>];                                         <span class="comment">// 0xc00 静态 Unicode 字符串缓冲区。</span></span><br><span class="line">    VOID* DeallocationStack;                                                <span class="comment">// 0xe0c 用于存储内存回收的堆栈指针。</span></span><br><span class="line">    VOID* TlsSlots[<span class="number">64</span>];                                                     <span class="comment">// 0xe10 线程本地存储（TLS）槽数组，用于存储每个槽中的 TLS 数据。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">TlsLinks</span>;</span>                                            <span class="comment">// 0xf10 与 TLS 相关的链表。</span></span><br><span class="line">    VOID* Vdm;                                                              <span class="comment">// 0xf18 VDM（虚拟 DOS 模式）相关数据。</span></span><br><span class="line">    VOID* ReservedForNtRpc;                                                 <span class="comment">// 0xf1c 保留给 NT RPC 的数据。</span></span><br><span class="line">    VOID* DbgSsReserved[<span class="number">2</span>];                                                 <span class="comment">// 0xf20 用于调试 SS（子系统）相关的保留数据。</span></span><br><span class="line">    ULONG HardErrorMode;                                                    <span class="comment">// 0xf28 用于线程处理硬错误模式的状态。</span></span><br><span class="line">    VOID* Instrumentation[<span class="number">9</span>];                                               <span class="comment">// 0xf2c 用于线程的性能监控和调试数据的数组。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">GUID</span> <span class="title">ActivityId</span>;</span>                                                <span class="comment">// 0xf50 当前线程的活动标识符（GUID）。</span></span><br><span class="line">    VOID* SubProcessTag;                                                    <span class="comment">// 0xf60 子进程标记。</span></span><br><span class="line">    VOID* EtwLocalData;                                                     <span class="comment">// 0xf64 本地 ETW（事件跟踪）数据。</span></span><br><span class="line">    VOID* EtwTraceData;                                                     <span class="comment">// 0xf68 ETW 追踪数据。</span></span><br><span class="line">    VOID* WinSockData;                                                      <span class="comment">// 0xf6c 与 Windows Sockets（WinSock）相关的数据。</span></span><br><span class="line">    ULONG GdiBatchCount;                                                    <span class="comment">// 0xf70 GDI 批量计数。</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">PROCESSOR_NUMBER</span> <span class="title">CurrentIdealProcessor</span>;</span>                     <span class="comment">// 0xf74 当前理想处理器的编号。</span></span><br><span class="line">        ULONG IdealProcessorValue;                                          <span class="comment">// 0xf74 理想处理器的数值表示。</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            UCHAR ReservedPad0;                                             <span class="comment">// 0xf74 保留字段。</span></span><br><span class="line">            UCHAR ReservedPad1;                                             <span class="comment">// 0xf75 保留字段。</span></span><br><span class="line">            UCHAR ReservedPad2;                                             <span class="comment">// 0xf76 保留字段。</span></span><br><span class="line">            UCHAR IdealProcessor;                                           <span class="comment">// 0xf77 理想处理器的编号。</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG GuaranteedStackBytes;                                             <span class="comment">// 0xf78 保证的栈空间字节数。</span></span><br><span class="line">    VOID* ReservedForPerf;                                                  <span class="comment">// 0xf7c 保留给性能监控的空间。</span></span><br><span class="line">    VOID* ReservedForOle;                                                   <span class="comment">// 0xf80 保留给 OLE（对象链接和嵌入）相关数据。</span></span><br><span class="line">    ULONG WaitingOnLoaderLock;                                              <span class="comment">// 0xf84 用于表示当前线程是否在等待加载锁。</span></span><br><span class="line">    VOID* SavedPriorityState;                                               <span class="comment">// 0xf88 保存的线程优先级状态。</span></span><br><span class="line">    ULONG SoftPatchPtr1;                                                    <span class="comment">// 0xf8c 软件补丁指针1。</span></span><br><span class="line">    VOID* ThreadPoolData;                                                   <span class="comment">// 0xf90 线程池数据。</span></span><br><span class="line">    VOID** TlsExpansionSlots;                                               <span class="comment">// 0xf94 扩展的 TLS 槽数组。</span></span><br><span class="line">    ULONG MuiGeneration;                                                    <span class="comment">// 0xf98 MUI（多语言用户界面）版本。</span></span><br><span class="line">    ULONG IsImpersonating;                                                  <span class="comment">// 0xf9c 标志，表示线程是否在模拟其他安全主体。</span></span><br><span class="line">    VOID* NlsCache;                                                         <span class="comment">// 0xfa0 国家语言支持（NLS）缓存。</span></span><br><span class="line">    VOID* pShimData;                                                        <span class="comment">// 0xfa4 与程序兼容性（Shim）相关的数据。</span></span><br><span class="line">    ULONG HeapVirtualAffinity;                                              <span class="comment">// 0xfa8 堆的虚拟亲和性。</span></span><br><span class="line">    VOID* CurrentTransactionHandle;                                         <span class="comment">// 0xfac 当前事务的句柄。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">TEB_ACTIVE_FRAME</span>* <span class="title">ActiveFrame</span>;</span>                                  <span class="comment">// 0xfb0 活动帧信息。</span></span><br><span class="line">    VOID* FlsData;                                                          <span class="comment">// 0xfb4 与 FLS（线程本地存储）相关的数据。</span></span><br><span class="line">    VOID* PreferredLanguages;                                               <span class="comment">// 0xfb8 用户首选语言列表。</span></span><br><span class="line">    VOID* UserPrefLanguages;                                                <span class="comment">// 0xfbc 用户偏好的语言列表。</span></span><br><span class="line">    VOID* MergedPrefLanguages;                                              <span class="comment">// 0xfc0 合并的语言偏好列表。</span></span><br><span class="line">    ULONG MuiImpersonation;                                                 <span class="comment">// 0xfc4 MUI 模拟状态。</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">volatile</span> USHORT CrossTebFlags;                                      <span class="comment">// 0xfc8 用于线程的跨 TEB 标志。</span></span><br><span class="line">        USHORT SpareCrossTebBits:<span class="number">16</span>;                                        <span class="comment">// 0xfc8 备用的跨 TEB 位。</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        USHORT SameTebFlags;                                                <span class="comment">// 0xfca 同一线程环境块（TEB）标志</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            USHORT SafeThunkCall:<span class="number">1</span>;                                         <span class="comment">// bit 0: 安全调用标志</span></span><br><span class="line">            USHORT InDebugPrint:<span class="number">1</span>;                                          <span class="comment">// bit 1: 当前线程处于调试打印模式</span></span><br><span class="line">            USHORT HasFiberData:<span class="number">1</span>;                                          <span class="comment">// bit 2: 当前线程拥有纤程数据</span></span><br><span class="line">            USHORT SkipThreadAttach:<span class="number">1</span>;                                      <span class="comment">// bit 3: 跳过线程附加操作</span></span><br><span class="line">            USHORT WerInShipAssertCode:<span class="number">1</span>;                                   <span class="comment">// bit 4: 标志，表示线程处于断言代码中</span></span><br><span class="line">            USHORT RanProcessInit:<span class="number">1</span>;                                        <span class="comment">// bit 5: 标志，表示进程初始化已完成</span></span><br><span class="line">            USHORT ClonedThread:<span class="number">1</span>;                                          <span class="comment">// bit 6: 标志，表示该线程为克隆线程</span></span><br><span class="line">            USHORT SuppressDebugMsg:<span class="number">1</span>;                                      <span class="comment">// bit 7: 是否抑制调试信息</span></span><br><span class="line">            USHORT DisableUserStackWalk:<span class="number">1</span>;                                  <span class="comment">// bit 8: 禁用用户栈跟踪</span></span><br><span class="line">            USHORT RtlExceptionAttached:<span class="number">1</span>;                                  <span class="comment">// bit 9: 标志，表示 RTL 异常已附加</span></span><br><span class="line">            USHORT InitialThread:<span class="number">1</span>;                                         <span class="comment">// bit 10: 标志，表示这是初始线程</span></span><br><span class="line">            USHORT SpareSameTebBits:<span class="number">5</span>;                                      <span class="comment">// bit 11-15: 备用位，暂时未使用</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    VOID* TxnScopeEnterCallback;                                            <span class="comment">// 0xfcc 事务作用域进入回调函数。</span></span><br><span class="line">    VOID* TxnScopeExitCallback;                                             <span class="comment">// 0xfd0 事务作用域退出回调函数。</span></span><br><span class="line">    VOID* TxnScopeContext;                                                  <span class="comment">// 0xfd4 事务作用域上下文数据。</span></span><br><span class="line">    ULONG LockCount;                                                        <span class="comment">// 0xfd8 锁计数，表示当前线程持有的锁的数量。</span></span><br><span class="line">    ULONG SpareUlong0;                                                      <span class="comment">// 0xfdc 备用的 ULONG 数据。</span></span><br><span class="line">    VOID* ResourceRetValue;                                                 <span class="comment">// 0xfe0 资源返回值。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h3><p>KTHREAD_STATE</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程调度状态（KTHREAD_STATE）</span></span><br><span class="line"><span class="comment">// 表示线程在调度器中的生命周期状态。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">KTHREAD_STATE</span> &#123;</span></span><br><span class="line">    Initialized,    <span class="comment">// （0）已初始化：线程对象已构造但尚未调度</span></span><br><span class="line">    Ready,          <span class="comment">// （1）就绪：线程已插入就绪队列，等待运行</span></span><br><span class="line">    Running,        <span class="comment">// （2）运行中：线程正在某处理器上执行</span></span><br><span class="line">    Standby,        <span class="comment">// （3）待命：被选为下一个要运行的线程</span></span><br><span class="line">    Terminated,     <span class="comment">// （4）已终止：线程执行完毕，等待资源释放</span></span><br><span class="line">    Waiting,        <span class="comment">// （5）等待中：线程正在等待某个事件或超时</span></span><br><span class="line">    Transition,     <span class="comment">// （6）过渡态：资源尚未准备好，暂不可调度</span></span><br><span class="line">    DeferredReady,  <span class="comment">// （7）延迟就绪：满足就绪条件但延后入队</span></span><br><span class="line">    GateWait        <span class="comment">// （8）等待 Gate：等待底层同步对象 Gate</span></span><br><span class="line">&#125; KTHREAD_STATE;</span><br></pre></td></tr></table></figure>

<p>线程切换由调用 <code>KiSwapContext</code> 和 <code>SwapContext</code>函数完成。</p>
<p>当决定从 <code>OldThread</code> 切换到 <code>NewThread</code> 时（x32）：</p>
<ol>
<li>检查运行状态: 确保目标线程没有在其他 CPU 上运行 (<code>Running</code> 标志) 。</li>
<li>切换内核栈:<ul>
<li>保存旧线程的 ESP 到 <code>OldThread-&gt;KernelStack</code>。</li>
<li>将 ESP 加载为 <code>NewThread-&gt;KernelStack</code>。</li>
<li><em>重要:</em> 这一步之后，CPU 实际上就已经在使用新线程的栈了。</li>
</ul>
</li>
<li>切换地址空间 (CR3):<ul>
<li>比较新旧线程的所属进程 (<code>ApcState.Process</code>)。</li>
<li>如果是不同进程，将 CR3 寄存器更新为新进程的 <code>DirectoryTableBase</code>。</li>
<li><em>注:</em> 这一步会导致 TLB (Translation Lookaside Buffer) 刷新，开销较大。</li>
</ul>
</li>
<li>更新 TSS (Task State Segment):<ul>
<li>更新 <code>TSS.Esp0</code>。这是为了确保当下次发生中断&#x2F;系统调用从用户态进入内核态时，CPU 能找到正确的内核栈位置。</li>
</ul>
</li>
<li>更新 TEB 指针: 修改 <code>fs:[0]</code> (KPCR) 中的 <code>Used_Self</code>指针指向新线程的 TEB。</li>
<li>恢复寄存器: 恢复 FPU&#x2F;SSE 状态（如果需要）和通用寄存器。</li>
</ol>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="x64页表自映射"><a href="#x64页表自映射" class="headerlink" title="x64页表自映射"></a>x64页表自映射</h3><p>x64 使用 4 级页表（PML4, PDPT, PDE, PTE）</p>
<p>当内核需要修改某个虚拟地址（比如 <code>0x12345678</code>）对应的 PTE（页表项）属性时，它不能直接去写物理内存。它必须先把存放这个 PTE 的物理页映射到一个虚拟地址上，才能通过 CPU指令（如 <code>mov</code>）去修改它。</p>
<p>如果没有自映射，内核每次修改页表都需要临时分配虚拟地址、映射物理页、修改、解除映射，这非常繁琐且低效。</p>
<p><img src="/image/2025-12-30-learning_windows_4/1767171485680.png" alt="1767171485680"></p>
<p>使用windbg命令 <code>!pte</code>查看 <code>0</code>地址数据</p>
<p>对pml4、pdpt、pde、pte四项的页表基址进行拆分得到如下（去除 <code>页内偏移</code>和 <code>高16位</code>）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pte_base：   111010111 000000000 000000000 000000000（FEB8000000）</span><br><span class="line">pde_base：   111010111 111010111 000000000 000000000（FEBF5C0000）</span><br><span class="line">pdpte_base： 111010111 111010111 111010111 000000000（FEBF5FAE00）</span><br><span class="line">pml4_base：  111010111 111010111 111010111 111010111（FEBF5FAFD7）</span><br></pre></td></tr></table></figure>

<p><img src="/image/2025-12-30-learning_windows_4/1767171602190.png" alt="1767171602190"></p>
<p>CPU是如何找到一个虚拟地址的物理地址的：</p>
<p>CPU先从CR3寄存器读取到PML4表的物理地址，从cr3+虚拟地址的最高9位 * 8处获得PDPT的物理地址，然后这个地址+虚拟地址的次高9位 * 8获得的地址是PDE的物理地址，以此类推从PTE上获取物理页帧号，物理地址&#x3D; <code>(PFN &lt;&lt; 12) + Offset(0x000)</code> 最后去内存条里找到数据</p>
<p>但如果是查找PTE表的物理地址呢？这里就和虚表自映射有关了，在cr3+PTE表虚拟地址最高9位*8处获得的地址其实是PML4的地址</p>
<p>在windbg上通过!pte命令获得的地址，实际上CPU从这些虚拟地址访问到的物理地址就是他们本身，这也解释了这些虚拟地址为什么要这样设计。</p>
<p>PTE表：在 x64 下，一个 PTE 是 64位（8字节）的，它里面存了物理地址和属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; dt nt!_MMPTE_HARDWARE</span><br><span class="line">   +0x000 Valid            : Pos 0, 1 Bit</span><br><span class="line">   +0x000 Dirty1           : Pos 1, 1 Bit</span><br><span class="line">   +0x000 Owner            : Pos 2, 1 Bit</span><br><span class="line">   +0x000 WriteThrough     : Pos 3, 1 Bit</span><br><span class="line">   +0x000 CacheDisable     : Pos 4, 1 Bit</span><br><span class="line">   +0x000 Accessed         : Pos 5, 1 Bit</span><br><span class="line">   +0x000 Dirty            : Pos 6, 1 Bit</span><br><span class="line">   +0x000 LargePage        : Pos 7, 1 Bit</span><br><span class="line">   +0x000 Global           : Pos 8, 1 Bit</span><br><span class="line">   +0x000 CopyOnWrite      : Pos 9, 1 Bit</span><br><span class="line">   +0x000 Unused           : Pos 10, 1 Bit</span><br><span class="line">   +0x000 Write            : Pos 11, 1 Bit</span><br><span class="line">   +0x000 PageFrameNumber  : Pos 12, 36 Bits</span><br><span class="line">   +0x000 ReservedForHardware : Pos 48, 4 Bits</span><br><span class="line">   +0x000 ReservedForSoftware : Pos 52, 4 Bits</span><br><span class="line">   +0x000 WsleAge          : Pos 56, 4 Bits</span><br><span class="line">   +0x000 WsleProtection   : Pos 60, 3 Bits</span><br><span class="line">   +0x000 NoExecute        : Pos 63, 1 Bit</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>位 (Bit)</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>63(最高位)</td>
<td>NX (No-Execute)</td>
<td>1&#x3D;禁止执行 , 0&#x3D;允许执行</td>
</tr>
<tr>
<td>12-62</td>
<td>PFN</td>
<td>物理页帧号 (实际物理地址)</td>
</tr>
<tr>
<td>2</td>
<td>U&#x2F;S (User&#x2F;Supervisor)</td>
<td>0&#x3D;内核页, 1&#x3D;用户页</td>
</tr>
<tr>
<td>1</td>
<td>R&#x2F;W (Read&#x2F;Write)</td>
<td>1&#x3D;可写, 0&#x3D;只读</td>
</tr>
<tr>
<td>0</td>
<td>P (Present)</td>
<td>1&#x3D;页面有效 , 0&#x3D;无效</td>
</tr>
</tbody></table>
<h3 id="PFN-数据库"><a href="#PFN-数据库" class="headerlink" title="PFN 数据库"></a>PFN 数据库</h3><p>一个巨大的数组，描述了所有物理内存的状态。</p>
<h4 id="MMPFN"><a href="#MMPFN" class="headerlink" title="MMPFN"></a>MMPFN</h4><p>每一个物理页（4KB）在内核中都对应一个 <code>_MMPFN</code> 结构体，所有物理页都记录在一个全局数组中。<code>_MMPFN</code> 结构体在数组中的下标（Index） ，就是物理页号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 物理页帧数据库条目 (MMPFN)</span></span><br><span class="line"><span class="comment">// 系统中每个物理页(4KB)对应一个此结构。</span></span><br><span class="line"><span class="comment">// 用于追踪物理页的状态、所有者、引用计数以及在LRU链表中的位置。</span></span><br><span class="line"><span class="comment">// 注意：此结构大量使用 Union，不同状态下字段含义不同。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">MMPFN</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="comment">// ============================================================</span></span><br><span class="line">        <span class="comment">// 场景 A：页面处于链表中 (Free, Standby, Modified, Zeroed)</span></span><br><span class="line">        <span class="comment">// ============================================================</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ListEntry</span>;</span>           <span class="comment">// [链表态] 标准双向链表节点，用于将此页挂在 Free/Standby 等队列中</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_BALANCED_NODE</span> <span class="title">TreeNode</span>;</span>     <span class="comment">// [链表态] 用于红黑树链接</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ============================================================</span></span><br><span class="line">        <span class="comment">// 场景 B：页面处于活动状态 (Active) 或其他特定状态</span></span><br><span class="line">        <span class="comment">// ============================================================</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> _<span class="title">SINGLE_LIST_ENTRY</span> <span class="title">NextSlistPfn</span>;</span>    <span class="comment">// [特殊] 用于单向链表（如 Lookaside 列表），快速分配用</span></span><br><span class="line">                VOID* Next;                               <span class="comment">// 指针形式的下一节点</span></span><br><span class="line">                ULONGLONG Flink:<span class="number">36</span>;                       <span class="comment">// 36位描述前向链接的页面PFN号</span></span><br><span class="line">                ULONGLONG NodeFlinkHigh:<span class="number">28</span>;               <span class="comment">// 前向链接的高位</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> _<span class="title">MI_ACTIVE_PFN</span> <span class="title">Active</span>;</span>             <span class="comment">// [活动态] 当页面正在使用时，包含工作集索引(WsIndex)等信息</span></span><br><span class="line">            &#125; u1;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> _<span class="title">MMPTE</span>* <span class="title">PteAddress</span>;</span>              <span class="comment">// 📌[活动态]指向引用此页的 PTE 的虚拟地址</span></span><br><span class="line">                ULONGLONG PteLong;                      <span class="comment">// 同上，长整型访问方式</span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">MMPTE</span> <span class="title">OriginalPte</span>;</span>                  <span class="comment">// 📌[链表态/恢复用] 原始 PTE 内容。</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">MIPFNBLINK</span> <span class="title">u2</span>;</span>           <span class="comment">// [链表态] 反向链接 (Blink) 或包含一些复杂的标志位组合</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============================================================</span></span><br><span class="line">    <span class="comment">// 引用计数与状态标志 (u3)</span></span><br><span class="line">    <span class="comment">// ============================================================</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            USHORT ReferenceCount;      <span class="comment">// 📌引用计数。</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">MMPFNENTRY1</span> <span class="title">e1</span>;</span> </span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">MMPFNENTRY3</span> <span class="title">e3</span>;</span>    <span class="comment">// 另一种视角的标志位组合</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                USHORT ReferenceCount;   <span class="comment">// 引用计数</span></span><br><span class="line">            &#125; e2;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            ULONG EntireField;        <span class="comment">// 用于一次性读取/清空这 4 个字节</span></span><br><span class="line">        &#125; e4;</span><br><span class="line">    &#125; u3;</span><br><span class="line"></span><br><span class="line">    USHORT NodeBlinkLow;           <span class="comment">// 链表节点反向链接低位</span></span><br><span class="line">    UCHAR Unused:<span class="number">4</span>;   </span><br><span class="line">    UCHAR Unused2:<span class="number">4</span>; </span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        UCHAR ViewCount;        <span class="comment">// [映射] 对于共享内存(Section)，记录有多少个视图映射了此页</span></span><br><span class="line">        UCHAR NodeFlinkLow;     <span class="comment">// 链表节点前向链接低位</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            UCHAR ModifiedListBucketIndex:<span class="number">4</span>;    <span class="comment">// [脏页] 在修改列表中属于哪个优先级桶（用于优化写入磁盘的顺序）</span></span><br><span class="line">            UCHAR AnchorLargePageSize:<span class="number">2</span>;        <span class="comment">// [大页] 如果这是大页(2MB/1GB)的一部分，记录大页尺寸</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============================================================</span></span><br><span class="line">    <span class="comment">// 物理页属性与层级关系 (u4)</span></span><br><span class="line">    <span class="comment">// ============================================================</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ULONGLONG PteFrame:<span class="number">36</span>;       <span class="comment">// PTE 所在页表的物理页帧号。</span></span><br><span class="line">        ULONGLONG ResidentPage:<span class="number">1</span>;    <span class="comment">// 是否驻留</span></span><br><span class="line">        ULONGLONG Unused1:<span class="number">1</span>;</span><br><span class="line">        ULONGLONG Unused2:<span class="number">1</span>;</span><br><span class="line">        ULONGLONG Partition:<span class="number">10</span>;     <span class="comment">// 分区 ID (用于多租户/容器隔离)</span></span><br><span class="line">        ULONGLONG FileOnly:<span class="number">1</span>;       <span class="comment">// 仅文件关联</span></span><br><span class="line">        ULONGLONG PfnExists:<span class="number">1</span>;      <span class="comment">// [硬件] 物理内存是否存在 (用于支持内存热插拔)</span></span><br><span class="line">        ULONGLONG Spare:<span class="number">9</span>;   </span><br><span class="line">        ULONGLONG PageIdentity:<span class="number">3</span>;     <span class="comment">// 页面身份标识 (例如是否是加密内存)</span></span><br><span class="line">  </span><br><span class="line">        ULONGLONG PrototypePte:<span class="number">1</span>;    <span class="comment">// 📌[关键标志] 原型 PTE 标志。</span></span><br><span class="line">                                     <span class="comment">// 0 = 私有内存 (Private)。PteAddress 指向普通页表。</span></span><br><span class="line">                                     <span class="comment">// 1 = 共享内存 (Mapped File/Section)。PteAddress 指向原型 PTE (Prototype PTE)。</span></span><br><span class="line">        ULONGLONG EntireField;       <span class="comment">// 完整字段访问</span></span><br><span class="line">    &#125; u4;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="MMPFNENTRY1"><a href="#MMPFNENTRY1" class="headerlink" title="MMPFNENTRY1"></a>MMPFNENTRY1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">MMPFNENTRY1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    UCHAR PageLocation : <span class="number">3</span>;       <span class="comment">// 📌页面当前所在的链表类型：</span></span><br><span class="line">                                  <span class="comment">// 0 = Zeroed (已清零，空闲)</span></span><br><span class="line">                                  <span class="comment">// 1 = Free (未清零，空闲)</span></span><br><span class="line">                                  <span class="comment">// 2 = Standby (备用，有数据但无人引用)</span></span><br><span class="line">                                  <span class="comment">// 3 = Modified (脏页，等待写回磁盘)</span></span><br><span class="line">                                  <span class="comment">// 4 = ModifiedNoWrite (脏页但不写回)</span></span><br><span class="line">                                  <span class="comment">// 5 = Bad (坏页)</span></span><br><span class="line">                                  <span class="comment">// 6 = Active (活动，正在被使用)</span></span><br><span class="line">                                  <span class="comment">// 7 = Transition (过渡态)</span></span><br><span class="line">    UCHAR WriteInProgress : <span class="number">1</span>;    <span class="comment">// [IO] 正在向磁盘写入（页面文件或映射文件）</span></span><br><span class="line">    UCHAR Modified : <span class="number">1</span>;           <span class="comment">// [脏位] 页面内容已被修改，与 PTE 中的 D 位同步</span></span><br><span class="line">    UCHAR ReadInProgress : <span class="number">1</span>;     <span class="comment">// [IO] 正在从磁盘读取（缺页异常处理中）</span></span><br><span class="line">    UCHAR CacheAttribute : <span class="number">2</span>;     <span class="comment">// [缓存] 硬件缓存策略 (Cached, Uncached, WriteCombined)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="空闲页的串联方式"><a href="#空闲页的串联方式" class="headerlink" title="空闲页的串联方式"></a>空闲页的串联方式</h4><p><img src="/image/2025-12-30-learning_windows_4/1769050159668.png" alt="1769050159668"></p>
<p>注：64位下是*0x30</p>
<h3 id="VAD"><a href="#VAD" class="headerlink" title="VAD"></a>VAD</h3><p>每个进程（<code>_EPROCESS</code>）都有一个 VAD树（AVL树），描述了该进程所有合法的虚拟地址范围。<code>VirtualAlloc</code> 本质上就是往这棵树里插入一个节点。</p>
<h4 id="MMVAD-SHORT"><a href="#MMVAD-SHORT" class="headerlink" title="MMVAD_SHORT"></a>MMVAD_SHORT</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x40 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">MMVAD_SHORT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">MMVAD_SHORT</span>* <span class="title">NextVad</span>;</span>                                   <span class="comment">//0x0</span></span><br><span class="line">            VOID* ExtraCreateInfo;                                          <span class="comment">//0x8</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_BALANCED_NODE</span> <span class="title">VadNode</span>;</span>                                  <span class="comment">//0x0 📌AVL 树节点</span></span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG StartingVpn;                                                      <span class="comment">//0x18 起始页号/0x1000</span></span><br><span class="line">    ULONG EndingVpn;                                                        <span class="comment">//0x1c 结束页号/0x1000</span></span><br><span class="line">    UCHAR StartingVpnHigh;                                                  <span class="comment">//0x20 起始页号的高 32 位</span></span><br><span class="line">    UCHAR EndingVpnHigh;                                                    <span class="comment">//0x21 结束页号的高 32 位</span></span><br><span class="line">    UCHAR CommitChargeHigh;                                                 <span class="comment">//0x22</span></span><br><span class="line">    UCHAR SpareNT64VadUChar;                                                <span class="comment">//0x23</span></span><br><span class="line">    LONG ReferenceCount;                                                    <span class="comment">//0x24 引用计数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EX_PUSH_LOCK</span> <span class="title">PushLock</span>;</span>                                          <span class="comment">//0x28 细粒度锁</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ULONG LongFlags;                                                    <span class="comment">//0x30</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">MMVAD_FLAGS</span> <span class="title">VadFlags</span>;</span>                                       <span class="comment">//0x30 📌</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">MM_PRIVATE_VAD_FLAGS</span> <span class="title">PrivateVadFlags</span>;</span>                       <span class="comment">//0x30</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">MM_GRAPHICS_VAD_FLAGS</span> <span class="title">GraphicsVadFlags</span>;</span>                     <span class="comment">//0x30</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">MM_SHARED_VAD_FLAGS</span> <span class="title">SharedVadFlags</span>;</span>                         <span class="comment">//0x30</span></span><br><span class="line">        <span class="keyword">volatile</span> ULONG VolatileVadLong;                                     <span class="comment">//0x30</span></span><br><span class="line">    &#125; u;                                                                    <span class="comment">//0x30</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ULONG LongFlags1;                                                   <span class="comment">//0x34</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">MMVAD_FLAGS1</span> <span class="title">VadFlags1</span>;</span>                                     <span class="comment">//0x34</span></span><br><span class="line">    &#125; u1;                                                                   <span class="comment">//0x34</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">MI_VAD_EVENT_BLOCK</span>* <span class="title">EventList</span>;</span>                                  <span class="comment">//0x38 用于处理某些内存事件</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<h4 id="MMVAD-FLAGS"><a href="#MMVAD-FLAGS" class="headerlink" title="MMVAD_FLAGS"></a>MMVAD_FLAGS</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x4 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">MMVAD_FLAGS</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ULONG Lock:<span class="number">1</span>;                                                           <span class="comment">//0x0 内存被 VirtualLock 锁定了</span></span><br><span class="line">    ULONG LockContended:<span class="number">1</span>;                                                  <span class="comment">//0x0 锁竞争标志</span></span><br><span class="line">    ULONG DeleteInProgress:<span class="number">1</span>;                                               <span class="comment">//0x0 正在删除中</span></span><br><span class="line">    ULONG NoChange:<span class="number">1</span>;                                                       <span class="comment">//0x0 禁止修改保护属性</span></span><br><span class="line">    ULONG VadType:<span class="number">3</span>;                                                        <span class="comment">//0x0 📌VAD 类型：</span></span><br><span class="line">                                				            <span class="comment">// 0 = Private (私有)</span></span><br><span class="line">                                                                            <span class="comment">// 1 = Mapped (文件映射)</span></span><br><span class="line">                                                                            <span class="comment">// 2 = Image (可执行文件/DLL)</span></span><br><span class="line">    ULONG Protection:<span class="number">5</span>;                                                     <span class="comment">//0x0 📌内存保护属性 (R/W/X)</span></span><br><span class="line">    ULONG PreferredNode:<span class="number">6</span>;                                                  <span class="comment">//0x0 </span></span><br><span class="line">    ULONG PageSize:<span class="number">2</span>;                                                       <span class="comment">//0x0 是否是大页 (Large Page)</span></span><br><span class="line">    ULONG PrivateMemory:<span class="number">1</span>;                                                  <span class="comment">//0x0 📌1 = 私有内存 (Commit), 0 = 映射对象</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<h4 id="MMVAD"><a href="#MMVAD" class="headerlink" title="MMVAD"></a>MMVAD</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x88 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">MMVAD</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">MMVAD_SHORT</span> <span class="title">Core</span>;</span>                                               <span class="comment">//0x0</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ULONG LongFlags2;                                                   <span class="comment">//0x40</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MMVAD_FLAGS2</span> <span class="title">VadFlags2</span>;</span>                            <span class="comment">//0x40</span></span><br><span class="line">    &#125; u2;                                                                   <span class="comment">//0x40</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">SUBSECTION</span>* <span class="title">Subsection</span>;</span>                                         <span class="comment">//0x48 指向文件映射的核心控制块</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">MMPTE</span>* <span class="title">FirstPrototypePte</span>;</span>                                       <span class="comment">//0x50 📌原型 PTE</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">MMPTE</span>* <span class="title">LastContiguousPte</span>;</span>                                       <span class="comment">//0x58</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ViewLinks</span>;</span>                                           <span class="comment">//0x60</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EPROCESS</span>* <span class="title">VadsProcess</span>;</span>                                          <span class="comment">//0x70 📌指回所属进程</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">MI_VAD_SEQUENTIAL_INFO</span> <span class="title">SequentialVa</span>;</span>                        <span class="comment">//0x78</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">MMEXTEND_INFO</span>* <span class="title">ExtendedInfo</span>;</span>                                <span class="comment">//0x78</span></span><br><span class="line">    &#125; u4;                                                                   <span class="comment">//0x78 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">FILE_OBJECT</span>* <span class="title">FileObject</span>;</span>                                        <span class="comment">//0x80 如果是文件映射，这里持有文件对象指针</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>MMVAD结构体包含MMVAD_SHORT包含MMVAD_FLAGS</p>
<p><code>EPROCESS-&gt;VadRoot</code>类型是 <code>_RTL_AVL_TREE</code>，<code>_RTL_AVL_TREE</code> 只有一个成员：<code>Root</code> (类型是 <code>_RTL_BALANCED_NODE*</code>)，就是二叉树的 <code>node</code>节点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; dt _RTL_BALANCED_NODE</span><br><span class="line">nt!_RTL_BALANCED_NODE</span><br><span class="line">   +0x000 Children         : [2] Ptr64 _RTL_BALANCED_NODE</span><br><span class="line">   +0x000 Left             : Ptr64 _RTL_BALANCED_NODE</span><br><span class="line">   +0x008 Right            : Ptr64 _RTL_BALANCED_NODE</span><br><span class="line">   +0x010 Red              : Pos 0, 1 Bit</span><br><span class="line">   +0x010 Balance          : Pos 0, 2 Bits</span><br><span class="line">   +0x010 ParentValue      : Uint8B</span><br></pre></td></tr></table></figure>

<p>当前节点 ：覆盖范围是 <code>[StartingVpn, EndingVpn]</code>。(Virtual Page Number)</p>
<p>左子树 ：所有 VPN 小于 <code>StartingVpn</code> 的内存块。</p>
<p>右子树 ：所有 VPN 大于 <code>EndingVpn</code> 的内存块。</p>
<p>起始页：<code>startingVpn*0x1000</code> 结束页:<code>EndVpn*0x1000+0xfff</code></p>
<p>私有内存：通过 VirtualAlloc&#x2F;VirtualAllocEx 申请的</p>
<p>映射内存：通过 CreateFileMapping 映射的</p>
<p>通过IDA跟踪 malloc 和 new 的调用过程，如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">malloc -&gt; _nh_malloc_dbg -&gt; _heap_alloc_dbg -&gt; _heap_alloc_base -&gt; HeapAlloc</span><br><span class="line">new -&gt; _nh_malloc -&gt; _nh_malloc_dbg -&gt; _heap_alloc_dbg -&gt; _heap_alloc_base -&gt; HeapAlloc</span><br></pre></td></tr></table></figure>

<p>堆其实就是操作系统通过调用 VirtualAlloc 函数预先分配好的一大块以4KB为单位的内存。 HeapAlloc 的作用就是在这一大块已经预先分配好的内存里面，分一些小份出来用。</p>
<h3 id="缺页异常"><a href="#缺页异常" class="headerlink" title="缺页异常"></a>缺页异常</h3><p>VirtualAlloc分配内存到缺页异常分配实际物理页</p>
<p>Allocation Phase</p>
<ol>
<li><code>VirtualAlloc</code> -&gt; <code>NtAllocateVirtualMemory</code> -&gt; <code>MiAllocateVirtualMemory</code>。</li>
<li><code>MiReserveUserMemory</code> -&gt; <code>MiInsertVad</code>。<ul>
<li><code>ExAllocatePoolMm</code>从内核池（Paged Pool）分配 64 字节，创建一个空的 <code>_MMVAD_SHORT</code> 结构体</li>
<li>遍历VAD 树插入节点。</li>
<li>PTE 状态 ：对应范围的 PTE 保持为 Demand Zero 格式（P&#x3D;0，PageFileHigh&#x3D;0，Protection&#x3D;非空）。</li>
</ul>
</li>
</ol>
<p>Page Fault</p>
<ol>
<li>触发 ：用户访问 VA（Virtual Address）</li>
<li>入口 ：<code>KiPageFault</code>读取 <code>CR2</code> 寄存器（故障地址）</li>
<li>分发 ：<code>MmAccessFault</code> -&gt;<code>MiDispatchFault</code>。检查 PTE，发现 <code>Valid=0</code>，判定为 Demand Zero，调用 <code>MiResolveDemandZeroFault</code></li>
<li>VAD 验证：进入 <code>MiResolveDemandZeroFault</code> 。调用  <code>MiLocateAddress(FaultingAddr)</code> 。这步优先检查VAD Hint（最近访问缓存），再在 VAD 树中查找（从 <code>EPROCESS</code>拿到的指针）。如果返回 NULL，则异常处理失败。</li>
<li>物理页获取： <code>MiResolvePrivateZeroFault</code> 内部调用 <code>MiGetPageChain</code>，从 <code>mmZeroedPageListHead</code> 或 <code>mmFreePageListHead</code>摘取物理页 PFN。</li>
<li>修补页表 ：<code>MiResolvePrivateZeroFault</code> 最后调用  <code>MiCompletePrivateZeroFault</code> ，该函数计算 <code>PTE_Address</code>，将新申请的 <code>PFN</code> 物理页号和 <code>Valid=1</code> 以及保护属性写入该地址。更新 PFN 数据库（<code>_MMPFN</code>）中的 <code>PteAddress</code> 指向该 PTE。</li>
</ol>
<h3 id="池分配器"><a href="#池分配器" class="headerlink" title="池分配器"></a>池分配器</h3><h4 id="POOL-HEADER"><a href="#POOL-HEADER" class="headerlink" title="POOL_HEADER"></a>POOL_HEADER</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; dt _POOL_HEADER</span><br><span class="line">nt!_POOL_HEADER</span><br><span class="line">   +0x000 PreviousSize     : Pos 0, 8 Bits  // 前一个块的大小</span><br><span class="line">   +0x000 PoolIndex        : Pos 8, 8 Bits  // 池索引</span><br><span class="line">   +0x002 BlockSize        : Pos 0, 8 Bits  // 当前块的大小 (包含 Header)</span><br><span class="line">   +0x002 PoolType         : Pos 8, 8 Bits  // 池类型 (NonPaged, Paged 等)</span><br><span class="line">   +0x000 Ulong1           : Uint4B</span><br><span class="line">   +0x004 PoolTag          : Uint4B         // 4字节标签</span><br><span class="line">   +0x008 ProcessBilled    : Ptr64 _EPROCESS //指向分配的进程的KPROCESS指针,只有在PoolType中设置了PoolQuota,才会被设置</span><br><span class="line">   +0x008 AllocatorBackTraceIndex : Uint2B</span><br><span class="line">   +0x00a PoolTagHash      : Uint2B</span><br></pre></td></tr></table></figure>

<p>与用户层使用的堆一样,段堆根据分配的大小提供不同的功能,定义了4个后端.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">低碎片堆</span><br><span class="line">– Low Fragmentation Heap (abbr LFH): RtlpHpLfhContextAllocate</span><br><span class="line">可变量大小后端</span><br><span class="line">– Variable Size (abbr VS): RtlpHpVsContextAllocateInternal</span><br><span class="line">分段分配</span><br><span class="line">– Segment Alloc (abbr Seg): RtlpHpSegAlloc</span><br><span class="line">大型分配</span><br><span class="line">– Large Alloc: RtlpHpLargeAlloc</span><br></pre></td></tr></table></figure>

<p>请求分配的大小与选择后端的映射关系如下图所示</p>
<p><img src="https://ashlq.github.io/2023/08/22/Windows10%E5%86%85%E6%A0%B8%E6%B1%A0%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/image-20230822151821128.png" alt="image-20230822151821128"></p>
<p>LFH用户态下没有 Chunk Header，完全依赖 <code>_HEAP_LFH_SUBSEGMENT</code> 中的 <code>BlockBitmap</code>来记录哪个块被分配了。</p>
<p>内核态下有 <code>POOL_HEADER</code>，内核需要 <code>Tag</code> (用于 <code>!poolused</code> 统计) 和 <code>PoolType</code> (用于判断是非分页还是分页)。</p>
<p>VS结构 <code>VS Header</code> + <code>POOL_HEADER</code> + <code>Driver Data</code>。</p>
<p>NonPagedPool (非分页池)</p>
<ul>
<li>定义 ：物理页永远驻留在 RAM 中，绝不会被交换（Swap&#x2F;Page Out）到磁盘上的 <code>pagefile.sys</code>。</li>
<li>底层 ：分配的虚拟地址对应的 PTE (页表项) 中的  Valid (V) 位始终为 1 。</li>
</ul>
<p>PagedPool (分页池)</p>
<ul>
<li>定义 ：物理页可以被内存管理器回收并写入磁盘。当你一段时间不访问它，RAM 里的物理页就被拿去给别人用了。</li>
<li>底层 ：当你访问已被换出的 PagedPool 时，CPU 硬件触发 缺页异常 (#PF) 。内核的缺页处理程序（<code>KiPageFault</code> -&gt; <code>MmAccessFault</code>）会去磁盘读取数据，重新分配物理页，修补 PTE，然后让你继续执行。</li>
</ul>
<p>NUMA(Non-Uniform Memory Access非一致性内存访问)</p>
<p>系统将 CPU 和内存划分成多个  节点 (Node) 。每个 CPU 都有自己“私有”的一块内存（本地节点）。CPU 访问这块内存速度非常快 。</p>
<h4 id="ExPoolState"><a href="#ExPoolState" class="headerlink" title="ExPoolState"></a>ExPoolState</h4><p>是一个全局变量，它是整个内核池系统的根对象。</p>
<h5 id="EX-POOL-HEAP-MANAGER-STATE"><a href="#EX-POOL-HEAP-MANAGER-STATE" class="headerlink" title="EX_POOL_HEAP_MANAGER_STATE"></a>EX_POOL_HEAP_MANAGER_STATE</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; dt nt!_EX_POOL_HEAP_MANAGER_STATE</span><br><span class="line">   +0x000 HeapManager      : _RTLP_HP_HEAP_MANAGER  // 通用堆管理器状态 (Bitmap, 全局锁等)</span><br><span class="line">   +0x38d0 NumberOfPools    : Uint4B  // 当前系统启用的池数量</span><br><span class="line">   +0x3900 PoolNode         : [64] _EX_HEAP_POOL_NODE  // NUMA 节点数组</span><br><span class="line">   +0x86900 SpecialHeaps     : [4] Ptr64 _SEGMENT_HEAP // 特殊用途堆 (通常是 Session)</span><br></pre></td></tr></table></figure>

<h5 id="EX-HEAP-POOL-NODE"><a href="#EX-HEAP-POOL-NODE" class="headerlink" title="EX_HEAP_POOL_NODE"></a>EX_HEAP_POOL_NODE</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; dt _EX_HEAP_POOL_NODE</span><br><span class="line">nt!_EX_HEAP_POOL_NODE</span><br><span class="line">   +0x000 Heaps            : [4] Ptr64 _SEGMENT_HEAP  // 0 = NonPaged, 1 = NonPagedNx, 2 = Paged, 3 = PagedSession</span><br><span class="line">   +0x040 Lookasides       : [2] _RTL_DYNAMIC_LOOKASIDE  // 用于管理延迟释放的链表</span><br></pre></td></tr></table></figure>

<h4 id="ExAllocatePool2简化流程"><a href="#ExAllocatePool2简化流程" class="headerlink" title="ExAllocatePool2简化流程"></a>ExAllocatePool2简化流程</h4><p><code>ExAllocatePool2 -&gt; ExpAllocatePoolWithTagFromNode</code></p>
<p>标志转换 : <code>POOL_FLAGS</code> (如 <code>POOL_FLAG_NON_PAGED</code>) <strong>$\rightarrow$</strong> <code>POOL_TYPE</code> (0, 1, 512…)。</p>
<p>读取 <code>KeGetCurrentPrcb()-&gt;ParentNode</code> 获取当前  <strong>NodeIndex</strong> 。</p>
<p><code>ExAllocateHeapPool</code></p>
<ul>
<li><strong>寻址逻辑</strong> :</li>
</ul>
<p>$$<br>\text{HeapPtr} &#x3D; \text{nt!ExPoolState.PoolNode}[\text{NodeIndex}].\text{Heaps}[\text{PoolType}]<br>$$</p>
<ul>
<li><strong>结果</strong> : 拿到一个具体的 <code>_SEGMENT_HEAP*</code> 指针。</li>
</ul>
<p><code>RtlpHpAllocateHeap</code></p>
<p>拿到 <code>_SEGMENT_HEAP</code> 后，根据 <code>Size</code> 进入以下决策树（这是你需要修正的地方）：</p>
<ol>
<li>一级缓存: Dynamic Lookaside (动态快表)<ul>
<li>范围 : 通常覆盖中等大小 (e.g., 512B - 3KB, 动态调整)。</li>
<li>位置 : <code>_SEGMENT_HEAP.UserContext</code> -&gt; <code>_RTL_DYNAMIC_LOOKASIDE</code>。</li>
<li>动作 : 检查单链表 (<code>SLIST</code>)。如果有空闲块， 原子操作弹出 (Pop) ，直接返回。</li>
</ul>
</li>
<li>二级分配: LFH (低碎片堆)<ul>
<li>范围 : 1B - 16,368B (16KB，0x3FF0)。</li>
<li>位置 : <code>_SEGMENT_HEAP.LfhContext</code>。</li>
<li>动作 : 计算 Bucket Index <strong>$\rightarrow$</strong> 扫描 <code>BlockBitmap</code> <strong>$\rightarrow$</strong> 找到空闲位 <strong>$\rightarrow$</strong> 置位并返回。</li>
</ul>
</li>
<li>三级分配: VS (可变大小)<ul>
<li>范围 : 16KB - 128KB (通常上限)。</li>
<li>位置 : <code>_SEGMENT_HEAP.VsContext</code>。</li>
<li>动作 : 搜索 <code>RB-Tree</code> (红黑树) 或空闲链表，进行切割 (Split) 或合并 (Coalesce)。</li>
</ul>
</li>
<li>四级分配: Segment&#x2F;Large Alloc<ul>
<li>范围 : &gt; 128KB。</li>
<li>动作 : 调用 <code>RtlpHpSegAlloc</code> 或 <code>RtlpHpLargeAlloc</code>，直接向内存管理器 (<code>Mm</code>) 申请独立的 VAD&#x2F;PTE。</li>
</ul>
</li>
</ol>
<h2 id="内核回调"><a href="#内核回调" class="headerlink" title="内核回调"></a>内核回调</h2><h3 id="系统通知型回调（Notify-Callbacks）"><a href="#系统通知型回调（Notify-Callbacks）" class="headerlink" title="系统通知型回调（Notify Callbacks）"></a>系统通知型回调（Notify Callbacks）</h3><h4 id="进程回调"><a href="#进程回调" class="headerlink" title="进程回调"></a>进程回调</h4><p>Windows 提供两种进程回调机制：</p>
<p><code>PCREATE_PROCESS_NOTIFY_ROUTINE</code>（基础版）</p>
<p><code>PCREATE_PROCESS_NOTIFY_ROUTINE</code> 类型的回调需要通过 <code>PsSetCreateProcessNotifyRoutine</code> 函数注册和移除 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NTKERNELAPI</span><br><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">PsSetCreateProcessNotifyRoutine</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PCREATE_PROCESS_NOTIFY_ROUTINE NotifyRoutine,  <span class="comment">// 回调函数，当进程创建或销毁时会被调用</span></span></span><br><span class="line"><span class="params">    _In_ BOOLEAN Remove                                    <span class="comment">// 布尔值，TRUE 表示移除回调函数，FALSE 表示注册回调</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>可以提供进程的 PID、父进程 ID 和创建&#x2F;销毁事件标志。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef VOID (*PCREATE_PROCESS_NOTIFY_ROUTINE)(</span><br><span class="line">    _In_ HANDLE ParentId,   // 父进程 PID</span><br><span class="line">    _In_ HANDLE ProcessId,  // 当前进程 PID</span><br><span class="line">    _In_ BOOLEAN Create     // TRUE 表示创建进程，FALSE 表示退出进程</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><code>PCREATE_PROCESS_NOTIFY_ROUTINE_EX</code>（扩展版）</p>
<p><code>PCREATE_PROCESS_NOTIFY_ROUTINE_EX</code> 回调函数是通过 <code>PsSetCreateProcessNotifyRoutineEx</code> 函数注册或删除的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NTKERNELAPI </span><br><span class="line">NTSTATUS </span><br><span class="line"><span class="title function_">PsSetCreateProcessNotifyRoutineEx</span> <span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PCREATE_PROCESS_NOTIFY_ROUTINE_EX NotifyRoutine,  <span class="comment">// 扩展回调函数，提供更多的进程上下文信息</span></span></span><br><span class="line"><span class="params">    _In_ BOOLEAN Remove                                        <span class="comment">// 布尔值，TRUE 表示移除回调，FALSE 表示注册回调</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>提供更丰富的进程创建上下文，包括 <code>EPROCESS</code> 指针、映像路径、命令行、映像对象等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">VOID</span> <span class="params">(*PCREATE_PROCESS_NOTIFY_ROUTINE_EX)</span><span class="params">(</span></span><br><span class="line"><span class="params">    _Inout_ PEPROCESS Process,             <span class="comment">// 进程对象的指针，包含详细的进程信息</span></span></span><br><span class="line"><span class="params">    _In_ HANDLE ProcessId,                 <span class="comment">// 目标进程的 ID</span></span></span><br><span class="line"><span class="params">    _Inout_opt_ PPS_CREATE_NOTIFY_INFO CreateInfo <span class="comment">// 额外的创建通知信息（如命令行等）</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>额外的信息结构体如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PS_CREATE_NOTIFY_INFO</span> &#123;</span></span><br><span class="line">    _In_ SIZE_T Size;                                     <span class="comment">// 0x00: 结构体大小，必须初始化为 sizeof(PS_CREATE_NOTIFY_INFO)</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        _In_ ULONG Flags;                                 <span class="comment">// 0x04: 进程创建特性标志位集合</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            _In_ ULONG FileOpenNameAvailable : <span class="number">1</span>;         <span class="comment">// bit0: 当设置为1时表示ImageFileName字段包含有效的映像文件名</span></span><br><span class="line">            _In_ ULONG IsSubsystemProcess : <span class="number">1</span>;            <span class="comment">// bit1: 当设置为1时表示该进程是子系统进程（如Win32子系统进程）</span></span><br><span class="line">            _In_ ULONG Reserved : <span class="number">30</span>;                     <span class="comment">// bit2-31: 保留位，必须设置为0，供系统将来使用</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    _In_ HANDLE ParentProcessId;                          <span class="comment">// 0x08: 父进程的进程ID（PID），标识创建此进程的父进程</span></span><br><span class="line">    _In_ CLIENT_ID CreatingThreadId;                      <span class="comment">// 0x0C: 创建此进程的线程ID（包含进程ID和线程ID的结构体）</span></span><br><span class="line">    _Inout_ <span class="class"><span class="keyword">struct</span> _<span class="title">FILE_OBJECT</span> *<span class="title">FileObject</span>;</span>              <span class="comment">// 0x14: 指向进程映像文件对象的指针，可用于文件重定向</span></span><br><span class="line">    _In_ PCUNICODE_STRING ImageFileName;                  <span class="comment">// 0x18: 指向进程映像文件完整路径的指针（NT路径格式）</span></span><br><span class="line">    _In_opt_ PCUNICODE_STRING CommandLine;                <span class="comment">// 0x1C: 指向进程命令行参数的指针（可选字段，在较新版本的 Windows 10/11 上才存在，低版本系统或某些子系统进程（如 csrss.exe）中会为 NULL）</span></span><br><span class="line">    _Inout_ NTSTATUS CreationStatus;                      <span class="comment">// 0x20: 进程创建状态码，驱动程序可修改此值来阻止进程创建</span></span><br><span class="line">&#125; PS_CREATE_NOTIFY_INFO, *PPS_CREATE_NOTIFY_INFO;</span><br></pre></td></tr></table></figure>

<h5 id="注册过程"><a href="#注册过程" class="headerlink" title="注册过程"></a>注册过程</h5><p>都会调用 <code>PspSetCreateProcessNotifyRoutine</code>函数</p>
<p><code>MmVerifyCallbackFunctionCheckFlags</code>验证该地址是否属于已加载的驱动模块</p>
<p><code>MiLookupDataTableEntry</code>会从全局变量 <code>nt!MmLoadedModuleTable</code> 指向的根节点出发，按照二叉搜索逻辑遍历隐藏在每个驱动结构体 +0xE8 处的 <code>BaseAddressIndexNode</code>（红黑树节点）。在遍历过程中，它通过指针偏移计算出当前节点的驱动内存范围（<code>DllBase</code> 至 <code>DllBase + Size</code>），若目标地址落在该范围内则命中，最后将节点地址减去 <code>0xE8</code> 还原得到 <code>_KLDR_DATA_TABLE_ENTRY</code> 的首地址。</p>
<p>同时对于扩展回调注册，会检查 <code>KLDR_DATA_TABLE_ENTRY</code> 的 Flags 字段是否是 <code>0x20</code>，<code>0x20</code> 对应的是 <code>LDRP_IMAGE_INTEGRITY_FORCED</code>，因此使其 <code>0x20</code> 置位即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">7: kd&gt; dt _KLDR_DATA_TABLE_ENTRY</span><br><span class="line">nt!_KLDR_DATA_TABLE_ENTRY</span><br><span class="line">   +0x000 InLoadOrderLinks : _LIST_ENTRY</span><br><span class="line">   +0x010 ExceptionTable   : Ptr64 Void</span><br><span class="line">   +0x018 ExceptionTableSize : Uint4B</span><br><span class="line">   +0x020 GpValue          : Ptr64 Void</span><br><span class="line">   +0x028 NonPagedDebugInfo : Ptr64 _NON_PAGED_DEBUG_INFO</span><br><span class="line">   +0x030 DllBase          : Ptr64 Void</span><br><span class="line">   +0x038 EntryPoint       : Ptr64 Void</span><br><span class="line">   +0x040 SizeOfImage      : Uint4B</span><br><span class="line">   +0x048 FullDllName      : _UNICODE_STRING</span><br><span class="line">   +0x058 BaseDllName      : _UNICODE_STRING</span><br><span class="line">   +0x068 Flags            : Uint4B</span><br><span class="line">   +0x06c LoadCount        : Uint2B</span><br><span class="line">   +0x06e u1               : &lt;anonymous-tag&gt;</span><br><span class="line">   +0x070 SectionPointer   : Ptr64 Void</span><br><span class="line">   +0x078 CheckSum         : Uint4B</span><br><span class="line">   +0x07c CoverageSectionSize : Uint4B</span><br><span class="line">   +0x080 CoverageSection  : Ptr64 Void</span><br><span class="line">   +0x088 LoadedImports    : Ptr64 Void</span><br><span class="line">   +0x090 Spare            : Ptr64 Void</span><br><span class="line">   +0x098 SizeOfImageNotRounded : Uint4B</span><br><span class="line">   +0x09c TimeDateStamp    : Uint4B</span><br></pre></td></tr></table></figure>

<p><code>ExAllocateCallBack</code>申请 <code>NonPagedPoolNx</code> (非分页不可执行内存) 24 字节。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">EX_CALLBACK_ROUTINE_BLOCK</span> &#123;</span></span><br><span class="line">    EX_RUNDOWN_REF RundownProtect; <span class="comment">// +0x00</span></span><br><span class="line">    PVOID Function;                <span class="comment">// +0x08: 驱动提供的回调函数地址</span></span><br><span class="line">    PVOID Context;                 <span class="comment">// +0x10: 标志，0为基础班，2为扩展版</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Block-&gt;Function = Routine</code>。</li>
<li><code>Block-&gt;Context = 0/2</code> （标志）。</li>
<li><code>Block-&gt;RundownProtect</code> 初始化 (通常为 0，但在激活后会变为 <code>0x20</code> 或类似值)</li>
</ul>
<p>遍历回调槽 <code>&amp;PspCreateProcessNotifyRoutine[i]</code>，尝试原子插入（最多注册 64 个进程回调函数）</p>
<p>插入成功则：</p>
<ul>
<li>更新对应计数 <code>PspCreateProcessNotifyRoutineExCount</code>；</li>
<li>设置 <code>PspNotifyEnableMask</code> 中对应 bit（普通&#x2F;EX）；</li>
</ul>
<h5 id="回调过程"><a href="#回调过程" class="headerlink" title="回调过程"></a>回调过程</h5><h6 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h6><p>对于进程创建事件，进程回调函数会在 <code>PspInsertThread</code> 函数中被调用</p>
<p> <code>PspInsertThread</code>(判断Process-&gt;ActiveThreads &#x3D;&#x3D; 1)-&gt; <code>PspCallProcessNotifyRoutines</code></p>
<p> <code>PspCallProcessNotifyRoutines</code></p>
<p>检查全局掩码 <code>PspNotifyEnableMask</code></p>
<ul>
<li>Bit 1 (0x2): 对应 <code>PsSetCreateProcessNotifyRoutine</code>。</li>
<li>Bit 2 (0x4): 对应 <code>PsSetCreateProcessNotifyRoutineEx</code>。</li>
</ul>
<p>如果 <code>PspNotifyEnableMask</code> 检查通过，函数会在栈上构造 <code>PS_CREATE_NOTIFY_INFO</code> 结构体</p>
<p>函数遍历全局数组 <code>PspCreateProcessNotifyRoutine</code>（最大 64 个槽位）执行注册的回调函数</p>
<h6 id="隐藏进程"><a href="#隐藏进程" class="headerlink" title="隐藏进程"></a>隐藏进程</h6><ol>
<li>修改 <code>PspNotifyEnableMask</code></li>
<li>修改 <code>PspCreateProcessNotifyRoutine</code> 数组内容</li>
</ol>
<h6 id="拦截进程"><a href="#拦截进程" class="headerlink" title="拦截进程"></a>拦截进程</h6><p>修改 <code>NotifyInfo-&gt;CreationStatus</code></p>
<p>代码在每次执行完 Ex 回调后，都会检查 <code>NotifyInfo</code>中的 <code>CreationStatus</code> 成员：</p>
<p>一旦检测到错误码，循环中止，并且随后调用 <code>PsTerminateProcess</code></p>
<h6 id="欺骗-Spoofing"><a href="#欺骗-Spoofing" class="headerlink" title="欺骗(Spoofing)"></a>欺骗(Spoofing)</h6><p><code>NotifyInfo</code> 结构体是在栈上分配并传递给所有回调的。</p>
<p>如果能 hook <code>PspCallProcessNotifyRoutines</code> 或者在第一个回调中修改 <code>NotifyInfo-&gt;ImageFileName</code> 或 <code>CommandLine</code> 指针指向伪造的字符串。 后续执行的安全软件回调会读取到伪造的信息（例如将 <code>malware.exe</code> 伪装成 <code>svchost.exe</code>），从而绕过基于文件名的检测规则。</p>
<h6 id="进程退出"><a href="#进程退出" class="headerlink" title="进程退出"></a>进程退出</h6><p>对于进程退出事件则是在 <code>PspExitProcess</code> 函数中调用的回调函数。</p>
<p><code>PspExitProcess</code>(判断EPROCESS-&gt;Flags3 &#x3D;&#x3D;0  || EPROCESS-&gt;PicoContext)-&gt;<code>PspCallProcessNotifyRoutines</code></p>
<p><code>NotifyInfo</code>为NULL</p>
<h4 id="线程回调"><a href="#线程回调" class="headerlink" title="线程回调"></a>线程回调</h4><p>线程回调允许驱动在线程创建与销毁事件发生时接收通知 ，以实现监控、日志记录、安全检测等功能。Windows 提供了线程回调函数 <code>PCREATE_THREAD_NOTIFY_ROUTINE</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">VOID</span> <span class="params">(*PCREATE_THREAD_NOTIFY_ROUTINE)</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ HANDLE ProcessId,   <span class="comment">// 所属进程的 PID</span></span></span><br><span class="line"><span class="params">    _In_ HANDLE ThreadId,    <span class="comment">// 线程 ID</span></span></span><br><span class="line"><span class="params">    _In_ BOOLEAN Create      <span class="comment">// TRUE 表示线程创建，FALSE 表示线程销毁</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>注册&#x2F;移除回调函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NTKERNELAPI</span><br><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">PsSetCreateThreadNotifyRoutine</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NTKERNELAPI</span><br><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">PsRemoveCreateThreadNotifyRoutine</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p><code>PsSetCreateThreadNotifyRoutineEx</code> 是 Windows 10 引入的增强线程回调接口，允许驱动程序注册用于监听系统范围内线程创建和销毁事件的回调函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NTKERNELAPI</span><br><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">PsSetCreateThreadNotifyRoutineEx</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PSCREATETHREADNOTIFYTYPE NotifyType,    <span class="comment">// 枚举类型，表示要注册哪种类型的线程通知机制</span></span></span><br><span class="line"><span class="params">    _In_ PVOID NotifyInformation                 <span class="comment">// 实际上是 PCREATE_THREAD_NOTIFY_ROUTINE 的函数指针</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p><code>PsSetCreateThreadNotifyRoutineEx</code> 注册的回调函数依旧使用 <code>PsRemoveCreateThreadNotifyRoutine</code> 卸载。</p>
<p>PSCREATETHREADNOTIFYTYPE指定通知类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">PSCREATETHREADNOTIFYTYPE</span> &#123;</span></span><br><span class="line">    PsCreateThreadNotifyNonSystem = <span class="number">0</span>,  <span class="comment">// 回调在新线程上执行</span></span><br><span class="line">    PsCreateThreadNotifySubsystems = <span class="number">1</span>  <span class="comment">// 回调为所有子系统线程调用</span></span><br><span class="line">&#125; PSCREATETHREADNOTIFYTYPE;</span><br></pre></td></tr></table></figure>

<h5 id="注册过程-1"><a href="#注册过程-1" class="headerlink" title="注册过程"></a>注册过程</h5><p>都会调用 <code>PspSetCreateThreadNotifyRoutine</code>函数，扩展版还是和进程回调注册一样检查驱动签名</p>
<p>和进程回调注册一样分配 <code>_EX_CALLBACK_ROUTINE_BLOCK</code> (24字节)。</p>
<p><code>nt!PspCreateThreadNotifyRoutine</code>同样是 64 个槽位 (<code>0x40</code>)。</p>
<p>和进程回调注册完全一样的指针编码（地址 | 0xF）和原子插入</p>
<p>PspNotifyEnableMask全局掩码</p>
<ul>
<li>Bit 3 (Value 8) ：启用普通线程通知（包括 NonSystem 类型）。</li>
<li>Bit 4 (Value 16) ：启用 Ex 扩展线程通知（Subsystems）。</li>
</ul>
<h5 id="回调过程-1"><a href="#回调过程-1" class="headerlink" title="回调过程"></a>回调过程</h5><p>普通线程创建通知</p>
<p><code>PspInsertThread</code>(判断EPROCESS-&gt;Flags3 &#x3D;&#x3D;0  || EPROCESS-&gt;PicoContext)-&gt;<code>PspCallThreadNotifyRoutines</code></p>
<p><code>PspCallThreadNotifyRoutines</code>检查 <code>PspNotifyEnableMask</code>的第3位，检查通过，函数遍历全局数组 <code>PspCreateThreadNotifyRoutine</code>（最大64个槽位）执行注册的回调函数。</p>
<p>子系统线程创建通知</p>
<p>发生在 <code>PspInitializeThunkContext</code>函数中，在 <code>RtlInitializeExtendedContext</code> （计算并分配用于存储处理器上下文）之后，但在 <code>PspSetContextThreadInternal</code> （获取当前线程的寄存器基础状态）之前，因此可以直接操作当前线程的内存、寄存器（Trap Frame）。</p>
<p>线程结束通知</p>
<p><code>PspExitProcess</code>(判断EPROCESS-&gt;Flags3 &#x3D;&#x3D;0  || EPROCESS-&gt;PicoContext)-&gt;<code>PspCallThreadNotifyRoutines</code></p>
<h4 id="模块回调"><a href="#模块回调" class="headerlink" title="模块回调"></a>模块回调</h4><p>模块回调是允许驱动程序在任何模块（包括 EXE、DLL、SYS）加载到进程地址空间时收到通知 ，以便实现监控、日志记录、DLL 注入检测、签名验证等功能。</p>
<p>Windows 提供的模块回调函数类型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">VOID</span> <span class="params">(*PLOAD_IMAGE_NOTIFY_ROUTINE)</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_opt_ PUNICODE_STRING FullImageName, <span class="comment">// 映像完整路径（可能为 NULL）</span></span></span><br><span class="line"><span class="params">    _In_ HANDLE ProcessId,                  <span class="comment">// 映像加载目标进程 ID（0 表示系统进程）</span></span></span><br><span class="line"><span class="params">    _In_ PIMAGE_INFO ImageInfo              <span class="comment">// 映像加载信息结构体指针</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p><code>PIMAGE_INFO</code> 结构体描述了加载的映像的地址、大小和加载类型等信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_INFO</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        ULONG Properties;                                         <span class="comment">// 0x00: 属性标志位集合（用于快速判断加载类型）</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ULONG ImageAddressingMode  : <span class="number">8</span>;  <span class="comment">// [bit 0–7]  映像寻址模式：0 = 32位，1 = 64位，其他值为保留</span></span><br><span class="line">            ULONG SystemModeImage      : <span class="number">1</span>;  <span class="comment">// [bit 8]    📌映像是否在内核模式下加载（例如内核驱动）</span></span><br><span class="line">            ULONG ImageMappedToAllPids : <span class="number">1</span>;  <span class="comment">// [bit 9]    是否映射到所有进程（例如共享模块）</span></span><br><span class="line">            ULONG ExtendedInfoPresent  : <span class="number">1</span>;  <span class="comment">// [bit 10]   是否存在扩展映像信息（IMAGE_INFO_EX 结构）</span></span><br><span class="line">            ULONG MachineTypeMismatch  : <span class="number">1</span>;  <span class="comment">// [bit 11]   架构不匹配标志（如加载 x86 模块到 x64）</span></span><br><span class="line">            ULONG ImageSignatureLevel  : <span class="number">4</span>;  <span class="comment">// [bit 12–15]映像签名级别（Windows Defender 驱动执行控制级别）</span></span><br><span class="line">            ULONG ImageSignatureType   : <span class="number">3</span>;  <span class="comment">// [bit 16–18]映像签名类型（PE 签名、Catalog 等）</span></span><br><span class="line">            ULONG ImagePartialMap      : <span class="number">1</span>;  <span class="comment">// [bit 19]   如果整个映像未完全映射则为 1（通常用于特殊加载方式）</span></span><br><span class="line">            ULONG Reserved             : <span class="number">12</span>; <span class="comment">// [bit 20–31]保留字段（必须为 0，供系统未来使用）</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    PVOID ImageBase;                        <span class="comment">// 0x04 / 0x08: 映像映射到进程地址空间中的基地址</span></span><br><span class="line">    ULONG ImageSelector;                    <span class="comment">// 0x08 / 0x10: 保留字段，仅用于 x86（段选择器，现代系统基本无用）</span></span><br><span class="line">    SIZE_T ImageSize;                       <span class="comment">// 0x0C / 0x18: 映像的大小（以字节为单位）</span></span><br><span class="line">    ULONG ImageSectionNumber;              <span class="comment">// 0x10 / 0x20: 所加载映像在 PE 文件中的节索引（可用于调试或定位符号）</span></span><br><span class="line"></span><br><span class="line">&#125; IMAGE_INFO, *PIMAGE_INFO;</span><br></pre></td></tr></table></figure>

<p>模块回调函数 <code>PLOAD_IMAGE_NOTIFY_ROUTINE</code> 的注册和移除函数是两个不同的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NTKERNELAPI</span><br><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">PsSetLoadImageNotifyRoutine</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PLOAD_IMAGE_NOTIFY_ROUTINE NotifyRoutine</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NTKERNELAPI</span><br><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">PsRemoveLoadImageNotifyRoutine</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PLOAD_IMAGE_NOTIFY_ROUTINE NotifyRoutine</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p><code>PsSetLoadImageNotifyRoutineEx</code> 是 Win10 引入的模块回调注册函数，相比于旧的 <code>PsSetLoadImageNotifyRoutine</code>，此版本支持传入  Flags 参数 ，以便控制回调行为，如是否通知跨架构（x86&#x2F;x64）映像等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">PsSetLoadImageNotifyRoutineEx</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PLOAD_IMAGE_NOTIFY_ROUTINE NotifyRoutine,</span></span><br><span class="line"><span class="params">    _In_ ULONG_PTR Flags</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Flags目前只支持 <code>PS_IMAGE_NOTIFY_CONFLICTING_ARCHITECTURE(0x1)</code></p>
<h5 id="注册过程-2"><a href="#注册过程-2" class="headerlink" title="注册过程"></a>注册过程</h5><p><code>PsSetLoadImageNotifyRoutine</code>直接调用 <code>PsSetLoadImageNotifyRoutineEx(a1,0)</code>，因此两者注册过程基本一致</p>
<p>和进程&#x2F;线程回调一模一样，申请 24 字节的 <code>_EX_CALLBACK_ROUTINE_BLOCK</code></p>
<ul>
<li><code>+0x00</code>: RundownProtect</li>
<li><code>+0x08</code>: 回调函数地址 (<code>NotifyRoutine</code>)</li>
<li><code>+0x10</code>: Flags (<code>a2</code>，值为 0 或 1)</li>
</ul>
<p>然后调用完全相同的原子交换函数 <code>ExCompareExchangeCallBack</code>，寻找 <code>PspLoadImageNotifyRoutine</code> 数组中的空槽（NULL），并将经过编码的指针（<code>Address | 0xF</code>）写入。</p>
<p>然后设置 <code>PspNotifyEnableMask</code>的第0位。后续是ETW 事件相关……</p>
<h5 id="回调过程-2"><a href="#回调过程-2" class="headerlink" title="回调过程"></a>回调过程</h5><p>在 <code>PsCallImageNotifyRoutines</code>检查 <code>PspNotifyEnableMask</code>第0位，遍历 <code>PspLoadImageNotifyRoutine</code> 数组（最大 64 个槽位），执行注册的回调函数。</p>
<p>交叉引用发现有三个函数调用它：</p>
<p>MiDriverLoadSucceeded：在驱动对象的 Section 对象创建成功，且内存控制区（Control Area）初始化之后。</p>
<p>DbgkCreateThread：在第一个线程初始化时运行，补发已经映射好的模块（EXE 和 NTDLL）的加载通知。</p>
<p>MiMapViewOfImageSection：<code>LoadLibrary</code> 加载的 DLL 或手动 Map 的内存映像。回调是在内存映射（Mapping）完成之后，但在 DLL 的入口点（DllMain）执行之前触发的。此时文件已经被映射到虚拟内存中，<code>ImageBase</code> 和 <code>ImageSize</code> 已确定。</p>
<h3 id="对象回调"><a href="#对象回调" class="headerlink" title="对象回调"></a>对象回调</h3><p>在Windows内核中， 对象回调机制（Object Callbacks）是一种安全和监控机制，允许内核模式驱动程序注册特定的回调函数，以监视或拦截对某些内核对象（例如进程、线程、文件等）的操作。</p>
<h4 id="注册-卸载回调"><a href="#注册-卸载回调" class="headerlink" title="注册&#x2F;卸载回调"></a>注册&#x2F;卸载回调</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册对象访问回调（要求驱动签名）</span></span><br><span class="line">NTKERNELAPI</span><br><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">ObRegisterCallbacks</span> <span class="params">(</span></span><br><span class="line"><span class="params">    _In_ POB_CALLBACK_REGISTRATION CallbackRegistration,  <span class="comment">// 指向 OB_CALLBACK_REGISTRATION 结构体：     </span></span></span><br><span class="line"><span class="params">    _Outptr_ PVOID *RegistrationHandle                     <span class="comment">// 返回注册后的句柄</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"><span class="comment">// 注销回调函数</span></span><br><span class="line">NTKERNELAPI</span><br><span class="line">VOID</span><br><span class="line"><span class="title function_">ObUnRegisterCallbacks</span> <span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PVOID RegistrationHandle                         <span class="comment">// 通过 ObRegisterCallbacks 返回的注册句柄</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p><code>OB_CALLBACK_REGISTRATION</code> 结构体描述一次对象访问回调注册请求，包含回调的元信息、目标对象类型、回调函数数组等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OB_CALLBACK_REGISTRATION</span> &#123;</span></span><br><span class="line">    USHORT Version;          <span class="comment">// 结构体版本号，OB_FLT_REGISTRATION_VERSION(0x100)，用ObGetFilterVersion函数动态获取</span></span><br><span class="line">    USHORT OperationRegistrationCount;         <span class="comment">// 数组元素数量，注册的对象类型数量（通常为 1~3）</span></span><br><span class="line">    UNICODE_STRING Altitude;    <span class="comment">// 优先级，格式：&lt;数字&gt;.&lt;驱动/产品标识符&gt;</span></span><br><span class="line">    PVOID RegistrationContext;  <span class="comment">// 自定义上下文指针，在PreOperation/PostOperation回调中可通过 RegistrationContext 参数获取</span></span><br><span class="line">    OB_OPERATION_REGISTRATION* OperationRegistration;</span><br><span class="line">&#125; OB_CALLBACK_REGISTRATION, *POB_CALLBACK_REGISTRATION;</span><br></pre></td></tr></table></figure>

<p><code>OB_OPERATION_REGISTRATION</code> 描述驱动希望拦截的对象类型、操作类型以及对应的回调函数。每个 <code>OB_OPERATION_REGISTRATION</code> 项表示一类对象（如进程、线程）的访问行为拦截配置。它提供两种类型的回调函数：</p>
<ul>
<li><code>PreOperation</code>：在句柄创建&#x2F;复制发生之前调用，允许回调函数修改访问权限，直接阻止访问行为。</li>
<li><code>PostOperation</code>：在句柄创建&#x2F;复制完成之后调用，不再允许修改访问权限。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OB_OPERATION_REGISTRATION</span> &#123;</span></span><br><span class="line">    In POBJECT_TYPE *ObjectType; <span class="comment">// 指向要监控的对象类型的全局指针</span></span><br><span class="line">    In OB_OPERATION Operations;   <span class="comment">// 要拦截的操作类型</span></span><br><span class="line">    In POB_PRE_OPERATION_CALLBACK PreOperation;    <span class="comment">// 预操作回调函数，在对象句柄创建或复制之前被调用。</span></span><br><span class="line">    In POB_POST_OPERATION_CALLBACK PostOperation; <span class="comment">// 后操作回调函数，在句柄创建/复制完成后调用</span></span><br><span class="line">&#125; OB_OPERATION_REGISTRATION, *POB_OPERATION_REGISTRATION;</span><br></pre></td></tr></table></figure>

<p>监控对象通过 <code>ObjectType</code> 字段描述，这个字段描述要拦截的对象种类 ，如进程、线程、注册表项等。我们需要将其填充为一个系统导出的全局的对象类型描述符指针。</p>
<table>
<thead>
<tr>
<th>对象名称</th>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>进程</td>
<td><code>PsProcessType</code></td>
<td>所有 <code>EPROCESS</code> 对象</td>
</tr>
<tr>
<td>线程</td>
<td><code>PsThreadType</code></td>
<td>所有 <code>ETHREAD</code> 对象</td>
</tr>
<tr>
<td>注册表键</td>
<td><code>CmKeyObjectType</code></td>
<td>所有注册表项对象（<code>KEY_OBJECT</code>）</td>
</tr>
<tr>
<td>事件</td>
<td><code>ExEventObjectType</code></td>
<td>事件对象（非用户事件）</td>
</tr>
<tr>
<td>信号量等</td>
<td><code>ExSemaphoreObjectType</code></td>
<td>同步对象（部分可见）</td>
</tr>
</tbody></table>
<p><code>Operations</code>字段值可以为以下之一或组合。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> OB_OPERATION_HANDLE_CREATE     0x00000001  <span class="comment">// 例如 ZwOpenProcess</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OB_OPERATION_HANDLE_DUPLICATE  0x00000002  <span class="comment">// 例如 DuplicateHandle</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>OB_OPERATION_HANDLE_CREATE</code>：当系统执行创建一个新对象句柄（handle）时触发。</li>
<li><code>OB_OPERATION_HANDLE_DUPLICATE</code>：当系统执行复制一个已存在的对象句柄时触发。</li>
</ul>
<h5 id="PreOperation"><a href="#PreOperation" class="headerlink" title="PreOperation"></a>PreOperation</h5><p>预操作回调函数，只能返回OB_PREOP_SUCCESS。函数定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">OB_PREOP_CALLBACK_STATUS</span></span><br><span class="line"><span class="params">(*POB_PRE_OPERATION_CALLBACK)</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_    PVOID RegistrationContext,                          <span class="comment">// 注册时提供的上下文指针，驱动可用于传递状态或配置</span></span></span><br><span class="line"><span class="params">    _Inout_ POB_PRE_OPERATION_INFORMATION OperationInformation  <span class="comment">// 包含此次对象访问操作的详细信息</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p><code>RegistrationContext</code> 参数来自于注册回调函数时 <code>OB_CALLBACK_REGISTRATION</code> 结构体的 <code>RegistrationContext</code> 成员，传递 <strong>用户</strong> 自定义的参数。</p>
<p><code>OperationInformation</code> 参数存放了发生回调时保存的信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OB_PRE_OPERATION_INFORMATION</span> &#123;</span></span><br><span class="line">    _In_ OB_OPERATION Operation;   <span class="comment">// 当前操作类型OB_OPERATION_HANDLE_CREATE(0x1)/DUPLICATE(0x2)</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        _In_ ULONG Flags;         <span class="comment">// 位标志字段，当前仅定义了 KernelHandle 位</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            _In_ ULONG KernelHandle : <span class="number">1</span>; <span class="comment">// 若为 1，表示此操作为内核句柄操作，驱动不可干预</span></span><br><span class="line">            _In_ ULONG Reserved     : <span class="number">31</span>;<span class="comment">// 保留</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;; </span><br><span class="line">    _In_ PVOID Object; <span class="comment">// 被访问的对象指针</span></span><br><span class="line">    _In_ POBJECT_TYPE ObjectType;  <span class="comment">// 被访问对象的类型指针</span></span><br><span class="line">    _Out_ PVOID CallContext;  <span class="comment">// 自定义上下文，用户可读写字段，可在PreOperation中设置，在PostOperation中获取</span></span><br><span class="line">    _In_ POB_PRE_OPERATION_PARAMETERS Parameters;  <span class="comment">// 包含访问操作的参数信息（联合体，依操作类型不同而异）</span></span><br><span class="line"></span><br><span class="line">&#125; OB_PRE_OPERATION_INFORMATION, *POB_PRE_OPERATION_INFORMATION;</span><br></pre></td></tr></table></figure>

<p><code>OB_PRE_OPERATION_INFORMATION</code> 结构体主要描述了事件类型和内核对象相关信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef union _OB_PRE_OPERATION_PARAMETERS &#123;</span><br><span class="line">    OB_PRE_CREATE_HANDLE_INFORMATION      CreateHandleInformation;     // 用于 OB_OPERATION_HANDLE_CREATE</span><br><span class="line">    OB_PRE_DUPLICATE_HANDLE_INFORMATION   DuplicateHandleInformation;  // 用于 OB_OPERATION_HANDLE_DUPLICATE</span><br><span class="line">&#125; OB_PRE_OPERATION_PARAMETERS, *POB_PRE_OPERATION_PARAMETERS;</span><br></pre></td></tr></table></figure>

<p>OB_PRE_CREATE_HANDLE_INFORMATION</p>
<p>可以给指定的进程句柄降权。由于是在创建句柄前的回调，因此此时句柄还未创建，也就不会在参数中传入。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _OB_PRE_CREATE_HANDLE_INFORMATION &#123;</span><br><span class="line">    _Inout_ ACCESS_MASK DesiredAccess;          // 可修改：最终授予用户的访问权限</span><br><span class="line">    _In_    ACCESS_MASK OriginalDesiredAccess;  // 只读：用户原始请求的访问权限</span><br><span class="line">&#125; OB_PRE_CREATE_HANDLE_INFORMATION, *POB_PRE_CREATE_HANDLE_INFORMATION;</span><br></pre></td></tr></table></figure>

<p>OB_PRE_DUPLICATE_HANDLE_INFORMATION</p>
<p>由于是进行句柄复制，因此会同时传递句柄权限，源进程和目标进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OB_PRE_DUPLICATE_HANDLE_INFORMATION</span> &#123;</span></span><br><span class="line">    _Inout_ ACCESS_MASK DesiredAccess;          <span class="comment">// 可修改：目标进程最终获得的访问权限</span></span><br><span class="line">    _In_    ACCESS_MASK OriginalDesiredAccess;  <span class="comment">// 只读：原始复制请求的权限</span></span><br><span class="line">    _In_    PVOID SourceProcess;                <span class="comment">// 源进程的 EPROCESS 指针（原始句柄所有者）</span></span><br><span class="line">    _In_    PVOID TargetProcess;                <span class="comment">// 目标进程的 EPROCESS 指针（接收者）</span></span><br><span class="line">&#125; OB_PRE_DUPLICATE_HANDLE_INFORMATION, *POB_PRE_DUPLICATE_HANDLE_INFORMATION;</span><br></pre></td></tr></table></figure>

<h5 id="PostOperation"><a href="#PostOperation" class="headerlink" title="PostOperation"></a>PostOperation</h5><p>后操作回调函数，是在对象访问操作（如创建或复制句柄）完成之后。其函数定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">VOID</span></span><br><span class="line"><span class="params">(*POB_POST_OPERATION_CALLBACK)</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PVOID RegistrationContext,                             <span class="comment">// 驱动注册时提供的上下文指针，用于传递状态或策略配置</span></span></span><br><span class="line"><span class="params">    _In_ POB_POST_OPERATION_INFORMATION OperationInformation    <span class="comment">// 本次对象访问操作的结果信息结构体</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p><code>OB_POST_OPERATION_INFORMATION</code> 与前面的 <code>OB_PRE_OPERATION_INFORMATION</code> 结构基本完全一致。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OB_POST_OPERATION_INFORMATION</span> &#123;</span></span><br><span class="line">    _In_ OB_OPERATION  Operation;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        _In_ ULONG Flags;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            _In_ ULONG KernelHandle:<span class="number">1</span>;</span><br><span class="line">            _In_ ULONG Reserved:<span class="number">31</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    _In_ PVOID                          Object;</span><br><span class="line">    _In_ POBJECT_TYPE                   ObjectType;</span><br><span class="line">    _In_ PVOID                          CallContext;</span><br><span class="line">    _In_ NTSTATUS                       ReturnStatus;</span><br><span class="line">    _In_ POB_POST_OPERATION_PARAMETERS  Parameters;</span><br><span class="line">&#125; OB_POST_OPERATION_INFORMATION,*POB_POST_OPERATION_INFORMATION;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于后操作回调函数不修改权限，因此 <code>OB_POST_OPERATION_PARAMETERS</code> 中只有 <code>GrantedAccess</code>，并且对于 <code>DUPLICATE</code> 事件也不提供双方的进程对象地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OB_POST_CREATE_HANDLE_INFORMATION</span> &#123;</span></span><br><span class="line">    _In_ ACCESS_MASK            GrantedAccess;</span><br><span class="line">&#125; OB_POST_CREATE_HANDLE_INFORMATION, *POB_POST_CREATE_HANDLE_INFORMATION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OB_POST_DUPLICATE_HANDLE_INFORMATION</span> &#123;</span></span><br><span class="line">    _In_ ACCESS_MASK            GrantedAccess;</span><br><span class="line">&#125; OB_POST_DUPLICATE_HANDLE_INFORMATION, * POB_POST_DUPLICATE_HANDLE_INFORMATION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> _<span class="title">OB_POST_OPERATION_PARAMETERS</span> &#123;</span></span><br><span class="line">    _In_ OB_POST_CREATE_HANDLE_INFORMATION       CreateHandleInformation;</span><br><span class="line">    _In_ OB_POST_DUPLICATE_HANDLE_INFORMATION    DuplicateHandleInformation;</span><br><span class="line">&#125; OB_POST_OPERATION_PARAMETERS, *POB_POST_OPERATION_PARAMETERS;</span><br></pre></td></tr></table></figure>

<h4 id="相关结构体"><a href="#相关结构体" class="headerlink" title="相关结构体"></a>相关结构体</h4><h5 id="OBJECT-TYPE-1"><a href="#OBJECT-TYPE-1" class="headerlink" title="OBJECT_TYPE"></a>OBJECT_TYPE</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">6: kd&gt; dt nt!_OBJECT_TYPE</span><br><span class="line">   +0x000 TypeList         : _LIST_ENTRY    // 链接所有 OBJECT_TYPE 实例</span><br><span class="line">   +0x010 Name             : _UNICODE_STRING</span><br><span class="line">   +0x020 DefaultObject    : Ptr64 Void  </span><br><span class="line">   +0x028 Index            : UChar        // 对象类型索引</span><br><span class="line">   +0x02c TotalNumberOfObjects : Uint4B   // 当前该类型对象的总数</span><br><span class="line">   +0x030 TotalNumberOfHandles : Uint4B   // 该类型所有对象的句柄总数</span><br><span class="line">   +0x034 HighWaterNumberOfObjects : Uint4B</span><br><span class="line">   +0x038 HighWaterNumberOfHandles : Uint4B</span><br><span class="line">   +0x040 TypeInfo         : _OBJECT_TYPE_INITIALIZER  // 类型初始化结构，定义该类型对象的行为（如回调、池分配方式等）</span><br><span class="line">   +0x0b8 TypeLock         : _EX_PUSH_LOCK </span><br><span class="line">   +0x0c0 Key              : Uint4B</span><br><span class="line">   +0x0c8 CallbackList     : _LIST_ENTRY  //📌对象回调链表，用于支持注册的 ObRegisterCallbacks 回调</span><br></pre></td></tr></table></figure>

<p>其中 <code>CallbackList</code> 是一个链表，存放我们注册的对象回调函数的存储结构 <code>OB_CALLBACK_ENTRY</code>。</p>
<h5 id="OBJECT-TYPE-INITIALIZER"><a href="#OBJECT-TYPE-INITIALIZER" class="headerlink" title="OBJECT_TYPE_INITIALIZER"></a>OBJECT_TYPE_INITIALIZER</h5><p><code>OBJECT_TYPE_INITIALIZER</code> 中还有一些列的回调函数，这些回调函数会针对不同内核对象的不同特性而指向不同的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x78 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_TYPE_INITIALIZER</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    USHORT Length;                                            <span class="comment">//0x0 结构体大小（用于版本兼容与校验）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        USHORT ObjectTypeFlags;                               <span class="comment">//0x2 对象类型标志位字段（压缩位）</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            UCHAR CaseInsensitive:<span class="number">1</span>;                          <span class="comment">//0x2 是否大小写不敏感（如符号链接对象）</span></span><br><span class="line">            UCHAR UnnamedObjectsOnly:<span class="number">1</span>;                       <span class="comment">//0x2 是否只允许匿名对象（如事件、信号量等）</span></span><br><span class="line">            UCHAR UseDefaultObject:<span class="number">1</span>;                         <span class="comment">//0x2 是否使用 DefaultObject 提供默认实例</span></span><br><span class="line">            UCHAR SecurityRequired:<span class="number">1</span>;                         <span class="comment">//0x2 创建时是否必须提供安全描述符</span></span><br><span class="line">            UCHAR MaintainHandleCount:<span class="number">1</span>;                      <span class="comment">//0x2 是否维护句柄引用计数</span></span><br><span class="line">            UCHAR MaintainTypeList:<span class="number">1</span>;                         <span class="comment">//0x2 是否加入全局对象类型链表</span></span><br><span class="line">            UCHAR SupportsObjectCallbacks:<span class="number">1</span>;                  <span class="comment">//0x2 📌是否支持对象回调</span></span><br><span class="line">            UCHAR CacheAligned:<span class="number">1</span>;                             <span class="comment">//0x2</span></span><br><span class="line">            UCHAR UseExtendedParameters:<span class="number">1</span>;                    <span class="comment">//0x3</span></span><br><span class="line">            UCHAR Reserved:<span class="number">7</span>;                                 <span class="comment">//0x3</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG ObjectTypeCode;                                      <span class="comment">//0x4</span></span><br><span class="line">    ULONG InvalidAttributes;                                   <span class="comment">//0x8</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">GENERIC_MAPPING</span> <span class="title">GenericMapping</span>;</span>                    <span class="comment">//0xc</span></span><br><span class="line">    ULONG ValidAccessMask;                                     <span class="comment">//0x1c 📌可用的访问权限位（ObCheckObjectAccess 用）</span></span><br><span class="line">    ULONG RetainAccess;                                        <span class="comment">//0x20 </span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> _<span class="title">POOL_TYPE</span> <span class="title">PoolType</span>;</span>                                  <span class="comment">//0x24 对象默认使用的内存池类型</span></span><br><span class="line">    ULONG DefaultPagedPoolCharge;                              <span class="comment">//0x28</span></span><br><span class="line">    ULONG DefaultNonPagedPoolCharge;                           <span class="comment">//0x2c</span></span><br><span class="line">    VOID (*DumpProcedure)(</span><br><span class="line">          VOID* arg1,</span><br><span class="line">          <span class="keyword">struct</span> _OBJECT_DUMP_CONTROL* arg2</span><br><span class="line">    );                                                        <span class="comment">//0x30 调试器 !object 调用的对象转储回调</span></span><br><span class="line">    LONG (*OpenProcedure)(</span><br><span class="line">          <span class="keyword">enum</span> _OB_OPEN_REASON arg1,</span><br><span class="line">          CHAR arg2, <span class="keyword">struct</span> _EPROCESS* arg3, </span><br><span class="line">          VOID* arg4, ULONG* arg5, ULONG arg6</span><br><span class="line">    );                                                        <span class="comment">//0x38 对象被打开（NtOpenXXX）时的访问控制回调</span></span><br><span class="line">    VOID (*CloseProcedure)(</span><br><span class="line">          <span class="keyword">struct</span> _EPROCESS* arg1,</span><br><span class="line">          VOID* arg2, ULONGLONG arg3, ULONGLONG arg4</span><br><span class="line">    );                                                        <span class="comment">//0x40 对象句柄关闭（NtClose）时调用的回调</span></span><br><span class="line">    VOID (*DeleteProcedure)(VOID* arg1);                      <span class="comment">//0x48 对象引用归零被删除时触发的清理回调</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        LONG (*ParseProcedure)(</span><br><span class="line">              VOID* arg1, VOID* arg2,</span><br><span class="line">              <span class="keyword">struct</span> _ACCESS_STATE* arg3,</span><br><span class="line">              CHAR arg4, ULONG arg5, <span class="keyword">struct</span> _UNICODE_STRING* arg6, </span><br><span class="line">              <span class="keyword">struct</span> _UNICODE_STRING* arg7, VOID* arg8, </span><br><span class="line">              <span class="keyword">struct</span> _SECURITY_QUALITY_OF_SERVICE* arg9, VOID** arg10</span><br><span class="line">        );                                                     <span class="comment">//0x50 对象路径解析（如 NtOpenFile 解析路径）</span></span><br><span class="line">        LONG (*ParseProcedureEx)(</span><br><span class="line">              VOID* arg1, VOID* arg2, <span class="keyword">struct</span> _ACCESS_STATE* arg3, </span><br><span class="line">              CHAR arg4, ULONG arg5, <span class="keyword">struct</span> _UNICODE_STRING* arg6, </span><br><span class="line">              <span class="keyword">struct</span> _UNICODE_STRING* arg7, VOID* arg8,</span><br><span class="line">              <span class="keyword">struct</span> _SECURITY_QUALITY_OF_SERVICE* arg9,</span><br><span class="line">              <span class="keyword">struct</span> _OB_EXTENDED_PARSE_PARAMETERS* arg10, VOID** arg11</span><br><span class="line">        );                                                     <span class="comment">//0x50</span></span><br><span class="line">    &#125;;</span><br><span class="line">    LONG (*SecurityProcedure)(</span><br><span class="line">          VOID* arg1, <span class="keyword">enum</span> _SECURITY_OPERATION_CODE arg2,</span><br><span class="line">          ULONG* arg3, VOID* arg4, ULONG* arg5, VOID** arg6, </span><br><span class="line">          <span class="keyword">enum</span> _POOL_TYPE arg7, <span class="keyword">struct</span> _GENERIC_MAPPING* arg8, CHAR arg9</span><br><span class="line">    );                                                        <span class="comment">//0x58 安全描述符读取/修改操作回调</span></span><br><span class="line">    LONG (*QueryNameProcedure)(</span><br><span class="line">          VOID* arg1, UCHAR arg2, </span><br><span class="line">          <span class="keyword">struct</span> _OBJECT_NAME_INFORMATION* arg3, </span><br><span class="line">          ULONG arg4, ULONG* arg5, CHAR arg6</span><br><span class="line">    );                                                        <span class="comment">//0x60 查询对象名称信息的回调（如 NtQueryObject）</span></span><br><span class="line">    UCHAR (*OkayToCloseProcedure)(</span><br><span class="line">           <span class="keyword">struct</span> _EPROCESS* arg1, VOID* arg2,</span><br><span class="line">           VOID* arg3, CHAR arg4</span><br><span class="line">    );                                                        <span class="comment">//0x68 判断是否允许关闭对象句柄（可用于保护特定句柄）</span></span><br><span class="line">    ULONG WaitObjectFlagMask;                                 <span class="comment">//0x70</span></span><br><span class="line">    USHORT WaitObjectFlagOffset;                              <span class="comment">//0x74</span></span><br><span class="line">    USHORT WaitObjectPointerOffset;                           <span class="comment">//0x76</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<h5 id="OB-CALLBACK-HANDLE"><a href="#OB-CALLBACK-HANDLE" class="headerlink" title="OB_CALLBACK_HANDLE"></a>OB_CALLBACK_HANDLE</h5><p>调用 <code>ObRegisterCallbacks</code> 注册回调函数成功后会返回一个 <code>RegistrationHandle</code> 句柄，其指向指向 <code>OB_CALLBACK_HANDLE</code> 未公开结构体。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _OB_CALLBACK_HANDLE &#123;</span><br><span class="line">    USHORT Version;                          // 0x00:注册结构版本号，必须为 OB_FLT_REGISTRATION_VERSION</span><br><span class="line">    USHORT OperationRegistrationCount;       // 0x02:实际成功注册的回调项数量（CallbackEntryArray中的项数）</span><br><span class="line">    UINT32 Padding;</span><br><span class="line">    PVOID RegistrationContext;               // 0x08:调用者定义的上下文，可在回调中访问</span><br><span class="line">    UNICODE_STRING Altitude;                 // 0x10:注册高度（Altitude）</span><br><span class="line">                                             // (16 bytes: Len, MaxLen, BufferPtr指向本内存块的最末尾)</span><br><span class="line">    OB_CALLBACK_ENTRY CallbackEntryArray[1]; // 0x20:变长数组，用于存储所有回调项（按需分配内存）</span><br><span class="line">&#125; OB_CALLBACK_HANDLE, *POB_CALLBACK_HANDLE;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _OB_CALLBACK_ENTRY &#123;</span><br><span class="line">    LIST_ENTRY CallbackList;               // 0x00:链表节点，挂入 ObjectType-&gt;CallbackList 链表</span><br><span class="line">    ULONG Operations;                      // 0x10:触发操作标志：如 OB_OPERATION_HANDLE_CREATE / DUPLICATE</span><br><span class="line">    ULONG Flags;                           // 0x14:状态标志：如 OB_CALLBACK_ACTIVE_FLAG</span><br><span class="line">    POB_CALLBACK_HANDLE CallbackHandle;   // 0x18:所属回调句柄（OB_CALLBACK_HANDLE），用于回溯清理</span><br><span class="line">    POBJECT_TYPE ObjectType;              // 0x20:注册目标对象类型（如 PsProcessType、PsThreadType）</span><br><span class="line">    POB_PRE_OPERATION_CALLBACK PreOperation;   // 0x28:创建或复制前的预回调函数指针</span><br><span class="line">    POB_POST_OPERATION_CALLBACK PostOperation; // 0x30:创建或复制后的后回调函数指针</span><br><span class="line">    EX_RUNDOWN_REF RundownRef;            // 0x38:Rundown 保护，用于延迟释放 CallbackEntry</span><br><span class="line">&#125; OB_CALLBACK_ENTRY, *POB_CALLBACK_ENTRY;</span><br></pre></td></tr></table></figure>

<h4 id="注册过程-3"><a href="#注册过程-3" class="headerlink" title="注册过程"></a>注册过程</h4><p>当用户调用 <code>ObRegisterCallbacks</code> 时：</p>
<ol>
<li>检查 <code>CallbackRegistration-&gt;Version</code> 是否为 <code>0x100</code></li>
<li>内核调用 <code>ExAllocatePoolWithTag</code>分配一块分配一块 PagedPool 内存，Tag 为 <code>&#39;ObCb&#39;</code>，包含 <code>OB_CALLBACK_HANDLE</code>和若干 <code>OB_CALLBACK_ENTRY</code>结构，会把用户的 <code>Altitude</code> 字符串拷贝到这块内存的尾部。</li>
<li>检查 <code>ObjectType</code> 是否支持回调（Flags &amp; 0x40），使用 <code>MmVerifyCallbackFunctionCheckFlags</code> 检查签名。</li>
<li>它为每个注册的操作（Process Create&#x2F;Duplicate 等）初始化一个 <code>OB_CALLBACK_ENTRY</code>。</li>
<li>它持有对象类型锁，遍历现有的回调链表。</li>
<li>它根据 <code>Altitude</code> 字符串的大小，将你的回调节点插入到 <code>ObjectType-&gt;CallbackList</code> 的特定位置。</li>
<li>CallbackList 是降序排列的，头部是 Altitude 最大的节点，尾部是 Altitude 最小的节点。</li>
<li>PreOperation是Altitude大的先执行，PostOperation与之相反</li>
</ol>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a href="/categories/">Category</a></li>
        
          <li><a href="/search/">Search</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/friends/">friends</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#windows"><span class="toc-number">1.</span> <span class="toc-text">windows</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8syscall"><span class="toc-number">1.1.</span> <span class="toc-text">系统调用syscall</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#x86%E4%B8%8BR3-R0"><span class="toc-number">1.1.1.</span> <span class="toc-text">x86下R3-&gt;R0</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#int-2e"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">int 2e</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sysenter-sysreturn"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">sysenter &#x2F; sysreturn</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KiFastCallEntry%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">KiFastCallEntry函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GDT%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E8%A1%A8%EF%BC%88Global-Description-Table%EF%BC%89"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">GDT全局描述表（Global Description Table）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.1.1.5.</span> <span class="toc-text">段寄存器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#x86%E4%B8%8BR0-R3"><span class="toc-number">1.1.2.</span> <span class="toc-text">x86下R0-&gt;R3</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">对象管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.1.</span> <span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#OBJECT-HEADER"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">_OBJECT_HEADER</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OBJECT-TYPE"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">_OBJECT_TYPE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ObCreateObject-ObjectAttributes-size-ObjectType"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">ObCreateObject(ObjectAttributes,size,ObjectType)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">1.2.2.</span> <span class="toc-text">对象命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#OBJECT-DIRECTORY"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">OBJECT_DIRECTORY</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E8%A7%A3%E6%9E%90"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">路径解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OBJECT-DIRECTORY-ENTRY"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">_OBJECT_DIRECTORY_ENTRY</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%A5%E6%9F%84"><span class="toc-number">1.2.3.</span> <span class="toc-text">句柄</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#EXHANDLE"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">EXHANDLE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HANDLE-TABLE"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">HANDLE_TABLE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HANDLE-TABLE-ENTRY"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">HANDLE_TABLE_ENTRY</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%AA%E5%8F%A5%E6%9F%84-Pseudo-Handles"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">伪句柄 (Pseudo Handles)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%A5%E6%9F%84%E8%A1%A8"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">全局句柄表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E5%8F%A5%E6%9F%84%E8%A1%A8"><span class="toc-number">1.2.3.6.</span> <span class="toc-text">私有句柄表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">1.3.</span> <span class="toc-text">线程&#x2F;进程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.1.</span> <span class="toc-text">进程结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#EPROCESS-Executive-Process"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">EPROCESS (Executive Process)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KPROCESS-Kernel-Process"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">KPROCESS (Kernel Process)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PEB-Process-Environment-Block"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">PEB (Process Environment Block)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%9F%A5%E6%89%BE"><span class="toc-number">1.3.2.</span> <span class="toc-text">进程查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E8%BF%9B%E7%A8%8B%E9%93%BE%E8%A1%A8"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">遍历进程链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E8%BF%9B%E7%A8%8BID"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">枚举进程ID</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F"><span class="toc-number">1.3.3.</span> <span class="toc-text">进程隐藏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%8A%A4"><span class="toc-number">1.3.4.</span> <span class="toc-text">进程保护</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BreakOnTermination-Flags-bit13"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">BreakOnTermination (Flags bit13)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ProcessInserted-Flags-bit26"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">ProcessInserted (Flags bit26)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ProtectedProcess-Flags2-bit11"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">ProtectedProcess (Flags2 bit11)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.5.</span> <span class="toc-text">线程结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ETHREAD-Executive-Thread"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">ETHREAD(Executive Thread)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KTHREAD-Kernel-Thread"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">KTHREAD (Kernel Thread)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TEB-Thread-Environment-Block"><span class="toc-number">1.3.5.3.</span> <span class="toc-text">TEB (Thread Environment Block):</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="toc-number">1.3.6.</span> <span class="toc-text">线程切换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.4.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#x64%E9%A1%B5%E8%A1%A8%E8%87%AA%E6%98%A0%E5%B0%84"><span class="toc-number">1.4.1.</span> <span class="toc-text">x64页表自映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PFN-%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.4.2.</span> <span class="toc-text">PFN 数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MMPFN"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">MMPFN</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MMPFNENTRY1"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">MMPFNENTRY1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E9%A1%B5%E7%9A%84%E4%B8%B2%E8%81%94%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">空闲页的串联方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VAD"><span class="toc-number">1.4.3.</span> <span class="toc-text">VAD</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MMVAD-SHORT"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">MMVAD_SHORT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MMVAD-FLAGS"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">MMVAD_FLAGS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MMVAD"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">MMVAD</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8"><span class="toc-number">1.4.4.</span> <span class="toc-text">缺页异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%A0%E5%88%86%E9%85%8D%E5%99%A8"><span class="toc-number">1.4.5.</span> <span class="toc-text">池分配器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#POOL-HEADER"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">POOL_HEADER</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ExPoolState"><span class="toc-number">1.4.5.2.</span> <span class="toc-text">ExPoolState</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#EX-POOL-HEAP-MANAGER-STATE"><span class="toc-number">1.4.5.2.1.</span> <span class="toc-text">EX_POOL_HEAP_MANAGER_STATE</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#EX-HEAP-POOL-NODE"><span class="toc-number">1.4.5.2.2.</span> <span class="toc-text">EX_HEAP_POOL_NODE</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ExAllocatePool2%E7%AE%80%E5%8C%96%E6%B5%81%E7%A8%8B"><span class="toc-number">1.4.5.3.</span> <span class="toc-text">ExAllocatePool2简化流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%9B%9E%E8%B0%83"><span class="toc-number">1.5.</span> <span class="toc-text">内核回调</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%9F%A5%E5%9E%8B%E5%9B%9E%E8%B0%83%EF%BC%88Notify-Callbacks%EF%BC%89"><span class="toc-number">1.5.1.</span> <span class="toc-text">系统通知型回调（Notify Callbacks）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%9B%9E%E8%B0%83"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">进程回调</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">1.5.1.1.1.</span> <span class="toc-text">注册过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E8%BF%87%E7%A8%8B"><span class="toc-number">1.5.1.1.2.</span> <span class="toc-text">回调过程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="toc-number">1.5.1.1.2.1.</span> <span class="toc-text">进程创建</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.5.1.1.2.2.</span> <span class="toc-text">隐藏进程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.5.1.1.2.3.</span> <span class="toc-text">拦截进程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%AC%BA%E9%AA%97-Spoofing"><span class="toc-number">1.5.1.1.2.4.</span> <span class="toc-text">欺骗(Spoofing)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA"><span class="toc-number">1.5.1.1.2.5.</span> <span class="toc-text">进程退出</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%9B%9E%E8%B0%83"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">线程回调</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E8%BF%87%E7%A8%8B-1"><span class="toc-number">1.5.1.2.1.</span> <span class="toc-text">注册过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E8%BF%87%E7%A8%8B-1"><span class="toc-number">1.5.1.2.2.</span> <span class="toc-text">回调过程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%9B%9E%E8%B0%83"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">模块回调</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E8%BF%87%E7%A8%8B-2"><span class="toc-number">1.5.1.3.1.</span> <span class="toc-text">注册过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E8%BF%87%E7%A8%8B-2"><span class="toc-number">1.5.1.3.2.</span> <span class="toc-text">回调过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%9B%9E%E8%B0%83"><span class="toc-number">1.5.2.</span> <span class="toc-text">对象回调</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C-%E5%8D%B8%E8%BD%BD%E5%9B%9E%E8%B0%83"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">注册&#x2F;卸载回调</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#PreOperation"><span class="toc-number">1.5.2.1.1.</span> <span class="toc-text">PreOperation</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#PostOperation"><span class="toc-number">1.5.2.1.2.</span> <span class="toc-text">PostOperation</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">相关结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#OBJECT-TYPE-1"><span class="toc-number">1.5.2.2.1.</span> <span class="toc-text">OBJECT_TYPE</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#OBJECT-TYPE-INITIALIZER"><span class="toc-number">1.5.2.2.2.</span> <span class="toc-text">OBJECT_TYPE_INITIALIZER</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#OB-CALLBACK-HANDLE"><span class="toc-number">1.5.2.2.3.</span> <span class="toc-text">OB_CALLBACK_HANDLE</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E8%BF%87%E7%A8%8B-3"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">注册过程</span></a></li></ol></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/&text=windows系统调用/对象管理/进程调度/内存管理/内核回调"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/&title=windows系统调用/对象管理/进程调度/内存管理/内核回调"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/&is_video=false&description=windows系统调用/对象管理/进程调度/内存管理/内核回调"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=windows系统调用/对象管理/进程调度/内存管理/内核回调&body=Check out this article: https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/&title=windows系统调用/对象管理/进程调度/内存管理/内核回调"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/&title=windows系统调用/对象管理/进程调度/内存管理/内核回调"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/&title=windows系统调用/对象管理/进程调度/内存管理/内核回调"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/&title=windows系统调用/对象管理/进程调度/内存管理/内核回调"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/&name=windows系统调用/对象管理/进程调度/内存管理/内核回调&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/&t=windows系统调用/对象管理/进程调度/内存管理/内核回调"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2025-2026
    Exploooosion
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/categories/">Category</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/friends/">friends</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
