<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="windowsbasic knowledge系统调用syscallx86下R3-&gt;R0int 2eCPU获取 IDT 的基地址，计算目标描述符地址：IDT Base + (0x2e * 8) 进行特权级检查：CPL &lt;&#x3D; DPL  CPL (Current Privilege Level) ：当前代码段（CS）的特权级（Ring 3）。 DPL (Descriptor P">
<meta property="og:type" content="article">
<meta property="og:title" content="windows 学习（四）--Basic Knowledge">
<meta property="og:url" content="https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/index.html">
<meta property="og:site_name" content="wooo~ Exploooosion&#39;s blog">
<meta property="og:description" content="windowsbasic knowledge系统调用syscallx86下R3-&gt;R0int 2eCPU获取 IDT 的基地址，计算目标描述符地址：IDT Base + (0x2e * 8) 进行特权级检查：CPL &lt;&#x3D; DPL  CPL (Current Privilege Level) ：当前代码段（CS）的特权级（Ring 3）。 DPL (Descriptor P">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://exploo0osion.github.io/image/2025-12-30-learning_windows_4/1767091367705.png">
<meta property="og:image" content="https://exploo0osion.github.io/image/2025-12-30-learning_windows_4/1768644706020.png">
<meta property="og:image" content="https://exploo0osion.github.io/image/2025-12-30-learning_windows_4/1768829175440.png">
<meta property="og:image" content="https://exploo0osion.github.io/image/2025-12-30-learning_windows_4/1767171485680.png">
<meta property="og:image" content="https://exploo0osion.github.io/image/2025-12-30-learning_windows_4/1767171602190.png">
<meta property="article:published_time" content="2025-12-29T16:00:00.000Z">
<meta property="article:modified_time" content="2026-01-21T10:12:13.677Z">
<meta property="article:author" content="Exploooosion">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://exploo0osion.github.io/image/2025-12-30-learning_windows_4/1767091367705.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>windows 学习（四）--Basic Knowledge</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<meta name="generator" content="Hexo 8.1.1"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/categories/">Category</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/friends/">friends</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2025/12/31/2025-12-31-leaning_windows_5/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2025/12/12/2025-12-12-windows_dll_injection/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/&text=windows 学习（四）--Basic Knowledge"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/&title=windows 学习（四）--Basic Knowledge"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/&is_video=false&description=windows 学习（四）--Basic Knowledge"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=windows 学习（四）--Basic Knowledge&body=Check out this article: https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/&title=windows 学习（四）--Basic Knowledge"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/&title=windows 学习（四）--Basic Knowledge"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/&title=windows 学习（四）--Basic Knowledge"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/&title=windows 学习（四）--Basic Knowledge"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/&name=windows 学习（四）--Basic Knowledge&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/&t=windows 学习（四）--Basic Knowledge"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#windows"><span class="toc-number">1.</span> <span class="toc-text">windows</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#basic-knowledge"><span class="toc-number">1.1.</span> <span class="toc-text">basic knowledge</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8syscall"><span class="toc-number">1.1.1.</span> <span class="toc-text">系统调用syscall</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#x86%E4%B8%8BR3-R0"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">x86下R3-&gt;R0</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#int-2e"><span class="toc-number">1.1.1.1.1.</span> <span class="toc-text">int 2e</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sysenter-sysreturn"><span class="toc-number">1.1.1.1.2.</span> <span class="toc-text">sysenter &#x2F; sysreturn</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#KiFastCallEntry%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.1.1.3.</span> <span class="toc-text">KiFastCallEntry函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#GDT%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E8%A1%A8%EF%BC%88Global-Description-Table%EF%BC%89"><span class="toc-number">1.1.1.1.4.</span> <span class="toc-text">GDT全局描述表（Global Description Table）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.1.1.1.5.</span> <span class="toc-text">段寄存器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x86%E4%B8%8BR0-R3"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">x86下R0-&gt;R3</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86"><span class="toc-number">1.1.2.</span> <span class="toc-text">对象管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#OBJECT-HEADER"><span class="toc-number">1.1.2.1.1.</span> <span class="toc-text">_OBJECT_HEADER</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#OBJECT-TYPE"><span class="toc-number">1.1.2.1.2.</span> <span class="toc-text">_OBJECT_TYPE</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ObCreateObject-ObjectAttributes-size-ObjectType"><span class="toc-number">1.1.2.1.3.</span> <span class="toc-text">ObCreateObject(ObjectAttributes,size,ObjectType)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">对象命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#OBJECT-DIRECTORY"><span class="toc-number">1.1.2.2.1.</span> <span class="toc-text">OBJECT_DIRECTORY</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E8%A7%A3%E6%9E%90"><span class="toc-number">1.1.2.2.2.</span> <span class="toc-text">路径解析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#OBJECT-DIRECTORY-ENTRY"><span class="toc-number">1.1.2.2.3.</span> <span class="toc-text">_OBJECT_DIRECTORY_ENTRY</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%A5%E6%9F%84"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">句柄</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#EXHANDLE"><span class="toc-number">1.1.2.3.1.</span> <span class="toc-text">EXHANDLE</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HANDLE-TABLE"><span class="toc-number">1.1.2.3.2.</span> <span class="toc-text">HANDLE_TABLE</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HANDLE-TABLE-ENTRY"><span class="toc-number">1.1.2.3.3.</span> <span class="toc-text">HANDLE_TABLE_ENTRY</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%AA%E5%8F%A5%E6%9F%84-Pseudo-Handles"><span class="toc-number">1.1.2.3.4.</span> <span class="toc-text">伪句柄 (Pseudo Handles)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%A5%E6%9F%84%E8%A1%A8"><span class="toc-number">1.1.2.3.5.</span> <span class="toc-text">全局句柄表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E5%8F%A5%E6%9F%84%E8%A1%A8"><span class="toc-number">1.1.2.3.6.</span> <span class="toc-text">私有句柄表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">1.1.3.</span> <span class="toc-text">线程&#x2F;进程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">进程结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#EPROCESS-Executive-Process"><span class="toc-number">1.1.3.1.1.</span> <span class="toc-text">EPROCESS (Executive Process)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#KPROCESS-Kernel-Process"><span class="toc-number">1.1.3.1.2.</span> <span class="toc-text">KPROCESS (Kernel Process)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#PEB-Process-Environment-Block"><span class="toc-number">1.1.3.1.3.</span> <span class="toc-text">PEB (Process Environment Block)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%9F%A5%E6%89%BE"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">进程查找</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E8%BF%9B%E7%A8%8B%E9%93%BE%E8%A1%A8"><span class="toc-number">1.1.3.2.1.</span> <span class="toc-text">遍历进程链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E8%BF%9B%E7%A8%8BID"><span class="toc-number">1.1.3.2.2.</span> <span class="toc-text">枚举进程ID</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">进程隐藏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%8A%A4"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">进程保护</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#BreakOnTermination-Flags-bit13"><span class="toc-number">1.1.3.4.1.</span> <span class="toc-text">BreakOnTermination (Flags bit13)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ProcessInserted-Flags-bit26"><span class="toc-number">1.1.3.4.2.</span> <span class="toc-text">ProcessInserted (Flags bit26)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ProtectedProcess-Flags2-bit11"><span class="toc-number">1.1.3.4.3.</span> <span class="toc-text">ProtectedProcess (Flags2 bit11)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.3.5.</span> <span class="toc-text">线程结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ETHREAD-Executive-Thread"><span class="toc-number">1.1.3.5.1.</span> <span class="toc-text">ETHREAD(Executive Thread)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#KTHREAD-Kernel-Thread"><span class="toc-number">1.1.3.5.2.</span> <span class="toc-text">KTHREAD (Kernel Thread)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TEB-Thread-Environment-Block"><span class="toc-number">1.1.3.5.3.</span> <span class="toc-text">TEB (Thread Environment Block):</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="toc-number">1.1.3.6.</span> <span class="toc-text">线程切换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.1.4.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#x64%E9%A1%B5%E8%A1%A8%E8%87%AA%E6%98%A0%E5%B0%84"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">x64页表自映射</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%9B%9E%E8%B0%83"><span class="toc-number">1.1.5.</span> <span class="toc-text">内核回调</span></a></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        windows 学习（四）--Basic Knowledge
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">Exploooosion</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2025-12-29T16:00:00.000Z" class="dt-published" itemprop="datePublished">2025-12-30</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/windows/">windows</a>
    </div>


      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <span id="more"></span>

<h1 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h1><h2 id="basic-knowledge"><a href="#basic-knowledge" class="headerlink" title="basic knowledge"></a>basic knowledge</h2><h3 id="系统调用syscall"><a href="#系统调用syscall" class="headerlink" title="系统调用syscall"></a>系统调用syscall</h3><h4 id="x86下R3-R0"><a href="#x86下R3-R0" class="headerlink" title="x86下R3-&gt;R0"></a>x86下R3-&gt;R0</h4><h5 id="int-2e"><a href="#int-2e" class="headerlink" title="int 2e"></a>int 2e</h5><p>CPU获取 IDT 的基地址，计算目标描述符地址：<code>IDT Base + (0x2e * 8)</code></p>
<p>进行特权级检查：CPL &lt;&#x3D; DPL</p>
<ul>
<li>CPL (Current Privilege Level) ：当前代码段（CS）的特权级（Ring 3）。</li>
<li>DPL (Descriptor Privilege Level) ：IDT 描述符中规定的特权级（必须是 3，否则用户态无权调用）</li>
</ul>
<p>从 IDT 描述符中提取段选择子 Segment Selector 。CPU 使用该 Selector 去查询 GDT</p>
<p>用户线程栈切换成内核线程栈，保存上下文 (Push Context，会压入一些寄存器)，从IDT（Interrupt Descriptor Table）中寻找0x2e对应的异常处理函数（KiSystemService）进入内核代码空间</p>
<h5 id="sysenter-sysreturn"><a href="#sysenter-sysreturn" class="headerlink" title="sysenter &#x2F; sysreturn"></a>sysenter &#x2F; sysreturn</h5><p>sysenter指令执行时会跳转到MSR[176]指向的函数地址（该函数实际是KiFastCallEntry），CS、SS、EIP、ESP均来自MSR寄存器，因此速度上比int 2e块（不需要压参数、读内存）</p>
<p>CS &lt;&#x3D;&#x3D; <code>IA32_SYSENTER_CS</code> (MSR 0x174)。</p>
<p>EIP &lt;&#x3D;&#x3D; <code>IA32_SYSENTER_EIP</code> (MSR 0x176)。</p>
<p>ESP &lt;&#x3D;&#x3D; <code>IA32_SYSENTER_ESP</code> (MSR 0x175)。</p>
<h5 id="KiFastCallEntry函数"><a href="#KiFastCallEntry函数" class="headerlink" title="KiFastCallEntry函数"></a>KiFastCallEntry函数</h5><p> <code>push 30h</code> &#x2F; <code>pop fs</code> FS 寄存器从用户态的  TEB 切换到内核态的 KPCR</p>
<p>0x30的二进制 ：<code>0000 0000 0011 0000</code></p>
<p>x86 段选择子的结构：</p>
<ul>
<li>RPL (最后2位) : <code>00</code> -&gt; Ring 0 (特权级 0，即内核态)。</li>
<li>TI (第3位) : <code>0</code> -&gt; GDT (全局描述符表)。</li>
<li>Index (高13位) : <code>0000000000110</code> -&gt; 6 (十进制)。</li>
</ul>
<h5 id="GDT全局描述表（Global-Description-Table）"><a href="#GDT全局描述表（Global-Description-Table）" class="headerlink" title="GDT全局描述表（Global Description Table）"></a>GDT全局描述表（Global Description Table）</h5><p>在 x86 保护模式 (Protected Mode) 下，内存不再是直接通过物理地址访问，而是通过 “分段 (Segmentation)” 机制访问。</p>
<ol>
<li>不直接给地址 ：当程序执行 <code>mov eax, [0x12345678]</code> 时，CPU 并不是直接去物理内存的 <code>0x12345678</code> 拿数据。</li>
<li>段选择子 (Selector) ：CPU 会先看当前段寄存器（如 <code>DS</code>、<code>CS</code>、<code>SS</code>）里存的  “索引号” （即选择子）。</li>
<li>查表 (Lookup) ：CPU 根据这个索引号，去 GDT 表里找到对应的  “段描述符 (Descriptor)” 。</li>
<li>鉴权与定位 ：描述符里记录了这段内存的  基地址 (Base) 、大小 (Limit) 和  权限 (Access Rights) 。只有检查通过，CPU 才会把 基地址 + 偏移量 算出线性地址。</li>
</ol>
<table>
<thead>
<tr>
<th>索引 (Index)</th>
<th>选择子 (Selector)</th>
<th>名称</th>
<th>DPL (特权级)</th>
<th>用途与特征</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0x00</td>
<td>NULL</td>
<td>-</td>
<td>空描述符 。硬件规定，不可使用。</td>
</tr>
<tr>
<td>1</td>
<td>0x08</td>
<td>KGDT_R0_CODE</td>
<td>0 (内核)</td>
<td>内核代码段 。Base&#x3D;0, Limit&#x3D;4GB。内核执行代码时 CS&#x3D;0x08。</td>
</tr>
<tr>
<td>2</td>
<td>0x10</td>
<td>KGDT_R0_DATA</td>
<td>0 (内核)</td>
<td>内核数据段 。Base&#x3D;0, Limit&#x3D;4GB。内核读写数据时 DS&#x2F;ES&#x2F;SS&#x3D;0x10。</td>
</tr>
<tr>
<td>3</td>
<td>0x1B</td>
<td>KGDT_R3_CODE</td>
<td>3 (用户)</td>
<td>用户代码段 。Base&#x3D;0, Limit&#x3D;4GB。用户程序运行时 CS&#x3D;0x1B (0x18</td>
</tr>
<tr>
<td>4</td>
<td>0x23</td>
<td>KGDT_R3_DATA</td>
<td>3 (用户)</td>
<td>用户数据段 。Base&#x3D;0, Limit&#x3D;4GB。用户程序运行时 DS&#x2F;ES&#x2F;SS&#x3D;0x23 (0x20</td>
</tr>
<tr>
<td>5</td>
<td>0x28</td>
<td>KGDT_TSS</td>
<td>0 (内核)</td>
<td>TSS (任务状态段) 。用于保存硬件上下文和栈切换信息 (ESP0)。</td>
</tr>
<tr>
<td>6</td>
<td>0x30</td>
<td>KGDT_R0_PCR</td>
<td>0 (内核)</td>
<td>内核 KPCR 指针 。 这是唯一的非平坦段 。Base&#x3D;KPCR地址。内核通过 FS 访问 CPU 专属数据。</td>
</tr>
<tr>
<td>7</td>
<td>0x3B</td>
<td>KGDT_R3_TEB</td>
<td>3 (用户)</td>
<td>用户 TEB 指针 。Base&#x3D;当前线程TEB地址。用户通过 FS 访问线程局部存储。</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>(其他保留项，如 LDT, VDM 等)</td>
</tr>
</tbody></table>
<p>LDT：局部描述表（Local Description Table），与GDT功能一致，但不能单独存在，只能嵌套在GDT中。</p>
<h5 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h5><p>CS (Code Segment) —— 必须指向代码</p>
<p>CPU 的取指单元（Instruction Fetch Unit）永远只从 <code>CS:EIP</code>（或 <code>CS:RIP</code>）指向的地址读取指令。CS 寄存器的低 2 位（CPL）代表了当前 CPU 的特权级（Ring 0 - Ring 3）。CS 指向 Ring 0 代码段 (0x08) 或 Ring 3 代码段 (0x1B)。</p>
<p>SS (Stack Segment) —— 必须指向堆栈</p>
<p>所有的隐式堆栈操作（如 <code>push</code>, <code>pop</code>, <code>call</code>, <code>ret</code>, <code>enter</code>, <code>leave</code>）以及基于 <code>ESP</code>&#x2F;<code>EBP</code> 的内存访问，默认使用 SS 段。SS 指向内核栈段 (0x10) 或用户栈段 (0x23)。</p>
<p>DS (Data Segment) &amp; ES (Extra Segment)</p>
<p>DS 是数据访问的默认段（例如 <code>mov eax, [ebx]</code> 默认就是 <code>ds:[ebx]</code>）。ES 是字符串指令（如 <code>movs</code>, <code>stos</code>）的目标段默认值。</p>
<p>FS &amp; GS (F-Segment &#x2F; G-Segment)</p>
<table>
<thead>
<tr>
<th>架构</th>
<th>FS 寄存器用途</th>
<th>GS 寄存器用途</th>
<th>为什么不同？</th>
</tr>
</thead>
<tbody><tr>
<td>x86 (32位)</td>
<td>指向 TEB (R3) &#x2F; KPCR (R0)</td>
<td>未大量使用 (通常为0)</td>
<td>x86下 FS 选择子很早就被分配给了 TEB&#x2F;PCR。</td>
</tr>
<tr>
<td>x64 (64位)</td>
<td>(兼容性保留，指向 32位TEB)</td>
<td>指向 TEB (R3) &#x2F; KPCR (R0)</td>
<td>x64下 CPU 允许 <code>swapgs</code>快速切换 GS，所以主要用 GS。</td>
</tr>
</tbody></table>
<p>fs:[0]：在3环时，该处指向的是TEB结构，0环下指向_KPCR结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">KPCR</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">NT_TIB</span> <span class="title">NtTib</span>;</span>                                               <span class="comment">//0x0</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span>* <span class="title">Used_ExceptionList</span>;</span>      <span class="comment">//0x0</span></span><br><span class="line">            VOID* Used_StackBase;                                           <span class="comment">//0x4</span></span><br><span class="line">            VOID* Spare2;                                                   <span class="comment">//0x8</span></span><br><span class="line">            VOID* TssCopy;                                                  <span class="comment">//0xc</span></span><br><span class="line">            ULONG ContextSwitches;                                          <span class="comment">//0x10</span></span><br><span class="line">            ULONG SetMemberCopy;                                            <span class="comment">//0x14</span></span><br><span class="line">            VOID* Used_Self;                                                <span class="comment">//0x18</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KPCR</span>* <span class="title">SelfPcr</span>;</span>                                                  <span class="comment">//0x1c</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KPRCB</span>* <span class="title">Prcb</span>;</span>                                                    <span class="comment">//0x20</span></span><br><span class="line">    UCHAR Irql;                                                             <span class="comment">//0x24</span></span><br><span class="line">    ULONG IRR;                                                              <span class="comment">//0x28</span></span><br><span class="line">    ULONG IrrActive;                                                        <span class="comment">//0x2c</span></span><br><span class="line">    ULONG IDR;                                                              <span class="comment">//0x30</span></span><br><span class="line">    VOID* KdVersionBlock;                                                   <span class="comment">//0x34</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KIDTENTRY</span>* <span class="title">IDT</span>;</span>                                                 <span class="comment">//0x38</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KGDTENTRY</span>* <span class="title">GDT</span>;</span>                                                 <span class="comment">//0x3c</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KTSS</span>* <span class="title">TSS</span>;</span>                                                      <span class="comment">//0x40</span></span><br><span class="line">    USHORT MajorVersion;                                                    <span class="comment">//0x44</span></span><br><span class="line">    USHORT MinorVersion;                                                    <span class="comment">//0x46</span></span><br><span class="line">    ULONG SetMember;                                                        <span class="comment">//0x48</span></span><br><span class="line">    ULONG StallScaleFactor;                                                 <span class="comment">//0x4c</span></span><br><span class="line">    UCHAR SpareUnused;                                                      <span class="comment">//0x50</span></span><br><span class="line">    UCHAR Number;                                                           <span class="comment">//0x51</span></span><br><span class="line">    UCHAR Spare0;                                                           <span class="comment">//0x52</span></span><br><span class="line">    UCHAR SecondLevelCacheAssociativity;                                    <span class="comment">//0x53</span></span><br><span class="line">    ULONG VdmAlert;                                                         <span class="comment">//0x54</span></span><br><span class="line">    ULONG KernelReserved[<span class="number">14</span>];                                               <span class="comment">//0x58</span></span><br><span class="line">    ULONG SecondLevelCacheSize;                                             <span class="comment">//0x90</span></span><br><span class="line">    ULONG HalReserved[<span class="number">16</span>];                                                  <span class="comment">//0x94</span></span><br><span class="line">    ULONG InterruptMode;                                                    <span class="comment">//0xd4</span></span><br><span class="line">    UCHAR Spare1;                                                           <span class="comment">//0xd8</span></span><br><span class="line">    ULONG KernelReserved2[<span class="number">17</span>];                                              <span class="comment">//0xdc</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KPRCB</span> <span class="title">PrcbData</span>;</span>                                                 <span class="comment">//0x120</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p> <code>mov ecx, fs:_KPCR.TSS</code>：通过 FS (KPCR) 获取当前任务状态段 (TSS)。</p>
<p><code>mov esp, [ecx+_KTSS.Esp0]</code>：栈指针切换到该线程真正的内核栈顶</p>
<p>后续是根据 <code>KTrap_Frame</code>的结构构建完整 <code>Trap Frame</code> 与异常链表，需要注意的是用户态的 <code>esp</code>是通过 <code>push edx</code>来压入的，因为 <code>sysenter</code>被封装成了 <code>KiFastSystemCall</code>函数，会先进行 <code>mov edx,esp;</code>然后再 <code>sysenter</code>，eip则是 <code>_KUSER_SHARED_DATA</code>中的 <code>SystemCallReturn</code> 地址</p>
<p><code>mov ebx, large fs:KPCR.SelfPcr</code>：获取 PCR 指针，<code>push dword ptr [ebx]</code>：保存当前的异常处理链表头 (<code>PCR.ExceptionList</code>) 到栈</p>
<p>最后保存到_KTHREAD.TrapFrame中</p>
<p>KTrap_Frame：栈帧，用来保存R3切换到R0的环境</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x8c bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">KTRAP_FRAME</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ULONG DbgEbp;                                                           <span class="comment">//0x0</span></span><br><span class="line">    ULONG DbgEip;                                                           <span class="comment">//0x4</span></span><br><span class="line">    ULONG DbgArgMark;                                                       <span class="comment">//0x8</span></span><br><span class="line">    ULONG DbgArgPointer;                                                    <span class="comment">//0xc</span></span><br><span class="line">    USHORT TempSegCs;                                                       <span class="comment">//0x10</span></span><br><span class="line">    UCHAR Logging;                                                          <span class="comment">//0x12</span></span><br><span class="line">    UCHAR Reserved;                                                         <span class="comment">//0x13</span></span><br><span class="line">    ULONG TempEsp;                                                          <span class="comment">//0x14</span></span><br><span class="line">    ULONG Dr0;                                                              <span class="comment">//0x18</span></span><br><span class="line">    ULONG Dr1;                                                              <span class="comment">//0x1c</span></span><br><span class="line">    ULONG Dr2;                                                              <span class="comment">//0x20</span></span><br><span class="line">    ULONG Dr3;                                                              <span class="comment">//0x24</span></span><br><span class="line">    ULONG Dr6;                                                              <span class="comment">//0x28</span></span><br><span class="line">    ULONG Dr7;                                                              <span class="comment">//0x2c</span></span><br><span class="line">    ULONG SegGs;                                                            <span class="comment">//0x30</span></span><br><span class="line">    ULONG SegEs;                                                            <span class="comment">//0x34</span></span><br><span class="line">    ULONG SegDs;                                                            <span class="comment">//0x38</span></span><br><span class="line">    ULONG Edx;                                                              <span class="comment">//0x3c</span></span><br><span class="line">    ULONG Ecx;                                                              <span class="comment">//0x40</span></span><br><span class="line">    ULONG Eax;                                                              <span class="comment">//0x44</span></span><br><span class="line">    ULONG PreviousPreviousMode;                                             <span class="comment">//0x48-----R0用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span>* <span class="title">ExceptionList</span>;</span>                   <span class="comment">//0x4c</span></span><br><span class="line">    ULONG SegFs;                                                            <span class="comment">//0x50</span></span><br><span class="line">    ULONG Edi;                                                              <span class="comment">//0x54</span></span><br><span class="line">    ULONG Esi;                                                              <span class="comment">//0x58</span></span><br><span class="line">    ULONG Ebx;                                                              <span class="comment">//0x5c</span></span><br><span class="line">    ULONG Ebp;                                                              <span class="comment">//0x60</span></span><br><span class="line">    ULONG ErrCode;                                                          <span class="comment">//0x64</span></span><br><span class="line">    ULONG Eip;                                                              <span class="comment">//0x68</span></span><br><span class="line">    ULONG SegCs;                                                            <span class="comment">//0x6c </span></span><br><span class="line">    ULONG EFlags;                                                           <span class="comment">//0x70-----R3用</span></span><br><span class="line">    ULONG HardwareEsp;                                                      <span class="comment">//0x74 </span></span><br><span class="line">    ULONG HardwareSegSs;                                                    <span class="comment">//0x78</span></span><br><span class="line">    ULONG V86Es;                                                            <span class="comment">//0x7c	虚拟8086模式下，保护模式下不用</span></span><br><span class="line">    ULONG V86Ds;                                                            <span class="comment">//0x80</span></span><br><span class="line">    ULONG V86Fs;                                                            <span class="comment">//0x84</span></span><br><span class="line">    ULONG V86Gs;                                                            <span class="comment">//0x88</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>确定系统服务表（SSDT vs Shadow SSDT）</p>
<p><code>mov edi, eax</code> &#x2F; <code>shr edi, 8</code> &#x2F; <code>and edi, 10h</code></p>
<p>Windows 系统调用号第 12 位（bit 12）用于区分表。</p>
<ul>
<li>如果 ID &lt; 0x1000，<code>edi</code> 结果为 0 -&gt; 使用 KeServiceDescriptorTable (核心内核函数)。</li>
<li>如果 ID &gt;&#x3D; 0x1000 (如 0x1xxx)，<code>edi</code> 结果为 0x10 -&gt; 使用 KeServiceDescriptorTableShadow (win32k.sys 图形&#x2F;窗口函数)。</li>
</ul>
<p><code>add edi, [esi+_KTHREAD.ServiceTable]</code> _KTHREAD中有服务表的基址，现在edi指向了正确的 Service Descriptor Table 结构体</p>
<p>获取 SSDT 参数表 (Argument Table) 的基址，获取 SSDT 函数地址表 (Service Table) 的基址。</p>
<p>从参数表中读取该系统调用需要的参数字节数 ，从函数表中读取目标内核函数地址 —-计算公式：表基址 + (调用号 * 4)。</p>
<p>通过 <code>rep movsd</code>从用户态堆栈完整拷贝到内核态堆栈（此时ECX–参数个数；ESI–由EDX赋予，EDX在sysenter前就指向old esp；   EDI–内核栈地址），最后 <code>call ebx</code>调用内核函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KSERVICE_TABLKSERVICE_TABLE_DESCRIPTORE_DESCRIPTOR</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PULONG_PTR FuncPoint;	<span class="comment">//指向函数表</span></span><br><span class="line">    PULONG Count;			<span class="comment">//调用的次数</span></span><br><span class="line">    PULONG Limit;			<span class="comment">//函数个数</span></span><br><span class="line">    PUCHAR ArgsPoint;		<span class="comment">//参数列表</span></span><br><span class="line">&#125;KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUMBER_SERVICE_TABLES 2</span></span><br><span class="line"> </span><br><span class="line">KSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTable[NUMBER_SERVICE_TABLES]</span><br><span class="line">KSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTableShadow[NUMBER_SERVICE_TABLES]</span><br></pre></td></tr></table></figure>

<p><img src="/image/2025-12-30-learning_windows_4/1767091367705.png" alt="1767091367705"></p>
<p>x64下 <code>syscall</code>似乎和x86下的 <code>sysenter</code>差不多，跳转的内核函数是 <code>KiSystemCall64</code></p>
<h4 id="x86下R0-R3"><a href="#x86下R0-R3" class="headerlink" title="x86下R0-&gt;R3"></a>x86下R0-&gt;R3</h4><p>处理APC：代码读取 <code>KPCR-&gt;CurrentThread</code> (<code>fs:124h</code>)</p>
<p>检查 <code>Thread-&gt;ApcState.UserApcPending</code>，如果有用户态的 APC（比如某些 I&#x2F;O 完成回调、线程挂起请求）， 需要先处理掉（APC注入的发生点）<code>call _KiDeliverApc</code>直到所有挂起的 APC都执行完毕。</p>
<p>恢复异常链表及调试寄存器（如果为调试模式的话）：从 TrapFrame 中取出用户态的 <code>ExceptionList</code>，写回 <code>fs:[0]</code> (KPCR的第一个成员指向TEB )，</p>
<p>检查 <code>TrapFrame-&gt;Dr7</code>。如果用户态程序下了硬件断点（Hardware Breakpoint），这里需要恢复调试寄存器 <code>DR0</code>-<code>DR7</code>。</p>
<p>恢复通用寄存器与栈调整，将ESP移动到TrapFrame-&gt;SegFs，<code>pop fs</code>恢复3环FS，再移动esp恢复各个通用寄存器，执行iret返回用户态自动从栈上弹出 EIP, CS, EFLAGS, ESP, SS</p>
<h3 id="对象管理"><a href="#对象管理" class="headerlink" title="对象管理"></a>对象管理</h3><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>内存模型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[ Optional Headers (Name, Creator, etc.) ]</span><br><span class="line">[ _OBJECT_HEADER ]  &lt;--- 核心元数据 (引用计数, TypeIndex 等)</span><br><span class="line">[ Object Body ]     &lt;--- 外部指针指向这里 (e.g., _EPROCESS, _FILE_OBJECT等)</span><br><span class="line"></span><br><span class="line">|---------------------------|</span><br><span class="line">| POOL_HEADER               |  内存池头部</span><br><span class="line">|---------------------------|</span><br><span class="line">| OBJECT_HEADER_NAME_INFO   |  名字信息 (可选)</span><br><span class="line">|---------------------------|</span><br><span class="line">| OBJECT_HEADER_HANDLE_INFO |  句柄信息 (可选)</span><br><span class="line">|---------------------------|</span><br><span class="line">| OBJECT_HEADER_QUOTA_INFO  |  配额信息 (可选)</span><br><span class="line">|---------------------------|</span><br><span class="line">| OBJECT_HEADER             |  内核对象统一头部 (必定存在)</span><br><span class="line">|---------------------------|</span><br><span class="line">| OBJECT_BODY               |  对象体结构 (如 DRIVER_OBJECT)</span><br><span class="line">|---------------------------|</span><br></pre></td></tr></table></figure>

<p>附加信息头是可选的，它包括了以下信息头的一个或多个</p>
<table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>结构</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td>创建信息头</td>
<td>OBJECT_HEADER_CREATOR_INFO</td>
<td>包含创建者信息，用来将创建的对象挂入其创建者的对象队列</td>
</tr>
<tr>
<td>命名信息头</td>
<td>OBJECT_HEADER_NAME_INFO</td>
<td>载有对象名和目录节点的指针</td>
</tr>
<tr>
<td>句柄信息头</td>
<td>OBJECT_HEADER_HANDLE_INFO</td>
<td>关于句柄的信息</td>
</tr>
<tr>
<td>配额信息头</td>
<td>OBJECT_HEADER_QUOTA_INFO</td>
<td>关于耗用内存配额的信息</td>
</tr>
</tbody></table>
<h5 id="OBJECT-HEADER"><a href="#OBJECT-HEADER" class="headerlink" title="_OBJECT_HEADER"></a>_OBJECT_HEADER</h5><p>x64 Win10 下通常为 0x30</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">6: kd&gt; dt nt!_OBJECT_HEADER</span><br><span class="line">   +0x000 PointerCount     : Int8B         //指针引用计数,当内核组件通过指针引用对象时增加,当降为0时,对象内存被释放。初始化为 1</span><br><span class="line">   +0x008 HandleCount      : Int8B         //句柄引用计数,用户模式或内核模式打开的Handle数量。</span><br><span class="line">   +0x008 NextToFree       : Ptr64 Void</span><br><span class="line">   +0x010 Lock             : _EX_PUSH_LOCK</span><br><span class="line">   +0x018 TypeIndex        : UChar         //索引，用于在全局类型数组中找到该对象的_OBJECT_TYPE。</span><br><span class="line">   +0x019 TraceFlags       : UChar </span><br><span class="line">   +0x019 DbgRefTrace      : Pos 0, 1 Bit</span><br><span class="line">   +0x019 DbgTracePermanent : Pos 1, 1 Bit</span><br><span class="line">   +0x01a InfoMask         : UChar         //标记是否有 Name/Handle/Quota 这三种可选头</span><br><span class="line">   +0x01b Flags            : UChar</span><br><span class="line">   +0x01b NewObject        : Pos 0, 1 Bit</span><br><span class="line">   +0x01b KernelObject     : Pos 1, 1 Bit</span><br><span class="line">   +0x01b KernelOnlyAccess : Pos 2, 1 Bit</span><br><span class="line">   +0x01b ExclusiveObject  : Pos 3, 1 Bit</span><br><span class="line">   +0x01b PermanentObject  : Pos 4, 1 Bit</span><br><span class="line">   +0x01b DefaultSecurityQuota : Pos 5, 1 Bit</span><br><span class="line">   +0x01b SingleHandleEntry : Pos 6, 1 Bit</span><br><span class="line">   +0x01b DeletedInline    : Pos 7, 1 Bit</span><br><span class="line">   +0x01c Reserved         : Uint4B</span><br><span class="line">   +0x020 ObjectCreateInfo : Ptr64 _OBJECT_CREATE_INFORMATION</span><br><span class="line">   +0x020 QuotaBlockCharged : Ptr64 Void</span><br><span class="line">   +0x028 SecurityDescriptor : Ptr64 Void</span><br><span class="line">   +0x030 Body             : _QUAD</span><br></pre></td></tr></table></figure>

<h5 id="OBJECT-TYPE"><a href="#OBJECT-TYPE" class="headerlink" title="_OBJECT_TYPE"></a>_OBJECT_TYPE</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">6: kd&gt; dt nt!_OBJECT_TYPE</span><br><span class="line">   +0x000 TypeList         : _LIST_ENTRY   </span><br><span class="line">   +0x010 Name             : _UNICODE_STRING</span><br><span class="line">   +0x020 DefaultObject    : Ptr64 Void</span><br><span class="line">   +0x028 Index            : UChar</span><br><span class="line">   +0x02c TotalNumberOfObjects : Uint4B   //当前该类型对象的总数</span><br><span class="line">   +0x030 TotalNumberOfHandles : Uint4B   //该类型所有对象的句柄总数</span><br><span class="line">   +0x034 HighWaterNumberOfObjects : Uint4B</span><br><span class="line">   +0x038 HighWaterNumberOfHandles : Uint4B</span><br><span class="line">   +0x040 TypeInfo         : _OBJECT_TYPE_INITIALIZER  //函数指针</span><br><span class="line">   +0x0b8 TypeLock         : _EX_PUSH_LOCK</span><br><span class="line">   +0x0c0 Key              : Uint4B</span><br><span class="line">   +0x0c8 CallbackList     : _LIST_ENTRY</span><br></pre></td></tr></table></figure>

<h5 id="ObCreateObject-ObjectAttributes-size-ObjectType"><a href="#ObCreateObject-ObjectAttributes-size-ObjectType" class="headerlink" title="ObCreateObject(ObjectAttributes,size,ObjectType)"></a>ObCreateObject(ObjectAttributes,size,ObjectType)</h5><ol>
<li>Capture (捕获) : 解析 <code>ObjectAttributes</code>，提取名字、安全描述符，暂存到 <code>OBJECT_CREATE_INFORMATION</code> 结构（通常利用 Lookaside List 优化，不直接分配堆）。</li>
<li>Calculate (计算) :<code>TotalSize = BodySize + sizeof(FixedHeader) + sizeof(OptionalHeaders) + Padding</code>。</li>
<li>Allocate (分配) :调用 <code>ExAllocatePoolWithTag</code>。<ul>
<li>Tag : 取自 <code>ObjectType-&gt;Key</code>。</li>
<li>Ptr : 拿到堆块首地址 <code>pChunk</code>。</li>
</ul>
</li>
<li>Format (格式化) :<ul>
<li>根据计算好的偏移，定位到 <code>FixedHeader</code> 的位置。</li>
<li>填充 <code>FixedHeader</code> (写入 <code>InfoMask</code>, <code>TypeIndex</code>)。</li>
<li>如果存在 Optional Headers，将名字、配额指针填入 Header 前面的内存区域。</li>
</ul>
</li>
<li>Return (返回) :<br>返回指向 Body 的指针。</li>
</ol>
<p>假设创建了一个带名字、带安全描述符的 Event 对象。最终内存里长这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[ 内存低地址 ]</span><br><span class="line">|</span><br><span class="line">|   &lt;--- ExAllocatePoolWithTag 返回的起始地址 (pChunk)</span><br><span class="line">|</span><br><span class="line">+-------------------------------------------------------+</span><br><span class="line">| Optional Header: _OBJECT_HEADER_QUOTA_INFO            | </span><br><span class="line">| (存在是因为带了SD需要计费)                              |</span><br><span class="line">+-------------------------------------------------------+</span><br><span class="line">| Optional Header: _OBJECT_HEADER_NAME_INFO             |</span><br><span class="line">| .Name      -&gt; 指向分页池中存放 &quot;MyEvent&quot; 字符串的地址     |</span><br><span class="line">| .Directory -&gt; 指向 &quot;\BaseNamedObjects&quot; 目录对象的指针    |</span><br><span class="line">+-------------------------------------------------------+</span><br><span class="line">| padding (对齐填充)                                     |</span><br><span class="line">+-------------------------------------------------------+</span><br><span class="line">| Fixed Header: _OBJECT_HEADER                          | &lt;--- 通过 Body - 0x30 访问</span><br><span class="line">| .PointerCount = 1                                     |</span><br><span class="line">| .InfoMask     = 0x0A (0x08 Quota | 0x02 Name)         |</span><br><span class="line">| .TypeIndex    = EventTypeIndex                        |</span><br><span class="line">| .SecurityDescriptor -&gt; 指向安全描述符的指针              |</span><br><span class="line">+-------------------------------------------------------+</span><br><span class="line">| Object Body: _KEVENT                                  | </span><br><span class="line">| .Header (Dispatcher Header)                           |</span><br><span class="line">| .SignalState                                          |</span><br><span class="line">| ...                                                   |</span><br><span class="line">+-------------------------------------------------------+</span><br><span class="line">|</span><br><span class="line">[ 内存高地址 ]</span><br></pre></td></tr></table></figure>

<h4 id="对象命名空间"><a href="#对象命名空间" class="headerlink" title="对象命名空间"></a>对象命名空间</h4><p>Object Manager 命名空间是 Windows 内核中统一管理一切内核对象的“对象目录树”，本质上是一个分层的哈希表结构。</p>
<h5 id="OBJECT-DIRECTORY"><a href="#OBJECT-DIRECTORY" class="headerlink" title="OBJECT_DIRECTORY"></a>OBJECT_DIRECTORY</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; dt nt!_OBJECT_DIRECTORY</span><br><span class="line">   +0x000 HashBuckets      : [37] Ptr64 _OBJECT_DIRECTORY_ENTRY  //指针数组,每个指向一个 _OBJECT_DIRECTORY_ENTRY 链表</span><br><span class="line">   +0x128 Lock             : _EX_PUSH_LOCK</span><br><span class="line">   +0x130 DeviceMap        : Ptr64 _DEVICE_MAP</span><br><span class="line">   +0x138 ShadowDirectory  : Ptr64 _OBJECT_DIRECTORY</span><br><span class="line">   +0x140 NamespaceEntry   : Ptr64 Void</span><br><span class="line">   +0x148 SessionObject    : Ptr64 Void</span><br><span class="line">   +0x150 Flags            : Uint4B</span><br><span class="line">   +0x154 SessionId        : Uint4B</span><br></pre></td></tr></table></figure>

<p>每一个“目录对象”（Directory Object），在内核中对应的结构体是 <code>_OBJECT_DIRECTORY</code>。</p>
<p>整个 Object Manager 命名空间以 <strong><code>\</code></strong> 为根目录，形成一棵类似文件系统的目录树。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">\                                （根目录，DirectoryObject）</span><br><span class="line">├── Driver                       所有驱动对象 (DriverObject)</span><br><span class="line">│     └── MyDriver</span><br><span class="line">│</span><br><span class="line">├── Device                       所有设备对象 (DeviceObject)</span><br><span class="line">│     └── Harddisk0</span><br><span class="line">│     └── Serial0</span><br><span class="line">│</span><br><span class="line">├── ??                           ★ 符号链接桥梁目录 (SymbolicLinkObject)</span><br><span class="line">│     ├── C:         → \Device\HarddiskVolume1</span><br><span class="line">│     ├── COM1       → \Device\Serial0</span><br><span class="line">│     └── MyLink     → \Device\MyDevice</span><br><span class="line">│</span><br><span class="line">├── BaseNamedObjects             ★ 用户会话 0 命名空间（全局同步对象）</span><br><span class="line">│     └── MyEvent</span><br><span class="line">│     └── MyMutex</span><br><span class="line">│</span><br><span class="line">├── Sessions                     ★ 多用户会话隔离目录</span><br><span class="line">│     └── 1</span><br><span class="line">│         └── BaseNamedObjects   （Session 1 的私有命名空间）</span><br><span class="line">│</span><br><span class="line">├── ObjectTypes                  ★ 已注册的内核对象类型列表</span><br><span class="line">├── Windows (部分版本存在)</span><br><span class="line">└── 其它系统内部目录</span><br></pre></td></tr></table></figure>

<p>其对应的物理形态（物理上它是哈希链表的嵌套）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[\ (Root)] -&gt; HashBuckets[...]</span><br><span class="line">      |</span><br><span class="line">      +--&gt; &quot;Driver&quot; (Directory Object)</span><br><span class="line">      |       |</span><br><span class="line">      |       +--&gt; HashBuckets[...] -&gt; &quot;MyDriver&quot; (Driver Object)</span><br><span class="line">      |</span><br><span class="line">      +--&gt; &quot;Device&quot; (Directory Object)</span><br><span class="line">              |</span><br><span class="line">              +--&gt; HashBuckets[...] -&gt; &quot;Harddisk0&quot; (Device Object)</span><br></pre></td></tr></table></figure>

<p>其中每一类目录的具体作用如下：</p>
<table>
<thead>
<tr>
<th>目录名</th>
<th>作用</th>
<th>常见对象类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>\Driver</code></td>
<td>存放所有已注册的内核驱动对象</td>
<td><code>DriverObject</code></td>
</tr>
<tr>
<td><code>\Device</code></td>
<td>存放所有设备对象，供 I&#x2F;O 管理器使用</td>
<td><code>DeviceObject</code></td>
</tr>
<tr>
<td><code>\??</code></td>
<td>符号链接目录：Win32 路径与内核对象桥接</td>
<td><code>SymbolicLinkObject</code></td>
</tr>
<tr>
<td><code>\BaseNamedObjects</code></td>
<td>全局同步对象命名区（Session 0 共享）</td>
<td><code>Event</code> &#x2F; <code>Mutex</code> &#x2F; <code>Semaphore</code></td>
</tr>
<tr>
<td><code>\Sessions\N\BaseNamedObjects</code></td>
<td>多用户会话隔离命名空间</td>
<td>各自的同步对象</td>
</tr>
<tr>
<td><code>\ObjectTypes</code></td>
<td>存放系统内置的对象类型定义表</td>
<td><code>ObjectTypeObject</code></td>
</tr>
<tr>
<td><code>\Callback</code></td>
<td>存放回调对象，用于内核模块间的通信。</td>
<td></td>
</tr>
<tr>
<td><code>\KnownDlls</code></td>
<td>存放系统已知 DLL 的 Section 对象（内存映射），加速 DLL 加载</td>
<td></td>
</tr>
</tbody></table>
<p>其中 <code>\??</code> 目录（全名为 <code>DosDevices Directory</code>）是 Object Manager 里专门用来桥接 <strong>Win32 路径系统 ↔ 内核命名空间</strong> 的目录。它里面挂载的都是 <strong>符号链接对象（SymbolicLinkObject）</strong>，用于：</p>
<ul>
<li>盘符映射 (<code>C:</code> → <code>\Device\HarddiskVolumeX</code>)</li>
<li>传统设备名 (<code>COM1</code> → <code>\Device\Serial0</code>)</li>
<li>自定义设备别名（通过 <code>IoCreateSymbolicLink()</code> 创建）</li>
</ul>
<p>影子机制：解决多用户登录的符号链接问题</p>
<p>当Session 0 (系统服务) 访问 <code>\??</code> 时，它直接指向 <code>\Global??</code></p>
<p>当Session 1 (普通用户) 访问 <code>\??</code> 时，它指向 <code>\Sessions\1\DosDevices</code>，该目录下有隐藏属性 <code>DeviceMap</code>，指向 <code>\Global??</code>，当查找不到时会从影子目录中查找</p>
<h5 id="路径解析"><a href="#路径解析" class="headerlink" title="路径解析"></a>路径解析</h5><table>
<thead>
<tr>
<th>路径类型</th>
<th>格式示例</th>
<th>谁在使用</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>1. Win32 文件路径</td>
<td><code>C:\Windows\Test.sys</code></td>
<td>用户态程序 (Explorer, Notepad)</td>
<td>包含盘符。内核不认识盘符 。</td>
</tr>
<tr>
<td>2. Win32 设备路径</td>
<td><code>\\.\COM1</code></td>
<td>用户态程序 (串口助手, 磁盘工具)</td>
<td>以 <code>\\.\</code>开头，用于访问非文件的设备。</td>
</tr>
<tr>
<td>3. NT 路径 (原生路径)</td>
<td><code>\Device\HarddiskVolume1\Windows</code></td>
<td>内核、驱动程序</td>
<td>绝对路径 。没有盘符，只有设备对象名。</td>
</tr>
<tr>
<td>4. 对象管理路径</td>
<td><code>\??\C:\Windows</code></td>
<td>Object Manager (Ob)</td>
<td>Win32 路径转换后的中间形态。</td>
</tr>
</tbody></table>
<p>文件示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CreateFile(&quot;C:\\Windows\\System32\\drivers\\Test.sys&quot;)</span><br><span class="line">      │</span><br><span class="line">      └─► Win32 → NT 转换</span><br><span class="line">              \??\C:\Windows\System32\drivers\Test.sys</span><br><span class="line">                   │</span><br><span class="line">                   └─► \??\C: (符号链接)</span><br><span class="line">                           ↓</span><br><span class="line">                          \Device\HarddiskVolume1</span><br><span class="line">                                │</span><br><span class="line">                                └─► 完整 NT 路径</span><br><span class="line">                                    \Device\HarddiskVolume1\Windows\System32\drivers\Test.sys</span><br></pre></td></tr></table></figure>

<p>设备示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CreateFile(&quot;\\\\.\\COM1&quot;)</span><br><span class="line">      │</span><br><span class="line">      └─► \??\COM1   (Win32 设备路径)</span><br><span class="line">             │</span><br><span class="line">             └─► 符号链接解析</span><br><span class="line">                  \Device\Serial0   ← 真实设备对象</span><br></pre></td></tr></table></figure>

<h5 id="OBJECT-DIRECTORY-ENTRY"><a href="#OBJECT-DIRECTORY-ENTRY" class="headerlink" title="_OBJECT_DIRECTORY_ENTRY"></a>_OBJECT_DIRECTORY_ENTRY</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; dt _OBJECT_DIRECTORY_ENTRY</span><br><span class="line">nt!_OBJECT_DIRECTORY_ENTRY</span><br><span class="line">   +0x000 ChainLink        : Ptr64 _OBJECT_DIRECTORY_ENTRY</span><br><span class="line">   +0x008 Object           : Ptr64 Void</span><br><span class="line">   +0x010 HashValue        : Uint4B</span><br></pre></td></tr></table></figure>

<p><img src="/image/2025-12-30-learning_windows_4/1768644706020.png" alt="1768644706020"></p>
<p>ObInsertObject会分配一个 <code>_OBJECT_DIRECTORY_ENTRY</code> 小结构，并让 <code>Entry-&gt;Object = NewObject</code>，将 Entry 挂入计算出的哈希桶（将对象名转大写并计算 Hash % 37）链表头部。</p>
<p>查找对象</p>
<h4 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h4><p>句柄 (Handle) 是 Windows 内核分配给用户态程序的一个”凭证”或 “索引”。它是一个32位的整数（即使在64位系统上，高32位通常也为 0，以便兼容 WOW64）。</p>
<p>用户态无法直接访问内核内存地址（Object Pointer），只能持有句柄。内核通过句柄在句柄表中查找，最终定位到真正的内核对象（如 <code>EPROCESS</code>, <code>KTHREAD</code>, <code>KEVENT</code> 等）。</p>
<h5 id="EXHANDLE"><a href="#EXHANDLE" class="headerlink" title="EXHANDLE"></a>EXHANDLE</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; dt _EXHANDLE</span><br><span class="line">nt!_EXHANDLE</span><br><span class="line">   +0x000 TagBits          : Pos 0, 2 Bits  //用户程序可使用的标签位，这两位对系统无意义，用户可用作句柄类型区分、调试标记等；</span><br><span class="line">   +0x000 Index            : Pos 2, 30 Bits //句柄索引字段，实际句柄值 / 4 即为该索引（因为句柄步长为 4）；</span><br><span class="line">   +0x000 GenericHandleOverlay : Ptr64 Void</span><br><span class="line">   +0x000 Value            : Uint8B</span><br></pre></td></tr></table></figure>

<ul>
<li>进程 ID 和线程 ID 本质上是全局句柄表(<code>PspCidTable</code>)的索引</li>
</ul>
<h5 id="HANDLE-TABLE"><a href="#HANDLE-TABLE" class="headerlink" title="HANDLE_TABLE"></a>HANDLE_TABLE</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; dt _HANDLE_TABLE</span><br><span class="line">nt!_HANDLE_TABLE</span><br><span class="line">   +0x000 NextHandleNeedingPool : Uint4B</span><br><span class="line">   +0x004 ExtraInfoPages   : Int4B</span><br><span class="line">   +0x008 TableCode        : Uint8B</span><br><span class="line">   +0x010 QuotaProcess     : Ptr64 _EPROCESS //所属进程的 EPROCESS 指针</span><br><span class="line">   +0x018 HandleTableList  : _LIST_ENTRY     //所有句柄表的全局链表</span><br><span class="line">   +0x028 UniqueProcessId  : Uint4B          //拥有该句柄表的进程 ID（PID）</span><br><span class="line">   +0x02c Flags            : Uint4B</span><br><span class="line">   +0x02c StrictFIFO       : Pos 0, 1 Bit</span><br><span class="line">   +0x02c EnableHandleExceptions : Pos 1, 1 Bit</span><br><span class="line">   +0x02c Rundown          : Pos 2, 1 Bit</span><br><span class="line">   +0x02c Duplicated       : Pos 3, 1 Bit</span><br><span class="line">   +0x02c RaiseUMExceptionOnInvalidHandleClose : Pos 4, 1 Bit</span><br><span class="line">   +0x030 HandleContentionEvent : _EX_PUSH_LOCK</span><br><span class="line">   +0x038 HandleTableLock  : _EX_PUSH_LOCK</span><br><span class="line">   +0x040 FreeLists        : [1] _HANDLE_TABLE_FREE_LIST</span><br><span class="line">   +0x040 ActualEntry      : [32] UChar</span><br><span class="line">   +0x060 DebugInfo        : Ptr64 _HANDLE_TRACE_DEBUG_INFO</span><br></pre></td></tr></table></figure>

<p>Windows 采用了类似内存分页的多级索引结构</p>
<p><code>TableCode</code> 是查找的入口，它编码了<strong>层级</strong>和<strong>地址</strong>：</p>
<p>低 2 位 (Level) :</p>
<ul>
<li><code>0</code>:  L0 (直接表) 。<code>TableCode</code> 指向直接的 <code>_HANDLE_TABLE_ENTRY</code> 数组。</li>
<li><code>1</code>:  L1 (两级表) 。<code>TableCode</code> 指向一个指针数组，每个指针指向一个 L0 表。</li>
<li><code>2</code>:  L2 (三级表) 。指向指针的指针。</li>
</ul>
<p>高位 (Address) : 清除低 2 位后，即为物理层级表的基址。</p>
<p>以 x64 为例（每页 4KB）：</p>
<ul>
<li>1 页存句柄项(存放实际的 <code>HANDLE_TABLE_ENTRY</code> 数组,256个指针项)。</li>
<li>1 页 L0页(512 个指针项，每个8字节)-&gt;句柄项。</li>
<li>1 页L1页 -&gt; 1 页 L0页-&gt;句柄项</li>
</ul>
<p><img src="/image/2025-12-30-learning_windows_4/1768829175440.png" alt="1768829175440"></p>
<h5 id="HANDLE-TABLE-ENTRY"><a href="#HANDLE-TABLE-ENTRY" class="headerlink" title="HANDLE_TABLE_ENTRY"></a>HANDLE_TABLE_ENTRY</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; dt nt!_HANDLE_TABLE_ENTRY</span><br><span class="line">   +0x000 Unlocked         : Pos 0, 1 Bit     //锁</span><br><span class="line">   +0x000 RefCnt           : Pos 1, 16 Bits   //句柄引用计数</span><br><span class="line">   +0x000 Attributes       : Pos 17, 3 Bits   //句柄属性(继承、保护)</span><br><span class="line">   +0x000 ObjectPointerBits : Pos 20, 44 Bits //对象指针</span><br><span class="line">   +0x008 GrantedAccessBits : Pos 0, 25 Bits  //打开句柄时获得的权限</span><br><span class="line">   +0x008 NoRightsUpgrade  : Pos 25, 1 Bit</span><br><span class="line">   +0x008 Spare1           : Pos 26, 6 Bits</span><br><span class="line">   +0x00c Spare2           : Uint4B</span><br></pre></td></tr></table></figure>

<p><code>Object</code>：指向实际内核对象的指针。</p>
<ul>
<li>全局句柄表 ，该指针指向进程或线程对象 。</li>
<li>私有句柄表 ，该指针指向内核对象的 <code>OBJECT_HEADER</code></li>
</ul>
<h5 id="伪句柄-Pseudo-Handles"><a href="#伪句柄-Pseudo-Handles" class="headerlink" title="伪句柄 (Pseudo Handles)"></a>伪句柄 (Pseudo Handles)</h5><p>这些值是硬编码的常量，不在句柄表中分配，直接由内核函数（如 <code>ObReferenceObjectByHandle</code>）特殊处理。</p>
<ul>
<li>-1 (CurrentProcess) : 指向当前进程自身。</li>
<li>-2 (CurrentThread) : 指向当前线程自身。</li>
<li>-3 (CurrentDebugObject) : 当前进程的调试端口。</li>
<li>-4 (CurrentDirectory) : 当前目录句柄。</li>
</ul>
<h5 id="全局句柄表"><a href="#全局句柄表" class="headerlink" title="全局句柄表"></a>全局句柄表</h5><p>全局句柄表 <code>PspCidTable</code> 是一个 <code>HANDLE_TABLE</code> 类型的全局指针，指向一个句柄表管理结构。这个表中存储着所有进程和线程对象。</p>
<p>表项中的 <code>Object</code> 字段直接指向对象体 (Body) （即 <code>EPROCESS</code> 或 <code>ETHREAD</code> 的起始地址），而不是指向 <code>OBJECT_HEADER</code></p>
<p>表项的 <code>GrantedAccess</code> 通常为 <code>0</code>，因为 PID&#x2F;TID 仅用于标识，不承载访问权限（权限检查在打开这些 ID 获取真正句柄时进行）。</p>
<h5 id="私有句柄表"><a href="#私有句柄表" class="headerlink" title="私有句柄表"></a>私有句柄表</h5><p>每个进程都有私有句柄表 (<code>EPROCESS-&gt;ObjectTable</code>)。</p>
<p>对象指针 ：表项指向对象的  OBJECT_HEADER （而非 Body）</p>
<h3 id="线程-进程调度"><a href="#线程-进程调度" class="headerlink" title="线程&#x2F;进程调度"></a>线程&#x2F;进程调度</h3><h4 id="进程结构"><a href="#进程结构" class="headerlink" title="进程结构"></a>进程结构</h4><h5 id="EPROCESS-Executive-Process"><a href="#EPROCESS-Executive-Process" class="headerlink" title="EPROCESS (Executive Process)"></a>EPROCESS (Executive Process)</h5><p>进程管理的最高层结构，管理进程生命周期、对象句柄、内存空间等。</p>
<p>包含: 资源配额、句柄表、令牌（Token）、调试端口等。</p>
<p>关键成员**:**</p>
<ul>
<li><code>ActiveProcessLinks</code>: 双向链表，连接所有活动进程。这是任务管理器枚举进程的依据。</li>
<li><code>UniqueProcessId</code>: 进程 ID (PID) 。</li>
<li><code>Token</code>: 访问令牌，决定进程权限。</li>
<li><code>ImageFileName</code>: 进程名（如 <code>notepad.exe</code>）。</li>
<li><code>Peb</code>: 指向用户模式 PEB 的指针 。</li>
<li><code>ObjectTable</code>: 当前进程的句柄表</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">EPROCESS</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KPROCESS</span> <span class="title">Pcb</span>;</span>                         <span class="comment">// 0x00: 📌进程调度器相关信息（KPROCESS，前面已详细注释）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EX_PUSH_LOCK</span> <span class="title">ProcessLock</span>;</span>             <span class="comment">// 0x98: 进程结构体自旋锁（用于多核同步）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">CreateTime</span>;</span>              <span class="comment">// 0xA0: 进程创建时间</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">ExitTime</span>;</span>                <span class="comment">// 0xA8: 进程退出时间（如果还在运行则为 0）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EX_RUNDOWN_REF</span> <span class="title">RundownProtect</span>;</span>        <span class="comment">// 0xB0: 清理保护机制（防止进程在使用中被删除）</span></span><br><span class="line">    VOID* UniqueProcessId;                        <span class="comment">// 0xB4: 📌当前进程的唯一 PID（HANDLE 类型）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ActiveProcessLinks</span>;</span>        <span class="comment">// 0xB8: 📌所有活动进程的双向链表</span></span><br><span class="line">    ULONG ProcessQuotaUsage[<span class="number">2</span>];                   <span class="comment">// 0xC0: 当前使用的分页池和非分页池配额</span></span><br><span class="line">    ULONG ProcessQuotaPeak[<span class="number">2</span>];                    <span class="comment">// 0xC8: 使用分页池和非分页池配额的历史峰值</span></span><br><span class="line">    <span class="keyword">volatile</span> ULONG CommitCharge;                  <span class="comment">// 0xD0: 当前已提交虚拟内存（以页为单位）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EPROCESS_QUOTA_BLOCK</span>* <span class="title">QuotaBlock</span>;</span>     <span class="comment">// 0xD4: 引用进程所属的配额块</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">PS_CPU_QUOTA_BLOCK</span>* <span class="title">CpuQuotaBlock</span>;</span>    <span class="comment">// 0xD8: CPU 使用配额控制结构</span></span><br><span class="line">    ULONG PeakVirtualSize;                        <span class="comment">// 0xDC: 虚拟内存使用峰值</span></span><br><span class="line">    ULONG VirtualSize;                            <span class="comment">// 0xE0: 当前虚拟内存使用量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">SessionProcessLinks</span>;</span>       <span class="comment">// 0xE4: 当前进程所属 session 的进程链表</span></span><br><span class="line">    VOID* DebugPort;                              <span class="comment">// 0xEC: 📌调试器端口（被调试时非 NULL）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        VOID* ExceptionPortData;                  <span class="comment">// 0xF0: 异常端口数据（调试器使用）</span></span><br><span class="line">        ULONG ExceptionPortValue;</span><br><span class="line">        ULONG ExceptionPortState:<span class="number">3</span>;               <span class="comment">// 异常端口状态位</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">HANDLE_TABLE</span>* <span class="title">ObjectTable</span>;</span>            <span class="comment">// 0xF4: 📌当前进程句柄表（用于对象管理）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EX_FAST_REF</span> <span class="title">Token</span>;</span>                    <span class="comment">// 0xF8: 📌进程访问令牌（权限、安全上下文）</span></span><br><span class="line">    ULONG WorkingSetPage;                         <span class="comment">// 0xFC: 工作集起始页（即最小驻留页数）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EX_PUSH_LOCK</span> <span class="title">AddressCreationLock</span>;</span>     <span class="comment">// 0x100: 地址空间创建时使用的锁</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ETHREAD</span>* <span class="title">RotateInProgress</span>;</span>            <span class="comment">// 0x104: 正在切换线程（调度使用）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ETHREAD</span>* <span class="title">ForkInProgress</span>;</span>              <span class="comment">// 0x108: 正在进行 fork 操作的线程</span></span><br><span class="line">    ULONG HardwareTrigger;                        <span class="comment">// 0x10C: 硬件相关标志，可能由调试或诊断工具触发</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">MM_AVL_TABLE</span>* <span class="title">PhysicalVadRoot</span>;</span>        <span class="comment">// 0x110: VAD AVL 树根指针（描述虚拟内存分布）</span></span><br><span class="line">    VOID* CloneRoot;                              <span class="comment">// 0x114: 克隆 VAD 树根（用于进程克隆）</span></span><br><span class="line">    <span class="keyword">volatile</span> ULONG NumberOfPrivatePages;          <span class="comment">// 0x118: 分配给进程的私有页数</span></span><br><span class="line">    <span class="keyword">volatile</span> ULONG NumberOfLockedPages;           <span class="comment">// 0x11C: 被锁定（不可换出）的页数</span></span><br><span class="line">    VOID* Win32Process;                           <span class="comment">// 0x120: 指向 Win32 子系统使用的进程结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EJOB</span>* <span class="title">volatile</span> <span class="title">Job</span>;</span>                   <span class="comment">// 0x124: 所属作业对象（Job 对象）</span></span><br><span class="line">    VOID* SectionObject;                          <span class="comment">// 0x128: 映像节对象（表示映像在内存中的映射）</span></span><br><span class="line">    VOID* SectionBaseAddress;                     <span class="comment">// 0x12C: 映像加载的基址（即 EXE 的加载地址）</span></span><br><span class="line">    ULONG Cookie;                                 <span class="comment">// 0x130: 安全 cookie（用于防护堆栈溢出等）</span></span><br><span class="line">    ULONG Spare8;                                 <span class="comment">// 0x134: 保留字段</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">PAGEFAULT_HISTORY</span>* <span class="title">WorkingSetWatch</span>;</span>   <span class="comment">// 0x138: 页面错误历史记录（用于诊断内存访问）</span></span><br><span class="line">    VOID* Win32WindowStation;                     <span class="comment">// 0x13C: 进程关联的窗口站</span></span><br><span class="line">    VOID* InheritedFromUniqueProcessId;           <span class="comment">// 0x140: 父进程 PID（如果有）</span></span><br><span class="line">    VOID* LdtInformation;                         <span class="comment">// 0x144: 本地描述符表（LDT）信息（32位支持）</span></span><br><span class="line">    VOID* VdmObjects;                             <span class="comment">// 0x148: 虚拟 DOS 支持结构体（V86 模式）</span></span><br><span class="line">    ULONG ConsoleHostProcess;                     <span class="comment">// 0x14C: 控制台宿主进程 PID（仅控制台进程使用）</span></span><br><span class="line">    VOID* DeviceMap;                              <span class="comment">// 0x150: 设备映射信息（如 \\Device\\HarddiskX）</span></span><br><span class="line">    VOID* EtwDataSource;                          <span class="comment">// 0x154: ETW 跟踪数据源指针</span></span><br><span class="line">    VOID* FreeTebHint;                            <span class="comment">// 0x158: 用于优化 TEB 分配的 hint 指针</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">HARDWARE_PTE</span> <span class="title">PageDirectoryPte</span>;</span>    <span class="comment">// 0x160: 页目录表条目（硬件 PTE 格式）</span></span><br><span class="line">        ULONGLONG Filler;</span><br><span class="line">    &#125;;</span><br><span class="line">    VOID* Session;                                <span class="comment">// 0x168: 当前进程所属的 session 对象</span></span><br><span class="line">    UCHAR ImageFileName[<span class="number">15</span>];                      <span class="comment">// 0x16C: 📌可执行文件名称（不带路径）</span></span><br><span class="line">    UCHAR PriorityClass;                          <span class="comment">// 0x17B: 优先级类别（与线程优先级相关）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">JobLinks</span>;</span>                  <span class="comment">// 0x17C: Job 对象下进程的链表节点</span></span><br><span class="line">    VOID* LockedPagesList;                        <span class="comment">// 0x184: 锁定页链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ThreadListHead</span>;</span>            <span class="comment">// 0x188: 当前进程线程链表头</span></span><br><span class="line">    VOID* SecurityPort;                           <span class="comment">// 0x190: 安全通信端口（IPC）</span></span><br><span class="line">    VOID* PaeTop;                                 <span class="comment">// 0x194: PAE 页表顶端指针（仅在 PAE 模式使用）</span></span><br><span class="line">    <span class="keyword">volatile</span> ULONG ActiveThreads;                 <span class="comment">// 0x198: 当前活跃线程数量</span></span><br><span class="line">    ULONG ImagePathHash;                          <span class="comment">// 0x19C: 映像路径哈希值（用于快速查找）</span></span><br><span class="line">    ULONG DefaultHardErrorProcessing;             <span class="comment">// 0x1A0: 错误处理策略（如是否弹框）</span></span><br><span class="line">    LONG LastThreadExitStatus;                    <span class="comment">// 0x1A4: 最后一个线程的退出码</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">PEB</span>* <span class="title">Peb</span>;</span>                             <span class="comment">// 0x1A8: 📌指向用户态的 PEB 结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EX_FAST_REF</span> <span class="title">PrefetchTrace</span>;</span>            <span class="comment">// 0x1AC: 预取跟踪结构</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">ReadOperationCount</span>;</span>      <span class="comment">// 0x1B0: 读操作次数</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">WriteOperationCount</span>;</span>     <span class="comment">// 0x1B8: 写操作次数</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">OtherOperationCount</span>;</span>     <span class="comment">// 0x1C0: 其他操作次数</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">ReadTransferCount</span>;</span>       <span class="comment">// 0x1C8: 读取字节数总和</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">WriteTransferCount</span>;</span>      <span class="comment">// 0x1D0: 写入字节数总和</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">OtherTransferCount</span>;</span>      <span class="comment">// 0x1D8: 其他传输字节数</span></span><br><span class="line">    ULONG CommitChargeLimit;                      <span class="comment">// 0x1E0: 提交内存配额上限</span></span><br><span class="line">    <span class="keyword">volatile</span> ULONG CommitChargePeak;              <span class="comment">// 0x1E4: 提交内存配额峰值</span></span><br><span class="line">    VOID* AweInfo;                                <span class="comment">// 0x1E8: Address Windowing Extensions 支持</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">SE_AUDIT_PROCESS_CREATION_INFO</span> <span class="title">SeAuditProcessCreationInfo</span>;</span> <span class="comment">// 0x1EC: 📌审计信息，指向映像路径（可能包含命令行、EXE 路径）的结构体，供审计系统使用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">MMSUPPORT</span> <span class="title">Vm</span>;</span>                         <span class="comment">// 0x1F0: 进程的内存管理器支持结构（MMSUPPORT）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">MmProcessLinks</span>;</span>            <span class="comment">// 0x25C: 用于分页内存管理的进程链表</span></span><br><span class="line">    VOID* HighestUserAddress;                     <span class="comment">// 0x264: 用户态可访问的最高地址</span></span><br><span class="line">    ULONG ModifiedPageCount;                      <span class="comment">// 0x268: 被修改的页面计数</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ULONG Flags2;                             <span class="comment">// 0x26C: 与调度、NUMA、安全、资源管理有关的扩展状态标志</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            ULONG JobNotReallyActive:<span class="number">1</span>;         <span class="comment">// bit 0: 进程关联的 Job 对象当前未被视为活跃状态</span></span><br><span class="line">            ULONG AccountingFolded:<span class="number">1</span>;           <span class="comment">// bit 1: 资源使用计数合并入 Job，不独立统计进程自身</span></span><br><span class="line">            ULONG NewProcessReported:<span class="number">1</span>;         <span class="comment">// bit 2: 进程创建事件已上报（防止重复报告）</span></span><br><span class="line">            ULONG ExitProcessReported:<span class="number">1</span>;        <span class="comment">// bit 3: 进程退出事件已上报</span></span><br><span class="line">            ULONG ReportCommitChanges:<span class="number">1</span>;        <span class="comment">// bit 4: 提交内存变化需要通知资源跟踪</span></span><br><span class="line">            ULONG LastReportMemory:<span class="number">1</span>;           <span class="comment">// bit 5: 记录上次内存报告（用于比较/优化）</span></span><br><span class="line">            ULONG ReportPhysicalPageChanges:<span class="number">1</span>;  <span class="comment">// bit 6: 页面物理位置变化需上报（诊断用途）</span></span><br><span class="line">            ULONG HandleTableRundown:<span class="number">1</span>;         <span class="comment">// bit 7: 句柄表正在清理中</span></span><br><span class="line">            ULONG NeedsHandleRundown:<span class="number">1</span>;         <span class="comment">// bit 8: 需要清理句柄表</span></span><br><span class="line">            ULONG RefTraceEnabled:<span class="number">1</span>;            <span class="comment">// bit 9: 启用引用计数跟踪</span></span><br><span class="line">            ULONG NumaAware:<span class="number">1</span>;                  <span class="comment">// bit10: 该进程为 NUMA 感知进程</span></span><br><span class="line">            ULONG ProtectedProcess:<span class="number">1</span>;           <span class="comment">// bit11: 📌受保护进程（如 lsass，不可注入/调试）</span></span><br><span class="line">            ULONG DefaultPagePriority:<span class="number">3</span>;        <span class="comment">// bit12–14: 默认页面优先级（用于分页决策）</span></span><br><span class="line">            ULONG PrimaryTokenFrozen:<span class="number">1</span>;         <span class="comment">// bit15: 主令牌被冻结（不可替换）</span></span><br><span class="line">            ULONG ProcessVerifierTarget:<span class="number">1</span>;      <span class="comment">// bit16: 启用进程验证器跟踪</span></span><br><span class="line">            ULONG StackRandomizationDisabled:<span class="number">1</span>; <span class="comment">// bit17: 禁用堆栈地址随机化（如调试中）</span></span><br><span class="line">            ULONG AffinityPermanent:<span class="number">1</span>;          <span class="comment">// bit18: 永久绑定 CPU 亲和性</span></span><br><span class="line">            ULONG AffinityUpdateEnable:<span class="number">1</span>;       <span class="comment">// bit19: 允许动态更新亲和性</span></span><br><span class="line">            ULONG PropagateNode:<span class="number">1</span>;              <span class="comment">// bit20: 跨 NUMA 节点传播数据</span></span><br><span class="line">            ULONG ExplicitAffinity:<span class="number">1</span>;           <span class="comment">// bit21: 已显式设置亲和性</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ULONG Flags;                              <span class="comment">// 0x270: 控制进程生命周期、内存行为、调试行为等的主状态标志</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            ULONG CreateReported:<span class="number">1</span>;           <span class="comment">// bit 0: 已报告进程创建事件（如 ETW）</span></span><br><span class="line">            ULONG NoDebugInherit:<span class="number">1</span>;           <span class="comment">// bit 1: 禁止继承调试器（子进程隔离）</span></span><br><span class="line">            ULONG ProcessExiting:<span class="number">1</span>;           <span class="comment">// bit 2: 进程正在退出（终止流程中）</span></span><br><span class="line">            ULONG ProcessDelete:<span class="number">1</span>;            <span class="comment">// bit 3: 进程对象标记为删除</span></span><br><span class="line">            ULONG Wow64SplitPages:<span class="number">1</span>;          <span class="comment">// bit 4: 启用分页拆分机制（32位兼容性）</span></span><br><span class="line">            ULONG VmDeleted:<span class="number">1</span>;                <span class="comment">// bit 5: 虚拟内存空间已销毁</span></span><br><span class="line">            ULONG OutswapEnabled:<span class="number">1</span>;           <span class="comment">// bit 6: 允许被换出内存（Outswap）</span></span><br><span class="line">            ULONG Outswapped:<span class="number">1</span>;               <span class="comment">// bit 7: 已被换出内存</span></span><br><span class="line">            ULONG ForkFailed:<span class="number">1</span>;               <span class="comment">// bit 8: Fork 操作失败</span></span><br><span class="line">            ULONG Wow64VaSpace4Gb:<span class="number">1</span>;          <span class="comment">// bit 9: 启用 Wow64 的完整 4GB 虚拟地址空间</span></span><br><span class="line">            ULONG AddressSpaceInitialized:<span class="number">2</span>;  <span class="comment">// bit10–11: 地址空间初始化状态（0=未初始化，1=中，2=完成）</span></span><br><span class="line">            ULONG SetTimerResolution:<span class="number">1</span>;       <span class="comment">// bit12: 请求高分辨率定时器</span></span><br><span class="line">            ULONG BreakOnTermination:<span class="number">1</span>;       <span class="comment">// bit13: 📌终止进程时触发调试器中断</span></span><br><span class="line">            ULONG DeprioritizeViews:<span class="number">1</span>;        <span class="comment">// bit14: 降低视图优先级</span></span><br><span class="line">            ULONG WriteWatch:<span class="number">1</span>;               <span class="comment">// bit15: 启用写入监控页机制</span></span><br><span class="line">            ULONG ProcessInSession:<span class="number">1</span>;         <span class="comment">// bit16: 进程属于用户会话</span></span><br><span class="line">            ULONG OverrideAddressSpace:<span class="number">1</span>;     <span class="comment">// bit17: 允许覆盖地址空间</span></span><br><span class="line">            ULONG HasAddressSpace:<span class="number">1</span>;          <span class="comment">// bit18: 地址空间已分配</span></span><br><span class="line">            ULONG LaunchPrefetched:<span class="number">1</span>;         <span class="comment">// bit19: 由预取器发起的进程</span></span><br><span class="line">            ULONG InjectInpageErrors:<span class="number">1</span>;       <span class="comment">// bit20: 启用页错误注入</span></span><br><span class="line">            ULONG VmTopDown:<span class="number">1</span>;                <span class="comment">// bit21: 自顶向下分配地址空间</span></span><br><span class="line">            ULONG ImageNotifyDone:<span class="number">1</span>;          <span class="comment">// bit22: 映像加载通知已完成</span></span><br><span class="line">            ULONG PdeUpdateNeeded:<span class="number">1</span>;          <span class="comment">// bit23: 需要更新页目录项</span></span><br><span class="line">            ULONG VdmAllowed:<span class="number">1</span>;               <span class="comment">// bit24: 允许 V86 模式执行（虚拟 8086）</span></span><br><span class="line">            ULONG CrossSessionCreate:<span class="number">1</span>;       <span class="comment">// bit25: 允许跨会话创建</span></span><br><span class="line">            ULONG ProcessInserted:<span class="number">1</span>;          <span class="comment">// bit26: 📌进程已插入系统链表</span></span><br><span class="line">            ULONG DefaultIoPriority:<span class="number">3</span>;        <span class="comment">// bit27–29: 默认 I/O 优先级（0=低优先，3=普通）</span></span><br><span class="line">            ULONG ProcessSelfDelete:<span class="number">1</span>;        <span class="comment">// bit30: 允许进程自删除（常用于恶意进程清理）</span></span><br><span class="line">            ULONG SetTimerResolutionLink:<span class="number">1</span>;   <span class="comment">// bit31: 关联定时器精度链表</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    LONG ExitStatus;                              <span class="comment">// 0x274: 📌进程的退出码，259（0x103）是 Windows 的“还在运行”的默认占位退出码，可以借此判断进程是否退出</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">MM_AVL_TABLE</span> <span class="title">VadRoot</span>;</span>                 <span class="comment">// 0x278: 📌VAD 树（内存分配记录 AVL 树）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ALPC_PROCESS_CONTEXT</span> <span class="title">AlpcContext</span>;</span>     <span class="comment">// 0x298: ALPC 本地进程通信上下文</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">TimerResolutionLink</span>;</span>       <span class="comment">// 0x2A8: 定时器精度链接节点</span></span><br><span class="line">    ULONG RequestedTimerResolution;               <span class="comment">// 0x2B0: 请求的定时器精度</span></span><br><span class="line">    ULONG ActiveThreadsHighWatermark;             <span class="comment">// 0x2B4: 活跃线程历史最高值</span></span><br><span class="line">    ULONG SmallestTimerResolution;                <span class="comment">// 0x2B8: 系统允许的最小定时器分辨率</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">PO_DIAG_STACK_RECORD</span>* <span class="title">TimerResolutionStackRecord</span>;</span> <span class="comment">// 0x2BC: 用于记录调用栈等定时器信息</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="KPROCESS-Kernel-Process"><a href="#KPROCESS-Kernel-Process" class="headerlink" title="KPROCESS (Kernel Process)"></a>KPROCESS (Kernel Process)</h5><p>EPROCESS 的第一个成员，专用于内核调度，仅描述 CPU 调度相关属性 。</p>
<p>关键成员:</p>
<ul>
<li><code>DirectoryTableBase</code>:  CR3 寄存器值，即页目录基址。切换进程本质就是切换这个值来改变虚拟地址空间。</li>
<li><code>ThreadListHead</code>: 该进程下所有线程的链表头。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0x98 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">KPROCESS</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DISPATCHER_HEADER</span> <span class="title">Header</span>;</span>             <span class="comment">// 0x00: 内核对象头，支持调度器的等待/信号机制（继承自调度器对象）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ProfileListHead</span>;</span>           <span class="comment">// 0x10: 性能分析器使用的链表，用于跟踪采样信息</span></span><br><span class="line">    ULONG DirectoryTableBase;                     <span class="comment">// 0x18: 📌页目录基址（CR3），用于进程虚拟地址空间的转换</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KGDTENTRY</span> <span class="title">LdtDescriptor</span>;</span>              <span class="comment">// 0x1C: 进程的 LDT（本地描述符表）描述符（32位兼容）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KIDTENTRY</span> <span class="title">Int21Descriptor</span>;</span>            <span class="comment">// 0x24: 兼容 INT 21H（DOS 中断）的描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ThreadListHead</span>;</span>            <span class="comment">// 0x2C: 📌本进程包含的所有线程链表头（每个 ETHREAD 挂在上面）</span></span><br><span class="line">    ULONG ProcessLock;                            <span class="comment">// 0x34: 内部同步锁，用于进程结构保护</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KAFFINITY_EX</span> <span class="title">Affinity</span>;</span>                <span class="comment">// 0x38: 允许在哪些处理器组（NUMA node）上运行的亲和性掩码</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ReadyListHead</span>;</span>             <span class="comment">// 0x44: 当前进程就绪线程列表（调度器使用）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">SINGLE_LIST_ENTRY</span> <span class="title">SwapListEntry</span>;</span>      <span class="comment">// 0x4C: 换出链表，用于支持进程的虚拟内存分页</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KAFFINITY_EX</span> <span class="title">ActiveProcessors</span>;</span><span class="comment">// 0x50: 当前活跃运行该进程线程的处理器掩码</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="keyword">volatile</span> LONG AutoAlignment:<span class="number">1</span>;        <span class="comment">// 0x5C.0: 自动对齐模式（用于捕获未对齐访问）</span></span><br><span class="line">            <span class="keyword">volatile</span> LONG DisableBoost:<span class="number">1</span>;         <span class="comment">// 0x5C.1: 禁用线程优先级提升（防止因等待而提升优先级）</span></span><br><span class="line">            <span class="keyword">volatile</span> LONG DisableQuantum:<span class="number">1</span>;       <span class="comment">// 0x5C.2: 禁用时间片限制（不被抢占）</span></span><br><span class="line">            <span class="keyword">volatile</span> ULONG ActiveGroupsMask:<span class="number">1</span>;    <span class="comment">// 0x5C.3: 活跃处理器组标志</span></span><br><span class="line">            <span class="keyword">volatile</span> LONG ReservedFlags:<span class="number">28</span>;       <span class="comment">// 0x5C.4~31: 保留</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">volatile</span> LONG ProcessFlags;               <span class="comment">// 0x5C: 原始标志位表示，整体视图</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    CHAR BasePriority;                            <span class="comment">// 0x60: 初始线程优先级（线程继承此值）</span></span><br><span class="line">    CHAR QuantumReset;                            <span class="comment">// 0x61: 时间片重置值（用于线程运行时刷新）</span></span><br><span class="line">    UCHAR Visited;                                <span class="comment">// 0x62: NUMA 节点访问标志（内部使用）</span></span><br><span class="line">    UCHAR Unused3;                                <span class="comment">// 0x63: 保留</span></span><br><span class="line"></span><br><span class="line">    ULONG ThreadSeed[<span class="number">1</span>];                          <span class="comment">// 0x64: 用于线程亲和性随机调度的种子</span></span><br><span class="line">    USHORT IdealNode[<span class="number">1</span>];                          <span class="comment">// 0x68: 线程理想的 NUMA 节点</span></span><br><span class="line">    USHORT IdealGlobalNode;                       <span class="comment">// 0x6A: 全局理想节点编号</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">KEXECUTE_OPTIONS</span> <span class="title">Flags</span>;</span>                <span class="comment">// 0x6C: 执行选项（禁止动态代码等安全配置）</span></span><br><span class="line">    UCHAR Unused1;                                <span class="comment">// 0x6D: 保留</span></span><br><span class="line">    USHORT IopmOffset;                            <span class="comment">// 0x6E: IO 权限位图偏移（用于 Virtual 8086 模式 I/O 控制）</span></span><br><span class="line"></span><br><span class="line">    ULONG Unused4;                                <span class="comment">// 0x70: 保留</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">KSTACK_COUNT</span> <span class="title">StackCount</span>;</span>               <span class="comment">// 0x74: 栈引用计数（线程栈使用情况）</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ProcessListEntry</span>;</span>          <span class="comment">// 0x78: 调度器用的进程链表项（可能链接所有活跃进程）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> ULONGLONG CycleTime;                 <span class="comment">// 0x80: 此进程被调度的 CPU 时间（时钟周期）</span></span><br><span class="line">    ULONG KernelTime;                             <span class="comment">// 0x88: 内核模式运行时间（单位：100ns）</span></span><br><span class="line">    ULONG UserTime;                               <span class="comment">// 0x8C: 用户模式运行时间（单位：100ns）</span></span><br><span class="line"></span><br><span class="line">    VOID* VdmTrapcHandler;                        <span class="comment">// 0x90: 虚拟 DOS 兼容处理程序（V86 模式支持）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="PEB-Process-Environment-Block"><a href="#PEB-Process-Environment-Block" class="headerlink" title="PEB (Process Environment Block)"></a>PEB (Process Environment Block)</h5><p>位于用户模式，存储进程的全局信息，描述当前进程的用户态环境，如模块、堆、TLS、参数等。</p>
<p>关键成员:<code>ImageBaseAddress</code> (基址), <code>Ldr</code> (模块加载链表), <code>ProcessParameters</code> (命令行参数) 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">PEB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    UCHAR InheritedAddressSpace;            <span class="comment">// 0x00: 是否继承地址空间（fork 子进程时为 TRUE）</span></span><br><span class="line">    UCHAR ReadImageFileExecOptions;         <span class="comment">// 0x01: 是否读取镜像执行选项（调试器等兼容选项）</span></span><br><span class="line">    UCHAR BeingDebugged;                    <span class="comment">// 0x02: 当前进程是否正在被调试（由调试器设置）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        UCHAR BitField;                     <span class="comment">// 0x03: 标志位集合</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            UCHAR ImageUsesLargePages:<span class="number">1</span>;            <span class="comment">// bit 0: 镜像是否使用大页内存</span></span><br><span class="line">            UCHAR IsProtectedProcess:<span class="number">1</span>;             <span class="comment">// bit 1: 是否为受保护进程（如 lsass）</span></span><br><span class="line">            UCHAR IsLegacyProcess:<span class="number">1</span>;                <span class="comment">// bit 2: 是否为传统进程（兼容旧系统）</span></span><br><span class="line">            UCHAR IsImageDynamicallyRelocated:<span class="number">1</span>;    <span class="comment">// bit 3: 是否启用了 ASLR（地址随机化）</span></span><br><span class="line">            UCHAR SkipPatchingUser32Forwarders:<span class="number">1</span>;   <span class="comment">// bit 4: 是否跳过 User32.dll 的 API 前向导出修补</span></span><br><span class="line">            UCHAR SpareBits:<span class="number">3</span>;                      <span class="comment">// bit 5-7: 保留位</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    VOID* Mutant;                          <span class="comment">// 0x04: 用于同步的互斥体句柄（防止并发创建）</span></span><br><span class="line">    VOID* ImageBaseAddress;               <span class="comment">// 0x08: 主模块（EXE）加载基地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">PEB_LDR_DATA</span>* <span class="title">Ldr</span>;</span>            <span class="comment">// 0x0C: 指向模块加载器（LDR）数据结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_USER_PROCESS_PARAMETERS</span>* <span class="title">ProcessParameters</span>;</span> <span class="comment">// 0x10: 进程参数，如命令行、环境变量等</span></span><br><span class="line">    VOID* SubSystemData;                  <span class="comment">// 0x14: 子系统专用数据（如 POSIX 子系统）</span></span><br><span class="line">    VOID* ProcessHeap;                    <span class="comment">// 0x18: 默认进程堆的地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_CRITICAL_SECTION</span>* <span class="title">FastPebLock</span>;</span>  <span class="comment">// 0x1C: 用于快速同步的临界区锁</span></span><br><span class="line">    VOID* AtlThunkSListPtr;               <span class="comment">// 0x20: ATL thunk 使用的单链表指针</span></span><br><span class="line">    VOID* IFEOKey;                        <span class="comment">// 0x24: 映像文件执行选项（Image File Execution Options）注册表键句柄</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ULONG CrossProcessFlags;          <span class="comment">// 0x28: 进程状态标志</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            ULONG ProcessInJob:<span class="number">1</span>;         <span class="comment">// bit 0: 进程是否属于 Job 对象</span></span><br><span class="line">            ULONG ProcessInitializing:<span class="number">1</span>;  <span class="comment">// bit 1: 进程是否尚在初始化中</span></span><br><span class="line">            ULONG ProcessUsingVEH:<span class="number">1</span>;      <span class="comment">// bit 2: 是否使用 VEH 异常处理（Vectored Exception Handler）</span></span><br><span class="line">            ULONG ProcessUsingVCH:<span class="number">1</span>;      <span class="comment">// bit 3: 是否使用 VCH 异常处理（Vectored Continue Handler）</span></span><br><span class="line">            ULONG ProcessUsingFTH:<span class="number">1</span>;      <span class="comment">// bit 4: 是否启用了故障容错处理（Fault Tolerant Heap）</span></span><br><span class="line">            ULONG ReservedBits0:<span class="number">27</span>;       <span class="comment">// bit 5-31: 保留</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        VOID* KernelCallbackTable;        <span class="comment">// 0x2C: 内核模式回调表（如 GUI 回调）</span></span><br><span class="line">        VOID* UserSharedInfoPtr;          <span class="comment">//        用户共享信息结构指针</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ULONG SystemReserved[<span class="number">1</span>];             <span class="comment">// 0x30: 系统保留字段</span></span><br><span class="line">    ULONG AtlThunkSListPtr32;            <span class="comment">// 0x34: ATL thunk 用于 32 位兼容的单链表指针</span></span><br><span class="line">    VOID* ApiSetMap;                     <span class="comment">// 0x38: API Set 映射结构（用于模块重定向）</span></span><br><span class="line">    ULONG TlsExpansionCounter;           <span class="comment">// 0x3C: TLS 扩展槽计数器</span></span><br><span class="line">    VOID* TlsBitmap;                     <span class="comment">// 0x40: TLS 位图指针（标记可用的 TLS 插槽）</span></span><br><span class="line">    ULONG TlsBitmapBits[<span class="number">2</span>];             <span class="comment">// 0x44: TLS 位图本体（64 个槽）</span></span><br><span class="line">    VOID* ReadOnlySharedMemoryBase;      <span class="comment">// 0x4C: 只读共享内存基地址（Windows 内部用途）</span></span><br><span class="line">    VOID* HotpatchInformation;           <span class="comment">// 0x50: 热补丁相关结构体</span></span><br><span class="line">    VOID** ReadOnlyStaticServerData;     <span class="comment">// 0x54: 静态服务器数据的指针数组</span></span><br><span class="line">    VOID* AnsiCodePageData;              <span class="comment">// 0x58: ANSI 码页数据（LCID 对应）</span></span><br><span class="line">    VOID* OemCodePageData;               <span class="comment">// 0x5C: OEM 码页数据</span></span><br><span class="line">    VOID* UnicodeCaseTableData;          <span class="comment">// 0x60: Unicode 大小写映射表</span></span><br><span class="line">    ULONG NumberOfProcessors;            <span class="comment">// 0x64: 系统中可用的逻辑处理器数量</span></span><br><span class="line">    ULONG NtGlobalFlag;                  <span class="comment">// 0x68: 全局标志位（调试器、特殊分配等标记）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">CriticalSectionTimeout</span>;</span>  <span class="comment">// 0x70: 临界区超时时间（用于死锁检测）</span></span><br><span class="line">    ULONG HeapSegmentReserve;            <span class="comment">// 0x78: 堆段保留大小</span></span><br><span class="line">    ULONG HeapSegmentCommit;             <span class="comment">// 0x7C: 堆段提交大小</span></span><br><span class="line">    ULONG HeapDeCommitTotalFreeThreshold;<span class="comment">// 0x80: 堆释放总阈值</span></span><br><span class="line">    ULONG HeapDeCommitFreeBlockThreshold;<span class="comment">// 0x84: 堆释放单块阈值</span></span><br><span class="line">    ULONG NumberOfHeaps;                 <span class="comment">// 0x88: 当前进程拥有的堆数量</span></span><br><span class="line">    ULONG MaximumNumberOfHeaps;          <span class="comment">// 0x8C: 最大堆数量</span></span><br><span class="line">    VOID** ProcessHeaps;                 <span class="comment">// 0x90: 堆数组指针（实际堆地址数组）</span></span><br><span class="line">    VOID* GdiSharedHandleTable;          <span class="comment">// 0x94: GDI 共享句柄表</span></span><br><span class="line">    VOID* ProcessStarterHelper;          <span class="comment">// 0x98: 启动帮助函数</span></span><br><span class="line">    ULONG GdiDCAttributeList;            <span class="comment">// 0x9C: GDI DC 属性位图（标识属性状态）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_CRITICAL_SECTION</span>* <span class="title">LoaderLock</span>;</span>  <span class="comment">// 0xA0: Ldr 模块加载器锁</span></span><br><span class="line">    ULONG OSMajorVersion;                <span class="comment">// 0xA4: 操作系统主版本号</span></span><br><span class="line">    ULONG OSMinorVersion;                <span class="comment">// 0xA8: 操作系统次版本号</span></span><br><span class="line">    USHORT OSBuildNumber;                <span class="comment">// 0xAC: 构建号（Build Number）</span></span><br><span class="line">    USHORT OSCSDVersion;                 <span class="comment">// 0xAE: 客户服务描述版本（如 SP1）</span></span><br><span class="line">    ULONG OSPlatformId;                  <span class="comment">// 0xB0: 平台 ID（Win32 NT = 2）</span></span><br><span class="line">    ULONG ImageSubsystem;                <span class="comment">// 0xB4: 子系统类型（GUI = 2, CUI = 3）</span></span><br><span class="line">    ULONG ImageSubsystemMajorVersion;    <span class="comment">// 0xB8: 子系统主版本号</span></span><br><span class="line">    ULONG ImageSubsystemMinorVersion;    <span class="comment">// 0xBC: 子系统次版本号</span></span><br><span class="line">    ULONG ActiveProcessAffinityMask;     <span class="comment">// 0xC0: 进程默认亲和性掩码</span></span><br><span class="line">    ULONG GdiHandleBuffer[<span class="number">34</span>];           <span class="comment">// 0xC4: 用于 GDI 的句柄缓存（优化）</span></span><br><span class="line">    VOID (*PostProcessInitRoutine)();    <span class="comment">// 0x14C: 进程初始化后回调函数</span></span><br><span class="line">    VOID* TlsExpansionBitmap;            <span class="comment">// 0x150: 扩展 TLS 位图</span></span><br><span class="line">    ULONG TlsExpansionBitmapBits[<span class="number">32</span>];    <span class="comment">// 0x154: TLS 扩展槽使用位图</span></span><br><span class="line">    ULONG SessionId;                     <span class="comment">// 0x1D4: 当前 Session 的 ID</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">ULARGE_INTEGER</span> <span class="title">AppCompatFlags</span>;</span>        <span class="comment">// 0x1D8: 应用兼容性标志</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">ULARGE_INTEGER</span> <span class="title">AppCompatFlagsUser</span>;</span>    <span class="comment">// 0x1E0: 用户级应用兼容性标志</span></span><br><span class="line">    VOID* pShimData;                     <span class="comment">// 0x1E8: Shim 层数据（兼容性修复层）</span></span><br><span class="line">    VOID* AppCompatInfo;                 <span class="comment">// 0x1EC: 应用兼容性信息结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> <span class="title">CSDVersion</span>;</span>   <span class="comment">// 0x1F0: 系统版本描述字符串（如 &quot;Service Pack 1&quot;）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ACTIVATION_CONTEXT_DATA</span>* <span class="title">ActivationContextData</span>;</span> <span class="comment">// 0x1F8: 激活上下文信息（Side-by-Side）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ASSEMBLY_STORAGE_MAP</span>* <span class="title">ProcessAssemblyStorageMap</span>;</span> <span class="comment">// 0x1FC: 应用程序集存储映射表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ACTIVATION_CONTEXT_DATA</span>* <span class="title">SystemDefaultActivationContextData</span>;</span> <span class="comment">// 0x200: 系统默认激活上下文</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ASSEMBLY_STORAGE_MAP</span>* <span class="title">SystemAssemblyStorageMap</span>;</span> <span class="comment">// 0x204: 系统程序集映射表</span></span><br><span class="line">    ULONG MinimumStackCommit;            <span class="comment">// 0x208: 最小堆栈提交大小</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">FLS_CALLBACK_INFO</span>* <span class="title">FlsCallback</span>;</span>      <span class="comment">// 0x20C: FLS 回调函数指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">FlsListHead</span>;</span>      <span class="comment">// 0x210: FLS 数据链表</span></span><br><span class="line">    VOID* FlsBitmap;                     <span class="comment">// 0x218: FLS 插槽使用位图</span></span><br><span class="line">    ULONG FlsBitmapBits[<span class="number">4</span>];              <span class="comment">// 0x21C: FLS 插槽实际位图（128 位）</span></span><br><span class="line">    ULONG FlsHighIndex;                  <span class="comment">// 0x22C: 当前最大 FLS 插槽索引</span></span><br><span class="line">    VOID* WerRegistrationData;           <span class="comment">// 0x230: Windows 错误报告注册数据</span></span><br><span class="line">    VOID* WerShipAssertPtr;              <span class="comment">// 0x234: Ship Assert 支持结构</span></span><br><span class="line">    VOID* pContextData;                  <span class="comment">// 0x238: 上下文数据（调试器/CLR）</span></span><br><span class="line">    VOID* pImageHeaderHash;              <span class="comment">// 0x23C: 镜像头部哈希值（完整性验证）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ULONG TracingFlags;              <span class="comment">// 0x240: 跟踪标志</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            ULONG HeapTracingEnabled:<span class="number">1</span>;         <span class="comment">// bit 0: 启用堆跟踪</span></span><br><span class="line">            ULONG CritSecTracingEnabled:<span class="number">1</span>;      <span class="comment">// bit 1: 启用临界区跟踪</span></span><br><span class="line">            ULONG SpareTracingBits:<span class="number">30</span>;          <span class="comment">// bit 2-31: 保留</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="进程查找"><a href="#进程查找" class="headerlink" title="进程查找"></a>进程查找</h4><h5 id="遍历进程链表"><a href="#遍历进程链表" class="headerlink" title="遍历进程链表"></a>遍历进程链表</h5><p><code>EPROCESS</code> 的 <code>ActiveProcessLinks</code> 字段表示当前活动的进程的 <code>EPROCESS</code> 构成的双向链表，我们可以遍历这个双向链表来查找指定进程名对应的 <code>EPROCESS</code></p>
<p><code>ActiveProcessLinks</code> 字段的偏移量可以通过 <code>PsGetProcessId</code> 函数来定位 <code>UniqueProcessId</code> 字段（该字段和 <code>ActiveProcessLinks</code>相邻）</p>
<p>对于 64 位我们只需要取 <code>PsGetProcessId</code> 后面 3 字节偏移位置的 4 字节即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">; HANDLE __stdcall PsGetProcessId(_EPROCESS *Process)</span><br><span class="line">PsGetProcessId proc near</span><br><span class="line">    mov     rax, [rcx+_EPROCESS.UniqueProcessId] ; 👈 48 8B 81 xx xx xx xx</span><br><span class="line">    retn</span><br><span class="line">PsGetProcessId endp</span><br></pre></td></tr></table></figure>

<h5 id="枚举进程ID"><a href="#枚举进程ID" class="headerlink" title="枚举进程ID"></a>枚举进程ID</h5><p>在某些场景下（如内核 Rootkit），<code>ActiveProcessLinks</code> 链表可能被恶意修改（如断链）以隐藏进程。这种情况下，仅靠 <code>ActiveProcessLinks</code> 遍历将无法发现目标进程。</p>
<p>Windows 为所有活动进程维护了系统对象句柄表。<code>PsLookupProcessByProcessId</code> 会通过这些内核内部机制而不是链表查找 <code>EPROCESS</code>，因此仍能定位被“断链”隐藏的进程。</p>
<h4 id="进程隐藏"><a href="#进程隐藏" class="headerlink" title="进程隐藏"></a>进程隐藏</h4><p>进程断链：将目标进程的 EPROCESS 从 <code>ActiveProcessLinks</code>链表中摘除（修改 Flink 和 Blink 指针）。这会让任务管理器无法显示该进程，但进程依然被 CPU 调度（因为它还在调度器的就绪队列中）。</p>
<p>PID 篡改：直接修改 <code>EPROCESS.UniqueProcessId</code>。虽然能干扰基于 PID 的工具，但可能导致系统不稳定 。</p>
<h4 id="进程保护"><a href="#进程保护" class="headerlink" title="进程保护"></a>进程保护</h4><h5 id="BreakOnTermination-Flags-bit13"><a href="#BreakOnTermination-Flags-bit13" class="headerlink" title="BreakOnTermination (Flags bit13)"></a>BreakOnTermination (Flags bit13)</h5><p>是一种机制，在进程即将被终止时触发断点。设置 <code>ETHREAD</code>或 <code>EPROCESS</code>的特定标志位。如果该进程被强行终止，系统会触发蓝屏（BSOD）。这通常是杀软或恶意驱动的自我保护手段。</p>
<h5 id="ProcessInserted-Flags-bit26"><a href="#ProcessInserted-Flags-bit26" class="headerlink" title="ProcessInserted (Flags bit26)"></a>ProcessInserted (Flags bit26)</h5><p>标志位设置为 0时，其他进程无法通过获得句柄对受保护进程进行修改或干预。常见的应用场景包括防止恶意软件或不当操作干扰受保护进程的运行。进程自身也将无法创建线程、访问或操作其他句柄，甚至可能无法执行对自身的管理操作。具体来说，创建新线程、分配内存、访问文件句柄等操作将受到影响，导致进程无法正常执行这些任务。</p>
<h5 id="ProtectedProcess-Flags2-bit11"><a href="#ProtectedProcess-Flags2-bit11" class="headerlink" title="ProtectedProcess (Flags2 bit11)"></a>ProtectedProcess (Flags2 bit11)</h5><p>是一种通过在操作系统中标记进程来防止其被结束或修改的技术。它可以确保某些关键进程（如操作系统服务或反病毒进程）不被恶意软件或未经授权的操作干扰。</p>
<p><code>ProtectedProcess</code> 标志与 <code>CreateProcess</code> 函数中的 <code>dwCreationFlags</code> 参数中的 <code>CREATE_PROTECTED_PROCESS</code> 标志位相关。使用 <code>CREATE_PROTECTED_PROCESS</code> 启动的进程会被标记为受保护进程。然而，该二进制文件必须具有由 Microsoft 提供的特殊签名，非 Microsoft 的二进制文件无法直接成为受保护进程。</p>
<h4 id="线程结构"><a href="#线程结构" class="headerlink" title="线程结构"></a>线程结构</h4><h5 id="ETHREAD-Executive-Thread"><a href="#ETHREAD-Executive-Thread" class="headerlink" title="ETHREAD(Executive Thread)"></a>ETHREAD(Executive Thread)</h5><p>线程管理的最高层结构。</p>
<p>包含: 线程创建时间、起始地址、所属进程等。</p>
<p>关键成员:<code>Cid</code> (包含 PID 和 TID) , <code>StartAddress</code> (线程入口) 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0x2B8 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">ETHREAD</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KTHREAD</span> <span class="title">Tcb</span>;</span>                            <span class="comment">// 0x000: 内核线程结构（线程控制块，KTHREAD）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">CreateTime</span>;</span>               <span class="comment">// 0x200: 线程创建时间（自系统启动以来的时间）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">ExitTime</span>;</span>             <span class="comment">// 0x208: 线程退出时间（0 表示未退出）</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">KeyedWaitChain</span>;</span>         <span class="comment">// 0x208: 用于 Keyed Event 同步的链表</span></span><br><span class="line">    &#125;;</span><br><span class="line">    LONG ExitStatus;                               <span class="comment">// 0x210: 线程退出状态码（如 0 为正常）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">PostBlockList</span>;</span>          <span class="comment">// 0x214: APC 完成时挂起的 IRP 等列表</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            VOID* ForwardLinkShadow;               <span class="comment">// 0x214: 内部链接指针</span></span><br><span class="line">            VOID* StartAddress;                    <span class="comment">// 0x218: 📌用户模式下的线程起始地址</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">TERMINATION_PORT</span>* <span class="title">TerminationPort</span>;</span> <span class="comment">// 0x21C: 通知线程终止的端口对象</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">ETHREAD</span>* <span class="title">ReaperLink</span>;</span>               <span class="comment">// 0x21C: 用于线程回收（Reaper）链表</span></span><br><span class="line">        VOID* KeyedWaitValue;                      <span class="comment">// 0x21C: Keyed Event 用的值</span></span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG ActiveTimerListLock;                     <span class="comment">// 0x220: 活动定时器链表锁</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ActiveTimerListHead</span>;</span>        <span class="comment">// 0x224: 活动定时器链表头</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">CLIENT_ID</span> <span class="title">Cid</span>;</span>                         <span class="comment">// 0x22C: 📌客户端 ID（包含进程 ID 和线程 ID）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">KSEMAPHORE</span> <span class="title">KeyedWaitSemaphore</span>;</span>     <span class="comment">// 0x234: Keyed Event 信号量</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">KSEMAPHORE</span> <span class="title">AlpcWaitSemaphore</span>;</span>      <span class="comment">// 0x234: ALPC 使用的信号量</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">PS_CLIENT_SECURITY_CONTEXT</span> <span class="title">ClientSecurity</span>;</span> <span class="comment">// 0x248: 线程安全上下文（用于模拟）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">IrpList</span>;</span>                    <span class="comment">// 0x24C: 线程持有的 IRP 链表</span></span><br><span class="line">    ULONG TopLevelIrp;                             <span class="comment">// 0x254: 用于避免 IRP 嵌套递归</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DEVICE_OBJECT</span>* <span class="title">DeviceToVerify</span>;</span>         <span class="comment">// 0x258: 安全检查使用的设备对象</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">PSP_CPU_QUOTA_APC</span>* <span class="title">CpuQuotaApc</span>;</span>         <span class="comment">// 0x25C: CPU 配额 APC（调控线程使用时间）</span></span><br><span class="line">    VOID* Win32StartAddress;                       <span class="comment">// 0x260: 📌Win32 子系统看到的起始地址</span></span><br><span class="line">    VOID* LegacyPowerObject;                       <span class="comment">// 0x264: 旧版电源对象（已废弃）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ThreadListEntry</span>;</span>            <span class="comment">// 0x268: 所在进程线程列表的节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EX_RUNDOWN_REF</span> <span class="title">RundownProtect</span>;</span>         <span class="comment">// 0x270: Rundown 保护机制（防止销毁中访问）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EX_PUSH_LOCK</span> <span class="title">ThreadLock</span>;</span>               <span class="comment">// 0x274: 线程对象自旋锁</span></span><br><span class="line">    ULONG ReadClusterSize;                         <span class="comment">// 0x278: 用于文件读取的集群大小优化</span></span><br><span class="line">    <span class="keyword">volatile</span> LONG MmLockOrdering;                  <span class="comment">// 0x27C: 内存管理器锁顺序调试字段</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        ULONG CrossThreadFlags;                    <span class="comment">// 0x280: 跨线程共享的状态标志</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ULONG Terminated               : <span class="number">1</span>;    <span class="comment">// bit 0: 线程已终止</span></span><br><span class="line">            ULONG ThreadInserted           : <span class="number">1</span>;    <span class="comment">// bit 1: 📌插入线程调度队列</span></span><br><span class="line">            ULONG HideFromDebugger         : <span class="number">1</span>;    <span class="comment">// bit 2: 📌隐藏线程以防调试</span></span><br><span class="line">            ULONG ActiveImpersonationInfo  : <span class="number">1</span>;    <span class="comment">// bit 3: 当前线程启用了模拟令牌</span></span><br><span class="line">            ULONG Reserved                 : <span class="number">1</span>;    <span class="comment">// bit 4: 保留位</span></span><br><span class="line">            ULONG HardErrorsAreDisabled    : <span class="number">1</span>;    <span class="comment">// bit 5: 禁用硬错误弹窗</span></span><br><span class="line">            ULONG BreakOnTermination       : <span class="number">1</span>;    <span class="comment">// bit 6: 📌线程终止时触发断点（调试用）</span></span><br><span class="line">            ULONG SkipCreationMsg          : <span class="number">1</span>;    <span class="comment">// bit 7: 跳过创建消息通知</span></span><br><span class="line">            ULONG SkipTerminationMsg       : <span class="number">1</span>;    <span class="comment">// bit 8: 跳过终止消息通知</span></span><br><span class="line">            ULONG CopyTokenOnOpen          : <span class="number">1</span>;    <span class="comment">// bit 9: 打开线程时复制其访问令牌</span></span><br><span class="line">            ULONG ThreadIoPriority         : <span class="number">3</span>;    <span class="comment">// bit 10–12: IO 优先级（0~7）</span></span><br><span class="line">            ULONG ThreadPagePriority       : <span class="number">3</span>;    <span class="comment">// bit 13–15: 页面优先级（0~7）</span></span><br><span class="line">            ULONG RundownFail              : <span class="number">1</span>;    <span class="comment">// bit 16: Rundown 阶段失败标记</span></span><br><span class="line">            ULONG NeedsWorkingSetAging     : <span class="number">1</span>;    <span class="comment">// bit 17: 需要工作集老化处理</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        ULONG SameThreadPassiveFlags;             <span class="comment">// 0x284: 被动线程上下文状态位（当前线程本地）</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ULONG ActiveExWorker                : <span class="number">1</span>;  <span class="comment">// bit 0: 是否为激活的工作线程（Ex worker）</span></span><br><span class="line">            ULONG ExWorkerCanWaitUser           : <span class="number">1</span>;  <span class="comment">// bit 1: Ex worker 是否可以等待用户对象</span></span><br><span class="line">            ULONG MemoryMaker                   : <span class="number">1</span>;  <span class="comment">// bit 2: 是否参与内存页生成（如内存映射）</span></span><br><span class="line">            ULONG ClonedThread                  : <span class="number">1</span>;  <span class="comment">// bit 3: 是否为克隆线程（CreateRemoteThreadEx 等）</span></span><br><span class="line">            ULONG KeyedEventInUse               : <span class="number">1</span>;  <span class="comment">// bit 4: 是否正在使用 KeyedEvent</span></span><br><span class="line">            ULONG RateApcState                  : <span class="number">2</span>;  <span class="comment">// bit 5–6: 用于页面优先级/调度器统计用途</span></span><br><span class="line">            ULONG SelfTerminate                 : <span class="number">1</span>;  <span class="comment">// bit 7: 是否调用 PsTerminateThread 终止自身</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        ULONG SameThreadApcFlags;                 <span class="comment">// 0x288: 当前线程用于 APC 管理的状态标志位</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            UCHAR Spare                              : <span class="number">1</span>;  <span class="comment">// bit  0: 保留</span></span><br><span class="line">            <span class="keyword">volatile</span> UCHAR StartAddressInvalid       : <span class="number">1</span>;  <span class="comment">// bit  1: 启动地址是否无效（调试或错误状态）</span></span><br><span class="line">            UCHAR EtwPageFaultCalloutActive          : <span class="number">1</span>;  <span class="comment">// bit  2: 是否正在处理 ETW 页面错误回调</span></span><br><span class="line">            UCHAR OwnsProcessWorkingSetExclusive     : <span class="number">1</span>;  <span class="comment">// bit  3: 是否独占进程工作集</span></span><br><span class="line">            UCHAR OwnsProcessWorkingSetShared        : <span class="number">1</span>;  <span class="comment">// bit  4: 是否共享进程工作集</span></span><br><span class="line">            UCHAR OwnsSystemCacheWorkingSetExclusive : <span class="number">1</span>;  <span class="comment">// bit  5: 是否独占系统缓存工作集</span></span><br><span class="line">            UCHAR OwnsSystemCacheWorkingSetShared    : <span class="number">1</span>;  <span class="comment">// bit  6: 是否共享系统缓存工作集</span></span><br><span class="line">            UCHAR OwnsSessionWorkingSetExclusive     : <span class="number">1</span>;  <span class="comment">// bit  7: 是否独占 session 工作集</span></span><br><span class="line">            UCHAR OwnsSessionWorkingSetShared        : <span class="number">1</span>;  <span class="comment">// bit  8: 是否共享 session 工作集</span></span><br><span class="line">            UCHAR OwnsProcessAddressSpaceExclusive   : <span class="number">1</span>;  <span class="comment">// bit  9: 是否独占进程地址空间</span></span><br><span class="line">            UCHAR OwnsProcessAddressSpaceShared      : <span class="number">1</span>;  <span class="comment">// bit 10: 是否共享进程地址空间</span></span><br><span class="line">            UCHAR SuppressSymbolLoad                 : <span class="number">1</span>;  <span class="comment">// bit 11: 禁用符号加载（用于调试）</span></span><br><span class="line">            UCHAR Prefetching                        : <span class="number">1</span>;  <span class="comment">// bit 12: 是否正在预取内存</span></span><br><span class="line">            UCHAR OwnsDynamicMemoryShared            : <span class="number">1</span>;  <span class="comment">// bit 13: 是否共享动态内存访问</span></span><br><span class="line">            UCHAR OwnsChangeControlAreaExclusive     : <span class="number">1</span>;  <span class="comment">// bit 14: 是否独占控制区（节段/文件映射）</span></span><br><span class="line">            UCHAR OwnsChangeControlAreaShared        : <span class="number">1</span>;  <span class="comment">// bit 15: 是否共享控制区</span></span><br><span class="line">            UCHAR OwnsPagedPoolWorkingSetExclusive   : <span class="number">1</span>;  <span class="comment">// bit 16: 是否独占分页池工作集</span></span><br><span class="line">            UCHAR OwnsPagedPoolWorkingSetShared      : <span class="number">1</span>;  <span class="comment">// bit 17: 是否共享分页池工作集</span></span><br><span class="line">            UCHAR OwnsSystemPtesWorkingSetExclusive  : <span class="number">1</span>;  <span class="comment">// bit 18: 是否独占系统 PTE 工作集</span></span><br><span class="line">            UCHAR OwnsSystemPtesWorkingSetShared     : <span class="number">1</span>;  <span class="comment">// bit 19: 是否共享系统 PTE 工作集</span></span><br><span class="line">            UCHAR TrimTrigger                        : <span class="number">2</span>;  <span class="comment">// bit 20–21: 页面修剪触发器标志</span></span><br><span class="line">            UCHAR Spare1                             : <span class="number">2</span>;  <span class="comment">// bit 22–23: 保留</span></span><br><span class="line">            UCHAR PriorityRegionActive;                    <span class="comment">// 0x28B: 当前是否处于优先处理区域（内存调度相关）</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    UCHAR CacheManagerActive;                      <span class="comment">// 0x28C: 是否参与 Cache Manager 操作</span></span><br><span class="line">    UCHAR DisablePageFaultClustering;              <span class="comment">// 0x28D: 是否禁用页面错误聚类（优化调入）</span></span><br><span class="line">    UCHAR ActiveFaultCount;                        <span class="comment">// 0x28E: 当前活动页面错误计数</span></span><br><span class="line">    UCHAR LockOrderState;                          <span class="comment">// 0x28F: 锁顺序状态标志（死锁检测辅助）</span></span><br><span class="line"></span><br><span class="line">    ULONG AlpcMessageId;                           <span class="comment">// 0x290: 当前正在处理的 ALPC 消息 ID</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        VOID* AlpcMessage;                         <span class="comment">// 0x294: 当前 ALPC 消息的指针</span></span><br><span class="line">        ULONG AlpcReceiveAttributeSet;             <span class="comment">// 0x294: ALPC 接收消息时的属性掩码</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">AlpcWaitListEntry</span>;</span>          <span class="comment">// 0x298: 等待 ALPC 消息时的链表节点</span></span><br><span class="line">    ULONG CacheManagerCount;                       <span class="comment">// 0x2A0: 参与 Cache Manager 调度的次数</span></span><br><span class="line">    ULONG IoBoostCount;                            <span class="comment">// 0x2A4: IO 优先级提升计数</span></span><br><span class="line">    ULONG IrpListLock;                             <span class="comment">// 0x2A8: IRP 列表自旋锁</span></span><br><span class="line">    VOID* ReservedForSynchTracking;                <span class="comment">// 0x2AC: 同步追踪保留字段</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">SINGLE_LIST_ENTRY</span> <span class="title">CmCallbackListHead</span>;</span>  <span class="comment">// 0x2B0: 注册表回调链表头（用于 Cm 注册通知）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="KTHREAD-Kernel-Thread"><a href="#KTHREAD-Kernel-Thread" class="headerlink" title="KTHREAD (Kernel Thread)"></a>KTHREAD (Kernel Thread)</h5><p>ETHREAD 的第一个成员，包含调度器所需的所有状态。</p>
<p>关键成员:</p>
<ul>
<li><code>KernelStack</code>: 内核栈指针（切换线程时保存 ESP）。</li>
<li><code>State</code>: 线程状态（Running, Ready, Waiting 等）。</li>
<li><code>Teb</code>: 指向用户模式 TEB 的指针。</li>
<li><code>ContextSwitches</code>: 上下文切换次数统计。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">KTHREAD</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DISPATCHER_HEADER</span> <span class="title">Header</span>;</span>             <span class="comment">// 0x00: 调度器头，支持线程同步、定时器等</span></span><br><span class="line">    <span class="keyword">volatile</span> ULONGLONG CycleTime;                 <span class="comment">// 0x10: 累计使用的 CPU 时间（时间戳计数）</span></span><br><span class="line">    <span class="keyword">volatile</span> ULONG HighCycleTime;                 <span class="comment">// 0x18: CycleTime 的高 32 位</span></span><br><span class="line">    ULONGLONG QuantumTarget;                      <span class="comment">// 0x20: 时间片截止时间</span></span><br><span class="line">    VOID* InitialStack;                           <span class="comment">// 0x28: 📌栈底指针</span></span><br><span class="line">    VOID* <span class="keyword">volatile</span> StackLimit;                    <span class="comment">// 0x2C: 📌栈顶界限（溢出保护）</span></span><br><span class="line">    VOID* KernelStack;                            <span class="comment">// 0x30: 📌当前内核栈指针，用户线程切换的时候保存 ESP</span></span><br><span class="line">    ULONG ThreadLock;                             <span class="comment">// 0x34: 自旋锁，用于线程结构保护</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">KWAIT_STATUS_REGISTER</span> <span class="title">WaitRegister</span>;</span>    <span class="comment">// 0x38: 等待状态寄存器（压缩状态位）</span></span><br><span class="line">    <span class="keyword">volatile</span> UCHAR Running;                       <span class="comment">// 0x39: 📌当前是否正在运行（1 表示运行）</span></span><br><span class="line">    UCHAR Alerted[<span class="number">2</span>];                             <span class="comment">// 0x3A: 📌[0]=内核APC警报, [1]=用户APC警报</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ULONG KernelStackResident:<span class="number">1</span>;          <span class="comment">// bit  0: 栈是否驻留在内存中</span></span><br><span class="line">            ULONG ReadyTransition:<span class="number">1</span>;              <span class="comment">// bit  1: 准备态转运行态</span></span><br><span class="line">            ULONG ProcessReadyQueue:<span class="number">1</span>;            <span class="comment">// bit  2: 线程是否在进程就绪队列中</span></span><br><span class="line">            ULONG WaitNext:<span class="number">1</span>;                     <span class="comment">// bit  3: 是否立即等待下一个事件</span></span><br><span class="line">            ULONG SystemAffinityActive:<span class="number">1</span>;         <span class="comment">// bit  4: 是否强制使用系统亲和性</span></span><br><span class="line">            ULONG Alertable:<span class="number">1</span>;                    <span class="comment">// bit  5: 📌是否可以中断（用于 APC）</span></span><br><span class="line">            ULONG GdiFlushActive:<span class="number">1</span>;               <span class="comment">// bit  6: 是否在刷新 GDI 缓存</span></span><br><span class="line">            ULONG UserStackWalkActive:<span class="number">1</span>;          <span class="comment">// bit  7: 是否正在遍历用户栈</span></span><br><span class="line">            ULONG ApcInterruptRequest:<span class="number">1</span>;          <span class="comment">// bit  8: 📌是否请求 APC 中断</span></span><br><span class="line">            ULONG ForceDeferSchedule:<span class="number">1</span>;           <span class="comment">// bit  9: 是否强制延迟调度</span></span><br><span class="line">            ULONG QuantumEndMigrate:<span class="number">1</span>;            <span class="comment">// bit 10: 是否允许量子结束时迁移</span></span><br><span class="line">            ULONG UmsDirectedSwitchEnable:<span class="number">1</span>;      <span class="comment">// bit 11: 是否启用 UMS 指定切换</span></span><br><span class="line">            ULONG TimerActive:<span class="number">1</span>;                  <span class="comment">// bit 12: 线程是否激活了计时器</span></span><br><span class="line">            ULONG SystemThread:<span class="number">1</span>;                 <span class="comment">// bit 13: 是否为系统线程（非用户）</span></span><br><span class="line">            ULONG Reserved:<span class="number">18</span>;                    <span class="comment">// bit 14-31: 保留位</span></span><br><span class="line">        &#125;;</span><br><span class="line">        LONG MiscFlags;                           <span class="comment">// 0x3C: 以上所有位的组合访问</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">KAPC_STATE</span> <span class="title">ApcState</span>;</span>              <span class="comment">// 0x40: 📌APC 状态，含队列与锁</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            UCHAR ApcStateFill[<span class="number">23</span>];               <span class="comment">// 填充</span></span><br><span class="line">            CHAR Priority;                        <span class="comment">// 0x57: 当前线程调度优先级</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">volatile</span> ULONG NextProcessor;                <span class="comment">// 0x58: 调度目标 CPU</span></span><br><span class="line">    <span class="keyword">volatile</span> ULONG DeferredProcessor;            <span class="comment">// 0x5C: 被延迟分配的 CPU</span></span><br><span class="line">    ULONG ApcQueueLock;                          <span class="comment">// 0x60: APC 队列互斥锁</span></span><br><span class="line">    ULONG ContextSwitches;                       <span class="comment">// 0x64: 上下文切换计数器</span></span><br><span class="line">    <span class="keyword">volatile</span> UCHAR State;                        <span class="comment">// 0x68: 线程状态（Initialized 等）</span></span><br><span class="line">    CHAR NpxState;                               <span class="comment">// 0x69: 协处理器状态</span></span><br><span class="line">    UCHAR WaitIrql;                              <span class="comment">// 0x6A: 等待时提升的 IRQL</span></span><br><span class="line">    CHAR WaitMode;                               <span class="comment">// 0x6B: 等待模式（内核 / 用户）</span></span><br><span class="line">    <span class="keyword">volatile</span> LONG WaitStatus;                    <span class="comment">// 0x6C: 等待完成状态</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KWAIT_BLOCK</span>* <span class="title">WaitBlockList</span>;</span>          <span class="comment">// 0x70: 等待块链表指针</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">WaitListEntry</span>;</span>        <span class="comment">// 0x74: 等待对象链表节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">SINGLE_LIST_ENTRY</span> <span class="title">SwapListEntry</span>;</span> <span class="comment">// 0x74: 用于交换线程的备用单链</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KQUEUE</span>* <span class="title">volatile</span> <span class="title">Queue</span>;</span>              <span class="comment">// 0x7C: 所在等待队列</span></span><br><span class="line">    ULONG WaitTime;                              <span class="comment">// 0x80: 等待开始时间</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            SHORT KernelApcDisable;              <span class="comment">// 0x84: 禁止内核 APC</span></span><br><span class="line">            SHORT SpecialApcDisable;             <span class="comment">// 0x86: 禁止特殊 APC（如调度）</span></span><br><span class="line">        &#125;;</span><br><span class="line">        ULONG CombinedApcDisable;                <span class="comment">// 0x84: 合并后的 APC 禁止位</span></span><br><span class="line">    &#125;;</span><br><span class="line">    VOID* Teb;                                   <span class="comment">// 0x88: 📌用户线程环境块 TEB 指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KTIMER</span> <span class="title">Timer</span>;</span>                        <span class="comment">// 0x90: 内核定时器对象</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ULONG AutoAlignment:<span class="number">1</span>;               <span class="comment">// bit  0: 栈自动对齐</span></span><br><span class="line">            ULONG DisableBoost:<span class="number">1</span>;                <span class="comment">// bit  1: 禁用优先级提升</span></span><br><span class="line">            ULONG EtwStackTraceApc1Inserted:<span class="number">1</span>;   <span class="comment">// bit  2: ETW APC1 插入标志</span></span><br><span class="line">            ULONG EtwStackTraceApc2Inserted:<span class="number">1</span>;   <span class="comment">// bit  3: ETW APC2 插入标志</span></span><br><span class="line">            ULONG CalloutActive:<span class="number">1</span>;               <span class="comment">// bit  4: 回调活动中</span></span><br><span class="line">            ULONG ApcQueueable:<span class="number">1</span>;                <span class="comment">// bit  5: 是否允许 APC 入队</span></span><br><span class="line">            ULONG EnableStackSwap:<span class="number">1</span>;             <span class="comment">// bit  6: 启用栈切换</span></span><br><span class="line">            ULONG GuiThread:<span class="number">1</span>;                   <span class="comment">// bit  7: 是否 GUI 线程</span></span><br><span class="line">            ULONG UmsPerformingSyscall:<span class="number">1</span>;        <span class="comment">// bit  8: UMS 正在执行系统调用</span></span><br><span class="line">            ULONG VdmSafe:<span class="number">1</span>;                     <span class="comment">// bit  9: VDM 兼容（16 位支持）</span></span><br><span class="line">            ULONG UmsDispatched:<span class="number">1</span>;               <span class="comment">// bit 10: 已分派为 UMS 线程</span></span><br><span class="line">            ULONG ReservedFlags:<span class="number">21</span>;              <span class="comment">// bit 11-31: 保留</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">volatile</span> LONG ThreadFlags;               <span class="comment">// 0xB8: 所有标志位联合体访问</span></span><br><span class="line">    &#125;;</span><br><span class="line">    VOID* ServiceTable;                          <span class="comment">// 0xBC: 系统调用服务表（指向 SSDT）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KWAIT_BLOCK</span> <span class="title">WaitBlock</span>[4];</span>           <span class="comment">// 0xC0: 最多支持同时等待 4 个同步对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">QueueListEntry</span>;</span>          <span class="comment">// 0x120: 在线程队列（如工作队列）中的节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KTRAP_FRAME</span>* <span class="title">TrapFrame</span>;</span>             <span class="comment">// 0x128: 当前陷阱帧指针（中断或异常时的栈帧）</span></span><br><span class="line">    VOID* FirstArgument;                        <span class="comment">// 0x12C: 初始参数（如新线程的入口参数）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        VOID* CallbackStack;                    <span class="comment">// 0x130: 当前正在执行的回调栈地址</span></span><br><span class="line">        ULONG CallbackDepth;                    <span class="comment">// 0x130: 回调嵌套深度</span></span><br><span class="line">    &#125;;</span><br><span class="line">    UCHAR ApcStateIndex;                        <span class="comment">// 0x134: 📌APC 状态索引（内核/用户）</span></span><br><span class="line">    CHAR BasePriority;                          <span class="comment">// 0x135: 初始基本优先级</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        CHAR PriorityDecrement;                 <span class="comment">// 0x136: 当前优先级减少值（优先级衰减）</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            UCHAR ForegroundBoost : <span class="number">4</span>;          <span class="comment">// bit 0-3: 前台线程优先级提升</span></span><br><span class="line">            UCHAR UnusualBoost   : <span class="number">4</span>;           <span class="comment">// bit 4-7: 特殊调度场景提升</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    UCHAR Preempted;                            <span class="comment">// 0x137: 是否被抢占</span></span><br><span class="line">    UCHAR AdjustReason;                         <span class="comment">// 0x138: 优先级调整原因</span></span><br><span class="line">    CHAR AdjustIncrement;                       <span class="comment">// 0x139: 优先级调整增量</span></span><br><span class="line">    CHAR PreviousMode;                          <span class="comment">// 0x13A: 上下文切换前的 CPU 模式（用户/内核）</span></span><br><span class="line">    CHAR Saturation;                            <span class="comment">// 0x13B: 饱和度指标，用于调度策略</span></span><br><span class="line">    ULONG SystemCallNumber;                     <span class="comment">// 0x13C: 上次系统调用号</span></span><br><span class="line">    ULONG FreezeCount;                          <span class="comment">// 0x140: 冻结计数（例如调试器挂起）</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> _<span class="title">GROUP_AFFINITY</span> <span class="title">UserAffinity</span>;</span> <span class="comment">// 0x144: 用户设置的 CPU 亲和性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KPROCESS</span>* <span class="title">Process</span>;</span>                  <span class="comment">// 0x150: 📌所属进程的 `_KPROCESS` 指针</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> _<span class="title">GROUP_AFFINITY</span> <span class="title">Affinity</span>;</span>   <span class="comment">// 0x154: 当前线程亲和性掩码（活动 CPU 集）</span></span><br><span class="line">    ULONG IdealProcessor;                       <span class="comment">// 0x160: 调度器理想的运行 CPU</span></span><br><span class="line">    ULONG UserIdealProcessor;                   <span class="comment">// 0x164: 用户设置的理想处理器编号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KAPC_STATE</span>* <span class="title">ApcStatePointer</span>[2];</span>     <span class="comment">// 0x168: 指向内核 / 用户 APC 状态</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">KAPC_STATE</span> <span class="title">SavedApcState</span>;</span>       <span class="comment">// 0x170: 保存的 APC 状态（线程挂起/恢复时）</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            UCHAR SavedApcStateFill[<span class="number">23</span>];        <span class="comment">// 填充对齐</span></span><br><span class="line">            UCHAR WaitReason;                   <span class="comment">// 0x187: 当前线程的等待原因（调试、同步等）</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    CHAR SuspendCount;                          <span class="comment">// 0x188: 被挂起次数（非 0 时线程暂停）</span></span><br><span class="line">    CHAR Spare1;                                <span class="comment">// 0x189: 保留</span></span><br><span class="line">    UCHAR OtherPlatformFill;                    <span class="comment">// 0x18A: 多平台兼容保留位</span></span><br><span class="line">    VOID* <span class="keyword">volatile</span> Win32Thread;                 <span class="comment">// 0x18C: 指向 Win32 子系统线程结构（如 CSR）</span></span><br><span class="line">    VOID* StackBase;                            <span class="comment">// 0x190: 栈基地址（高地址）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">KAPC</span> <span class="title">SuspendApc</span>;</span>                <span class="comment">// 0x194: 用于挂起线程的 APC 对象</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            UCHAR SuspendApcFill0[<span class="number">1</span>];           <span class="comment">// 0x194</span></span><br><span class="line">            UCHAR ResourceIndex;                <span class="comment">// 0x195: 分配资源索引</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            UCHAR SuspendApcFill1[<span class="number">3</span>];           <span class="comment">// 0x194</span></span><br><span class="line">            UCHAR QuantumReset;                 <span class="comment">// 0x197: 时间片重置标志</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            UCHAR SuspendApcFill2[<span class="number">4</span>];           <span class="comment">// 0x194</span></span><br><span class="line">            ULONG KernelTime;                   <span class="comment">// 0x198: 已消耗的内核时间</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            UCHAR SuspendApcFill3[<span class="number">36</span>];          <span class="comment">// 0x194</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">KPRCB</span>* <span class="title">volatile</span> <span class="title">WaitPrcb</span>;</span>   <span class="comment">// 0x1B8: 当前等待的 PRCB（处理器控制块）</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            UCHAR SuspendApcFill4[<span class="number">40</span>];          <span class="comment">// 0x194</span></span><br><span class="line">            VOID* LegoData;                     <span class="comment">// 0x1BC: LEGO 用户模式调度器数据</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            UCHAR SuspendApcFill5[<span class="number">47</span>];          <span class="comment">// 0x194</span></span><br><span class="line">            UCHAR LargeStack;                   <span class="comment">// 0x1C3: 是否使用大栈（&gt;默认大小）</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG UserTime;                             <span class="comment">// 0x1C4: 已消耗的用户模式时间</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">KSEMAPHORE</span> <span class="title">SuspendSemaphore</span>;</span>    <span class="comment">// 0x1C8: 挂起信号量（用于线程恢复）</span></span><br><span class="line">        UCHAR SuspendSemaphorefill[<span class="number">20</span>];         <span class="comment">// 填充用</span></span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG SListFaultCount;                      <span class="comment">// 0x1DC: SList 异常计数（栈溢出等）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ThreadListEntry</span>;</span>         <span class="comment">// 0x1E0: 📌线程链表节点（进程中的线程列表）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">MutantListHead</span>;</span>          <span class="comment">// 0x1E8: 线程持有的互斥体链表头</span></span><br><span class="line">    VOID* SListFaultAddress;                    <span class="comment">// 0x1F0: 最后一个异常 SList 操作地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KTHREAD_COUNTERS</span>* <span class="title">ThreadCounters</span>;</span>   <span class="comment">// 0x1F4: 性能统计计数器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">XSTATE_SAVE</span>* <span class="title">XStateSave</span>;</span>            <span class="comment">// 0x1F8: 扩展浮点 / AVX 状态保存结构</span></span><br><span class="line">&#125;; <span class="comment">// 0x200 bytes</span></span><br></pre></td></tr></table></figure>

<h5 id="TEB-Thread-Environment-Block"><a href="#TEB-Thread-Environment-Block" class="headerlink" title="TEB (Thread Environment Block):"></a>TEB (Thread Environment Block):</h5><p>位于用户模式，存储线程局部数据。</p>
<ul>
<li>关键成员:<code>NtTib</code> (栈范围), <code>TlsSlots</code> (线程本地存储 TLS)。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">TEB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">NT_TIB</span> <span class="title">NtTib</span>;</span>                                                   <span class="comment">// 0x0  存储线程信息块（TIB），包括堆栈指针、异常处理信息等。</span></span><br><span class="line">    VOID* EnvironmentPointer;                                               <span class="comment">// 0x1c 指向当前线程环境块的指针，通常包含与线程环境相关的信息。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">CLIENT_ID</span> <span class="title">ClientId</span>;</span>                                             <span class="comment">// 0x20 存储线程的客户端ID（包含进程ID和线程ID）。</span></span><br><span class="line">    VOID* ActiveRpcHandle;                                                  <span class="comment">// 0x28 当前活动的 RPC 句柄，用于跟踪线程参与的 RPC 调用。</span></span><br><span class="line">    VOID* ThreadLocalStoragePointer;                                        <span class="comment">// 0x2c 指向线程本地存储（TLS）区域的指针。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">PEB</span>* <span class="title">ProcessEnvironmentBlock</span>;</span>                                   <span class="comment">// 0x30 指向进程环境块（PEB）的指针，包含进程的全局信息。</span></span><br><span class="line">    ULONG LastErrorValue;                                                   <span class="comment">// 0x34 线程的最后错误值，用于记录线程的错误状态。</span></span><br><span class="line">    ULONG CountOfOwnedCriticalSections;                                     <span class="comment">// 0x38 线程拥有的临界区数量，表示该线程管理的临界区的数量。</span></span><br><span class="line">    VOID* CsrClientThread;                                                  <span class="comment">// 0x3c 指向客户端线程信息的指针。</span></span><br><span class="line">    VOID* Win32ThreadInfo;                                                  <span class="comment">// 0x40 指向 Windows 32 位线程信息的指针，通常用于存储 Windows 特定的线程信息。</span></span><br><span class="line">    ULONG User32Reserved[<span class="number">26</span>];                                               <span class="comment">// 0x44 保留字段，供用户使用的 32 位操作系统相关数据。</span></span><br><span class="line">    ULONG UserReserved[<span class="number">5</span>];                                                  <span class="comment">// 0xac 额外的用户保留数据。</span></span><br><span class="line">    VOID* WOW32Reserved;                                                    <span class="comment">// 0xc0 32 位应用程序的相关数据，供 WOW（Windows on Windows）支持使用。</span></span><br><span class="line">    ULONG CurrentLocale;                                                    <span class="comment">// 0xc4 当前线程的区域设置标识符。</span></span><br><span class="line">    ULONG FpSoftwareStatusRegister;                                         <span class="comment">// 0xc8 用于存储浮点运算软件状态寄存器的值。</span></span><br><span class="line">    VOID* SystemReserved1[<span class="number">54</span>];                                              <span class="comment">// 0xcc 保留字段，供系统内部使用。</span></span><br><span class="line">    LONG ExceptionCode;                                                     <span class="comment">// 0x1a4 存储与当前线程异常相关的代码。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ACTIVATION_CONTEXT_STACK</span>* <span class="title">ActivationContextStackPointer</span>;</span>        <span class="comment">// 0x1a8 指向激活上下文堆栈的指针，通常用于存储与应用程序活动相关的上下文信息。</span></span><br><span class="line">    UCHAR SpareBytes[<span class="number">36</span>];                                                   <span class="comment">// 0x1ac 保留字节，供未来使用。</span></span><br><span class="line">    ULONG TxFsContext;                                                      <span class="comment">// 0x1d0 用于跟踪事务文件系统（TxFs）上下文的字段。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">GDI_TEB_BATCH</span> <span class="title">GdiTebBatch</span>;</span>                                      <span class="comment">// 0x1d4 与 GDI（图形设备接口）相关的线程批处理信息。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">CLIENT_ID</span> <span class="title">RealClientId</span>;</span>                                         <span class="comment">// 0x6b4 线程的实际客户端ID，包含进程ID和线程ID。</span></span><br><span class="line">    VOID* GdiCachedProcessHandle;                                           <span class="comment">// 0x6bc 存储 GDI 缓存的进程句柄。</span></span><br><span class="line">    ULONG GdiClientPID;                                                     <span class="comment">// 0x6c0 GDI 客户端进程ID。</span></span><br><span class="line">    ULONG GdiClientTID;                                                     <span class="comment">// 0x6c4 GDI 客户端线程ID。</span></span><br><span class="line">    VOID* GdiThreadLocalInfo;                                               <span class="comment">// 0x6c8 存储 GDI 线程本地信息的指针。</span></span><br><span class="line">    ULONG Win32ClientInfo[<span class="number">62</span>];                                              <span class="comment">// 0x6cc 存储 Windows 32 位客户端信息的数组。</span></span><br><span class="line">    VOID* glDispatchTable[<span class="number">233</span>];                                             <span class="comment">// 0x7c4 OpenGL 调度表，包含图形渲染相关的函数指针。</span></span><br><span class="line">    ULONG glReserved1[<span class="number">29</span>];                                                  <span class="comment">// 0xb68 OpenGL 保留字段。</span></span><br><span class="line">    VOID* glReserved2;                                                      <span class="comment">// 0xbdc 额外的 OpenGL 保留字段。</span></span><br><span class="line">    VOID* glSectionInfo;                                                    <span class="comment">// 0xbe0 OpenGL 部分信息。</span></span><br><span class="line">    VOID* glSection;                                                        <span class="comment">// 0xbe4 OpenGL 部分数据。</span></span><br><span class="line">    VOID* glTable;                                                          <span class="comment">// 0xbe8 OpenGL 表格数据。</span></span><br><span class="line">    VOID* glCurrentRC;                                                      <span class="comment">// 0xbec 当前渲染上下文。</span></span><br><span class="line">    VOID* glContext;                                                        <span class="comment">// 0xbf0 OpenGL 上下文。</span></span><br><span class="line">    ULONG LastStatusValue;                                                  <span class="comment">// 0xbf4 记录线程的最后状态值。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> <span class="title">StaticUnicodeString</span>;</span>                             <span class="comment">// 0xbf8 静态 Unicode 字符串，用于存储静态字符串数据。</span></span><br><span class="line">    WCHAR StaticUnicodeBuffer[<span class="number">261</span>];                                         <span class="comment">// 0xc00 静态 Unicode 字符串缓冲区。</span></span><br><span class="line">    VOID* DeallocationStack;                                                <span class="comment">// 0xe0c 用于存储内存回收的堆栈指针。</span></span><br><span class="line">    VOID* TlsSlots[<span class="number">64</span>];                                                     <span class="comment">// 0xe10 线程本地存储（TLS）槽数组，用于存储每个槽中的 TLS 数据。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">TlsLinks</span>;</span>                                            <span class="comment">// 0xf10 与 TLS 相关的链表。</span></span><br><span class="line">    VOID* Vdm;                                                              <span class="comment">// 0xf18 VDM（虚拟 DOS 模式）相关数据。</span></span><br><span class="line">    VOID* ReservedForNtRpc;                                                 <span class="comment">// 0xf1c 保留给 NT RPC 的数据。</span></span><br><span class="line">    VOID* DbgSsReserved[<span class="number">2</span>];                                                 <span class="comment">// 0xf20 用于调试 SS（子系统）相关的保留数据。</span></span><br><span class="line">    ULONG HardErrorMode;                                                    <span class="comment">// 0xf28 用于线程处理硬错误模式的状态。</span></span><br><span class="line">    VOID* Instrumentation[<span class="number">9</span>];                                               <span class="comment">// 0xf2c 用于线程的性能监控和调试数据的数组。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">GUID</span> <span class="title">ActivityId</span>;</span>                                                <span class="comment">// 0xf50 当前线程的活动标识符（GUID）。</span></span><br><span class="line">    VOID* SubProcessTag;                                                    <span class="comment">// 0xf60 子进程标记。</span></span><br><span class="line">    VOID* EtwLocalData;                                                     <span class="comment">// 0xf64 本地 ETW（事件跟踪）数据。</span></span><br><span class="line">    VOID* EtwTraceData;                                                     <span class="comment">// 0xf68 ETW 追踪数据。</span></span><br><span class="line">    VOID* WinSockData;                                                      <span class="comment">// 0xf6c 与 Windows Sockets（WinSock）相关的数据。</span></span><br><span class="line">    ULONG GdiBatchCount;                                                    <span class="comment">// 0xf70 GDI 批量计数。</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">PROCESSOR_NUMBER</span> <span class="title">CurrentIdealProcessor</span>;</span>                     <span class="comment">// 0xf74 当前理想处理器的编号。</span></span><br><span class="line">        ULONG IdealProcessorValue;                                          <span class="comment">// 0xf74 理想处理器的数值表示。</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            UCHAR ReservedPad0;                                             <span class="comment">// 0xf74 保留字段。</span></span><br><span class="line">            UCHAR ReservedPad1;                                             <span class="comment">// 0xf75 保留字段。</span></span><br><span class="line">            UCHAR ReservedPad2;                                             <span class="comment">// 0xf76 保留字段。</span></span><br><span class="line">            UCHAR IdealProcessor;                                           <span class="comment">// 0xf77 理想处理器的编号。</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG GuaranteedStackBytes;                                             <span class="comment">// 0xf78 保证的栈空间字节数。</span></span><br><span class="line">    VOID* ReservedForPerf;                                                  <span class="comment">// 0xf7c 保留给性能监控的空间。</span></span><br><span class="line">    VOID* ReservedForOle;                                                   <span class="comment">// 0xf80 保留给 OLE（对象链接和嵌入）相关数据。</span></span><br><span class="line">    ULONG WaitingOnLoaderLock;                                              <span class="comment">// 0xf84 用于表示当前线程是否在等待加载锁。</span></span><br><span class="line">    VOID* SavedPriorityState;                                               <span class="comment">// 0xf88 保存的线程优先级状态。</span></span><br><span class="line">    ULONG SoftPatchPtr1;                                                    <span class="comment">// 0xf8c 软件补丁指针1。</span></span><br><span class="line">    VOID* ThreadPoolData;                                                   <span class="comment">// 0xf90 线程池数据。</span></span><br><span class="line">    VOID** TlsExpansionSlots;                                               <span class="comment">// 0xf94 扩展的 TLS 槽数组。</span></span><br><span class="line">    ULONG MuiGeneration;                                                    <span class="comment">// 0xf98 MUI（多语言用户界面）版本。</span></span><br><span class="line">    ULONG IsImpersonating;                                                  <span class="comment">// 0xf9c 标志，表示线程是否在模拟其他安全主体。</span></span><br><span class="line">    VOID* NlsCache;                                                         <span class="comment">// 0xfa0 国家语言支持（NLS）缓存。</span></span><br><span class="line">    VOID* pShimData;                                                        <span class="comment">// 0xfa4 与程序兼容性（Shim）相关的数据。</span></span><br><span class="line">    ULONG HeapVirtualAffinity;                                              <span class="comment">// 0xfa8 堆的虚拟亲和性。</span></span><br><span class="line">    VOID* CurrentTransactionHandle;                                         <span class="comment">// 0xfac 当前事务的句柄。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">TEB_ACTIVE_FRAME</span>* <span class="title">ActiveFrame</span>;</span>                                  <span class="comment">// 0xfb0 活动帧信息。</span></span><br><span class="line">    VOID* FlsData;                                                          <span class="comment">// 0xfb4 与 FLS（线程本地存储）相关的数据。</span></span><br><span class="line">    VOID* PreferredLanguages;                                               <span class="comment">// 0xfb8 用户首选语言列表。</span></span><br><span class="line">    VOID* UserPrefLanguages;                                                <span class="comment">// 0xfbc 用户偏好的语言列表。</span></span><br><span class="line">    VOID* MergedPrefLanguages;                                              <span class="comment">// 0xfc0 合并的语言偏好列表。</span></span><br><span class="line">    ULONG MuiImpersonation;                                                 <span class="comment">// 0xfc4 MUI 模拟状态。</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">volatile</span> USHORT CrossTebFlags;                                      <span class="comment">// 0xfc8 用于线程的跨 TEB 标志。</span></span><br><span class="line">        USHORT SpareCrossTebBits:<span class="number">16</span>;                                        <span class="comment">// 0xfc8 备用的跨 TEB 位。</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        USHORT SameTebFlags;                                                <span class="comment">// 0xfca 同一线程环境块（TEB）标志</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            USHORT SafeThunkCall:<span class="number">1</span>;                                         <span class="comment">// bit 0: 安全调用标志</span></span><br><span class="line">            USHORT InDebugPrint:<span class="number">1</span>;                                          <span class="comment">// bit 1: 当前线程处于调试打印模式</span></span><br><span class="line">            USHORT HasFiberData:<span class="number">1</span>;                                          <span class="comment">// bit 2: 当前线程拥有纤程数据</span></span><br><span class="line">            USHORT SkipThreadAttach:<span class="number">1</span>;                                      <span class="comment">// bit 3: 跳过线程附加操作</span></span><br><span class="line">            USHORT WerInShipAssertCode:<span class="number">1</span>;                                   <span class="comment">// bit 4: 标志，表示线程处于断言代码中</span></span><br><span class="line">            USHORT RanProcessInit:<span class="number">1</span>;                                        <span class="comment">// bit 5: 标志，表示进程初始化已完成</span></span><br><span class="line">            USHORT ClonedThread:<span class="number">1</span>;                                          <span class="comment">// bit 6: 标志，表示该线程为克隆线程</span></span><br><span class="line">            USHORT SuppressDebugMsg:<span class="number">1</span>;                                      <span class="comment">// bit 7: 是否抑制调试信息</span></span><br><span class="line">            USHORT DisableUserStackWalk:<span class="number">1</span>;                                  <span class="comment">// bit 8: 禁用用户栈跟踪</span></span><br><span class="line">            USHORT RtlExceptionAttached:<span class="number">1</span>;                                  <span class="comment">// bit 9: 标志，表示 RTL 异常已附加</span></span><br><span class="line">            USHORT InitialThread:<span class="number">1</span>;                                         <span class="comment">// bit 10: 标志，表示这是初始线程</span></span><br><span class="line">            USHORT SpareSameTebBits:<span class="number">5</span>;                                      <span class="comment">// bit 11-15: 备用位，暂时未使用</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    VOID* TxnScopeEnterCallback;                                            <span class="comment">// 0xfcc 事务作用域进入回调函数。</span></span><br><span class="line">    VOID* TxnScopeExitCallback;                                             <span class="comment">// 0xfd0 事务作用域退出回调函数。</span></span><br><span class="line">    VOID* TxnScopeContext;                                                  <span class="comment">// 0xfd4 事务作用域上下文数据。</span></span><br><span class="line">    ULONG LockCount;                                                        <span class="comment">// 0xfd8 锁计数，表示当前线程持有的锁的数量。</span></span><br><span class="line">    ULONG SpareUlong0;                                                      <span class="comment">// 0xfdc 备用的 ULONG 数据。</span></span><br><span class="line">    VOID* ResourceRetValue;                                                 <span class="comment">// 0xfe0 资源返回值。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h4><p>KTHREAD_STATE</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程调度状态（KTHREAD_STATE）</span></span><br><span class="line"><span class="comment">// 表示线程在调度器中的生命周期状态。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">KTHREAD_STATE</span> &#123;</span></span><br><span class="line">    Initialized,    <span class="comment">// （0）已初始化：线程对象已构造但尚未调度</span></span><br><span class="line">    Ready,          <span class="comment">// （1）就绪：线程已插入就绪队列，等待运行</span></span><br><span class="line">    Running,        <span class="comment">// （2）运行中：线程正在某处理器上执行</span></span><br><span class="line">    Standby,        <span class="comment">// （3）待命：被选为下一个要运行的线程</span></span><br><span class="line">    Terminated,     <span class="comment">// （4）已终止：线程执行完毕，等待资源释放</span></span><br><span class="line">    Waiting,        <span class="comment">// （5）等待中：线程正在等待某个事件或超时</span></span><br><span class="line">    Transition,     <span class="comment">// （6）过渡态：资源尚未准备好，暂不可调度</span></span><br><span class="line">    DeferredReady,  <span class="comment">// （7）延迟就绪：满足就绪条件但延后入队</span></span><br><span class="line">    GateWait        <span class="comment">// （8）等待 Gate：等待底层同步对象 Gate</span></span><br><span class="line">&#125; KTHREAD_STATE;</span><br></pre></td></tr></table></figure>

<p>线程切换由调用 <code>KiSwapContext</code> 和 <code>SwapContext</code>函数完成。</p>
<p>当决定从 <code>OldThread</code> 切换到 <code>NewThread</code> 时（x32）：</p>
<ol>
<li>检查运行状态: 确保目标线程没有在其他 CPU 上运行 (<code>Running</code> 标志) 。</li>
<li>切换内核栈:<ul>
<li>保存旧线程的 ESP 到 <code>OldThread-&gt;KernelStack</code>。</li>
<li>将 ESP 加载为 <code>NewThread-&gt;KernelStack</code>。</li>
<li><em>重要:</em> 这一步之后，CPU 实际上就已经在使用新线程的栈了。</li>
</ul>
</li>
<li>切换地址空间 (CR3):<ul>
<li>比较新旧线程的所属进程 (<code>ApcState.Process</code>)。</li>
<li>如果是不同进程，将 CR3 寄存器更新为新进程的 <code>DirectoryTableBase</code>。</li>
<li><em>注:</em> 这一步会导致 TLB (Translation Lookaside Buffer) 刷新，开销较大。</li>
</ul>
</li>
<li>更新 TSS (Task State Segment):<ul>
<li>更新 <code>TSS.Esp0</code>。这是为了确保当下次发生中断&#x2F;系统调用从用户态进入内核态时，CPU 能找到正确的内核栈位置。</li>
</ul>
</li>
<li>更新 TEB 指针: 修改 <code>fs:[0]</code> (KPCR) 中的 <code>Used_Self</code>指针指向新线程的 TEB。</li>
<li>恢复寄存器: 恢复 FPU&#x2F;SSE 状态（如果需要）和通用寄存器。</li>
</ol>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h4 id="x64页表自映射"><a href="#x64页表自映射" class="headerlink" title="x64页表自映射"></a>x64页表自映射</h4><p>x64 使用 4 级页表（PML4, PDPT, PDE, PTE）</p>
<p>当内核需要修改某个虚拟地址（比如 <code>0x12345678</code>）对应的 PTE（页表项）属性时，它不能直接去写物理内存。它必须先把存放这个 PTE 的物理页映射到一个虚拟地址上，才能通过 CPU指令（如 <code>mov</code>）去修改它。</p>
<p>如果没有自映射，内核每次修改页表都需要临时分配虚拟地址、映射物理页、修改、解除映射，这非常繁琐且低效。</p>
<p><img src="/image/2025-12-30-learning_windows_4/1767171485680.png" alt="1767171485680"></p>
<p>使用windbg命令 <code>!pte</code>查看 <code>0</code>地址数据</p>
<p>对pml4、pdpt、pde、pte四项的页表基址进行拆分得到如下（去除 <code>页内偏移</code>和 <code>高16位</code>）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pte_base：   111010111 000000000 000000000 000000000（FEB8000000）</span><br><span class="line">pde_base：   111010111 111010111 000000000 000000000（FEBF5C0000）</span><br><span class="line">pdpte_base： 111010111 111010111 111010111 000000000（FEBF5FAE00）</span><br><span class="line">pml4_base：  111010111 111010111 111010111 111010111（FEBF5FAFD7）</span><br></pre></td></tr></table></figure>

<p><img src="/image/2025-12-30-learning_windows_4/1767171602190.png" alt="1767171602190"></p>
<p>CPU是如何找到一个虚拟地址的物理地址的：</p>
<p>CPU先从CR3寄存器读取到PML4表的物理地址，从cr3+虚拟地址的最高9位 * 8处获得PDPT的物理地址，然后这个地址+虚拟地址的次高9位 * 8获得的地址是PDE的物理地址，以此类推从PTE上获取物理页帧号，物理地址&#x3D; <code>(PFN &lt;&lt; 12) + Offset(0x000)</code> 最后去内存条里找到数据</p>
<p>但如果是查找PTE表的物理地址呢？这里就和虚表自映射有关了，在cr3+PTE表虚拟地址最高9位*8处获得的地址其实是PML4的地址</p>
<p>在windbg上通过!pte命令获得的地址，实际上CPU从这些虚拟地址访问到的物理地址就是他们本身，这也解释了这些虚拟地址为什么要这样设计。</p>
<p>PTE表：在 x64 下，一个 PTE 是 64位（8字节）的，它里面存了物理地址和属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; dt nt!_MMPTE_HARDWARE</span><br><span class="line">   +0x000 Valid            : Pos 0, 1 Bit</span><br><span class="line">   +0x000 Dirty1           : Pos 1, 1 Bit</span><br><span class="line">   +0x000 Owner            : Pos 2, 1 Bit</span><br><span class="line">   +0x000 WriteThrough     : Pos 3, 1 Bit</span><br><span class="line">   +0x000 CacheDisable     : Pos 4, 1 Bit</span><br><span class="line">   +0x000 Accessed         : Pos 5, 1 Bit</span><br><span class="line">   +0x000 Dirty            : Pos 6, 1 Bit</span><br><span class="line">   +0x000 LargePage        : Pos 7, 1 Bit</span><br><span class="line">   +0x000 Global           : Pos 8, 1 Bit</span><br><span class="line">   +0x000 CopyOnWrite      : Pos 9, 1 Bit</span><br><span class="line">   +0x000 Unused           : Pos 10, 1 Bit</span><br><span class="line">   +0x000 Write            : Pos 11, 1 Bit</span><br><span class="line">   +0x000 PageFrameNumber  : Pos 12, 36 Bits</span><br><span class="line">   +0x000 ReservedForHardware : Pos 48, 4 Bits</span><br><span class="line">   +0x000 ReservedForSoftware : Pos 52, 4 Bits</span><br><span class="line">   +0x000 WsleAge          : Pos 56, 4 Bits</span><br><span class="line">   +0x000 WsleProtection   : Pos 60, 3 Bits</span><br><span class="line">   +0x000 NoExecute        : Pos 63, 1 Bit</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>位 (Bit)</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>63(最高位)</td>
<td>NX (No-Execute)</td>
<td>1&#x3D;禁止执行 , 0&#x3D;允许执行</td>
</tr>
<tr>
<td>12-62</td>
<td>PFN</td>
<td>物理页帧号 (实际物理地址)</td>
</tr>
<tr>
<td>2</td>
<td>U&#x2F;S (User&#x2F;Supervisor)</td>
<td>0&#x3D;内核页, 1&#x3D;用户页</td>
</tr>
<tr>
<td>1</td>
<td>R&#x2F;W (Read&#x2F;Write)</td>
<td>1&#x3D;可写, 0&#x3D;只读</td>
</tr>
<tr>
<td>0</td>
<td>P (Present)</td>
<td>1&#x3D;页面有效 , 0&#x3D;无效</td>
</tr>
</tbody></table>
<h3 id="内核回调"><a href="#内核回调" class="headerlink" title="内核回调"></a>内核回调</h3>
  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a href="/categories/">Category</a></li>
        
          <li><a href="/search/">Search</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/friends/">friends</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#windows"><span class="toc-number">1.</span> <span class="toc-text">windows</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#basic-knowledge"><span class="toc-number">1.1.</span> <span class="toc-text">basic knowledge</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8syscall"><span class="toc-number">1.1.1.</span> <span class="toc-text">系统调用syscall</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#x86%E4%B8%8BR3-R0"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">x86下R3-&gt;R0</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#int-2e"><span class="toc-number">1.1.1.1.1.</span> <span class="toc-text">int 2e</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sysenter-sysreturn"><span class="toc-number">1.1.1.1.2.</span> <span class="toc-text">sysenter &#x2F; sysreturn</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#KiFastCallEntry%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.1.1.3.</span> <span class="toc-text">KiFastCallEntry函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#GDT%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E8%A1%A8%EF%BC%88Global-Description-Table%EF%BC%89"><span class="toc-number">1.1.1.1.4.</span> <span class="toc-text">GDT全局描述表（Global Description Table）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.1.1.1.5.</span> <span class="toc-text">段寄存器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x86%E4%B8%8BR0-R3"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">x86下R0-&gt;R3</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86"><span class="toc-number">1.1.2.</span> <span class="toc-text">对象管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#OBJECT-HEADER"><span class="toc-number">1.1.2.1.1.</span> <span class="toc-text">_OBJECT_HEADER</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#OBJECT-TYPE"><span class="toc-number">1.1.2.1.2.</span> <span class="toc-text">_OBJECT_TYPE</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ObCreateObject-ObjectAttributes-size-ObjectType"><span class="toc-number">1.1.2.1.3.</span> <span class="toc-text">ObCreateObject(ObjectAttributes,size,ObjectType)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">对象命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#OBJECT-DIRECTORY"><span class="toc-number">1.1.2.2.1.</span> <span class="toc-text">OBJECT_DIRECTORY</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E8%A7%A3%E6%9E%90"><span class="toc-number">1.1.2.2.2.</span> <span class="toc-text">路径解析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#OBJECT-DIRECTORY-ENTRY"><span class="toc-number">1.1.2.2.3.</span> <span class="toc-text">_OBJECT_DIRECTORY_ENTRY</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%A5%E6%9F%84"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">句柄</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#EXHANDLE"><span class="toc-number">1.1.2.3.1.</span> <span class="toc-text">EXHANDLE</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HANDLE-TABLE"><span class="toc-number">1.1.2.3.2.</span> <span class="toc-text">HANDLE_TABLE</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HANDLE-TABLE-ENTRY"><span class="toc-number">1.1.2.3.3.</span> <span class="toc-text">HANDLE_TABLE_ENTRY</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%AA%E5%8F%A5%E6%9F%84-Pseudo-Handles"><span class="toc-number">1.1.2.3.4.</span> <span class="toc-text">伪句柄 (Pseudo Handles)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%A5%E6%9F%84%E8%A1%A8"><span class="toc-number">1.1.2.3.5.</span> <span class="toc-text">全局句柄表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E5%8F%A5%E6%9F%84%E8%A1%A8"><span class="toc-number">1.1.2.3.6.</span> <span class="toc-text">私有句柄表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">1.1.3.</span> <span class="toc-text">线程&#x2F;进程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">进程结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#EPROCESS-Executive-Process"><span class="toc-number">1.1.3.1.1.</span> <span class="toc-text">EPROCESS (Executive Process)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#KPROCESS-Kernel-Process"><span class="toc-number">1.1.3.1.2.</span> <span class="toc-text">KPROCESS (Kernel Process)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#PEB-Process-Environment-Block"><span class="toc-number">1.1.3.1.3.</span> <span class="toc-text">PEB (Process Environment Block)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%9F%A5%E6%89%BE"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">进程查找</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E8%BF%9B%E7%A8%8B%E9%93%BE%E8%A1%A8"><span class="toc-number">1.1.3.2.1.</span> <span class="toc-text">遍历进程链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E8%BF%9B%E7%A8%8BID"><span class="toc-number">1.1.3.2.2.</span> <span class="toc-text">枚举进程ID</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">进程隐藏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%8A%A4"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">进程保护</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#BreakOnTermination-Flags-bit13"><span class="toc-number">1.1.3.4.1.</span> <span class="toc-text">BreakOnTermination (Flags bit13)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ProcessInserted-Flags-bit26"><span class="toc-number">1.1.3.4.2.</span> <span class="toc-text">ProcessInserted (Flags bit26)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ProtectedProcess-Flags2-bit11"><span class="toc-number">1.1.3.4.3.</span> <span class="toc-text">ProtectedProcess (Flags2 bit11)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.3.5.</span> <span class="toc-text">线程结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ETHREAD-Executive-Thread"><span class="toc-number">1.1.3.5.1.</span> <span class="toc-text">ETHREAD(Executive Thread)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#KTHREAD-Kernel-Thread"><span class="toc-number">1.1.3.5.2.</span> <span class="toc-text">KTHREAD (Kernel Thread)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TEB-Thread-Environment-Block"><span class="toc-number">1.1.3.5.3.</span> <span class="toc-text">TEB (Thread Environment Block):</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="toc-number">1.1.3.6.</span> <span class="toc-text">线程切换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.1.4.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#x64%E9%A1%B5%E8%A1%A8%E8%87%AA%E6%98%A0%E5%B0%84"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">x64页表自映射</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%9B%9E%E8%B0%83"><span class="toc-number">1.1.5.</span> <span class="toc-text">内核回调</span></a></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/&text=windows 学习（四）--Basic Knowledge"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/&title=windows 学习（四）--Basic Knowledge"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/&is_video=false&description=windows 学习（四）--Basic Knowledge"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=windows 学习（四）--Basic Knowledge&body=Check out this article: https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/&title=windows 学习（四）--Basic Knowledge"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/&title=windows 学习（四）--Basic Knowledge"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/&title=windows 学习（四）--Basic Knowledge"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/&title=windows 学习（四）--Basic Knowledge"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/&name=windows 学习（四）--Basic Knowledge&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://exploo0osion.github.io/2025/12/30/2025-12-30-learning_windows_4/&t=windows 学习（四）--Basic Knowledge"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2025-2026
    Exploooosion
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/categories/">Category</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/friends/">friends</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
